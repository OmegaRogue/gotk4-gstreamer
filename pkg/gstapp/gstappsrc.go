// Code generated by girgen. DO NOT EDIT.

package gstapp

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/app/app.h>
// extern void _gotk4_gstapp1_AppSrc_ConnectNeedData(gpointer, guint, guintptr);
// extern void _gotk4_gstapp1_AppSrc_ConnectEnoughData(gpointer, guintptr);
// extern void _gotk4_gstapp1_AppSrcClass_need_data(GstAppSrc*, guint);
// extern void _gotk4_gstapp1_AppSrcClass_enough_data(GstAppSrc*);
// extern gboolean _gotk4_gstapp1_AppSrc_ConnectSeekData(gpointer, guint64, guintptr);
// extern gboolean _gotk4_gstapp1_AppSrcClass_seek_data(GstAppSrc*, guint64);
// extern GstFlowReturn _gotk4_gstapp1_AppSrc_ConnectPushSample(gpointer, GstSample*, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSrc_ConnectPushBufferList(gpointer, GstBufferList*, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSrc_ConnectPushBuffer(gpointer, GstBuffer*, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSrc_ConnectEndOfStream(gpointer, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_push_sample(GstAppSrc*, GstSample*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_push_buffer_list(GstAppSrc*, GstBufferList*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_push_buffer(GstAppSrc*, GstBuffer*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_end_of_stream(GstAppSrc*);
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_end_of_stream(void* fnptr, GstAppSrc* arg0) {
//   return ((GstFlowReturn (*)(GstAppSrc*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_push_buffer(void* fnptr, GstAppSrc* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstAppSrc*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_push_buffer_list(void* fnptr, GstAppSrc* arg0, GstBufferList* arg1) {
//   return ((GstFlowReturn (*)(GstAppSrc*, GstBufferList*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_push_sample(void* fnptr, GstAppSrc* arg0, GstSample* arg1) {
//   return ((GstFlowReturn (*)(GstAppSrc*, GstSample*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstapp1_AppSrc_virtual_seek_data(void* fnptr, GstAppSrc* arg0, guint64 arg1) {
//   return ((gboolean (*)(GstAppSrc*, guint64))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstapp1_AppSrc_virtual_enough_data(void* fnptr, GstAppSrc* arg0) {
//   ((void (*)(GstAppSrc*))(fnptr))(arg0);
// };
// void _gotk4_gstapp1_AppSrc_virtual_need_data(void* fnptr, GstAppSrc* arg0, guint arg1) {
//   ((void (*)(GstAppSrc*, guint))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeAppStreamType = coreglib.Type(C.gst_app_stream_type_get_type())
	GTypeAppSrc        = coreglib.Type(C.gst_app_src_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAppStreamType, F: marshalAppStreamType},
		coreglib.TypeMarshaler{T: GTypeAppSrc, F: marshalAppSrc},
	})
}

// AppStreamType: stream type.
type AppStreamType C.gint

const (
	// AppStreamTypeStream: no seeking is supported in the stream, such as a
	// live stream.
	AppStreamTypeStream AppStreamType = iota
	// AppStreamTypeSeekable: stream is seekable but seeking might not be very
	// fast, such as data from a webserver.
	AppStreamTypeSeekable
	// AppStreamTypeRandomAccess: stream is seekable and seeking is fast, such
	// as in a local file.
	AppStreamTypeRandomAccess
)

func marshalAppStreamType(p uintptr) (interface{}, error) {
	return AppStreamType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AppStreamType.
func (a AppStreamType) String() string {
	switch a {
	case AppStreamTypeStream:
		return "Stream"
	case AppStreamTypeSeekable:
		return "Seekable"
	case AppStreamTypeRandomAccess:
		return "RandomAccess"
	default:
		return fmt.Sprintf("AppStreamType(%d)", a)
	}
}

// AppSrcOverrides contains methods that are overridable.
type AppSrcOverrides struct {
	// EndOfStream indicates to the appsrc element that the last buffer queued
	// in the element is the last buffer of the stream.
	//
	// The function returns the following values:
	//
	//    - flowReturn when the EOS was successfully queued. T_FLOW_FLUSHING when
	//      appsrc is not PAUSED or PLAYING.
	//
	EndOfStream func() gst.FlowReturn
	EnoughData  func()
	// The function takes the following parameters:
	//
	NeedData func(length uint)
	// PushBuffer adds a buffer to the queue of buffers that the appsrc element
	// will push to its source pad. This function takes ownership of the buffer.
	//
	// When the block property is TRUE, this function can block until free space
	// becomes available in the queue.
	//
	// The function takes the following parameters:
	//
	//    - buffer to push.
	//
	// The function returns the following values:
	//
	//    - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING
	//      when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
	//
	PushBuffer func(buffer *gst.Buffer) gst.FlowReturn
	// PushBufferList adds a buffer list to the queue of buffers and buffer
	// lists that the appsrc element will push to its source pad. This function
	// takes ownership of buffer_list.
	//
	// When the block property is TRUE, this function can block until free space
	// becomes available in the queue.
	//
	// The function takes the following parameters:
	//
	//    - bufferList to push.
	//
	// The function returns the following values:
	//
	//    - flowReturn when the buffer list was successfully queued.
	//      T_FLOW_FLUSHING when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when
	//      EOS occurred.
	//
	PushBufferList func(bufferList *gst.BufferList) gst.FlowReturn
	// PushSample: extract a buffer from the provided sample and adds it to the
	// queue of buffers that the appsrc element will push to its source pad. Any
	// previous caps that were set on appsrc will be replaced by the caps
	// associated with the sample if not equal.
	//
	// This function does not take ownership of the sample so the sample needs
	// to be unreffed after calling this function.
	//
	// When the block property is TRUE, this function can block until free space
	// becomes available in the queue.
	//
	// The function takes the following parameters:
	//
	//    - sample from which buffer and caps may be extracted.
	//
	// The function returns the following values:
	//
	//    - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING
	//      when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
	//
	PushSample func(sample *gst.Sample) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SeekData func(offset uint64) bool
}

func defaultAppSrcOverrides(v *AppSrc) AppSrcOverrides {
	return AppSrcOverrides{
		EndOfStream:    v.endOfStream,
		EnoughData:     v.enoughData,
		NeedData:       v.needData,
		PushBuffer:     v.pushBuffer,
		PushBufferList: v.pushBufferList,
		PushSample:     v.pushSample,
		SeekData:       v.seekData,
	}
}

// AppSrc: appsrc element can be used by applications to insert data into a
// GStreamer pipeline. Unlike most GStreamer elements, appsrc provides external
// API functions.
//
// appsrc can be used by linking with the libgstapp library to access the
// methods directly or by using the appsrc action signals.
//
// Before operating appsrc, the caps property must be set to fixed caps
// describing the format of the data that will be pushed with appsrc. An
// exception to this is when pushing buffers with unknown caps, in which case no
// caps should be set. This is typically true of file-like sources that push raw
// byte buffers. If you don't want to explicitly set the caps, you can use
// gst_app_src_push_sample. This method gets the caps associated with the sample
// and sets them on the appsrc replacing any previously set caps (if different
// from sample's caps).
//
// The main way of handing data to the appsrc element is by calling the
// gst_app_src_push_buffer() method or by emitting the push-buffer action
// signal. This will put the buffer onto a queue from which appsrc will read
// from in its streaming thread. It is important to note that data transport
// will not happen from the thread that performed the push-buffer call.
//
// The "max-bytes", "max-buffers" and "max-time" properties control how much
// data can be queued in appsrc before appsrc considers the queue full. A filled
// internal queue will always signal the "enough-data" signal, which signals the
// application that it should stop pushing data into appsrc. The "block"
// property will cause appsrc to block the push-buffer method until free data
// becomes available again.
//
// When the internal queue is running out of data, the "need-data" signal is
// emitted, which signals the application that it should start pushing more data
// into appsrc.
//
// In addition to the "need-data" and "enough-data" signals, appsrc can emit the
// "seek-data" signal when the "stream-mode" property is set to "seekable" or
// "random-access". The signal argument will contain the new desired position in
// the stream expressed in the unit set with the "format" property. After
// receiving the seek-data signal, the application should push-buffers from the
// new position.
//
// These signals allow the application to operate the appsrc in two different
// ways:
//
// The push mode, in which the application repeatedly calls the
// push-buffer/push-sample method with a new buffer/sample. Optionally, the
// queue size in the appsrc can be controlled with the enough-data and need-data
// signals by respectively stopping/starting the push-buffer/push-sample calls.
// This is a typical mode of operation for the stream-type "stream" and
// "seekable". Use this mode when implementing various network protocols or
// hardware devices.
//
// The pull mode, in which the need-data signal triggers the next push-buffer
// call. This mode is typically used in the "random-access" stream-type. Use
// this mode for file access or other randomly accessible sources. In this mode,
// a buffer of exactly the amount of bytes given by the need-data signal should
// be pushed into appsrc.
//
// In all modes, the size property on appsrc should contain the total stream
// size in bytes. Setting this property is mandatory in the random-access mode.
// For the stream and seekable modes, setting this property is optional but
// recommended.
//
// When the application has finished pushing data into appsrc, it should call
// gst_app_src_end_of_stream() or emit the end-of-stream action signal. After
// this call, no more buffers can be pushed into appsrc until a flushing seek
// occurs or the state of the appsrc has gone through READY.
type AppSrc struct {
	_ [0]func() // equal guard
	gstbase.BaseSrc

	gst.URIHandler
}

var (
	_ gstbase.BaseSrcer = (*AppSrc)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppSrc, *AppSrcClass, AppSrcOverrides](
		GTypeAppSrc,
		initAppSrcClass,
		wrapAppSrc,
		defaultAppSrcOverrides,
	)
}

func initAppSrcClass(gclass unsafe.Pointer, overrides AppSrcOverrides, classInitFunc func(*AppSrcClass)) {
	pclass := (*C.GstAppSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAppSrc))))

	if overrides.EndOfStream != nil {
		pclass.end_of_stream = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_end_of_stream)
	}

	if overrides.EnoughData != nil {
		pclass.enough_data = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_enough_data)
	}

	if overrides.NeedData != nil {
		pclass.need_data = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_need_data)
	}

	if overrides.PushBuffer != nil {
		pclass.push_buffer = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_push_buffer)
	}

	if overrides.PushBufferList != nil {
		pclass.push_buffer_list = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_push_buffer_list)
	}

	if overrides.PushSample != nil {
		pclass.push_sample = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_push_sample)
	}

	if overrides.SeekData != nil {
		pclass.seek_data = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_seek_data)
	}

	if classInitFunc != nil {
		class := (*AppSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppSrc(obj *coreglib.Object) *AppSrc {
	return &AppSrc{
		BaseSrc: gstbase.BaseSrc{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
		URIHandler: gst.URIHandler{
			Object: obj,
		},
	}
}

func marshalAppSrc(p uintptr) (interface{}, error) {
	return wrapAppSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEndOfStream: notify appsrc that no more buffer are available.
func (appsrc *AppSrc) ConnectEndOfStream(f func() (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "end-of-stream", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectEndOfStream), f)
}

// ConnectEnoughData: signal that the source has enough data. It is recommended
// that the application stops calling push-buffer until the need-data signal is
// emitted again to avoid excessive buffer queueing.
func (appsrc *AppSrc) ConnectEnoughData(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "enough-data", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectEnoughData), f)
}

// ConnectNeedData: signal that the source needs more data. In the callback or
// from another thread you should call push-buffer or end-of-stream.
//
// length is just a hint and when it is set to -1, any number of bytes can be
// pushed into appsrc.
//
// You can call push-buffer multiple times until the enough-data signal is
// fired.
func (appsrc *AppSrc) ConnectNeedData(f func(length uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "need-data", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectNeedData), f)
}

// ConnectPushBuffer adds a buffer to the queue of buffers that the appsrc
// element will push to its source pad.
//
// This function does not take ownership of the buffer, but it takes a reference
// so the buffer can be unreffed at any time after calling this function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
func (appsrc *AppSrc) ConnectPushBuffer(f func(buffer *gst.Buffer) (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "push-buffer", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectPushBuffer), f)
}

// ConnectPushBufferList adds a buffer list to the queue of buffers and buffer
// lists that the appsrc element will push to its source pad.
//
// This function does not take ownership of the buffer list, but it takes a
// reference so the buffer list can be unreffed at any time after calling this
// function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
func (appsrc *AppSrc) ConnectPushBufferList(f func(bufferList *gst.BufferList) (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "push-buffer-list", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectPushBufferList), f)
}

// ConnectPushSample: extract a buffer from the provided sample and adds the
// extracted buffer to the queue of buffers that the appsrc element will push to
// its source pad. This function set the appsrc caps based on the caps in the
// sample and reset the caps if they change. Only the caps and the buffer of the
// provided sample are used and not for example the segment in the sample.
//
// This function does not take ownership of the sample, but it takes a reference
// so the sample can be unreffed at any time after calling this function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
func (appsrc *AppSrc) ConnectPushSample(f func(sample *gst.Sample) (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "push-sample", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectPushSample), f)
}

// ConnectSeekData: seek to the given offset. The next push-buffer should
// produce buffers from the new offset. This callback is only called for
// seekable stream types.
func (appsrc *AppSrc) ConnectSeekData(f func(offset uint64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "seek-data", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectSeekData), f)
}

// EndOfStream indicates to the appsrc element that the last buffer queued in
// the element is the last buffer of the stream.
//
// The function returns the following values:
//
//    - flowReturn when the EOS was successfully queued. T_FLOW_FLUSHING when
//      appsrc is not PAUSED or PLAYING.
//
func (appsrc *AppSrc) EndOfStream() gst.FlowReturn {
	var _arg0 *C.GstAppSrc    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_end_of_stream(_arg0)
	runtime.KeepAlive(appsrc)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Caps: get the configured caps on appsrc.
//
// The function returns the following values:
//
//    - caps produced by the source. gst_caps_unref() after usage.
//
func (appsrc *AppSrc) Caps() *gst.Caps {
	var _arg0 *C.GstAppSrc // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_caps(_arg0)
	runtime.KeepAlive(appsrc)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// CurrentLevelBuffers: get the number of currently queued buffers inside
// appsrc.
//
// The function returns the following values:
//
//    - guint64: number of currently queued buffers.
//
func (appsrc *AppSrc) CurrentLevelBuffers() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_current_level_buffers(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// CurrentLevelBytes: get the number of currently queued bytes inside appsrc.
//
// The function returns the following values:
//
//    - guint64: number of currently queued bytes.
//
func (appsrc *AppSrc) CurrentLevelBytes() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_current_level_bytes(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// CurrentLevelTime: get the amount of currently queued time inside appsrc.
//
// The function returns the following values:
//
//    - clockTime: amount of currently queued time.
//
func (appsrc *AppSrc) CurrentLevelTime() gst.ClockTime {
	var _arg0 *C.GstAppSrc   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_current_level_time(_arg0)
	runtime.KeepAlive(appsrc)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Duration: get the duration of the stream in nanoseconds. A value of
// GST_CLOCK_TIME_NONE means that the duration is not known.
//
// The function returns the following values:
//
//    - clockTime: duration of the stream previously set with
//      gst_app_src_set_duration();.
//
func (appsrc *AppSrc) Duration() gst.ClockTime {
	var _arg0 *C.GstAppSrc   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_duration(_arg0)
	runtime.KeepAlive(appsrc)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// EmitSignals: check if appsrc will emit the "new-preroll" and "new-buffer"
// signals.
//
// The function returns the following values:
//
//    - ok: TRUE if appsrc is emitting the "new-preroll" and "new-buffer"
//      signals.
//
func (appsrc *AppSrc) EmitSignals() bool {
	var _arg0 *C.GstAppSrc // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_emit_signals(_arg0)
	runtime.KeepAlive(appsrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Latency: retrieve the min and max latencies in min and max respectively.
//
// The function returns the following values:
//
//    - min latency.
//    - max latency.
//
func (appsrc *AppSrc) Latency() (min, max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // in
	var _arg2 C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	C.gst_app_src_get_latency(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(appsrc)

	var _min uint64 // out
	var _max uint64 // out

	_min = uint64(_arg1)
	_max = uint64(_arg2)

	return _min, _max
}

// LeakyType returns the currently set AppLeakyType. See
// gst_app_src_set_leaky_type() for more details.
//
// The function returns the following values:
//
//    - appLeakyType: currently set AppLeakyType.
//
func (appsrc *AppSrc) LeakyType() AppLeakyType {
	var _arg0 *C.GstAppSrc      // out
	var _cret C.GstAppLeakyType // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_leaky_type(_arg0)
	runtime.KeepAlive(appsrc)

	var _appLeakyType AppLeakyType // out

	_appLeakyType = AppLeakyType(_cret)

	return _appLeakyType
}

// MaxBuffers: get the maximum amount of buffers that can be queued in appsrc.
//
// The function returns the following values:
//
//    - guint64: maximum amount of buffers that can be queued.
//
func (appsrc *AppSrc) MaxBuffers() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_max_buffers(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MaxBytes: get the maximum amount of bytes that can be queued in appsrc.
//
// The function returns the following values:
//
//    - guint64: maximum amount of bytes that can be queued.
//
func (appsrc *AppSrc) MaxBytes() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_max_bytes(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MaxTime: get the maximum amount of time that can be queued in appsrc.
//
// The function returns the following values:
//
//    - clockTime: maximum amount of time that can be queued.
//
func (appsrc *AppSrc) MaxTime() gst.ClockTime {
	var _arg0 *C.GstAppSrc   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_max_time(_arg0)
	runtime.KeepAlive(appsrc)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Size: get the size of the stream in bytes. A value of -1 means that the size
// is not known.
//
// The function returns the following values:
//
//    - gint64: size of the stream previously set with gst_app_src_set_size();.
//
func (appsrc *AppSrc) Size() int64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.gint64     // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_size(_arg0)
	runtime.KeepAlive(appsrc)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// StreamType: get the stream type. Control the stream type of appsrc with
// gst_app_src_set_stream_type().
//
// The function returns the following values:
//
//    - appStreamType: stream type.
//
func (appsrc *AppSrc) StreamType() AppStreamType {
	var _arg0 *C.GstAppSrc       // out
	var _cret C.GstAppStreamType // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_stream_type(_arg0)
	runtime.KeepAlive(appsrc)

	var _appStreamType AppStreamType // out

	_appStreamType = AppStreamType(_cret)

	return _appStreamType
}

// PushBuffer adds a buffer to the queue of buffers that the appsrc element will
// push to its source pad. This function takes ownership of the buffer.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//    - buffer to push.
//
// The function returns the following values:
//
//    - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//      appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
//
func (appsrc *AppSrc) PushBuffer(buffer *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_app_src_push_buffer(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushBufferList adds a buffer list to the queue of buffers and buffer lists
// that the appsrc element will push to its source pad. This function takes
// ownership of buffer_list.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//    - bufferList to push.
//
// The function returns the following values:
//
//    - flowReturn when the buffer list was successfully queued. T_FLOW_FLUSHING
//      when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
//
func (appsrc *AppSrc) PushBufferList(bufferList *gst.BufferList) gst.FlowReturn {
	var _arg0 *C.GstAppSrc     // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(bufferList)), nil)

	_cret = C.gst_app_src_push_buffer_list(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(bufferList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushSample: extract a buffer from the provided sample and adds it to the
// queue of buffers that the appsrc element will push to its source pad. Any
// previous caps that were set on appsrc will be replaced by the caps associated
// with the sample if not equal.
//
// This function does not take ownership of the sample so the sample needs to be
// unreffed after calling this function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//    - sample from which buffer and caps may be extracted.
//
// The function returns the following values:
//
//    - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//      appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
//
func (appsrc *AppSrc) PushSample(sample *gst.Sample) gst.FlowReturn {
	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstSample    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_app_src_push_sample(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(sample)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetCaps: set the capabilities on the appsrc element. This function takes a
// copy of the caps structure. After calling this method, the source will only
// produce caps that match caps. caps must be fixed and the caps on the buffers
// must match the caps or left NULL.
//
// The function takes the following parameters:
//
//    - caps (optional) to set.
//
func (appsrc *AppSrc) SetCaps(caps *gst.Caps) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 *C.GstCaps   // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_app_src_set_caps(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(caps)
}

// SetDuration: set the duration of the stream in nanoseconds. A value of
// GST_CLOCK_TIME_NONE means that the duration is not known.
//
// The function takes the following parameters:
//
//    - duration to set.
//
func (appsrc *AppSrc) SetDuration(duration gst.ClockTime) {
	var _arg0 *C.GstAppSrc   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(duration)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_app_src_set_duration(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(duration)
}

// SetEmitSignals: make appsrc emit the "new-preroll" and "new-buffer" signals.
// This option is by default disabled because signal emission is expensive and
// unneeded when the application prefers to operate in pull mode.
//
// The function takes the following parameters:
//
//    - emit: new state.
//
func (appsrc *AppSrc) SetEmitSignals(emit bool) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	if emit {
		_arg1 = C.TRUE
	}

	C.gst_app_src_set_emit_signals(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(emit)
}

// SetLatency: configure the min and max latency in src. If min is set to -1,
// the default latency calculations for pseudo-live sources will be used.
//
// The function takes the following parameters:
//
//    - min latency.
//    - max latency.
//
func (appsrc *AppSrc) SetLatency(min, max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out
	var _arg2 C.guint64    // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(min)
	_arg2 = C.guint64(max)

	C.gst_app_src_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetLeakyType: when set to any other value than GST_APP_LEAKY_TYPE_NONE then
// the appsrc will drop any buffers that are pushed into it once its internal
// queue is full. The selected type defines whether to drop the oldest or new
// buffers.
//
// The function takes the following parameters:
//
//    - leaky: AppLeakyType.
//
func (appsrc *AppSrc) SetLeakyType(leaky AppLeakyType) {
	var _arg0 *C.GstAppSrc      // out
	var _arg1 C.GstAppLeakyType // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.GstAppLeakyType(leaky)

	C.gst_app_src_set_leaky_type(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(leaky)
}

// SetMaxBuffers: set the maximum amount of buffers that can be queued in
// appsrc. After the maximum amount of buffers are queued, appsrc will emit the
// "enough-data" signal.
//
// The function takes the following parameters:
//
//    - max: maximum number of buffers to queue.
//
func (appsrc *AppSrc) SetMaxBuffers(max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(max)

	C.gst_app_src_set_max_buffers(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(max)
}

// SetMaxBytes: set the maximum amount of bytes that can be queued in appsrc.
// After the maximum amount of bytes are queued, appsrc will emit the
// "enough-data" signal.
//
// The function takes the following parameters:
//
//    - max: maximum number of bytes to queue.
//
func (appsrc *AppSrc) SetMaxBytes(max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(max)

	C.gst_app_src_set_max_bytes(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(max)
}

// SetMaxTime: set the maximum amount of time that can be queued in appsrc.
// After the maximum amount of time are queued, appsrc will emit the
// "enough-data" signal.
//
// The function takes the following parameters:
//
//    - max: maximum amonut of time to queue.
//
func (appsrc *AppSrc) SetMaxTime(max gst.ClockTime) {
	var _arg0 *C.GstAppSrc   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(max)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_app_src_set_max_time(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(max)
}

// SetSize: set the size of the stream in bytes. A value of -1 means that the
// size is not known.
//
// The function takes the following parameters:
//
//    - size to set.
//
func (appsrc *AppSrc) SetSize(size int64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.gint64     // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.gint64(size)

	C.gst_app_src_set_size(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(size)
}

// SetStreamType: set the stream type on appsrc. For seekable streams, the
// "seek" signal must be connected to.
//
// A stream_type stream.
//
// The function takes the following parameters:
//
//    - typ: new state.
//
func (appsrc *AppSrc) SetStreamType(typ AppStreamType) {
	var _arg0 *C.GstAppSrc       // out
	var _arg1 C.GstAppStreamType // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.GstAppStreamType(typ)

	C.gst_app_src_set_stream_type(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(typ)
}

// endOfStream indicates to the appsrc element that the last buffer queued in
// the element is the last buffer of the stream.
//
// The function returns the following values:
//
//    - flowReturn when the EOS was successfully queued. T_FLOW_FLUSHING when
//      appsrc is not PAUSED or PLAYING.
//
func (appsrc *AppSrc) endOfStream() gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.end_of_stream

	var _arg0 *C.GstAppSrc    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C._gotk4_gstapp1_AppSrc_virtual_end_of_stream(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsrc)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

func (appsrc *AppSrc) enoughData() {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.enough_data

	var _arg0 *C.GstAppSrc // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	C._gotk4_gstapp1_AppSrc_virtual_enough_data(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsrc)
}

// The function takes the following parameters:
//
func (appsrc *AppSrc) needData(length uint) {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.need_data

	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint(length)

	C._gotk4_gstapp1_AppSrc_virtual_need_data(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(length)
}

// pushBuffer adds a buffer to the queue of buffers that the appsrc element will
// push to its source pad. This function takes ownership of the buffer.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//    - buffer to push.
//
// The function returns the following values:
//
//    - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//      appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
//
func (appsrc *AppSrc) pushBuffer(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.push_buffer

	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C._gotk4_gstapp1_AppSrc_virtual_push_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// pushBufferList adds a buffer list to the queue of buffers and buffer lists
// that the appsrc element will push to its source pad. This function takes
// ownership of buffer_list.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//    - bufferList to push.
//
// The function returns the following values:
//
//    - flowReturn when the buffer list was successfully queued. T_FLOW_FLUSHING
//      when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
//
func (appsrc *AppSrc) pushBufferList(bufferList *gst.BufferList) gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.push_buffer_list

	var _arg0 *C.GstAppSrc     // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(bufferList)), nil)

	_cret = C._gotk4_gstapp1_AppSrc_virtual_push_buffer_list(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(bufferList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// pushSample: extract a buffer from the provided sample and adds it to the
// queue of buffers that the appsrc element will push to its source pad. Any
// previous caps that were set on appsrc will be replaced by the caps associated
// with the sample if not equal.
//
// This function does not take ownership of the sample so the sample needs to be
// unreffed after calling this function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//    - sample from which buffer and caps may be extracted.
//
// The function returns the following values:
//
//    - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//      appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
//
func (appsrc *AppSrc) pushSample(sample *gst.Sample) gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.push_sample

	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstSample    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C._gotk4_gstapp1_AppSrc_virtual_push_sample(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(sample)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (appsrc *AppSrc) seekData(offset uint64) bool {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.seek_data

	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(offset)

	_cret = C._gotk4_gstapp1_AppSrc_virtual_seek_data(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(offset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppSrcClass: instance of this type is always passed by reference.
type AppSrcClass struct {
	*appSrcClass
}

// appSrcClass is the struct that's finalized.
type appSrcClass struct {
	native *C.GstAppSrcClass
}

func (a *AppSrcClass) BasesrcClass() *gstbase.BaseSrcClass {
	valptr := &a.native.basesrc_class
	var _v *gstbase.BaseSrcClass // out
	_v = (*gstbase.BaseSrcClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
