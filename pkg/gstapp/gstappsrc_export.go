// Code generated by girgen. DO NOT EDIT.

package gstapp

import (
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gst/app/app.h>
import "C"

//export _gotk4_gstapp1_AppSrc_ConnectEndOfStream
func _gotk4_gstapp1_AppSrc_ConnectEndOfStream(arg0 C.gpointer, arg1 C.guintptr) (cret C.GstFlowReturn) {
	var f func() (flowReturn gst.FlowReturn)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (flowReturn gst.FlowReturn))
	}

	flowReturn := f()

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstapp1_AppSrc_ConnectEnoughData
func _gotk4_gstapp1_AppSrc_ConnectEnoughData(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gstapp1_AppSrc_ConnectNeedData
func _gotk4_gstapp1_AppSrc_ConnectNeedData(arg0 C.gpointer, arg1 C.guint, arg2 C.guintptr) {
	var f func(length uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(length uint))
	}

	var _length uint // out

	_length = uint(arg1)

	f(_length)
}

//export _gotk4_gstapp1_AppSrc_ConnectPushBuffer
func _gotk4_gstapp1_AppSrc_ConnectPushBuffer(arg0 C.gpointer, arg1 *C.GstBuffer, arg2 C.guintptr) (cret C.GstFlowReturn) {
	var f func(buffer *gst.Buffer) (flowReturn gst.FlowReturn)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(buffer *gst.Buffer) (flowReturn gst.FlowReturn))
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := f(_buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstapp1_AppSrc_ConnectPushBufferList
func _gotk4_gstapp1_AppSrc_ConnectPushBufferList(arg0 C.gpointer, arg1 *C.GstBufferList, arg2 C.guintptr) (cret C.GstFlowReturn) {
	var f func(bufferList *gst.BufferList) (flowReturn gst.FlowReturn)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(bufferList *gst.BufferList) (flowReturn gst.FlowReturn))
	}

	var _bufferList *gst.BufferList // out

	_bufferList = (*gst.BufferList)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := f(_bufferList)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstapp1_AppSrc_ConnectPushSample
func _gotk4_gstapp1_AppSrc_ConnectPushSample(arg0 C.gpointer, arg1 *C.GstSample, arg2 C.guintptr) (cret C.GstFlowReturn) {
	var f func(sample *gst.Sample) (flowReturn gst.FlowReturn)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sample *gst.Sample) (flowReturn gst.FlowReturn))
	}

	var _sample *gst.Sample // out

	_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := f(_sample)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstapp1_AppSrc_ConnectSeekData
func _gotk4_gstapp1_AppSrc_ConnectSeekData(arg0 C.gpointer, arg1 C.guint64, arg2 C.guintptr) (cret C.gboolean) {
	var f func(offset uint64) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(offset uint64) (ok bool))
	}

	var _offset uint64 // out

	_offset = uint64(arg1)

	ok := f(_offset)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}
