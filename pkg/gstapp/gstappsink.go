// Code generated by girgen. DO NOT EDIT.

package gstapp

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/app/app.h>
// extern void _gotk4_gstapp1_AppSink_ConnectEos(gpointer, guintptr);
// extern void _gotk4_gstapp1_AppSinkClass_eos(GstAppSink*);
// extern gboolean _gotk4_gstapp1_AppSink_ConnectNewSerializedEvent(gpointer, guintptr);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_try_pull_sample(GstAppSink*, GstClockTime);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_try_pull_preroll(GstAppSink*, GstClockTime);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_pull_sample(GstAppSink*);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_pull_preroll(GstAppSink*);
// extern GstSample _gotk4_gstapp1_AppSink_ConnectTryPullSample(gpointer, guint64, guintptr);
// extern GstSample _gotk4_gstapp1_AppSink_ConnectTryPullPreroll(gpointer, guint64, guintptr);
// extern GstSample _gotk4_gstapp1_AppSink_ConnectPullSample(gpointer, guintptr);
// extern GstSample _gotk4_gstapp1_AppSink_ConnectPullPreroll(gpointer, guintptr);
// extern GstMiniObject _gotk4_gstapp1_AppSink_ConnectTryPullObject(gpointer, guint64, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSink_ConnectNewSample(gpointer, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSink_ConnectNewPreroll(gpointer, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSinkClass_new_sample(GstAppSink*);
// extern GstFlowReturn _gotk4_gstapp1_AppSinkClass_new_preroll(GstAppSink*);
// GstFlowReturn _gotk4_gstapp1_AppSink_virtual_new_preroll(void* fnptr, GstAppSink* arg0) {
//   return ((GstFlowReturn (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstapp1_AppSink_virtual_new_sample(void* fnptr, GstAppSink* arg0) {
//   return ((GstFlowReturn (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_pull_preroll(void* fnptr, GstAppSink* arg0) {
//   return ((GstSample* (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_pull_sample(void* fnptr, GstAppSink* arg0) {
//   return ((GstSample* (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_try_pull_preroll(void* fnptr, GstAppSink* arg0, GstClockTime arg1) {
//   return ((GstSample* (*)(GstAppSink*, GstClockTime))(fnptr))(arg0, arg1);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_try_pull_sample(void* fnptr, GstAppSink* arg0, GstClockTime arg1) {
//   return ((GstSample* (*)(GstAppSink*, GstClockTime))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstapp1_AppSink_virtual_eos(void* fnptr, GstAppSink* arg0) {
//   ((void (*)(GstAppSink*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAppSink = coreglib.Type(C.gst_app_sink_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAppSink, F: marshalAppSink},
	})
}

// AppSinkOverrides contains methods that are overridable.
type AppSinkOverrides struct {
	Eos func()
	// The function returns the following values:
	//
	NewPreroll func() gst.FlowReturn
	// The function returns the following values:
	//
	NewSample func() gst.FlowReturn
	// PullPreroll: get the last preroll sample in appsink. This was the sample
	// that caused the appsink to preroll in the PAUSED state.
	//
	// This function is typically used when dealing with a pipeline in the
	// PAUSED state. Calling this function after doing a seek will give the
	// sample right after the seek position.
	//
	// Calling this function will clear the internal reference to the preroll
	// buffer.
	//
	// Note that the preroll sample will also be returned as the first sample
	// when calling gst_app_sink_pull_sample().
	//
	// If an EOS event was received before any buffers, this function returns
	// NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
	//
	// This function blocks until a preroll sample or EOS is received or the
	// appsink element is set to the READY/NULL state.
	//
	// The function returns the following values:
	//
	//    - sample (optional) or NULL when the appsink is stopped or EOS. Call
	//      gst_sample_unref() after usage.
	//
	PullPreroll func() *gst.Sample
	// PullSample: this function blocks until a sample or EOS becomes available
	// or the appsink element is set to the READY/NULL state.
	//
	// This function will only return samples when the appsink is in the PLAYING
	// state. All rendered buffers will be put in a queue so that the
	// application can pull samples at its own rate. Note that when the
	// application does not pull samples fast enough, the queued buffers could
	// consume a lot of memory, especially when dealing with raw video frames.
	//
	// If an EOS event was received before any buffers, this function returns
	// NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
	//
	// The function returns the following values:
	//
	//    - sample (optional) or NULL when the appsink is stopped or EOS. Call
	//      gst_sample_unref() after usage.
	//
	PullSample func() *gst.Sample
	// TryPullPreroll: get the last preroll sample in appsink. This was the
	// sample that caused the appsink to preroll in the PAUSED state.
	//
	// This function is typically used when dealing with a pipeline in the
	// PAUSED state. Calling this function after doing a seek will give the
	// sample right after the seek position.
	//
	// Calling this function will clear the internal reference to the preroll
	// buffer.
	//
	// Note that the preroll sample will also be returned as the first sample
	// when calling gst_app_sink_pull_sample().
	//
	// If an EOS event was received before any buffers or the timeout expires,
	// this function returns NULL. Use gst_app_sink_is_eos () to check for the
	// EOS condition.
	//
	// This function blocks until a preroll sample or EOS is received, the
	// appsink element is set to the READY/NULL state, or the timeout expires.
	//
	// The function takes the following parameters:
	//
	//    - timeout: maximum amount of time to wait for the preroll sample.
	//
	// The function returns the following values:
	//
	//    - sample (optional) or NULL when the appsink is stopped or EOS or the
	//      timeout expires. Call gst_sample_unref() after usage.
	//
	TryPullPreroll func(timeout gst.ClockTime) *gst.Sample
	// TryPullSample: this function blocks until a sample or EOS becomes
	// available or the appsink element is set to the READY/NULL state or the
	// timeout expires.
	//
	// This function will only return samples when the appsink is in the PLAYING
	// state. All rendered buffers will be put in a queue so that the
	// application can pull samples at its own rate. Note that when the
	// application does not pull samples fast enough, the queued buffers could
	// consume a lot of memory, especially when dealing with raw video frames.
	//
	// If an EOS event was received before any buffers or the timeout expires,
	// this function returns NULL. Use gst_app_sink_is_eos () to check for the
	// EOS condition.
	//
	// The function takes the following parameters:
	//
	//    - timeout: maximum amount of time to wait for a sample.
	//
	// The function returns the following values:
	//
	//    - sample (optional) or NULL when the appsink is stopped or EOS or the
	//      timeout expires. Call gst_sample_unref() after usage.
	//
	TryPullSample func(timeout gst.ClockTime) *gst.Sample
}

func defaultAppSinkOverrides(v *AppSink) AppSinkOverrides {
	return AppSinkOverrides{
		Eos:            v.eos,
		NewPreroll:     v.newPreroll,
		NewSample:      v.newSample,
		PullPreroll:    v.pullPreroll,
		PullSample:     v.pullSample,
		TryPullPreroll: v.tryPullPreroll,
		TryPullSample:  v.tryPullSample,
	}
}

// AppSink: appsink is a sink plugin that supports many different methods for
// making the application get a handle on the GStreamer data in a pipeline.
// Unlike most GStreamer elements, Appsink provides external API functions.
//
// appsink can be used by linking to the gstappsink.h header file to access the
// methods or by using the appsink action signals and properties.
//
// The normal way of retrieving samples from appsink is by using the
// gst_app_sink_pull_sample() and gst_app_sink_pull_preroll() methods. These
// methods block until a sample becomes available in the sink or when the sink
// is shut down or reaches EOS. There are also timed variants of these methods,
// gst_app_sink_try_pull_sample() and gst_app_sink_try_pull_preroll(), which
// accept a timeout parameter to limit the amount of time to wait.
//
// Appsink will internally use a queue to collect buffers from the streaming
// thread. If the application is not pulling samples fast enough, this queue
// will consume a lot of memory over time. The "max-buffers" property can be
// used to limit the queue size. The "drop" property controls whether the
// streaming thread blocks or if older buffers are dropped when the maximum
// queue size is reached. Note that blocking the streaming thread can negatively
// affect real-time performance and should be avoided.
//
// If a blocking behaviour is not desirable, setting the "emit-signals" property
// to TRUE will make appsink emit the "new-sample" and "new-preroll" signals
// when a sample can be pulled without blocking.
//
// The "caps" property on appsink can be used to control the formats that
// appsink can receive. This property can contain non-fixed caps, the format of
// the pulled samples can be obtained by getting the sample caps.
//
// If one of the pull-preroll or pull-sample methods return NULL, the appsink is
// stopped or in the EOS state. You can check for the EOS state with the "eos"
// property or with the gst_app_sink_is_eos() method.
//
// The eos signal can also be used to be informed when the EOS state is reached
// to avoid polling.
type AppSink struct {
	_ [0]func() // equal guard
	gstbase.BaseSink

	gst.URIHandler
}

var (
	_ gstbase.BaseSinker = (*AppSink)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppSink, *AppSinkClass, AppSinkOverrides](
		GTypeAppSink,
		initAppSinkClass,
		wrapAppSink,
		defaultAppSinkOverrides,
	)
}

func initAppSinkClass(gclass unsafe.Pointer, overrides AppSinkOverrides, classInitFunc func(*AppSinkClass)) {
	pclass := (*C.GstAppSinkClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAppSink))))

	if overrides.Eos != nil {
		pclass.eos = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_eos)
	}

	if overrides.NewPreroll != nil {
		pclass.new_preroll = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_new_preroll)
	}

	if overrides.NewSample != nil {
		pclass.new_sample = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_new_sample)
	}

	if overrides.PullPreroll != nil {
		pclass.pull_preroll = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_pull_preroll)
	}

	if overrides.PullSample != nil {
		pclass.pull_sample = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_pull_sample)
	}

	if overrides.TryPullPreroll != nil {
		pclass.try_pull_preroll = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_try_pull_preroll)
	}

	if overrides.TryPullSample != nil {
		pclass.try_pull_sample = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_try_pull_sample)
	}

	if classInitFunc != nil {
		class := (*AppSinkClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppSink(obj *coreglib.Object) *AppSink {
	return &AppSink{
		BaseSink: gstbase.BaseSink{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
		URIHandler: gst.URIHandler{
			Object: obj,
		},
	}
}

func marshalAppSink(p uintptr) (interface{}, error) {
	return wrapAppSink(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEos: signal that the end-of-stream has been reached. This signal is
// emitted from the streaming thread.
func (appsink *AppSink) ConnectEos(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "eos", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectEos), f)
}

// ConnectNewPreroll: signal that a new preroll sample is available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
//
// The new preroll sample can be retrieved with the "pull-preroll" action signal
// or gst_app_sink_pull_preroll() either from this signal callback or from any
// other thread.
//
// Note that this signal is only emitted when the "emit-signals" property is set
// to TRUE, which it is not by default for performance reasons.
func (appsink *AppSink) ConnectNewPreroll(f func() (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "new-preroll", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectNewPreroll), f)
}

// ConnectNewSample: signal that a new sample is available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
//
// The new sample can be retrieved with the "pull-sample" action signal or
// gst_app_sink_pull_sample() either from this signal callback or from any other
// thread.
//
// Note that this signal is only emitted when the "emit-signals" property is set
// to TRUE, which it is not by default for performance reasons.
func (appsink *AppSink) ConnectNewSample(f func() (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "new-sample", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectNewSample), f)
}

// ConnectNewSerializedEvent: signal that a new downstream serialized event is
// available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
//
// The new event can be retrieved with the "try-pull-object" action signal or
// gst_app_sink_pull_object() either from this signal callback or from any other
// thread.
//
// EOS will not be notified using this signal, use AppSink::eos instead. EOS
// cannot be pulled either, use gst_app_sink_is_eos() to check for it.
//
// Note that this signal is only emitted when the "emit-signals" property is set
// to TRUE, which it is not by default for performance reasons.
//
// The callback should return TRUE if the event has been handled, which will
// skip basesink handling of the event, FALSE otherwise.
func (appsink *AppSink) ConnectNewSerializedEvent(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "new-serialized-event", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectNewSerializedEvent), f)
}

// ConnectPullPreroll: get the last preroll sample in appsink. This was the
// sample that caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample() or the "pull-sample" action signal.
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// This function blocks until a preroll sample or EOS is received or the appsink
// element is set to the READY/NULL state.
func (appsink *AppSink) ConnectPullPreroll(f func() (sample *gst.Sample)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "pull-preroll", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectPullPreroll), f)
}

// ConnectPullSample: this function blocks until a sample or EOS becomes
// available or the appsink element is set to the READY/NULL state.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered samples will be put in a queue so that the application
// can pull samples at its own rate.
//
// Note that when the application does not pull samples fast enough, the queued
// samples could consume a lot of memory, especially when dealing with raw video
// frames. It's possible to control the behaviour of the queue with the "drop"
// and "max-buffers" properties.
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
func (appsink *AppSink) ConnectPullSample(f func() (sample *gst.Sample)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "pull-sample", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectPullSample), f)
}

// ConnectTryPullObject: this function blocks until a sample or an event becomes
// available or the appsink element is set to the READY/NULL state or the
// timeout expires.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered samples and events will be put in a queue so that the
// application can pull them at its own rate. Events can be pulled when the
// appsink is in the READY, PAUSED or PLAYING state.
//
// Note that when the application does not pull samples fast enough, the queued
// samples could consume a lot of memory, especially when dealing with raw video
// frames. It's possible to control the behaviour of the queue with the "drop"
// and "max-buffers" properties.
//
// This function will only pull serialized events, excluding the EOS event for
// which this functions returns NULL. Use gst_app_sink_is_eos() to check for the
// EOS condition.
//
// This signal is a variant of AppSink::try-pull-sample: that can be used to
// handle incoming events as well as samples.
//
// Note that future releases may extend this API to return other object types so
// make sure that your code is checking for the actual type it is handling.
func (appsink *AppSink) ConnectTryPullObject(f func(timeout uint64) (miniObject *gst.MiniObject)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "try-pull-object", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectTryPullObject), f)
}

// ConnectTryPullPreroll: get the last preroll sample in appsink. This was the
// sample that caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample() or the "pull-sample" action signal.
//
// If an EOS event was received before any buffers or the timeout expires, this
// function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// This function blocks until a preroll sample or EOS is received, the appsink
// element is set to the READY/NULL state, or the timeout expires.
func (appsink *AppSink) ConnectTryPullPreroll(f func(timeout uint64) (sample *gst.Sample)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "try-pull-preroll", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectTryPullPreroll), f)
}

// ConnectTryPullSample: this function blocks until a sample or EOS becomes
// available or the appsink element is set to the READY/NULL state or the
// timeout expires.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered samples will be put in a queue so that the application
// can pull samples at its own rate.
//
// Note that when the application does not pull samples fast enough, the queued
// samples could consume a lot of memory, especially when dealing with raw video
// frames. It's possible to control the behaviour of the queue with the "drop"
// and "max-buffers" properties.
//
// If an EOS event was received before any buffers or the timeout expires, this
// function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
func (appsink *AppSink) ConnectTryPullSample(f func(timeout uint64) (sample *gst.Sample)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "try-pull-sample", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectTryPullSample), f)
}

// BufferListSupport: check if appsink supports buffer lists.
//
// The function returns the following values:
//
//    - ok: TRUE if appsink supports buffer lists.
//
func (appsink *AppSink) BufferListSupport() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_buffer_list_support(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Caps: get the configured caps on appsink.
//
// The function returns the following values:
//
//    - caps (optional) accepted by the sink. gst_caps_unref() after usage.
//
func (appsink *AppSink) Caps() *gst.Caps {
	var _arg0 *C.GstAppSink // out
	var _cret *C.GstCaps    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_caps(_arg0)
	runtime.KeepAlive(appsink)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// Drop: check if appsink will drop old buffers when the maximum amount of
// queued buffers is reached.
//
// The function returns the following values:
//
//    - ok: TRUE if appsink is dropping old buffers when the queue is filled.
//
func (appsink *AppSink) Drop() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_drop(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EmitSignals: check if appsink will emit the "new-preroll" and "new-sample"
// signals.
//
// The function returns the following values:
//
//    - ok: TRUE if appsink is emitting the "new-preroll" and "new-sample"
//      signals.
//
func (appsink *AppSink) EmitSignals() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_emit_signals(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxBuffers: get the maximum amount of buffers that can be queued in appsink.
//
// The function returns the following values:
//
//    - guint: maximum amount of buffers that can be queued.
//
func (appsink *AppSink) MaxBuffers() uint {
	var _arg0 *C.GstAppSink // out
	var _cret C.guint       // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_max_buffers(_arg0)
	runtime.KeepAlive(appsink)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// WaitOnEos: check if appsink will wait for all buffers to be consumed when an
// EOS is received.
//
// The function returns the following values:
//
//    - ok: TRUE if appsink will wait for all buffers to be consumed when an EOS
//      is received.
//
func (appsink *AppSink) WaitOnEos() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_wait_on_eos(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEos: check if appsink is EOS, which is when no more samples can be pulled
// because an EOS event was received.
//
// This function also returns TRUE when the appsink is not in the PAUSED or
// PLAYING state.
//
// The function returns the following values:
//
//    - ok: TRUE if no more samples can be pulled and the appsink is EOS.
//
func (appsink *AppSink) IsEos() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_is_eos(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PullPreroll: get the last preroll sample in appsink. This was the sample that
// caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// This function blocks until a preroll sample or EOS is received or the appsink
// element is set to the READY/NULL state.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS. Call
//      gst_sample_unref() after usage.
//
func (appsink *AppSink) PullPreroll() *gst.Sample {
	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_pull_preroll(_arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// PullSample: this function blocks until a sample or EOS becomes available or
// the appsink element is set to the READY/NULL state.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS. Call
//      gst_sample_unref() after usage.
//
func (appsink *AppSink) PullSample() *gst.Sample {
	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_pull_sample(_arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// SetBufferListSupport: instruct appsink to enable or disable buffer list
// support.
//
// For backwards-compatibility reasons applications need to opt in to indicate
// that they will be able to handle buffer lists.
//
// The function takes the following parameters:
//
//    - enableLists: enable or disable buffer list support.
//
func (appsink *AppSink) SetBufferListSupport(enableLists bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if enableLists {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_buffer_list_support(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(enableLists)
}

// SetCaps: set the capabilities on the appsink element. This function takes a
// copy of the caps structure. After calling this method, the sink will only
// accept caps that match caps. If caps is non-fixed, or incomplete, you must
// check the caps on the samples to get the actual used caps.
//
// The function takes the following parameters:
//
//    - caps (optional) to set.
//
func (appsink *AppSink) SetCaps(caps *gst.Caps) {
	var _arg0 *C.GstAppSink // out
	var _arg1 *C.GstCaps    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_app_sink_set_caps(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(caps)
}

// SetDrop: instruct appsink to drop old buffers when the maximum amount of
// queued buffers is reached.
//
// The function takes the following parameters:
//
//    - drop: new state.
//
func (appsink *AppSink) SetDrop(drop bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if drop {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_drop(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(drop)
}

// SetEmitSignals: make appsink emit the "new-preroll" and "new-sample" signals.
// This option is by default disabled because signal emission is expensive and
// unneeded when the application prefers to operate in pull mode.
//
// The function takes the following parameters:
//
//    - emit: new state.
//
func (appsink *AppSink) SetEmitSignals(emit bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if emit {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_emit_signals(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(emit)
}

// SetMaxBuffers: set the maximum amount of buffers that can be queued in
// appsink. After this amount of buffers are queued in appsink, any more buffers
// will block upstream elements until a sample is pulled from appsink.
//
// The function takes the following parameters:
//
//    - max: maximum number of buffers to queue.
//
func (appsink *AppSink) SetMaxBuffers(max uint) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint(max)

	C.gst_app_sink_set_max_buffers(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(max)
}

// SetWaitOnEos: instruct appsink to wait for all buffers to be consumed when an
// EOS is received.
//
// The function takes the following parameters:
//
//    - wait: new state.
//
func (appsink *AppSink) SetWaitOnEos(wait bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if wait {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_wait_on_eos(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(wait)
}

// TryPullPreroll: get the last preroll sample in appsink. This was the sample
// that caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers or the timeout expires, this
// function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// This function blocks until a preroll sample or EOS is received, the appsink
// element is set to the READY/NULL state, or the timeout expires.
//
// The function takes the following parameters:
//
//    - timeout: maximum amount of time to wait for the preroll sample.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS or the
//      timeout expires. Call gst_sample_unref() after usage.
//
func (appsink *AppSink) TryPullPreroll(timeout gst.ClockTime) *gst.Sample {
	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint64(timeout)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_app_sink_try_pull_preroll(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// TryPullSample: this function blocks until a sample or EOS becomes available
// or the appsink element is set to the READY/NULL state or the timeout expires.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers or the timeout expires, this
// function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// The function takes the following parameters:
//
//    - timeout: maximum amount of time to wait for a sample.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS or the
//      timeout expires. Call gst_sample_unref() after usage.
//
func (appsink *AppSink) TryPullSample(timeout gst.ClockTime) *gst.Sample {
	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint64(timeout)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_app_sink_try_pull_sample(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

func (appsink *AppSink) eos() {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.eos

	var _arg0 *C.GstAppSink // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	C._gotk4_gstapp1_AppSink_virtual_eos(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)
}

// The function returns the following values:
//
func (appsink *AppSink) newPreroll() gst.FlowReturn {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.new_preroll

	var _arg0 *C.GstAppSink   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_new_preroll(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function returns the following values:
//
func (appsink *AppSink) newSample() gst.FlowReturn {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.new_sample

	var _arg0 *C.GstAppSink   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_new_sample(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// pullPreroll: get the last preroll sample in appsink. This was the sample that
// caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// This function blocks until a preroll sample or EOS is received or the appsink
// element is set to the READY/NULL state.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS. Call
//      gst_sample_unref() after usage.
//
func (appsink *AppSink) pullPreroll() *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.pull_preroll

	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_pull_preroll(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// pullSample: this function blocks until a sample or EOS becomes available or
// the appsink element is set to the READY/NULL state.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS. Call
//      gst_sample_unref() after usage.
//
func (appsink *AppSink) pullSample() *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.pull_sample

	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_pull_sample(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// tryPullPreroll: get the last preroll sample in appsink. This was the sample
// that caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers or the timeout expires, this
// function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// This function blocks until a preroll sample or EOS is received, the appsink
// element is set to the READY/NULL state, or the timeout expires.
//
// The function takes the following parameters:
//
//    - timeout: maximum amount of time to wait for the preroll sample.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS or the
//      timeout expires. Call gst_sample_unref() after usage.
//
func (appsink *AppSink) tryPullPreroll(timeout gst.ClockTime) *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.try_pull_preroll

	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint64(timeout)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C._gotk4_gstapp1_AppSink_virtual_try_pull_preroll(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// tryPullSample: this function blocks until a sample or EOS becomes available
// or the appsink element is set to the READY/NULL state or the timeout expires.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers or the timeout expires, this
// function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// The function takes the following parameters:
//
//    - timeout: maximum amount of time to wait for a sample.
//
// The function returns the following values:
//
//    - sample (optional) or NULL when the appsink is stopped or EOS or the
//      timeout expires. Call gst_sample_unref() after usage.
//
func (appsink *AppSink) tryPullSample(timeout gst.ClockTime) *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.try_pull_sample

	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint64(timeout)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C._gotk4_gstapp1_AppSink_virtual_try_pull_sample(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// AppSinkClass: instance of this type is always passed by reference.
type AppSinkClass struct {
	*appSinkClass
}

// appSinkClass is the struct that's finalized.
type appSinkClass struct {
	native *C.GstAppSinkClass
}

func (a *AppSinkClass) BasesinkClass() *gstbase.BaseSinkClass {
	valptr := &a.native.basesink_class
	var _v *gstbase.BaseSinkClass // out
	_v = (*gstbase.BaseSinkClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
