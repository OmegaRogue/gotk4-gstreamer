// Code generated by girgen. DO NOT EDIT.

package gstallocators

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/allocators/allocators.h>
import "C"

// GType values.
var (
	GTypeFdAllocator = coreglib.Type(C.gst_fd_allocator_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFdAllocator, F: marshalFdAllocator},
	})
}

// FdMemoryFlags various flags to control the operation of the fd backed memory.
type FdMemoryFlags C.guint

const (
	// FdMemoryFlagNone: no flag.
	FdMemoryFlagNone FdMemoryFlags = 0b0
	// FdMemoryFlagKeepMapped: once the memory is mapped, keep it mapped until
	// the memory is destroyed.
	FdMemoryFlagKeepMapped FdMemoryFlags = 0b1
	// FdMemoryFlagMapPrivate: do a private mapping instead of the default
	// shared mapping.
	FdMemoryFlagMapPrivate FdMemoryFlags = 0b10
	// FdMemoryFlagDontClose: don't close the file descriptor when the memory is
	// freed. Since: 1.10.
	FdMemoryFlagDontClose FdMemoryFlags = 0b100
)

// String returns the names in string for FdMemoryFlags.
func (f FdMemoryFlags) String() string {
	if f == 0 {
		return "FdMemoryFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(84)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FdMemoryFlagNone:
			builder.WriteString("None|")
		case FdMemoryFlagKeepMapped:
			builder.WriteString("KeepMapped|")
		case FdMemoryFlagMapPrivate:
			builder.WriteString("MapPrivate|")
		case FdMemoryFlagDontClose:
			builder.WriteString("DontClose|")
		default:
			builder.WriteString(fmt.Sprintf("FdMemoryFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FdMemoryFlags) Has(other FdMemoryFlags) bool {
	return (f & other) == other
}

// FdMemoryGetFd: get the fd from mem. Call gst_is_fd_memory() to check if mem
// has an fd.
//
// The function takes the following parameters:
//
//    - mem: Memory.
//
// The function returns the following values:
//
//    - gint: fd of mem or -1 when there is no fd on mem.
//
func FdMemoryGetFd(mem *gst.Memory) int {
	var _arg1 *C.GstMemory // out
	var _cret C.gint       // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_fd_memory_get_fd(_arg1)
	runtime.KeepAlive(mem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsFdMemory: check if mem is memory backed by an fd.
//
// The function takes the following parameters:
//
//    - mem: Memory.
//
// The function returns the following values:
//
//    - ok: TRUE when mem has an fd that can be retrieved with
//      gst_fd_memory_get_fd().
//
func IsFdMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_fd_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FdAllocatorOverrides contains methods that are overridable.
type FdAllocatorOverrides struct {
}

func defaultFdAllocatorOverrides(v *FdAllocator) FdAllocatorOverrides {
	return FdAllocatorOverrides{}
}

// FdAllocator: base class for allocators with fd-backed memory.
type FdAllocator struct {
	_ [0]func() // equal guard
	gst.Allocator
}

var (
	_ gst.Allocatorrer = (*FdAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FdAllocator, *FdAllocatorClass, FdAllocatorOverrides](
		GTypeFdAllocator,
		initFdAllocatorClass,
		wrapFdAllocator,
		defaultFdAllocatorOverrides,
	)
}

func initFdAllocatorClass(gclass unsafe.Pointer, overrides FdAllocatorOverrides, classInitFunc func(*FdAllocatorClass)) {
	if classInitFunc != nil {
		class := (*FdAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFdAllocator(obj *coreglib.Object) *FdAllocator {
	return &FdAllocator{
		Allocator: gst.Allocator{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalFdAllocator(p uintptr) (interface{}, error) {
	return wrapFdAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFdAllocator: return a new fd allocator.
//
// The function returns the following values:
//
//    - fdAllocator: new fd allocator, or NULL if the allocator isn't available.
//      Use gst_object_unref() to release the allocator after usage.
//
func NewFdAllocator() *FdAllocator {
	var _cret *C.GstAllocator // in

	_cret = C.gst_fd_allocator_new()

	var _fdAllocator *FdAllocator // out

	_fdAllocator = wrapFdAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fdAllocator
}

// FdAllocatorAlloc: return a GstMemory that wraps a generic file descriptor.
//
// The function takes the following parameters:
//
//    - allocator to be used for this memory.
//    - fd: file descriptor.
//    - size: memory size.
//    - flags: extra FdMemoryFlags.
//
// The function returns the following values:
//
//    - memory: gstMemory based on allocator. When the buffer will be released
//      the allocator will close the fd unless the GST_FD_MEMORY_FLAG_DONT_CLOSE
//      flag is specified. The memory is only mmapped on gst_buffer_map()
//      request.
//
func FdAllocatorAlloc(allocator gst.Allocatorrer, fd int, size uint, flags FdMemoryFlags) *gst.Memory {
	var _arg1 *C.GstAllocator    // out
	var _arg2 C.gint             // out
	var _arg3 C.gsize            // out
	var _arg4 C.GstFdMemoryFlags // out
	var _cret *C.GstMemory       // in

	_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg2 = C.gint(fd)
	_arg3 = C.gsize(size)
	_arg4 = C.GstFdMemoryFlags(flags)

	_cret = C.gst_fd_allocator_alloc(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _memory *gst.Memory // out

	_memory = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_memory)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _memory
}
