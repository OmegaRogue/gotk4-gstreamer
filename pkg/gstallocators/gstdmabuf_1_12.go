// Code generated by girgen. DO NOT EDIT.

package gstallocators

import (
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/allocators/allocators.h>
import "C"

// GType values.
var (
	GTypeDmaBufAllocator = coreglib.Type(C.gst_dmabuf_allocator_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDmaBufAllocator, F: marshalDmaBufAllocator},
	})
}

// CAPS_FEATURE_MEMORY_DMABUF: constant that defines the caps feature name for
// DMA buffer sharing.
//
// It has to be used for non-mappable dma-buf only, i.e. when the underlying
// memory is not mappable to user space. Or when the mapped memory contains non
// meaningful data. It can be the case for protected content or when the user
// wants explicitly avoid any software post processing.
//
// In these cases all elements between the exported and the importer has to work
// in passthrough mode. This is done by adding this caps feature.
//
// When the memory is mappable for read and write requests then it is assumes to
// be a fast path and so this caps feature should not be used. Though according
// to the dma-buf protocol, while it is mapped it prevents the exporter to
// migrate the buffer.
//
// This caps feature should not serve at all the purpose of selecting the
// GST_ALLOCATOR_DMABUF allocator during caps negotiation. When the exporter is
// the upstream element from the importer point of view, the exporter should try
// to map the dma buffer at runtime (preferably during decide_allocation phase).
// When it succeeds for T_MAP_READWRITE this caps feature should not be used.
// This allows scalers, color converts and any image processing filters to work
// directly on the dma buffer. In this case the importer element should check
// all incoming memory using gst_is_dmabuf_memory().
const CAPS_FEATURE_MEMORY_DMABUF = "memory:DMABuf"

// DmaBufAllocatorOverrides contains methods that are overridable.
type DmaBufAllocatorOverrides struct {
}

func defaultDmaBufAllocatorOverrides(v *DmaBufAllocator) DmaBufAllocatorOverrides {
	return DmaBufAllocatorOverrides{}
}

// DmaBufAllocator: base class for allocators with dmabuf-backed memory.
type DmaBufAllocator struct {
	_ [0]func() // equal guard
	FdAllocator
}

var (
	_ gst.Allocatorrer = (*DmaBufAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DmaBufAllocator, *DmaBufAllocatorClass, DmaBufAllocatorOverrides](
		GTypeDmaBufAllocator,
		initDmaBufAllocatorClass,
		wrapDmaBufAllocator,
		defaultDmaBufAllocatorOverrides,
	)
}

func initDmaBufAllocatorClass(gclass unsafe.Pointer, overrides DmaBufAllocatorOverrides, classInitFunc func(*DmaBufAllocatorClass)) {
	if classInitFunc != nil {
		class := (*DmaBufAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDmaBufAllocator(obj *coreglib.Object) *DmaBufAllocator {
	return &DmaBufAllocator{
		FdAllocator: FdAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalDmaBufAllocator(p uintptr) (interface{}, error) {
	return wrapDmaBufAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDmaBufAllocator: return a new dmabuf allocator.
//
// The function returns the following values:
//
//    - dmaBufAllocator: new dmabuf allocator, or NULL if the allocator isn't
//      available. Use gst_object_unref() to release the allocator after usage.
//
func NewDmaBufAllocator() *DmaBufAllocator {
	var _cret *C.GstAllocator // in

	_cret = C.gst_dmabuf_allocator_new()

	var _dmaBufAllocator *DmaBufAllocator // out

	_dmaBufAllocator = wrapDmaBufAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dmaBufAllocator
}
