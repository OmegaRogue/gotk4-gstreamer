// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
// extern void _gotk4_gstbase1_CollectPadsFlushFunction(GstCollectPads*, gpointer);
// extern gint _gotk4_gstbase1_CollectPadsCompareFunction(GstCollectPads*, GstCollectData*, GstClockTime, GstCollectData*, GstClockTime, gpointer);
// extern gboolean _gotk4_gstbase1_CollectPadsQueryFunction(GstCollectPads*, GstCollectData*, GstQuery*, gpointer);
// extern gboolean _gotk4_gstbase1_CollectPadsEventFunction(GstCollectPads*, GstCollectData*, GstEvent*, gpointer);
// extern GstFlowReturn _gotk4_gstbase1_CollectPadsFunction(GstCollectPads*, gpointer);
// extern GstFlowReturn _gotk4_gstbase1_CollectPadsClipFunction(GstCollectPads*, GstCollectData*, GstBuffer*, GstBuffer**, gpointer);
// extern GstFlowReturn _gotk4_gstbase1_CollectPadsBufferFunction(GstCollectPads*, GstCollectData*, GstBuffer*, gpointer);
import "C"

// GType values.
var (
	GTypeCollectPads = coreglib.Type(C.gst_collect_pads_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCollectPads, F: marshalCollectPads},
	})
}

type CollectPadsStateFlags C.guint

const (
	// CollectPadsStateEos: set if collectdata's pad is EOS.
	CollectPadsStateEos CollectPadsStateFlags = 0b1
	// CollectPadsStateFlushing: set if collectdata's pad is flushing.
	CollectPadsStateFlushing CollectPadsStateFlags = 0b10
	// CollectPadsStateNewSegment: set if collectdata's pad received a
	// new_segment event.
	CollectPadsStateNewSegment CollectPadsStateFlags = 0b100
	// CollectPadsStateWaiting: set if collectdata's pad must be waited for when
	// collecting.
	CollectPadsStateWaiting CollectPadsStateFlags = 0b1000
	// CollectPadsStateLocked: set collectdata's pad WAITING state must not be
	// changed. CollectPadsStateFlags indicate private state of a collectdata('s
	// pad).
	CollectPadsStateLocked CollectPadsStateFlags = 0b10000
)

// String returns the names in string for CollectPadsStateFlags.
func (c CollectPadsStateFlags) String() string {
	if c == 0 {
		return "CollectPadsStateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(118)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CollectPadsStateEos:
			builder.WriteString("Eos|")
		case CollectPadsStateFlushing:
			builder.WriteString("Flushing|")
		case CollectPadsStateNewSegment:
			builder.WriteString("NewSegment|")
		case CollectPadsStateWaiting:
			builder.WriteString("Waiting|")
		case CollectPadsStateLocked:
			builder.WriteString("Locked|")
		default:
			builder.WriteString(fmt.Sprintf("CollectPadsStateFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CollectPadsStateFlags) Has(other CollectPadsStateFlags) bool {
	return (c & other) == other
}

// CollectPadsBufferFunction: function that will be called when a (considered
// oldest) buffer can be muxed. If all pads have reached EOS, this function is
// called with NULL buffer and NULL data.
type CollectPadsBufferFunction func(pads *CollectPads, data *CollectData, buffer *gst.Buffer) (flowReturn gst.FlowReturn)

// CollectPadsClipFunction: function that will be called when inbuffer is
// received on the pad managed by data in the collectpad object pads.
//
// The function should use the segment of data and the negotiated media type on
// the pad to perform clipping of inbuffer.
//
// This function takes ownership of inbuffer and should output a buffer in
// outbuffer or return NULL in outbuffer if the buffer should be dropped.
type CollectPadsClipFunction func(pads *CollectPads, data *CollectData, inbuffer *gst.Buffer) (outbuffer *gst.Buffer, flowReturn gst.FlowReturn)

// CollectPadsCompareFunction: function for comparing two timestamps of buffers
// or newsegments collected on one pad.
type CollectPadsCompareFunction func(pads *CollectPads, data1 *CollectData, timestamp1 gst.ClockTime, data2 *CollectData, timestamp2 gst.ClockTime) (gint int)

// CollectPadsEventFunction: function that will be called while processing an
// event. It takes ownership of the event and is responsible for chaining up (to
// gst_collect_pads_event_default()) or dropping events (such typical cases
// being handled by the default handler).
type CollectPadsEventFunction func(pads *CollectPads, pad *CollectData, event *gst.Event) (ok bool)

// CollectPadsFunction: function that will be called when all pads have received
// data.
type CollectPadsFunction func(pads *CollectPads) (flowReturn gst.FlowReturn)

// CollectPadsQueryFunction: function that will be called while processing a
// query. It takes ownership of the query and is responsible for chaining up (to
// events downstream (with gst_pad_event_default()).
type CollectPadsQueryFunction func(pads *CollectPads, pad *CollectData, query *gst.Query) (ok bool)

// CollectPadsOverrides contains methods that are overridable.
type CollectPadsOverrides struct {
}

func defaultCollectPadsOverrides(v *CollectPads) CollectPadsOverrides {
	return CollectPadsOverrides{}
}

// CollectPads manages a set of pads that operate in collect mode. This means
// that control is given to the manager of this object when all pads have data.
//
//    * Collectpads are created with gst_collect_pads_new(). A callback should then
//      be installed with gst_collect_pads_set_function ().
//
//    * Pads are added to the collection with gst_collect_pads_add_pad()/
//      gst_collect_pads_remove_pad(). The pad has to be a sinkpad. When added,
//      the chain, event and query functions of the pad are overridden. The
//      element_private of the pad is used to store private information for the
//      collectpads.
//
//    * For each pad, data is queued in the _chain function or by
//      performing a pull_range.
//
//    * When data is queued on all pads in waiting mode, the callback function is called.
//
//    * Data can be dequeued from the pad with the gst_collect_pads_pop() method.
//      One can peek at the data with the gst_collect_pads_peek() function.
//      These functions will return NULL if the pad received an EOS event. When all
//      pads return NULL from a gst_collect_pads_peek(), the element can emit an EOS
//      event itself.
//
//    * Data can also be dequeued in byte units using the gst_collect_pads_available(),
//      gst_collect_pads_read_buffer() and gst_collect_pads_flush() calls.
//
//    * Elements should call gst_collect_pads_start() and gst_collect_pads_stop() in
//      their state change functions to start and stop the processing of the collectpads.
//      The gst_collect_pads_stop() call should be called before calling the parent
//      element state change function in the PAUSED_TO_READY state change to ensure
//      no pad is blocked and the element can finish streaming.
//
//    * gst_collect_pads_set_waiting() sets a pad to waiting or non-waiting mode.
//      CollectPads element is not waiting for data to be collected on non-waiting pads.
//      Thus these pads may but need not have data when the callback is called.
//      All pads are in waiting mode by default.
type CollectPads struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*CollectPads)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CollectPads, *CollectPadsClass, CollectPadsOverrides](
		GTypeCollectPads,
		initCollectPadsClass,
		wrapCollectPads,
		defaultCollectPadsOverrides,
	)
}

func initCollectPadsClass(gclass unsafe.Pointer, overrides CollectPadsOverrides, classInitFunc func(*CollectPadsClass)) {
	if classInitFunc != nil {
		class := (*CollectPadsClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCollectPads(obj *coreglib.Object) *CollectPads {
	return &CollectPads{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalCollectPads(p uintptr) (interface{}, error) {
	return wrapCollectPads(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCollectPads: create a new instance of CollectPads.
//
// MT safe.
//
// The function returns the following values:
//
//    - collectPads: new CollectPads, or NULL in case of an error.
//
func NewCollectPads() *CollectPads {
	var _cret *C.GstCollectPads // in

	_cret = C.gst_collect_pads_new()

	var _collectPads *CollectPads // out

	_collectPads = wrapCollectPads(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _collectPads
}

// Available: query how much bytes can be read from each queued buffer. This
// means that the result of this call is the maximum number of bytes that can be
// read from each of the pads.
//
// This function should be called with pads STREAM_LOCK held, such as in the
// callback.
//
// MT safe.
//
// The function returns the following values:
//
//    - guint: maximum number of bytes queued on all pads. This function returns
//      0 if a pad has no queued buffer.
//
func (pads *CollectPads) Available() uint {
	var _arg0 *C.GstCollectPads // out
	var _cret C.guint           // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))

	_cret = C.gst_collect_pads_available(_arg0)
	runtime.KeepAlive(pads)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ClipRunningTime: convenience clipping function that converts incoming
// buffer's timestamp to running time, or clips the buffer if outside configured
// segment.
//
// Since 1.6, this clipping function also sets the DTS parameter of the
// GstCollectData structure. This version of the running time DTS can be
// negative. G_MININT64 is used to indicate invalid value.
//
// The function takes the following parameters:
//
//    - cdata: collect data of corresponding pad.
//    - buf: buffer being clipped.
//    - userData (optional): user data (unused).
//
// The function returns the following values:
//
//    - outbuf (optional): output buffer with running time, or NULL if clipped.
//    - flowReturn
//
func (pads *CollectPads) ClipRunningTime(cdata *CollectData, buf *gst.Buffer, userData unsafe.Pointer) (*gst.Buffer, gst.FlowReturn) {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 *C.GstBuffer      // out
	var _arg3 *C.GstBuffer      // in
	var _arg4 C.gpointer        // out
	var _cret C.GstFlowReturn   // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(cdata)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.gst_collect_pads_clip_running_time(_arg0, _arg1, _arg2, &_arg3, _arg4)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(cdata)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(userData)

	var _outbuf *gst.Buffer        // out
	var _flowReturn gst.FlowReturn // out

	if _arg3 != nil {
		_outbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_outbuf)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	_flowReturn = gst.FlowReturn(_cret)

	return _outbuf, _flowReturn
}

// EventDefault: default CollectPads event handling that elements should always
// chain up to to ensure proper operation. Element might however indicate event
// should not be forwarded downstream.
//
// The function takes the following parameters:
//
//    - data: collect data of corresponding pad.
//    - event being processed.
//    - discard process but do not send event downstream.
//
// The function returns the following values:
//
func (pads *CollectPads) EventDefault(data *CollectData, event *gst.Event, discard bool) bool {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 *C.GstEvent       // out
	var _arg3 C.gboolean        // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	if discard {
		_arg3 = C.TRUE
	}

	_cret = C.gst_collect_pads_event_default(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)
	runtime.KeepAlive(event)
	runtime.KeepAlive(discard)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flush size bytes from the pad data.
//
// This function should be called with pads STREAM_LOCK held, such as in the
// callback.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - data to use.
//    - size: number of bytes to flush.
//
// The function returns the following values:
//
//    - guint: number of bytes flushed This can be less than size and is 0 if the
//      pad was end-of-stream.
//
func (pads *CollectPads) Flush(data *CollectData, size uint) uint {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 C.guint           // out
	var _cret C.guint           // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = C.guint(size)

	_cret = C.gst_collect_pads_flush(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Peek at the buffer currently queued in data. This function should be called
// with the pads STREAM_LOCK held, such as in the callback handler.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - data to use.
//
// The function returns the following values:
//
//    - buffer (optional) in data or NULL if no buffer is queued. should unref
//      the buffer after usage.
//
func (pads *CollectPads) Peek(data *CollectData) *gst.Buffer {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _cret *C.GstBuffer      // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.gst_collect_pads_peek(_arg0, _arg1)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// Pop the buffer currently queued in data. This function should be called with
// the pads STREAM_LOCK held, such as in the callback handler.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - data to use.
//
// The function returns the following values:
//
//    - buffer (optional) in data or NULL if no buffer was queued. You should
//      unref the buffer after usage.
//
func (pads *CollectPads) Pop(data *CollectData) *gst.Buffer {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _cret *C.GstBuffer      // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.gst_collect_pads_pop(_arg0, _arg1)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// QueryDefault: default CollectPads query handling that elements should always
// chain up to to ensure proper operation. Element might however indicate query
// should not be forwarded downstream.
//
// The function takes the following parameters:
//
//    - data: collect data of corresponding pad.
//    - query being processed.
//    - discard process but do not send event downstream.
//
// The function returns the following values:
//
func (pads *CollectPads) QueryDefault(data *CollectData, query *gst.Query, discard bool) bool {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 *C.GstQuery       // out
	var _arg3 C.gboolean        // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if discard {
		_arg3 = C.TRUE
	}

	_cret = C.gst_collect_pads_query_default(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)
	runtime.KeepAlive(query)
	runtime.KeepAlive(discard)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReadBuffer: get a subbuffer of size bytes from the given pad data.
//
// This function should be called with pads STREAM_LOCK held, such as in the
// callback.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - data to use.
//    - size: number of bytes to read.
//
// The function returns the following values:
//
//    - buffer (optional): sub buffer. The size of the buffer can be less that
//      requested. A return of NULL signals that the pad is end-of-stream. Unref
//      the buffer after use.
//
func (pads *CollectPads) ReadBuffer(data *CollectData, size uint) *gst.Buffer {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 C.guint           // out
	var _cret *C.GstBuffer      // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = C.guint(size)

	_cret = C.gst_collect_pads_read_buffer(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// RemovePad: remove a pad from the collection of collect pads. This function
// will also free the CollectData and all the resources that were allocated with
// gst_collect_pads_add_pad().
//
// The pad will be deactivated automatically when pads is stopped.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - pad to remove.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad could be removed.
//
func (pads *CollectPads) RemovePad(pad *gst.Pad) bool {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstPad         // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_collect_pads_remove_pad(_arg0, _arg1)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetBufferFunction: set the callback function and user data that will be
// called with the oldest buffer when all pads have been collected, or NULL on
// EOS. If a buffer is passed, the callback owns a reference and must unref it.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - fn: function to set.
//
func (pads *CollectPads) SetBufferFunction(fn CollectPadsBufferFunction) {
	var _arg0 *C.GstCollectPads              // out
	var _arg1 C.GstCollectPadsBufferFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsBufferFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_buffer_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(fn)
}

// SetClipFunction: install a clipping function that is called right after a
// buffer is received on a pad managed by pads. See CollectPadsClipFunction for
// more info.
//
// The function takes the following parameters:
//
//    - clipfunc: clip function to install.
//
func (pads *CollectPads) SetClipFunction(clipfunc CollectPadsClipFunction) {
	var _arg0 *C.GstCollectPads            // out
	var _arg1 C.GstCollectPadsClipFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsClipFunction)
	_arg2 = C.gpointer(gbox.Assign(clipfunc))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_clip_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(clipfunc)
}

// SetCompareFunction: set the timestamp comparison function.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - fn: function to set.
//
func (pads *CollectPads) SetCompareFunction(fn CollectPadsCompareFunction) {
	var _arg0 *C.GstCollectPads               // out
	var _arg1 C.GstCollectPadsCompareFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsCompareFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_compare_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(fn)
}

// SetEventFunction: set the event callback function and user data that will be
// called when collectpads has received an event originating from one of the
// collected pads. If the event being processed is a serialized one, this
// callback is called with pads STREAM_LOCK held, otherwise not. As this lock
// should be held when calling a number of CollectPads functions, it should be
// acquired if so (unusually) needed.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - fn: function to set.
//
func (pads *CollectPads) SetEventFunction(fn CollectPadsEventFunction) {
	var _arg0 *C.GstCollectPads             // out
	var _arg1 C.GstCollectPadsEventFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsEventFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_event_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(fn)
}

// SetFlushFunction: install a flush function that is called when the internal
// state of all pads should be flushed as part of flushing seek handling. See
// CollectPadsFlushFunction for more info.
//
// The function takes the following parameters:
//
//    - fn: flush function to install.
//
func (pads *CollectPads) SetFlushFunction(fn CollectPadsFlushFunction) {
	var _arg0 *C.GstCollectPads             // out
	var _arg1 C.GstCollectPadsFlushFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsFlushFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_flush_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(fn)
}

// SetFlushing: change the flushing state of all the pads in the collection. No
// pad is able to accept anymore data when flushing is TRUE. Calling this
// function with flushing FALSE makes pads accept data again. Caller must ensure
// that downstream streaming (thread) is not blocked, e.g. by sending a
// FLUSH_START downstream.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - flushing: desired state of the pads.
//
func (pads *CollectPads) SetFlushing(flushing bool) {
	var _arg0 *C.GstCollectPads // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	if flushing {
		_arg1 = C.TRUE
	}

	C.gst_collect_pads_set_flushing(_arg0, _arg1)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(flushing)
}

// SetFunction collectPads provides a default collection algorithm that will
// determine the oldest buffer available on all of its pads, and then delegate
// to a configured callback. However, if circumstances are more complicated
// and/or more control is desired, this sets a callback that will be invoked
// instead when all the pads added to the collection have buffers queued.
// Evidently, this callback is not compatible with
// gst_collect_pads_set_buffer_function() callback. If this callback is set, the
// former will be unset.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - fn: function to set.
//
func (pads *CollectPads) SetFunction(fn CollectPadsFunction) {
	var _arg0 *C.GstCollectPads        // out
	var _arg1 C.GstCollectPadsFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(fn)
}

// SetQueryFunction: set the query callback function and user data that will be
// called after collectpads has received a query originating from one of the
// collected pads. If the query being processed is a serialized one, this
// callback is called with pads STREAM_LOCK held, otherwise not. As this lock
// should be held when calling a number of CollectPads functions, it should be
// acquired if so (unusually) needed.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - fn: function to set.
//
func (pads *CollectPads) SetQueryFunction(fn CollectPadsQueryFunction) {
	var _arg0 *C.GstCollectPads             // out
	var _arg1 C.GstCollectPadsQueryFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstbase1_CollectPadsQueryFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_collect_pads_set_query_function(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(fn)
}

// SetWaiting sets a pad to waiting or non-waiting mode, if at least this pad
// has not been created with locked waiting state, in which case nothing
// happens.
//
// This function should be called with pads STREAM_LOCK held, such as in the
// callback.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - data to use.
//    - waiting: boolean indicating whether this pad should operate in waiting or
//      non-waiting mode.
//
func (pads *CollectPads) SetWaiting(data *CollectData, waiting bool) {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 C.gboolean        // out

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))
	if waiting {
		_arg2 = C.TRUE
	}

	C.gst_collect_pads_set_waiting(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)
	runtime.KeepAlive(waiting)
}

// SrcEventDefault: default CollectPads event handling for the src pad of
// elements. Elements can chain up to this to let flushing seek event handling
// be done by CollectPads.
//
// The function takes the following parameters:
//
//    - pad: src Pad that received the event.
//    - event being processed.
//
// The function returns the following values:
//
func (pads *CollectPads) SrcEventDefault(pad *gst.Pad, event *gst.Event) bool {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstPad         // out
	var _arg2 *C.GstEvent       // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_collect_pads_src_event_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts the processing of data in the collect_pads.
//
// MT safe.
func (pads *CollectPads) Start() {
	var _arg0 *C.GstCollectPads // out

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))

	C.gst_collect_pads_start(_arg0)
	runtime.KeepAlive(pads)
}

// Stop stops the processing of data in the collect_pads. this function will
// also unblock any blocking operations.
//
// MT safe.
func (pads *CollectPads) Stop() {
	var _arg0 *C.GstCollectPads // out

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))

	C.gst_collect_pads_stop(_arg0)
	runtime.KeepAlive(pads)
}

// TakeBuffer: get a subbuffer of size bytes from the given pad data. Flushes
// the amount of read bytes.
//
// This function should be called with pads STREAM_LOCK held, such as in the
// callback.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - data to use.
//    - size: number of bytes to read.
//
// The function returns the following values:
//
//    - buffer (optional): sub buffer. The size of the buffer can be less that
//      requested. A return of NULL signals that the pad is end-of-stream. Unref
//      the buffer after use.
//
func (pads *CollectPads) TakeBuffer(data *CollectData, size uint) *gst.Buffer {
	var _arg0 *C.GstCollectPads // out
	var _arg1 *C.GstCollectData // out
	var _arg2 C.guint           // out
	var _cret *C.GstBuffer      // in

	_arg0 = (*C.GstCollectPads)(unsafe.Pointer(coreglib.InternObject(pads).Native()))
	_arg1 = (*C.GstCollectData)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = C.guint(size)

	_cret = C.gst_collect_pads_take_buffer(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pads)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// CollectData: structure used by the collect_pads.
//
// An instance of this type is always passed by reference.
type CollectData struct {
	*collectData
}

// collectData is the struct that's finalized.
type collectData struct {
	native *C.GstCollectData
}

// Collect: owner CollectPads.
func (c *CollectData) Collect() *CollectPads {
	valptr := &c.native.collect
	var _v *CollectPads // out
	_v = wrapCollectPads(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// Pad managed by this data.
func (c *CollectData) Pad() *gst.Pad {
	valptr := &c.native.pad
	var _v *gst.Pad // out
	{
		obj := coreglib.Take(unsafe.Pointer(*valptr))
		_v = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}
	return _v
}

// Buffer: currently queued buffer.
func (c *CollectData) Buffer() *gst.Buffer {
	valptr := &c.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Pos: position in the buffer.
func (c *CollectData) Pos() uint {
	valptr := &c.native.pos
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Segment: last segment received.
func (c *CollectData) Segment() *gst.Segment {
	valptr := &c.native.segment
	var _v *gst.Segment // out
	_v = (*gst.Segment)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Pos: position in the buffer.
func (c *CollectData) SetPos(pos uint) {
	valptr := &c.native.pos
	*valptr = C.guint(pos)
}

// CollectPadsClass: instance of this type is always passed by reference.
type CollectPadsClass struct {
	*collectPadsClass
}

// collectPadsClass is the struct that's finalized.
type collectPadsClass struct {
	native *C.GstCollectPadsClass
}

func (c *CollectPadsClass) ParentClass() *gst.ObjectClass {
	valptr := &c.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
