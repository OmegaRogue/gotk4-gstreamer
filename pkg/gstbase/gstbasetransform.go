// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
// extern void _gotk4_gstbase1_BaseTransformClass_before_transform(GstBaseTransform*, GstBuffer*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_transform_size(GstBaseTransform*, GstPadDirection, GstCaps*, gsize, GstCaps*, gsize*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_transform_meta(GstBaseTransform*, GstBuffer*, GstMeta*, GstBuffer*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_stop(GstBaseTransform*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_start(GstBaseTransform*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_src_event(GstBaseTransform*, GstEvent*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_sink_event(GstBaseTransform*, GstEvent*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_set_caps(GstBaseTransform*, GstCaps*, GstCaps*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_query(GstBaseTransform*, GstPadDirection, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_propose_allocation(GstBaseTransform*, GstQuery*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_get_unit_size(GstBaseTransform*, GstCaps*, gsize*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_filter_meta(GstBaseTransform*, GstQuery*, GType, GstStructure*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_decide_allocation(GstBaseTransform*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_copy_metadata(GstBaseTransform*, GstBuffer*, GstBuffer*);
// extern gboolean _gotk4_gstbase1_BaseTransformClass_accept_caps(GstBaseTransform*, GstPadDirection, GstCaps*);
// extern GstFlowReturn _gotk4_gstbase1_BaseTransformClass_transform_ip(GstBaseTransform*, GstBuffer*);
// extern GstFlowReturn _gotk4_gstbase1_BaseTransformClass_transform(GstBaseTransform*, GstBuffer*, GstBuffer*);
// extern GstFlowReturn _gotk4_gstbase1_BaseTransformClass_submit_input_buffer(GstBaseTransform*, gboolean, GstBuffer*);
// extern GstFlowReturn _gotk4_gstbase1_BaseTransformClass_prepare_output_buffer(GstBaseTransform*, GstBuffer*, GstBuffer**);
// extern GstFlowReturn _gotk4_gstbase1_BaseTransformClass_generate_output(GstBaseTransform*, GstBuffer**);
// extern GstCaps* _gotk4_gstbase1_BaseTransformClass_transform_caps(GstBaseTransform*, GstPadDirection, GstCaps*, GstCaps*);
// extern GstCaps* _gotk4_gstbase1_BaseTransformClass_fixate_caps(GstBaseTransform*, GstPadDirection, GstCaps*, GstCaps*);
// GstCaps* _gotk4_gstbase1_BaseTransform_virtual_fixate_caps(void* fnptr, GstBaseTransform* arg0, GstPadDirection arg1, GstCaps* arg2, GstCaps* arg3) {
//   return ((GstCaps* (*)(GstBaseTransform*, GstPadDirection, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstCaps* _gotk4_gstbase1_BaseTransform_virtual_transform_caps(void* fnptr, GstBaseTransform* arg0, GstPadDirection arg1, GstCaps* arg2, GstCaps* arg3) {
//   return ((GstCaps* (*)(GstBaseTransform*, GstPadDirection, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstFlowReturn _gotk4_gstbase1_BaseTransform_virtual_generate_output(void* fnptr, GstBaseTransform* arg0, GstBuffer** arg1) {
//   return ((GstFlowReturn (*)(GstBaseTransform*, GstBuffer**))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseTransform_virtual_prepare_output_buffer(void* fnptr, GstBaseTransform* arg0, GstBuffer* arg1, GstBuffer** arg2) {
//   return ((GstFlowReturn (*)(GstBaseTransform*, GstBuffer*, GstBuffer**))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gstbase1_BaseTransform_virtual_submit_input_buffer(void* fnptr, GstBaseTransform* arg0, gboolean arg1, GstBuffer* arg2) {
//   return ((GstFlowReturn (*)(GstBaseTransform*, gboolean, GstBuffer*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gstbase1_BaseTransform_virtual_transform(void* fnptr, GstBaseTransform* arg0, GstBuffer* arg1, GstBuffer* arg2) {
//   return ((GstFlowReturn (*)(GstBaseTransform*, GstBuffer*, GstBuffer*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gstbase1_BaseTransform_virtual_transform_ip(void* fnptr, GstBaseTransform* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstBaseTransform*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_accept_caps(void* fnptr, GstBaseTransform* arg0, GstPadDirection arg1, GstCaps* arg2) {
//   return ((gboolean (*)(GstBaseTransform*, GstPadDirection, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_copy_metadata(void* fnptr, GstBaseTransform* arg0, GstBuffer* arg1, GstBuffer* arg2) {
//   return ((gboolean (*)(GstBaseTransform*, GstBuffer*, GstBuffer*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_decide_allocation(void* fnptr, GstBaseTransform* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseTransform*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_filter_meta(void* fnptr, GstBaseTransform* arg0, GstQuery* arg1, GType arg2, GstStructure* arg3) {
//   return ((gboolean (*)(GstBaseTransform*, GstQuery*, GType, GstStructure*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_get_unit_size(void* fnptr, GstBaseTransform* arg0, GstCaps* arg1, gsize* arg2) {
//   return ((gboolean (*)(GstBaseTransform*, GstCaps*, gsize*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_propose_allocation(void* fnptr, GstBaseTransform* arg0, GstQuery* arg1, GstQuery* arg2) {
//   return ((gboolean (*)(GstBaseTransform*, GstQuery*, GstQuery*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_query(void* fnptr, GstBaseTransform* arg0, GstPadDirection arg1, GstQuery* arg2) {
//   return ((gboolean (*)(GstBaseTransform*, GstPadDirection, GstQuery*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_set_caps(void* fnptr, GstBaseTransform* arg0, GstCaps* arg1, GstCaps* arg2) {
//   return ((gboolean (*)(GstBaseTransform*, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_sink_event(void* fnptr, GstBaseTransform* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstBaseTransform*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_src_event(void* fnptr, GstBaseTransform* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstBaseTransform*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_start(void* fnptr, GstBaseTransform* arg0) {
//   return ((gboolean (*)(GstBaseTransform*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_stop(void* fnptr, GstBaseTransform* arg0) {
//   return ((gboolean (*)(GstBaseTransform*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_transform_meta(void* fnptr, GstBaseTransform* arg0, GstBuffer* arg1, GstMeta* arg2, GstBuffer* arg3) {
//   return ((gboolean (*)(GstBaseTransform*, GstBuffer*, GstMeta*, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstbase1_BaseTransform_virtual_transform_size(void* fnptr, GstBaseTransform* arg0, GstPadDirection arg1, GstCaps* arg2, gsize arg3, GstCaps* arg4, gsize* arg5) {
//   return ((gboolean (*)(GstBaseTransform*, GstPadDirection, GstCaps*, gsize, GstCaps*, gsize*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gstbase1_BaseTransform_virtual_before_transform(void* fnptr, GstBaseTransform* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBaseTransform*, GstBuffer*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBaseTransform = coreglib.Type(C.gst_base_transform_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBaseTransform, F: marshalBaseTransform},
	})
}

// BASE_TRANSFORM_SINK_NAME: name of the templates for the sink pad.
const BASE_TRANSFORM_SINK_NAME = "sink"

// BASE_TRANSFORM_SRC_NAME: name of the templates for the source pad.
const BASE_TRANSFORM_SRC_NAME = "src"

// BaseTransformOverrides contains methods that are overridable.
type BaseTransformOverrides struct {
	// The function takes the following parameters:
	//
	//    - direction
	//    - caps
	//
	// The function returns the following values:
	//
	AcceptCaps func(direction gst.PadDirection, caps *gst.Caps) bool
	// The function takes the following parameters:
	//
	BeforeTransform func(buffer *gst.Buffer)
	// The function takes the following parameters:
	//
	//    - input
	//    - outbuf
	//
	// The function returns the following values:
	//
	CopyMetadata func(input, outbuf *gst.Buffer) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	//    - query
	//    - api
	//    - params
	//
	// The function returns the following values:
	//
	FilterMeta func(query *gst.Query, api coreglib.Type, params *gst.Structure) bool
	// The function takes the following parameters:
	//
	//    - direction
	//    - caps
	//    - othercaps
	//
	// The function returns the following values:
	//
	FixateCaps func(direction gst.PadDirection, caps, othercaps *gst.Caps) *gst.Caps
	// The function returns the following values:
	//
	//    - outbuf
	//    - flowReturn
	//
	GenerateOutput func() (*gst.Buffer, gst.FlowReturn)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	//    - size
	//    - ok
	//
	UnitSize func(caps *gst.Caps) (uint, bool)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	//    - outbuf
	//    - flowReturn
	//
	PrepareOutputBuffer func(input *gst.Buffer) (*gst.Buffer, gst.FlowReturn)
	// The function takes the following parameters:
	//
	//    - decideQuery
	//    - query
	//
	// The function returns the following values:
	//
	ProposeAllocation func(decideQuery, query *gst.Query) bool
	// The function takes the following parameters:
	//
	//    - direction
	//    - query
	//
	// The function returns the following values:
	//
	Query func(direction gst.PadDirection, query *gst.Query) bool
	// The function takes the following parameters:
	//
	//    - incaps
	//    - outcaps
	//
	// The function returns the following values:
	//
	SetCaps func(incaps, outcaps *gst.Caps) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function takes the following parameters:
	//
	//    - isDiscont
	//    - input
	//
	// The function returns the following values:
	//
	SubmitInputBuffer func(isDiscont bool, input *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	//    - inbuf
	//    - outbuf
	//
	// The function returns the following values:
	//
	Transform func(inbuf, outbuf *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	//    - direction
	//    - caps
	//    - filter
	//
	// The function returns the following values:
	//
	TransformCaps func(direction gst.PadDirection, caps, filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	TransformIP func(buf *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	//    - outbuf
	//    - meta
	//    - inbuf
	//
	// The function returns the following values:
	//
	TransformMeta func(outbuf *gst.Buffer, meta *gst.Meta, inbuf *gst.Buffer) bool
	// The function takes the following parameters:
	//
	//    - direction
	//    - caps
	//    - size
	//    - othercaps
	//
	// The function returns the following values:
	//
	//    - othersize
	//    - ok
	//
	TransformSize func(direction gst.PadDirection, caps *gst.Caps, size uint, othercaps *gst.Caps) (uint, bool)
}

func defaultBaseTransformOverrides(v *BaseTransform) BaseTransformOverrides {
	return BaseTransformOverrides{
		AcceptCaps:          v.acceptCaps,
		BeforeTransform:     v.beforeTransform,
		CopyMetadata:        v.copyMetadata,
		DecideAllocation:    v.decideAllocation,
		FilterMeta:          v.filterMeta,
		FixateCaps:          v.fixateCaps,
		GenerateOutput:      v.generateOutput,
		UnitSize:            v.unitSize,
		PrepareOutputBuffer: v.prepareOutputBuffer,
		ProposeAllocation:   v.proposeAllocation,
		Query:               v.query,
		SetCaps:             v.setCaps,
		SinkEvent:           v.sinkEvent,
		SrcEvent:            v.srcEvent,
		Start:               v.start,
		Stop:                v.stop,
		SubmitInputBuffer:   v.submitInputBuffer,
		Transform:           v.transform,
		TransformCaps:       v.transformCaps,
		TransformIP:         v.transformIP,
		TransformMeta:       v.transformMeta,
		TransformSize:       v.transformSize,
	}
}

// BaseTransform: this base class is for filter elements that process data.
// Elements that are suitable for implementation using BaseTransform are ones
// where the size and caps of the output is known entirely from the input caps
// and buffer sizes. These include elements that directly transform one buffer
// into another, modify the contents of a buffer in-place, as well as elements
// that collate multiple input buffers into one output buffer, or that expand
// one input buffer into multiple output buffers. See below for more concrete
// use cases.
//
// It provides for:
//
// * one sinkpad and one srcpad * Possible formats on sink and source pad
// implemented with custom transform_caps function. By default uses same format
// on sink and source.
//
// * Handles state changes * Does flushing * Push mode * Pull mode if the
// sub-class transform can operate on arbitrary data
//
// Use Cases
//
// Passthrough mode
//
//    * Element has no interest in modifying the buffer. It may want to inspect it,
//      in which case the element should have a transform_ip function. If there
//      is no transform_ip function in passthrough mode, the buffer is pushed
//      intact.
//
//    * The BaseTransformClass.passthrough_on_same_caps variable
//      will automatically set/unset passthrough based on whether the
//      element negotiates the same caps on both pads.
//
//    * BaseTransformClass.passthrough_on_same_caps on an element that
//      doesn't implement a transform_caps function is useful for elements that
//      only inspect data (such as level)
//
//    * Example elements
//
//      * Level
//      * Videoscale, audioconvert, videoconvert, audioresample in certain modes.
//
// Modifications in-place - input buffer and output buffer are the same thing.
//
// * The element must implement a transform_ip function. * Output buffer size
// must <= input buffer size * If the always_in_place flag is set, non-writable
// buffers will be copied and passed to the transform_ip function, otherwise a
// new buffer will be created and the transform function called.
//
// * Incoming writable buffers will be passed to the transform_ip function
// immediately. * only implementing transform_ip and not transform implies
// always_in_place = TRUE
//
//    * Example elements:
//      * Volume
//      * Audioconvert in certain modes (signed/unsigned conversion)
//      * videoconvert in certain modes (endianness swapping)
//
// Modifications only to the caps/metadata of a buffer
//
// * The element does not require writable data, but non-writable buffers should
// be subbuffered so that the meta-information can be replaced.
//
// * Elements wishing to operate in this mode should replace the
// prepare_output_buffer method to create subbuffers of the input buffer and set
// always_in_place to TRUE
//
// * Example elements * Capsfilter when setting caps on outgoing buffers that
// have none. * identity when it is going to re-timestamp buffers by datarate.
//
// Normal mode
//
//    * always_in_place flag is not set, or there is no transform_ip function
//    * Element will receive an input buffer and output buffer to operate on.
//    * Output buffer is allocated by calling the prepare_output_buffer function.
//    * Example elements:
//      * Videoscale, videoconvert, audioconvert when doing
//      scaling/conversions
//
// Special output buffer allocations
//
//    * Elements which need to do special allocation of their output buffers
//      beyond allocating output buffers via the negotiated allocator or
//      buffer pool should implement the prepare_output_buffer method.
//
//    * Example elements:
//      * efence
//
//
// Sub-class settable flags on GstBaseTransform
//
// * passthrough
//
//    * Implies that in the current configuration, the sub-class is not interested in modifying the buffers.
//    * Elements which are always in passthrough mode whenever the same caps has been negotiated on both pads can set the class variable passthrough_on_same_caps to have this behaviour automatically.
//
// * always_in_place * Determines whether a non-writable buffer will be copied
// before passing to the transform_ip function.
//
//    * Implied TRUE if no transform function is implemented.
//    * Implied FALSE if ONLY transform function is implemented.
type BaseTransform struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*BaseTransform)(nil)
)

// BaseTransformer describes types inherited from class BaseTransform.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type BaseTransformer interface {
	coreglib.Objector
	baseBaseTransform() *BaseTransform
}

var _ BaseTransformer = (*BaseTransform)(nil)

func init() {
	coreglib.RegisterClassInfo[*BaseTransform, *BaseTransformClass, BaseTransformOverrides](
		GTypeBaseTransform,
		initBaseTransformClass,
		wrapBaseTransform,
		defaultBaseTransformOverrides,
	)
}

func initBaseTransformClass(gclass unsafe.Pointer, overrides BaseTransformOverrides, classInitFunc func(*BaseTransformClass)) {
	pclass := (*C.GstBaseTransformClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBaseTransform))))

	if overrides.AcceptCaps != nil {
		pclass.accept_caps = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_accept_caps)
	}

	if overrides.BeforeTransform != nil {
		pclass.before_transform = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_before_transform)
	}

	if overrides.CopyMetadata != nil {
		pclass.copy_metadata = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_copy_metadata)
	}

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_decide_allocation)
	}

	if overrides.FilterMeta != nil {
		pclass.filter_meta = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_filter_meta)
	}

	if overrides.FixateCaps != nil {
		pclass.fixate_caps = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_fixate_caps)
	}

	if overrides.GenerateOutput != nil {
		pclass.generate_output = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_generate_output)
	}

	if overrides.UnitSize != nil {
		pclass.get_unit_size = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_get_unit_size)
	}

	if overrides.PrepareOutputBuffer != nil {
		pclass.prepare_output_buffer = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_prepare_output_buffer)
	}

	if overrides.ProposeAllocation != nil {
		pclass.propose_allocation = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_propose_allocation)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_query)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_set_caps)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_sink_event)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_src_event)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_stop)
	}

	if overrides.SubmitInputBuffer != nil {
		pclass.submit_input_buffer = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_submit_input_buffer)
	}

	if overrides.Transform != nil {
		pclass.transform = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_transform)
	}

	if overrides.TransformCaps != nil {
		pclass.transform_caps = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_transform_caps)
	}

	if overrides.TransformIP != nil {
		pclass.transform_ip = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_transform_ip)
	}

	if overrides.TransformMeta != nil {
		pclass.transform_meta = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_transform_meta)
	}

	if overrides.TransformSize != nil {
		pclass.transform_size = (*[0]byte)(C._gotk4_gstbase1_BaseTransformClass_transform_size)
	}

	if classInitFunc != nil {
		class := (*BaseTransformClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBaseTransform(obj *coreglib.Object) *BaseTransform {
	return &BaseTransform{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalBaseTransform(p uintptr) (interface{}, error) {
	return wrapBaseTransform(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (trans *BaseTransform) baseBaseTransform() *BaseTransform {
	return trans
}

// BaseBaseTransform returns the underlying base object.
func BaseBaseTransform(obj BaseTransformer) *BaseTransform {
	return obj.baseBaseTransform()
}

// Allocator lets BaseTransform sub-classes know the memory allocator used by
// the base class and its params.
//
// Unref the allocator after use.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) of allocator.
//
func (trans *BaseTransform) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstBaseTransform   // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	C.gst_base_transform_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(trans)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _allocator, _params
}

// The function returns the following values:
//
//    - bufferPool (optional): instance of the BufferPool used by trans; free it
//      after use.
//
func (trans *BaseTransform) BufferPool() *gst.BufferPool {
	var _arg0 *C.GstBaseTransform // out
	var _cret *C.GstBufferPool    // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C.gst_base_transform_get_buffer_pool(_arg0)
	runtime.KeepAlive(trans)

	var _bufferPool *gst.BufferPool // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_bufferPool = &gst.BufferPool{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			}
		}
	}

	return _bufferPool
}

// IsInPlace: see if trans is configured as a in_place transform.
//
// The function returns the following values:
//
//    - ok: TRUE if the transform is configured in in_place mode.
//
//      MT safe.
//
func (trans *BaseTransform) IsInPlace() bool {
	var _arg0 *C.GstBaseTransform // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C.gst_base_transform_is_in_place(_arg0)
	runtime.KeepAlive(trans)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPassthrough: see if trans is configured as a passthrough transform.
//
// The function returns the following values:
//
//    - ok: TRUE if the transform is configured in passthrough mode.
//
//      MT safe.
//
func (trans *BaseTransform) IsPassthrough() bool {
	var _arg0 *C.GstBaseTransform // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C.gst_base_transform_is_passthrough(_arg0)
	runtime.KeepAlive(trans)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsQosEnabled queries if the transform will handle QoS.
//
// The function returns the following values:
//
//    - ok: TRUE if QoS is enabled.
//
//      MT safe.
//
func (trans *BaseTransform) IsQosEnabled() bool {
	var _arg0 *C.GstBaseTransform // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C.gst_base_transform_is_qos_enabled(_arg0)
	runtime.KeepAlive(trans)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reconfigure negotiates src pad caps with downstream elements if the source
// pad is marked as needing reconfiguring. Unmarks GST_PAD_FLAG_NEED_RECONFIGURE
// in any case. But marks it again if negotiation fails.
//
// Do not call this in the BaseTransformClass::transform or
// BaseTransformClass::transform_ip vmethod. Call this in
// BaseTransformClass::submit_input_buffer,
// BaseTransformClass::prepare_output_buffer or in
// BaseTransformClass::generate_output _before_ any output buffer is allocated.
//
// It will be default be called when handling an ALLOCATION query or at the very
// beginning of the default BaseTransformClass::submit_input_buffer
// implementation.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (trans *BaseTransform) Reconfigure() bool {
	var _arg0 *C.GstBaseTransform // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C.gst_base_transform_reconfigure(_arg0)
	runtime.KeepAlive(trans)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReconfigureSink instructs trans to request renegotiation upstream. This
// function is typically called after properties on the transform were set that
// influence the input format.
func (trans *BaseTransform) ReconfigureSink() {
	var _arg0 *C.GstBaseTransform // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	C.gst_base_transform_reconfigure_sink(_arg0)
	runtime.KeepAlive(trans)
}

// ReconfigureSrc instructs trans to renegotiate a new downstream transform on
// the next buffer. This function is typically called after properties on the
// transform were set that influence the output format.
func (trans *BaseTransform) ReconfigureSrc() {
	var _arg0 *C.GstBaseTransform // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	C.gst_base_transform_reconfigure_src(_arg0)
	runtime.KeepAlive(trans)
}

// SetGapAware: if gap_aware is FALSE (the default), output buffers will have
// the GST_BUFFER_FLAG_GAP flag unset.
//
// If set to TRUE, the element must handle output buffers with this flag set
// correctly, i.e. it can assume that the buffer contains neutral data but must
// unset the flag if the output is no neutral data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - gapAware: new state.
//
func (trans *BaseTransform) SetGapAware(gapAware bool) {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	if gapAware {
		_arg1 = C.TRUE
	}

	C.gst_base_transform_set_gap_aware(_arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(gapAware)
}

// SetInPlace determines whether a non-writable buffer will be copied before
// passing to the transform_ip function.
//
//    * Always TRUE if no transform function is implemented.
//    * Always FALSE if ONLY transform function is implemented.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - inPlace: boolean value indicating that we would like to operate on
//      in_place buffers.
//
func (trans *BaseTransform) SetInPlace(inPlace bool) {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	if inPlace {
		_arg1 = C.TRUE
	}

	C.gst_base_transform_set_in_place(_arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(inPlace)
}

// SetPassthrough: set passthrough mode for this filter by default. This is
// mostly useful for filters that do not care about negotiation.
//
// Always TRUE for filters which don't implement either a transform or
// transform_ip or generate_output method.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - passthrough: boolean indicating passthrough mode.
//
func (trans *BaseTransform) SetPassthrough(passthrough bool) {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	if passthrough {
		_arg1 = C.TRUE
	}

	C.gst_base_transform_set_passthrough(_arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(passthrough)
}

// SetPreferPassthrough: if prefer_passthrough is TRUE (the default), trans will
// check and prefer passthrough caps from the list of caps returned by the
// transform_caps vmethod.
//
// If set to FALSE, the element must order the caps returned from the
// transform_caps function in such a way that the preferred format is first in
// the list. This can be interesting for transforms that can do passthrough
// transforms but prefer to do something else, like a capsfilter.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - preferPassthrough: new state.
//
func (trans *BaseTransform) SetPreferPassthrough(preferPassthrough bool) {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	if preferPassthrough {
		_arg1 = C.TRUE
	}

	C.gst_base_transform_set_prefer_passthrough(_arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(preferPassthrough)
}

// SetQosEnabled: enable or disable QoS handling in the transform.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (trans *BaseTransform) SetQosEnabled(enabled bool) {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_base_transform_set_qos_enabled(_arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(enabled)
}

// UpdateQos: set the QoS parameters in the transform. This function is called
// internally when a QOS event is received but subclasses can provide custom
// information when needed.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - proportion: proportion.
//    - diff against the clock.
//    - timestamp of the buffer generating the QoS expressed in running_time.
//
func (trans *BaseTransform) UpdateQos(proportion float64, diff gst.ClockTimeDiff, timestamp gst.ClockTime) {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gdouble           // out
	var _arg2 C.GstClockTimeDiff  // out
	var _arg3 C.GstClockTime      // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = C.gdouble(proportion)
	_arg2 = C.gint64(diff)
	type _ = gst.ClockTimeDiff
	type _ = int64
	_arg3 = C.guint64(timestamp)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_base_transform_update_qos(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(proportion)
	runtime.KeepAlive(diff)
	runtime.KeepAlive(timestamp)
}

// UpdateSrcCaps updates the srcpad caps and sends the caps downstream. This
// function can be used by subclasses when they have already negotiated their
// caps but found a change in them (or computed new information). This way, they
// can notify downstream about that change without losing any buffer.
//
// The function takes the following parameters:
//
//    - updatedCaps: updated version of the srcpad caps to be pushed downstream.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps could be sent downstream FALSE otherwise.
//
func (trans *BaseTransform) UpdateSrcCaps(updatedCaps *gst.Caps) bool {
	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstCaps          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(updatedCaps)))

	_cret = C.gst_base_transform_update_src_caps(_arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(updatedCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - direction
//    - caps
//
// The function returns the following values:
//
func (trans *BaseTransform) acceptCaps(direction gst.PadDirection, caps *gst.Caps) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.accept_caps

	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstCaps          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_accept_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (trans *BaseTransform) beforeTransform(buffer *gst.Buffer) {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.before_transform

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // out

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C._gotk4_gstbase1_BaseTransform_virtual_before_transform(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(buffer)
}

// The function takes the following parameters:
//
//    - input
//    - outbuf
//
// The function returns the following values:
//
func (trans *BaseTransform) copyMetadata(input, outbuf *gst.Buffer) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.copy_metadata

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // out
	var _arg2 *C.GstBuffer        // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_copy_metadata(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(input)
	runtime.KeepAlive(outbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (trans *BaseTransform) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstQuery         // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - query
//    - api
//    - params
//
// The function returns the following values:
//
func (trans *BaseTransform) filterMeta(query *gst.Query, api coreglib.Type, params *gst.Structure) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.filter_meta

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstQuery         // out
	var _arg2 C.GType             // out
	var _arg3 *C.GstStructure     // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg2 = C.GType(api)
	_arg3 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(params)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_filter_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(query)
	runtime.KeepAlive(api)
	runtime.KeepAlive(params)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - direction
//    - caps
//    - othercaps
//
// The function returns the following values:
//
func (trans *BaseTransform) fixateCaps(direction gst.PadDirection, caps, othercaps *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.fixate_caps

	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstCaps          // out
	var _arg3 *C.GstCaps          // out
	var _cret *C.GstCaps          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(othercaps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(othercaps)), nil)

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_fixate_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(othercaps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// The function returns the following values:
//
//    - outbuf
//    - flowReturn
//
func (trans *BaseTransform) generateOutput() (*gst.Buffer, gst.FlowReturn) {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.generate_output

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // in
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_generate_output(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(trans)

	var _outbuf *gst.Buffer        // out
	var _flowReturn gst.FlowReturn // out

	_outbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_outbuf)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = gst.FlowReturn(_cret)

	return _outbuf, _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//    - size
//    - ok
//
func (trans *BaseTransform) unitSize(caps *gst.Caps) (uint, bool) {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.get_unit_size

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstCaps          // out
	var _arg2 C.gsize             // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_get_unit_size(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(caps)

	var _size uint // out
	var _ok bool   // out

	_size = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _size, _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
//    - outbuf
//    - flowReturn
//
func (trans *BaseTransform) prepareOutputBuffer(input *gst.Buffer) (*gst.Buffer, gst.FlowReturn) {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.prepare_output_buffer

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // out
	var _arg2 *C.GstBuffer        // in
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(input)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_prepare_output_buffer(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(input)

	var _outbuf *gst.Buffer        // out
	var _flowReturn gst.FlowReturn // out

	_outbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_outbuf)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = gst.FlowReturn(_cret)

	return _outbuf, _flowReturn
}

// The function takes the following parameters:
//
//    - decideQuery
//    - query
//
// The function returns the following values:
//
func (trans *BaseTransform) proposeAllocation(decideQuery, query *gst.Query) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.propose_allocation

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstQuery         // out
	var _arg2 *C.GstQuery         // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(decideQuery)))
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_propose_allocation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(decideQuery)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - direction
//    - query
//
// The function returns the following values:
//
func (trans *BaseTransform) query(direction gst.PadDirection, query *gst.Query) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.query

	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstQuery         // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - incaps
//    - outcaps
//
// The function returns the following values:
//
func (trans *BaseTransform) setCaps(incaps, outcaps *gst.Caps) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.set_caps

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstCaps          // out
	var _arg2 *C.GstCaps          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(incaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outcaps)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(incaps)
	runtime.KeepAlive(outcaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (trans *BaseTransform) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.sink_event

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstEvent         // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (trans *BaseTransform) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.src_event

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstEvent         // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (trans *BaseTransform) start() bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.start

	var _arg0 *C.GstBaseTransform // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(trans)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (trans *BaseTransform) stop() bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.stop

	var _arg0 *C.GstBaseTransform // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(trans)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - isDiscont
//    - input
//
// The function returns the following values:
//
func (trans *BaseTransform) submitInputBuffer(isDiscont bool, input *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.submit_input_buffer

	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.gboolean          // out
	var _arg2 *C.GstBuffer        // out
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	if isDiscont {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(input)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_submit_input_buffer(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(isDiscont)
	runtime.KeepAlive(input)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
//    - inbuf
//    - outbuf
//
// The function returns the following values:
//
func (trans *BaseTransform) transform(inbuf, outbuf *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.transform

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // out
	var _arg2 *C.GstBuffer        // out
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_transform(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
//    - direction
//    - caps
//    - filter
//
// The function returns the following values:
//
func (trans *BaseTransform) transformCaps(direction gst.PadDirection, caps, filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.transform_caps

	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstCaps          // out
	var _arg3 *C.GstCaps          // out
	var _cret *C.GstCaps          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_transform_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (trans *BaseTransform) transformIP(buf *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.transform_ip

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // out
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_transform_ip(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(buf)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
//    - outbuf
//    - meta
//    - inbuf
//
// The function returns the following values:
//
func (trans *BaseTransform) transformMeta(outbuf *gst.Buffer, meta *gst.Meta, inbuf *gst.Buffer) bool {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.transform_meta

	var _arg0 *C.GstBaseTransform // out
	var _arg1 *C.GstBuffer        // out
	var _arg2 *C.GstMeta          // out
	var _arg3 *C.GstBuffer        // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))
	_arg2 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_transform_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(inbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - direction
//    - caps
//    - size
//    - othercaps
//
// The function returns the following values:
//
//    - othersize
//    - ok
//
func (trans *BaseTransform) transformSize(direction gst.PadDirection, caps *gst.Caps, size uint, othercaps *gst.Caps) (uint, bool) {
	gclass := (*C.GstBaseTransformClass)(coreglib.PeekParentClass(trans))
	fnarg := gclass.transform_size

	var _arg0 *C.GstBaseTransform // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstCaps          // out
	var _arg3 C.gsize             // out
	var _arg4 *C.GstCaps          // out
	var _arg5 C.gsize             // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GstBaseTransform)(unsafe.Pointer(coreglib.InternObject(trans).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = C.gsize(size)
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(othercaps)))

	_cret = C._gotk4_gstbase1_BaseTransform_virtual_transform_size(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(size)
	runtime.KeepAlive(othercaps)

	var _othersize uint // out
	var _ok bool        // out

	_othersize = uint(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _othersize, _ok
}

// BaseTransformClass subclasses can override any of the available virtual
// methods or not, as needed. At minimum either transform or transform_ip need
// to be overridden. If the element can overwrite the input data with the
// results (data is of the same type and quantity) it should provide
// transform_ip.
//
// An instance of this type is always passed by reference.
type BaseTransformClass struct {
	*baseTransformClass
}

// baseTransformClass is the struct that's finalized.
type baseTransformClass struct {
	native *C.GstBaseTransformClass
}

// ParentClass: element parent class.
func (b *BaseTransformClass) ParentClass() *gst.ElementClass {
	valptr := &b.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PassthroughOnSameCaps: if set to TRUE, passthrough mode will be automatically
// enabled if the caps are the same. Set to FALSE by default.
func (b *BaseTransformClass) PassthroughOnSameCaps() bool {
	valptr := &b.native.passthrough_on_same_caps
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// TransformIPOnPassthrough: if set to TRUE, transform_ip will be called in
// passthrough mode. The passed buffer might not be writable. When FALSE,
// neither transform nor transform_ip will be called in passthrough mode. Set to
// TRUE by default.
func (b *BaseTransformClass) TransformIPOnPassthrough() bool {
	valptr := &b.native.transform_ip_on_passthrough
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}
