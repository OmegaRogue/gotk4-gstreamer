// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/base/base.h>
import "C"

// ByteReader provides a byte reader that can read different integer and
// floating point types from a memory buffer. It provides functions for reading
// signed/unsigned, little/big endian integers of 8, 16, 24, 32 and 64 bits and
// functions for reading little/big endian floating points numbers of 32 and 64
// bits. It also provides functions to read NUL-terminated strings in various
// character encodings.
//
// An instance of this type is always passed by reference.
type ByteReader struct {
	*byteReader
}

// byteReader is the struct that's finalized.
type byteReader struct {
	native *C.GstByteReader
}

// DupStringUTF16: free-function: g_free
//
// Returns a newly-allocated copy of the current data position if there is a
// NUL-terminated UTF-16 string in the data (this could be an empty string as
// well), and advances the current position.
//
// No input checking for valid UTF-16 is done. This function is endianness
// agnostic - you should not assume the UTF-16 characters are in host
// endianness.
//
// This function will fail if no NUL-terminator was found in in the data.
//
// Note: there is no peek or get variant of this function to ensure correct byte
// alignment of the UTF-16 string.
//
// The function returns the following values:
//
//    - str address of a #guint16 pointer variable in which to store the result.
//    - ok: TRUE if a string could be read, FALSE otherwise. The string put into
//      str must be freed with g_free() when no longer needed.
//
func (reader *ByteReader) DupStringUTF16() ([]uint16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 *C.guint16       // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_dup_string_utf16(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _str []uint16 // out
	var _ok bool      // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		var i int
		var z C.guint16
		for p := _arg1; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_arg1, i)
		_str = make([]uint16, i)
		for i := range src {
			_str[i] = uint16(src[i])
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _str, _ok
}

// DupStringUTF32: free-function: g_free
//
// Returns a newly-allocated copy of the current data position if there is a
// NUL-terminated UTF-32 string in the data (this could be an empty string as
// well), and advances the current position.
//
// No input checking for valid UTF-32 is done. This function is endianness
// agnostic - you should not assume the UTF-32 characters are in host
// endianness.
//
// This function will fail if no NUL-terminator was found in in the data.
//
// Note: there is no peek or get variant of this function to ensure correct byte
// alignment of the UTF-32 string.
//
// The function returns the following values:
//
//    - str address of a #guint32 pointer variable in which to store the result.
//    - ok: TRUE if a string could be read, FALSE otherwise. The string put into
//      str must be freed with g_free() when no longer needed.
//
func (reader *ByteReader) DupStringUTF32() ([]uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 *C.guint32       // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_dup_string_utf32(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _str []uint32 // out
	var _ok bool      // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		var i int
		var z C.guint32
		for p := _arg1; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_arg1, i)
		_str = make([]uint32, i)
		for i := range src {
			_str[i] = uint32(src[i])
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _str, _ok
}

// Float32Be: read a 32 bit big endian floating point value into val and update
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gfloat to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Float32Be() (float32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gfloat         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_float32_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float32 // out
	var _ok bool     // out

	_val = float32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Float32LE: read a 32 bit little endian floating point value into val and
// update the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gfloat to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Float32LE() (float32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gfloat         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_float32_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float32 // out
	var _ok bool     // out

	_val = float32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Float64Be: read a 64 bit big endian floating point value into val and update
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gdouble to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Float64Be() (float64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gdouble        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_float64_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float64 // out
	var _ok bool     // out

	_val = float64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Float64LE: read a 64 bit little endian floating point value into val and
// update the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gdouble to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Float64LE() (float64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gdouble        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_float64_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float64 // out
	var _ok bool     // out

	_val = float64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int16Be: read a signed 16 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int16Be() (int16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint16         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int16_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int16 // out
	var _ok bool   // out

	_val = int16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int16LE: read a signed 16 bit little endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int16LE() (int16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint16         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int16_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int16 // out
	var _ok bool   // out

	_val = int16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int24Be: read a signed 24 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int24Be() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int24_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int24LE: read a signed 24 bit little endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int24LE() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int24_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int32Be: read a signed 32 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int32Be() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int32_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int32LE: read a signed 32 bit little endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int32LE() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int32_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int64Be: read a signed 64 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int64Be() (int64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint64         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int64_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int64 // out
	var _ok bool   // out

	_val = int64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int64LE: read a signed 64 bit little endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int64LE() (int64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint64         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int64_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int64 // out
	var _ok bool   // out

	_val = int64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Int8: read a signed 8 bit integer into val and update the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint8 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Int8() (int8, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint8          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_int8(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int8 // out
	var _ok bool  // out

	_val = int8(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Pos returns the current position of a ByteReader instance in bytes.
//
// The function returns the following values:
//
//    - guint: current position of reader in bytes.
//
func (reader *ByteReader) Pos() uint {
	var _arg0 *C.GstByteReader // out
	var _cret C.guint          // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_pos(_arg0)
	runtime.KeepAlive(reader)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Remaining returns the remaining number of bytes of a ByteReader instance.
//
// The function returns the following values:
//
//    - guint: remaining number of bytes of reader instance.
//
func (reader *ByteReader) Remaining() uint {
	var _arg0 *C.GstByteReader // out
	var _cret C.guint          // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_remaining(_arg0)
	runtime.KeepAlive(reader)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Size returns the total number of bytes of a ByteReader instance.
//
// The function returns the following values:
//
//    - guint: total number of bytes of reader instance.
//
func (reader *ByteReader) Size() uint {
	var _arg0 *C.GstByteReader // out
	var _cret C.guint          // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_size(_arg0)
	runtime.KeepAlive(reader)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Uint16Be: read an unsigned 16 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint16Be() (uint16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint16        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint16_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint16 // out
	var _ok bool    // out

	_val = uint16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint16LE: read an unsigned 16 bit little endian integer into val and update
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint16LE() (uint16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint16        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint16_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint16 // out
	var _ok bool    // out

	_val = uint16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint24Be: read an unsigned 24 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint24Be() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint24_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint24LE: read an unsigned 24 bit little endian integer into val and update
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint24LE() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint24_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint32Be: read an unsigned 32 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint32Be() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint32_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint32LE: read an unsigned 32 bit little endian integer into val and update
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint32LE() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint32_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint64Be: read an unsigned 64 bit big endian integer into val and update the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint64Be() (uint64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint64        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint64_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint64 // out
	var _ok bool    // out

	_val = uint64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint64LE: read an unsigned 64 bit little endian integer into val and update
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint64LE() (uint64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint64        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint64_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint64 // out
	var _ok bool    // out

	_val = uint64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Uint8: read an unsigned 8 bit integer into val and update the current
// position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint8 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) Uint8() (byte, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint8         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_get_uint8(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val byte // out
	var _ok bool  // out

	_val = byte(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// Init initializes a ByteReader instance to read from data. This function can
// be called on already initialized instances.
//
// The function takes the following parameters:
//
//    - data from which the ByteReader should read.
//
func (reader *ByteReader) Init(data []byte) {
	var _arg0 *C.GstByteReader // out
	var _arg1 *C.guint8        // out
	var _arg2 C.guint

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	C.gst_byte_reader_init(_arg0, _arg1, _arg2)
	runtime.KeepAlive(reader)
	runtime.KeepAlive(data)
}

// MaskedScanUint32: scan for pattern pattern with applied mask mask in the byte
// reader data, starting from offset offset relative to the current position.
//
// The bytes in pattern and mask are interpreted left-to-right, regardless of
// endianness. All four bytes of the pattern must be present in the byte reader
// data for it to match, even if the first or last bytes are masked out.
//
// It is an error to call this function without making sure that there is enough
// data (offset+size bytes) in the byte reader.
//
// The function takes the following parameters:
//
//    - mask to apply to data before matching against pattern.
//    - pattern to match (after mask is applied).
//    - offset from which to start scanning, relative to the current position.
//    - size: number of bytes to scan from offset.
//
// The function returns the following values:
//
//    - guint: offset of the first match, or -1 if no match was found.
//
//      Example:
//
//         // Assume the reader contains 0x00 0x01 0x02 ... 0xfe 0xff
//
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 0, 256);
//         // -> returns 0
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 1, 255);
//         // -> returns -1
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x01020304, 1, 255);
//         // -> returns 1
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0001, 0, 256);
//         // -> returns -1
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0203, 0, 256);
//         // -> returns 0
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 256);
//         // -> returns 2
//         gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 4);
//         // -> returns -1.
//
func (reader *ByteReader) MaskedScanUint32(mask uint32, pattern uint32, offset uint, size uint) uint {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // out
	var _arg2 C.guint32        // out
	var _arg3 C.guint          // out
	var _arg4 C.guint          // out
	var _cret C.guint          // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))
	_arg1 = C.guint32(mask)
	_arg2 = C.guint32(pattern)
	_arg3 = C.guint(offset)
	_arg4 = C.guint(size)

	_cret = C.gst_byte_reader_masked_scan_uint32(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(reader)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaskedScanUint32Peek: scan for pattern pattern with applied mask mask in the
// byte reader data, starting from offset offset relative to the current
// position.
//
// The bytes in pattern and mask are interpreted left-to-right, regardless of
// endianness. All four bytes of the pattern must be present in the byte reader
// data for it to match, even if the first or last bytes are masked out.
//
// It is an error to call this function without making sure that there is enough
// data (offset+size bytes) in the byte reader.
//
// The function takes the following parameters:
//
//    - mask to apply to data before matching against pattern.
//    - pattern to match (after mask is applied).
//    - offset from which to start scanning, relative to the current position.
//    - size: number of bytes to scan from offset.
//
// The function returns the following values:
//
//    - value: pointer to uint32 to return matching data.
//    - guint: offset of the first match, or -1 if no match was found.
//
func (reader *ByteReader) MaskedScanUint32Peek(mask uint32, pattern uint32, offset uint, size uint) (uint32, uint) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // out
	var _arg2 C.guint32        // out
	var _arg3 C.guint          // out
	var _arg4 C.guint          // out
	var _arg5 C.guint32        // in
	var _cret C.guint          // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))
	_arg1 = C.guint32(mask)
	_arg2 = C.guint32(pattern)
	_arg3 = C.guint(offset)
	_arg4 = C.guint(size)

	_cret = C.gst_byte_reader_masked_scan_uint32_peek(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(reader)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _value uint32 // out
	var _guint uint   // out

	_value = uint32(_arg5)
	_guint = uint(_cret)

	return _value, _guint
}

// PeekFloat32Be: read a 32 bit big endian floating point value into val but
// keep the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gfloat to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekFloat32Be() (float32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gfloat         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_float32_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float32 // out
	var _ok bool     // out

	_val = float32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekFloat32LE: read a 32 bit little endian floating point value into val but
// keep the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gfloat to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekFloat32LE() (float32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gfloat         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_float32_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float32 // out
	var _ok bool     // out

	_val = float32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekFloat64Be: read a 64 bit big endian floating point value into val but
// keep the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gdouble to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekFloat64Be() (float64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gdouble        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_float64_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float64 // out
	var _ok bool     // out

	_val = float64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekFloat64LE: read a 64 bit little endian floating point value into val but
// keep the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gdouble to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekFloat64LE() (float64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gdouble        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_float64_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val float64 // out
	var _ok bool     // out

	_val = float64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt16Be: read a signed 16 bit big endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt16Be() (int16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint16         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int16_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int16 // out
	var _ok bool   // out

	_val = int16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt16LE: read a signed 16 bit little endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt16LE() (int16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint16         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int16_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int16 // out
	var _ok bool   // out

	_val = int16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt24Be: read a signed 24 bit big endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt24Be() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int24_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt24LE: read a signed 24 bit little endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt24LE() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int24_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt32Be: read a signed 32 bit big endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt32Be() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int32_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt32LE: read a signed 32 bit little endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt32LE() (int32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint32         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int32_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int32 // out
	var _ok bool   // out

	_val = int32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt64Be: read a signed 64 bit big endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt64Be() (int64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint64         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int64_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int64 // out
	var _ok bool   // out

	_val = int64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt64LE: read a signed 64 bit little endian integer into val but keep the
// current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt64LE() (int64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint64         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int64_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int64 // out
	var _ok bool   // out

	_val = int64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekInt8: read a signed 8 bit integer into val but keep the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #gint8 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekInt8() (int8, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.gint8          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_int8(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val int8 // out
	var _ok bool  // out

	_val = int8(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint16Be: read an unsigned 16 bit big endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint16Be() (uint16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint16        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint16_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint16 // out
	var _ok bool    // out

	_val = uint16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint16LE: read an unsigned 16 bit little endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint16 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint16LE() (uint16, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint16        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint16_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint16 // out
	var _ok bool    // out

	_val = uint16(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint24Be: read an unsigned 24 bit big endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint24Be() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint24_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint24LE: read an unsigned 24 bit little endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint24LE() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint24_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint32Be: read an unsigned 32 bit big endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint32Be() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint32_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint32LE: read an unsigned 32 bit little endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint32 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint32LE() (uint32, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint32        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint32_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint32 // out
	var _ok bool    // out

	_val = uint32(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint64Be: read an unsigned 64 bit big endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint64Be() (uint64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint64        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint64_be(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint64 // out
	var _ok bool    // out

	_val = uint64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint64LE: read an unsigned 64 bit little endian integer into val but keep
// the current position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint64 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint64LE() (uint64, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint64        // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint64_le(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val uint64 // out
	var _ok bool    // out

	_val = uint64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// PeekUint8: read an unsigned 8 bit integer into val but keep the current
// position.
//
// The function returns the following values:
//
//    - val: pointer to a #guint8 to store the result.
//    - ok: TRUE if successful, FALSE otherwise.
//
func (reader *ByteReader) PeekUint8() (byte, bool) {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint8         // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_peek_uint8(_arg0, &_arg1)
	runtime.KeepAlive(reader)

	var _val byte // out
	var _ok bool  // out

	_val = byte(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _val, _ok
}

// SetPos sets the new position of a ByteReader instance to pos in bytes.
//
// The function takes the following parameters:
//
//    - pos: new position in bytes.
//
// The function returns the following values:
//
//    - ok: TRUE if the position could be set successfully, FALSE otherwise.
//
func (reader *ByteReader) SetPos(pos uint) bool {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))
	_arg1 = C.guint(pos)

	_cret = C.gst_byte_reader_set_pos(_arg0, _arg1)
	runtime.KeepAlive(reader)
	runtime.KeepAlive(pos)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Skip skips nbytes bytes of the ByteReader instance.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to skip.
//
// The function returns the following values:
//
//    - ok: TRUE if nbytes bytes could be skipped, FALSE otherwise.
//
func (reader *ByteReader) Skip(nbytes uint) bool {
	var _arg0 *C.GstByteReader // out
	var _arg1 C.guint          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))
	_arg1 = C.guint(nbytes)

	_cret = C.gst_byte_reader_skip(_arg0, _arg1)
	runtime.KeepAlive(reader)
	runtime.KeepAlive(nbytes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SkipStringUTF16 skips a NUL-terminated UTF-16 string in the ByteReader
// instance, advancing the current position to the byte after the string.
//
// No input checking for valid UTF-16 is done.
//
// This function will fail if no NUL-terminator was found in in the data.
//
// The function returns the following values:
//
//    - ok: TRUE if a string could be skipped, FALSE otherwise.
//
func (reader *ByteReader) SkipStringUTF16() bool {
	var _arg0 *C.GstByteReader // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_skip_string_utf16(_arg0)
	runtime.KeepAlive(reader)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SkipStringUTF32 skips a NUL-terminated UTF-32 string in the ByteReader
// instance, advancing the current position to the byte after the string.
//
// No input checking for valid UTF-32 is done.
//
// This function will fail if no NUL-terminator was found in in the data.
//
// The function returns the following values:
//
//    - ok: TRUE if a string could be skipped, FALSE otherwise.
//
func (reader *ByteReader) SkipStringUTF32() bool {
	var _arg0 *C.GstByteReader // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_skip_string_utf32(_arg0)
	runtime.KeepAlive(reader)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SkipStringUTF8 skips a NUL-terminated string in the ByteReader instance,
// advancing the current position to the byte after the string. This will work
// for any NUL-terminated string with a character width of 8 bits, so ASCII,
// UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.
//
// This function will fail if no NUL-terminator was found in in the data.
//
// The function returns the following values:
//
//    - ok: TRUE if a string could be skipped, FALSE otherwise.
//
func (reader *ByteReader) SkipStringUTF8() bool {
	var _arg0 *C.GstByteReader // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteReader)(gextras.StructNative(unsafe.Pointer(reader)))

	_cret = C.gst_byte_reader_skip_string_utf8(_arg0)
	runtime.KeepAlive(reader)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
