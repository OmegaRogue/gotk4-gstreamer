// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
import "C"

// GType values.
var (
	GTypeAdapter = coreglib.Type(C.gst_adapter_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAdapter, F: marshalAdapter},
	})
}

// Adapter: this class is for elements that receive buffers in an undesired
// size. While for example raw video contains one image per buffer, the same is
// not true for a lot of other formats, especially those that come directly from
// a file. So if you have undefined buffer sizes and require a specific size,
// this object is for you.
//
// An adapter is created with gst_adapter_new(). It can be freed again with
// g_object_unref().
//
// The theory of operation is like this: All buffers received are put into the
// adapter using gst_adapter_push() and the data is then read back in chunks of
// the desired size using gst_adapter_map()/gst_adapter_unmap() and/or
// gst_adapter_copy(). After the data has been processed, it is freed using
// gst_adapter_unmap().
//
// Other methods such as gst_adapter_take() and gst_adapter_take_buffer()
// combine gst_adapter_map() and gst_adapter_unmap() in one method and are
// potentially more convenient for some use cases.
//
// For example, a sink pad's chain function that needs to pass data to a library
// in 512-byte chunks could be implemented like this:
//
//    static GstFlowReturn
//    sink_pad_chain (GstPad *pad, GstObject *parent, GstBuffer *buffer)
//    {
//      MyElement *this;
//      GstAdapter *adapter;
//      GstFlowReturn ret = GST_FLOW_OK;
//
//      this = MY_ELEMENT (parent);
//
//      adapter = this->adapter;
//
//      // put buffer into adapter
//      gst_adapter_push (adapter, buffer);
//
//      // while we can read out 512 bytes, process them
//      while (gst_adapter_available (adapter) >= 512 && ret == GST_FLOW_OK) {
//        const guint8 *data = gst_adapter_map (adapter, 512);
//        // use flowreturn as an error value
//        ret = my_library_foo (data);
//        gst_adapter_unmap (adapter);
//        gst_adapter_flush (adapter, 512);
//      }
//      return ret;
//    }
//
// For another example, a simple element inside GStreamer that uses Adapter is
// the libvisual element.
//
// An element using Adapter in its sink pad chain function should ensure that
// when the FLUSH_STOP event is received, that any queued data is cleared using
// gst_adapter_clear(). Data should also be cleared or processed on EOS and when
// changing state from GST_STATE_PAUSED to GST_STATE_READY.
//
// Also check the GST_BUFFER_FLAG_DISCONT flag on the buffer. Some elements
// might need to clear the adapter after a discontinuity.
//
// The adapter will keep track of the timestamps of the buffers that were
// pushed. The last seen timestamp before the current position can be queried
// with gst_adapter_prev_pts(). This function can optionally return the number
// of bytes between the start of the buffer that carried the timestamp and the
// current adapter position. The distance is useful when dealing with, for
// example, raw audio samples because it allows you to calculate the timestamp
// of the current adapter position by using the last seen timestamp and the
// amount of bytes since. Additionally, the gst_adapter_prev_pts_at_offset() can
// be used to determine the last seen timestamp at a particular offset in the
// adapter.
//
// The adapter will also keep track of the offset of the buffers
// (T_BUFFER_OFFSET) that were pushed. The last seen offset before the current
// position can be queried with gst_adapter_prev_offset(). This function can
// optionally return the number of bytes between the start of the buffer that
// carried the offset and the current adapter position.
//
// Additionally the adapter also keeps track of the PTS, DTS and buffer offset
// at the last discontinuity, which can be retrieved with
// gst_adapter_pts_at_discont(), gst_adapter_dts_at_discont() and
// gst_adapter_offset_at_discont(). The number of bytes that were consumed since
// then can be queried with gst_adapter_distance_from_discont().
//
// A last thing to note is that while Adapter is pretty optimized, merging
// buffers still might be an operation that requires a malloc() and memcpy()
// operation, and these operations are not the fastest. Because of this, some
// functions like gst_adapter_available_fast() are provided to help speed up
// such cases should you want to. To avoid repeated memory allocations,
// gst_adapter_copy() can be used to copy data into a (statically allocated)
// user provided buffer.
//
// Adapter is not MT safe. All operations on an adapter must be serialized by
// the caller. This is not normally a problem, however, as the normal use case
// of Adapter is inside one pad's chain function, in which case access is
// serialized via the pad's STREAM_LOCK.
//
// Note that gst_adapter_push() takes ownership of the buffer passed. Use
// gst_buffer_ref() before pushing it into the adapter if you still want to
// access the buffer later. The adapter will never modify the data in the buffer
// pushed in it.
type Adapter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Adapter)(nil)
)

func wrapAdapter(obj *coreglib.Object) *Adapter {
	return &Adapter{
		Object: obj,
	}
}

func marshalAdapter(p uintptr) (interface{}, error) {
	return wrapAdapter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAdapter creates a new Adapter. Free with g_object_unref().
//
// The function returns the following values:
//
//    - adapter: new Adapter.
//
func NewAdapter() *Adapter {
	var _cret *C.GstAdapter // in

	_cret = C.gst_adapter_new()

	var _adapter *Adapter // out

	_adapter = wrapAdapter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _adapter
}

// Available gets the maximum amount of bytes available, that is it returns the
// maximum value that can be supplied to gst_adapter_map() without that function
// returning NULL.
//
// The function returns the following values:
//
//    - gsize: number of bytes available in adapter.
//
func (adapter *Adapter) Available() uint {
	var _arg0 *C.GstAdapter // out
	var _cret C.gsize       // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_available(_arg0)
	runtime.KeepAlive(adapter)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// AvailableFast gets the maximum number of bytes that are immediately available
// without requiring any expensive operations (like copying the data into a
// temporary buffer).
//
// The function returns the following values:
//
//    - gsize: number of bytes that are available in adapter without expensive
//      operations.
//
func (adapter *Adapter) AvailableFast() uint {
	var _arg0 *C.GstAdapter // out
	var _cret C.gsize       // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_available_fast(_arg0)
	runtime.KeepAlive(adapter)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Clear removes all buffers from adapter.
func (adapter *Adapter) Clear() {
	var _arg0 *C.GstAdapter // out

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	C.gst_adapter_clear(_arg0)
	runtime.KeepAlive(adapter)
}

// Copy: similar to gst_adapter_copy, but more suitable for language bindings.
// size bytes of data starting at offset will be copied out of the buffers
// contained in adapter and into a new #GBytes structure which is returned.
// Depending on the value of the size argument an empty #GBytes structure may be
// returned.
//
// The function takes the following parameters:
//
//    - offset bytes offset in the adapter to start from.
//    - size: number of bytes to copy.
//
// The function returns the following values:
//
//    - bytes: new #GBytes structure containing the copied data.
//
func (adapter *Adapter) Copy(offset, size uint) *glib.Bytes {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _arg2 C.gsize       // out
	var _cret *C.GBytes     // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(offset)
	_arg2 = C.gsize(size)

	_cret = C.gst_adapter_copy_bytes(_arg0, _arg1, _arg2)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// DistanceFromDiscont: get the distance in bytes since the last buffer with the
// GST_BUFFER_FLAG_DISCONT flag.
//
// The distance will be reset to 0 for all buffers with GST_BUFFER_FLAG_DISCONT
// on them, and then calculated for all other following buffers based on their
// size.
//
// The function returns the following values:
//
//    - guint64: offset. Can be GST_BUFFER_OFFSET_NONE.
//
func (adapter *Adapter) DistanceFromDiscont() uint64 {
	var _arg0 *C.GstAdapter // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_distance_from_discont(_arg0)
	runtime.KeepAlive(adapter)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// DtsAtDiscont: get the DTS that was on the last buffer with the
// GST_BUFFER_FLAG_DISCONT flag, or GST_CLOCK_TIME_NONE.
//
// The function returns the following values:
//
//    - clockTime: DTS at the last discont or GST_CLOCK_TIME_NONE.
//
func (adapter *Adapter) DtsAtDiscont() gst.ClockTime {
	var _arg0 *C.GstAdapter  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_dts_at_discont(_arg0)
	runtime.KeepAlive(adapter)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Flush flushes the first flush bytes in the adapter. The caller must ensure
// that at least this many bytes are available.
//
// See also: gst_adapter_map(), gst_adapter_unmap().
//
// The function takes the following parameters:
//
//    - flush: number of bytes to flush.
//
func (adapter *Adapter) Flush(flush uint) {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(flush)

	C.gst_adapter_flush(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(flush)
}

// Buffer returns a Buffer containing the first nbytes of the adapter, but does
// not flush them from the adapter. See gst_adapter_take_buffer() for details.
//
// Caller owns a reference to the returned buffer. gst_buffer_unref() after
// usage.
//
// Free-function: gst_buffer_unref.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to get.
//
// The function returns the following values:
//
//    - buffer (optional) containing the first nbytes of the adapter, or NULL if
//      nbytes bytes are not available. gst_buffer_unref() when no longer needed.
//
func (adapter *Adapter) Buffer(nbytes uint) *gst.Buffer {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_get_buffer(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// BufferFast returns a Buffer containing the first nbytes of the adapter, but
// does not flush them from the adapter. See gst_adapter_take_buffer_fast() for
// details.
//
// Caller owns a reference to the returned buffer. gst_buffer_unref() after
// usage.
//
// Free-function: gst_buffer_unref.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to get.
//
// The function returns the following values:
//
//    - buffer (optional) containing the first nbytes of the adapter, or NULL if
//      nbytes bytes are not available. gst_buffer_unref() when no longer needed.
//
func (adapter *Adapter) BufferFast(nbytes uint) *gst.Buffer {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_get_buffer_fast(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// BufferList returns a BufferList of buffers containing the first nbytes bytes
// of the adapter but does not flush them from the adapter. See
// gst_adapter_take_buffer_list() for details.
//
// Caller owns the returned list. Call gst_buffer_list_unref() to free the list
// after usage.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to get.
//
// The function returns the following values:
//
//    - bufferList (optional) of buffers containing the first nbytes of the
//      adapter, or NULL if nbytes bytes are not available.
//
func (adapter *Adapter) BufferList(nbytes uint) *gst.BufferList {
	var _arg0 *C.GstAdapter    // out
	var _arg1 C.gsize          // out
	var _cret *C.GstBufferList // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_get_buffer_list(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _bufferList *gst.BufferList // out

	if _cret != nil {
		_bufferList = (*gst.BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_bufferList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _bufferList
}

// List returns a #GList of buffers containing the first nbytes bytes of the
// adapter, but does not flush them from the adapter. See
// gst_adapter_take_list() for details.
//
// Caller owns returned list and contained buffers. gst_buffer_unref() each
// buffer in the list before freeing the list after usage.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to get.
//
// The function returns the following values:
//
//    - list (optional) of buffers containing the first nbytes of the adapter, or
//      NULL if nbytes bytes are not available.
//
func (adapter *Adapter) List(nbytes uint) []*gst.Buffer {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _cret *C.GList      // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_get_list(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _list []*gst.Buffer // out

	if _cret != nil {
		_list = make([]*gst.Buffer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.GstBuffer)(v)
			var dst *gst.Buffer // out
			dst = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(src)))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(dst)),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
			_list = append(_list, dst)
		})
	}

	return _list
}

// MaskedScanUint32: scan for pattern pattern with applied mask mask in the
// adapter data, starting from offset offset.
//
// The bytes in pattern and mask are interpreted left-to-right, regardless of
// endianness. All four bytes of the pattern must be present in the adapter for
// it to match, even if the first or last bytes are masked out.
//
// It is an error to call this function without making sure that there is enough
// data (offset+size bytes) in the adapter.
//
// This function calls gst_adapter_masked_scan_uint32_peek() passing NULL for
// value.
//
// The function takes the following parameters:
//
//    - mask to apply to data before matching against pattern.
//    - pattern to match (after mask is applied).
//    - offset into the adapter data from which to start scanning, returns the
//      last scanned position.
//    - size: number of bytes to scan from offset.
//
// The function returns the following values:
//
//    - gssize: offset of the first match, or -1 if no match was found.
//
//      Example:
//
//         // Assume the adapter contains 0x00 0x01 0x02 ... 0xfe 0xff
//
//         gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 0, 256);
//         // -> returns 0
//         gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 1, 255);
//         // -> returns -1
//         gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x01020304, 1, 255);
//         // -> returns 1
//         gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0001, 0, 256);
//         // -> returns -1
//         gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0203, 0, 256);
//         // -> returns 0
//         gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 256);
//         // -> returns 2
//         gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 4);
//         // -> returns -1.
//
func (adapter *Adapter) MaskedScanUint32(mask, pattern uint32, offset, size uint) int {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.guint32     // out
	var _arg2 C.guint32     // out
	var _arg3 C.gsize       // out
	var _arg4 C.gsize       // out
	var _cret C.gssize      // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.guint32(mask)
	_arg2 = C.guint32(pattern)
	_arg3 = C.gsize(offset)
	_arg4 = C.gsize(size)

	_cret = C.gst_adapter_masked_scan_uint32(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// MaskedScanUint32Peek: scan for pattern pattern with applied mask mask in the
// adapter data, starting from offset offset. If a match is found, the value
// that matched is returned through value, otherwise value is left untouched.
//
// The bytes in pattern and mask are interpreted left-to-right, regardless of
// endianness. All four bytes of the pattern must be present in the adapter for
// it to match, even if the first or last bytes are masked out.
//
// It is an error to call this function without making sure that there is enough
// data (offset+size bytes) in the adapter.
//
// The function takes the following parameters:
//
//    - mask to apply to data before matching against pattern.
//    - pattern to match (after mask is applied).
//    - offset into the adapter data from which to start scanning, returns the
//      last scanned position.
//    - size: number of bytes to scan from offset.
//
// The function returns the following values:
//
//    - value (optional): pointer to uint32 to return matching data.
//    - gssize: offset of the first match, or -1 if no match was found.
//
func (adapter *Adapter) MaskedScanUint32Peek(mask, pattern uint32, offset, size uint) (uint32, int) {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.guint32     // out
	var _arg2 C.guint32     // out
	var _arg3 C.gsize       // out
	var _arg4 C.gsize       // out
	var _arg5 C.guint32     // in
	var _cret C.gssize      // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.guint32(mask)
	_arg2 = C.guint32(pattern)
	_arg3 = C.gsize(offset)
	_arg4 = C.gsize(size)

	_cret = C.gst_adapter_masked_scan_uint32_peek(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _value uint32 // out
	var _gssize int   // out

	_value = uint32(_arg5)
	_gssize = int(_cret)

	return _value, _gssize
}

// OffsetAtDiscont: get the offset that was on the last buffer with the
// GST_BUFFER_FLAG_DISCONT flag, or GST_BUFFER_OFFSET_NONE.
//
// The function returns the following values:
//
//    - guint64: offset at the last discont or GST_BUFFER_OFFSET_NONE.
//
func (adapter *Adapter) OffsetAtDiscont() uint64 {
	var _arg0 *C.GstAdapter // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_offset_at_discont(_arg0)
	runtime.KeepAlive(adapter)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// PrevDts: get the dts that was before the current byte in the adapter. When
// distance is given, the amount of bytes between the dts and the current
// position is returned.
//
// The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when the
// adapter is first created or when it is cleared. This also means that before
// the first byte with a dts is removed from the adapter, the dts and distance
// returned are GST_CLOCK_TIME_NONE and 0 respectively.
//
// The function returns the following values:
//
//    - distance (optional): pointer to location for distance, or NULL.
//    - clockTime: previously seen dts.
//
func (adapter *Adapter) PrevDts() (uint64, gst.ClockTime) {
	var _arg0 *C.GstAdapter  // out
	var _arg1 C.guint64      // in
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_prev_dts(_arg0, &_arg1)
	runtime.KeepAlive(adapter)

	var _distance uint64         // out
	var _clockTime gst.ClockTime // out

	_distance = uint64(_arg1)
	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _distance, _clockTime
}

// PrevDtsAtOffset: get the dts that was before the byte at offset offset in the
// adapter. When distance is given, the amount of bytes between the dts and the
// current position is returned.
//
// The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when the
// adapter is first created or when it is cleared. This also means that before
// the first byte with a dts is removed from the adapter, the dts and distance
// returned are GST_CLOCK_TIME_NONE and 0 respectively.
//
// The function takes the following parameters:
//
//    - offset in the adapter at which to get timestamp.
//
// The function returns the following values:
//
//    - distance (optional): pointer to location for distance, or NULL.
//    - clockTime: previously seen dts at given offset.
//
func (adapter *Adapter) PrevDtsAtOffset(offset uint) (uint64, gst.ClockTime) {
	var _arg0 *C.GstAdapter  // out
	var _arg1 C.gsize        // out
	var _arg2 C.guint64      // in
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(offset)

	_cret = C.gst_adapter_prev_dts_at_offset(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(offset)

	var _distance uint64         // out
	var _clockTime gst.ClockTime // out

	_distance = uint64(_arg2)
	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _distance, _clockTime
}

// PrevOffset: get the offset that was before the current byte in the adapter.
// When distance is given, the amount of bytes between the offset and the
// current position is returned.
//
// The offset is reset to GST_BUFFER_OFFSET_NONE and the distance is set to 0
// when the adapter is first created or when it is cleared. This also means that
// before the first byte with an offset is removed from the adapter, the offset
// and distance returned are GST_BUFFER_OFFSET_NONE and 0 respectively.
//
// The function returns the following values:
//
//    - distance (optional): pointer to a location for distance, or NULL.
//    - guint64 previous seen offset.
//
func (adapter *Adapter) PrevOffset() (distance, guint64 uint64) {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.guint64     // in
	var _cret C.guint64     // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_prev_offset(_arg0, &_arg1)
	runtime.KeepAlive(adapter)

	var _distance uint64 // out
	var _guint64 uint64  // out

	_distance = uint64(_arg1)
	_guint64 = uint64(_cret)

	return _distance, _guint64
}

// PrevPts: get the pts that was before the current byte in the adapter. When
// distance is given, the amount of bytes between the pts and the current
// position is returned.
//
// The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when the
// adapter is first created or when it is cleared. This also means that before
// the first byte with a pts is removed from the adapter, the pts and distance
// returned are GST_CLOCK_TIME_NONE and 0 respectively.
//
// The function returns the following values:
//
//    - distance (optional): pointer to location for distance, or NULL.
//    - clockTime: previously seen pts.
//
func (adapter *Adapter) PrevPts() (uint64, gst.ClockTime) {
	var _arg0 *C.GstAdapter  // out
	var _arg1 C.guint64      // in
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_prev_pts(_arg0, &_arg1)
	runtime.KeepAlive(adapter)

	var _distance uint64         // out
	var _clockTime gst.ClockTime // out

	_distance = uint64(_arg1)
	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _distance, _clockTime
}

// PrevPtsAtOffset: get the pts that was before the byte at offset offset in the
// adapter. When distance is given, the amount of bytes between the pts and the
// current position is returned.
//
// The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when the
// adapter is first created or when it is cleared. This also means that before
// the first byte with a pts is removed from the adapter, the pts and distance
// returned are GST_CLOCK_TIME_NONE and 0 respectively.
//
// The function takes the following parameters:
//
//    - offset in the adapter at which to get timestamp.
//
// The function returns the following values:
//
//    - distance (optional): pointer to location for distance, or NULL.
//    - clockTime: previously seen pts at given offset.
//
func (adapter *Adapter) PrevPtsAtOffset(offset uint) (uint64, gst.ClockTime) {
	var _arg0 *C.GstAdapter  // out
	var _arg1 C.gsize        // out
	var _arg2 C.guint64      // in
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(offset)

	_cret = C.gst_adapter_prev_pts_at_offset(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(offset)

	var _distance uint64         // out
	var _clockTime gst.ClockTime // out

	_distance = uint64(_arg2)
	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _distance, _clockTime
}

// PtsAtDiscont: get the PTS that was on the last buffer with the
// GST_BUFFER_FLAG_DISCONT flag, or GST_CLOCK_TIME_NONE.
//
// The function returns the following values:
//
//    - clockTime: PTS at the last discont or GST_CLOCK_TIME_NONE.
//
func (adapter *Adapter) PtsAtDiscont() gst.ClockTime {
	var _arg0 *C.GstAdapter  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	_cret = C.gst_adapter_pts_at_discont(_arg0)
	runtime.KeepAlive(adapter)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Push adds the data from buf to the data stored inside adapter and takes
// ownership of the buffer.
//
// The function takes the following parameters:
//
//    - buf to add to queue in the adapter.
//
func (adapter *Adapter) Push(buf *gst.Buffer) {
	var _arg0 *C.GstAdapter // out
	var _arg1 *C.GstBuffer  // out

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf)), nil)

	C.gst_adapter_push(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(buf)
}

// TakeBuffer returns a Buffer containing the first nbytes bytes of the adapter.
// The returned bytes will be flushed from the adapter. This function is
// potentially more performant than gst_adapter_take() since it can reuse the
// memory in pushed buffers by subbuffering or merging. This function will
// always return a buffer with a single memory region.
//
// Note that no assumptions should be made as to whether certain buffer flags
// such as the DISCONT flag are set on the returned buffer, or not. The caller
// needs to explicitly set or unset flags that should be set or unset.
//
// Since 1.6 this will also copy over all GstMeta of the input buffers except
// for meta with the GST_META_FLAG_POOLED flag or with the "memory" tag.
//
// Caller owns a reference to the returned buffer. gst_buffer_unref() after
// usage.
//
// Free-function: gst_buffer_unref.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to take.
//
// The function returns the following values:
//
//    - buffer (optional) containing the first nbytes of the adapter, or NULL if
//      nbytes bytes are not available. gst_buffer_unref() when no longer needed.
//
func (adapter *Adapter) TakeBuffer(nbytes uint) *gst.Buffer {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_take_buffer(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// TakeBufferFast returns a Buffer containing the first nbytes of the adapter.
// The returned bytes will be flushed from the adapter. This function is
// potentially more performant than gst_adapter_take_buffer() since it can reuse
// the memory in pushed buffers by subbuffering or merging. Unlike
// gst_adapter_take_buffer(), the returned buffer may be composed of multiple
// non-contiguous Memory objects, no copies are made.
//
// Note that no assumptions should be made as to whether certain buffer flags
// such as the DISCONT flag are set on the returned buffer, or not. The caller
// needs to explicitly set or unset flags that should be set or unset.
//
// This will also copy over all GstMeta of the input buffers except for meta
// with the GST_META_FLAG_POOLED flag or with the "memory" tag.
//
// This function can return buffer up to the return value of
// gst_adapter_available() without making copies if possible.
//
// Caller owns a reference to the returned buffer. gst_buffer_unref() after
// usage.
//
// Free-function: gst_buffer_unref.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to take.
//
// The function returns the following values:
//
//    - buffer (optional) containing the first nbytes of the adapter, or NULL if
//      nbytes bytes are not available. gst_buffer_unref() when no longer needed.
//
func (adapter *Adapter) TakeBufferFast(nbytes uint) *gst.Buffer {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_take_buffer_fast(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// TakeBufferList returns a BufferList of buffers containing the first nbytes
// bytes of the adapter. The returned bytes will be flushed from the adapter.
// When the caller can deal with individual buffers, this function is more
// performant because no memory should be copied.
//
// Caller owns the returned list. Call gst_buffer_list_unref() to free the list
// after usage.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to take.
//
// The function returns the following values:
//
//    - bufferList (optional) of buffers containing the first nbytes of the
//      adapter, or NULL if nbytes bytes are not available.
//
func (adapter *Adapter) TakeBufferList(nbytes uint) *gst.BufferList {
	var _arg0 *C.GstAdapter    // out
	var _arg1 C.gsize          // out
	var _cret *C.GstBufferList // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_take_buffer_list(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _bufferList *gst.BufferList // out

	if _cret != nil {
		_bufferList = (*gst.BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_bufferList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _bufferList
}

// TakeList returns a #GList of buffers containing the first nbytes bytes of the
// adapter. The returned bytes will be flushed from the adapter. When the caller
// can deal with individual buffers, this function is more performant because no
// memory should be copied.
//
// Caller owns returned list and contained buffers. gst_buffer_unref() each
// buffer in the list before freeing the list after usage.
//
// The function takes the following parameters:
//
//    - nbytes: number of bytes to take.
//
// The function returns the following values:
//
//    - list (optional) of buffers containing the first nbytes of the adapter, or
//      NULL if nbytes bytes are not available.
//
func (adapter *Adapter) TakeList(nbytes uint) []*gst.Buffer {
	var _arg0 *C.GstAdapter // out
	var _arg1 C.gsize       // out
	var _cret *C.GList      // in

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg1 = C.gsize(nbytes)

	_cret = C.gst_adapter_take_list(_arg0, _arg1)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(nbytes)

	var _list []*gst.Buffer // out

	if _cret != nil {
		_list = make([]*gst.Buffer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.GstBuffer)(v)
			var dst *gst.Buffer // out
			dst = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(src)))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(dst)),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
			_list = append(_list, dst)
		})
	}

	return _list
}

// Unmap releases the memory obtained with the last gst_adapter_map().
func (adapter *Adapter) Unmap() {
	var _arg0 *C.GstAdapter // out

	_arg0 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))

	C.gst_adapter_unmap(_arg0)
	runtime.KeepAlive(adapter)
}
