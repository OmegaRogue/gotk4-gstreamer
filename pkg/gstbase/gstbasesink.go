// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
// extern void _gotk4_gstbase1_BaseSinkClass_get_times(GstBaseSink*, GstBuffer*, GstClockTime*, GstClockTime*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_unlock_stop(GstBaseSink*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_unlock(GstBaseSink*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_stop(GstBaseSink*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_start(GstBaseSink*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_set_caps(GstBaseSink*, GstCaps*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_query(GstBaseSink*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_propose_allocation(GstBaseSink*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_event(GstBaseSink*, GstEvent*);
// extern gboolean _gotk4_gstbase1_BaseSinkClass_activate_pull(GstBaseSink*, gboolean);
// extern GstFlowReturn _gotk4_gstbase1_BaseSinkClass_wait_event(GstBaseSink*, GstEvent*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSinkClass_render_list(GstBaseSink*, GstBufferList*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSinkClass_render(GstBaseSink*, GstBuffer*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSinkClass_preroll(GstBaseSink*, GstBuffer*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSinkClass_prepare_list(GstBaseSink*, GstBufferList*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSinkClass_prepare(GstBaseSink*, GstBuffer*);
// extern GstCaps* _gotk4_gstbase1_BaseSinkClass_get_caps(GstBaseSink*, GstCaps*);
// extern GstCaps* _gotk4_gstbase1_BaseSinkClass_fixate(GstBaseSink*, GstCaps*);
// GstCaps* _gotk4_gstbase1_BaseSink_virtual_fixate(void* fnptr, GstBaseSink* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstBaseSink*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstCaps* _gotk4_gstbase1_BaseSink_virtual_get_caps(void* fnptr, GstBaseSink* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstBaseSink*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSink_virtual_prepare(void* fnptr, GstBaseSink* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstBaseSink*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSink_virtual_prepare_list(void* fnptr, GstBaseSink* arg0, GstBufferList* arg1) {
//   return ((GstFlowReturn (*)(GstBaseSink*, GstBufferList*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSink_virtual_preroll(void* fnptr, GstBaseSink* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstBaseSink*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSink_virtual_render(void* fnptr, GstBaseSink* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstBaseSink*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSink_virtual_render_list(void* fnptr, GstBaseSink* arg0, GstBufferList* arg1) {
//   return ((GstFlowReturn (*)(GstBaseSink*, GstBufferList*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSink_virtual_wait_event(void* fnptr, GstBaseSink* arg0, GstEvent* arg1) {
//   return ((GstFlowReturn (*)(GstBaseSink*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_activate_pull(void* fnptr, GstBaseSink* arg0, gboolean arg1) {
//   return ((gboolean (*)(GstBaseSink*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_event(void* fnptr, GstBaseSink* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstBaseSink*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_propose_allocation(void* fnptr, GstBaseSink* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseSink*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_query(void* fnptr, GstBaseSink* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseSink*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_set_caps(void* fnptr, GstBaseSink* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstBaseSink*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_start(void* fnptr, GstBaseSink* arg0) {
//   return ((gboolean (*)(GstBaseSink*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_stop(void* fnptr, GstBaseSink* arg0) {
//   return ((gboolean (*)(GstBaseSink*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_unlock(void* fnptr, GstBaseSink* arg0) {
//   return ((gboolean (*)(GstBaseSink*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSink_virtual_unlock_stop(void* fnptr, GstBaseSink* arg0) {
//   return ((gboolean (*)(GstBaseSink*))(fnptr))(arg0);
// };
// void _gotk4_gstbase1_BaseSink_virtual_get_times(void* fnptr, GstBaseSink* arg0, GstBuffer* arg1, GstClockTime* arg2, GstClockTime* arg3) {
//   ((void (*)(GstBaseSink*, GstBuffer*, GstClockTime*, GstClockTime*))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeBaseSink = coreglib.Type(C.gst_base_sink_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBaseSink, F: marshalBaseSink},
	})
}

// BaseSinkOverrides contains methods that are overridable.
type BaseSinkOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ActivatePull func(active bool) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Event func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Fixate func(caps *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Caps func(filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	//    - buffer
	//    - start
	//    - end
	//
	Times func(buffer *gst.Buffer, start, end *gst.ClockTime)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Prepare func(buffer *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	PrepareList func(bufferList *gst.BufferList) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Preroll func(buffer *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProposeAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Query func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Render func(buffer *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	RenderList func(bufferList *gst.BufferList) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetCaps func(caps *gst.Caps) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function returns the following values:
	//
	Unlock func() bool
	// The function returns the following values:
	//
	UnlockStop func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	WaitEvent func(event *gst.Event) gst.FlowReturn
}

func defaultBaseSinkOverrides(v *BaseSink) BaseSinkOverrides {
	return BaseSinkOverrides{
		ActivatePull:      v.activatePull,
		Event:             v.event,
		Fixate:            v.fixate,
		Caps:              v.caps,
		Times:             v.times,
		Prepare:           v.prepare,
		PrepareList:       v.prepareList,
		Preroll:           v.preroll,
		ProposeAllocation: v.proposeAllocation,
		Query:             v.query,
		Render:            v.render,
		RenderList:        v.renderList,
		SetCaps:           v.setCaps,
		Start:             v.start,
		Stop:              v.stop,
		Unlock:            v.unlock,
		UnlockStop:        v.unlockStop,
		WaitEvent:         v.waitEvent,
	}
}

// BaseSink is the base class for sink elements in GStreamer, such as
// xvimagesink or filesink. It is a layer on top of Element that provides a
// simplified interface to plugin writers. BaseSink handles many details for
// you, for example: preroll, clock synchronization, state changes, activation
// in push or pull mode, and queries.
//
// In most cases, when writing sink elements, there is no need to implement
// class methods from Element or to set functions on pads, because the BaseSink
// infrastructure should be sufficient.
//
// BaseSink provides support for exactly one sink pad, which should be named
// "sink". A sink implementation (subclass of BaseSink) should install a pad
// template in its class_init function, like so:
//
//    static void
//    my_element_class_init (GstMyElementClass *klass)
//    {
//      GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
//
//      // sinktemplate should be a StaticPadTemplate with direction
//      // GST_PAD_SINK and name "sink"
//      gst_element_class_add_static_pad_template (gstelement_class, &sinktemplate);
//
//      gst_element_class_set_static_metadata (gstelement_class,
//          "Sink name",
//          "Sink",
//          "My Sink element",
//          "The author <my.sinkmy.email>");
//    }
//
// BaseSink will handle the prerolling correctly. This means that it will return
// GST_STATE_CHANGE_ASYNC from a state change to PAUSED until the first buffer
// arrives in this element. The base class will call the BaseSinkClass::preroll
// vmethod with this preroll buffer and will then commit the state change to the
// next asynchronously pending state.
//
// When the element is set to PLAYING, BaseSink will synchronise on the clock
// using the times returned from BaseSinkClass::get_times. If this function
// returns GST_CLOCK_TIME_NONE for the start time, no synchronisation will be
// done. Synchronisation can be disabled entirely by setting the object
// BaseSink:sync property to FALSE.
//
// After synchronisation the virtual method BaseSinkClass::render will be
// called. Subclasses should minimally implement this method.
//
// Subclasses that synchronise on the clock in the BaseSinkClass::render method
// are supported as well. These classes typically receive a buffer in the render
// method and can then potentially block on the clock while rendering. A typical
// example is an audiosink. These subclasses can use
// gst_base_sink_wait_preroll() to perform the blocking wait.
//
// Upon receiving the EOS event in the PLAYING state, BaseSink will wait for the
// clock to reach the time indicated by the stop time of the last
// BaseSinkClass::get_times call before posting an EOS message. When the element
// receives EOS in PAUSED, preroll completes, the event is queued and an EOS
// message is posted when going to PLAYING.
//
// BaseSink will internally use the GST_EVENT_SEGMENT events to schedule
// synchronisation and clipping of buffers. Buffers that fall completely outside
// of the current segment are dropped. Buffers that fall partially in the
// segment are rendered (and prerolled). Subclasses should do any subbuffer
// clipping themselves when needed.
//
// BaseSink will by default report the current playback position in
// GST_FORMAT_TIME based on the current clock time and segment information. If
// no clock has been set on the element, the query will be forwarded upstream.
//
// The BaseSinkClass::set_caps function will be called when the subclass should
// configure itself to process a specific media type.
//
// The BaseSinkClass::start and BaseSinkClass::stop virtual methods will be
// called when resources should be allocated. Any BaseSinkClass::preroll,
// BaseSinkClass::render and BaseSinkClass::set_caps function will be called
// between the BaseSinkClass::start and BaseSinkClass::stop calls.
//
// The BaseSinkClass::event virtual method will be called when an event is
// received by BaseSink. Normally this method should only be overridden by very
// specific elements (such as file sinks) which need to handle the newsegment
// event specially.
//
// The BaseSinkClass::unlock method is called when the elements should unblock
// any blocking operations they perform in the BaseSinkClass::render method.
// This is mostly useful when the BaseSinkClass::render method performs a
// blocking write on a file descriptor, for example.
//
// The BaseSink:max-lateness property affects how the sink deals with buffers
// that arrive too late in the sink. A buffer arrives too late in the sink when
// the presentation time (as a combination of the last segment, buffer timestamp
// and element base_time) plus the duration is before the current time of the
// clock. If the frame is later than max-lateness, the sink will drop the buffer
// without calling the render method. This feature is disabled if sync is
// disabled, the BaseSinkClass::get_times method does not return a valid start
// time or max-lateness is set to -1 (the default). Subclasses can use
// gst_base_sink_set_max_lateness() to configure the max-lateness value.
//
// The BaseSink:qos property will enable the quality-of-service features of the
// basesink which gather statistics about the real-time performance of the clock
// synchronisation. For each buffer received in the sink, statistics are
// gathered and a QOS event is sent upstream with these numbers. This
// information can then be used by upstream elements to reduce their processing
// rate, for example.
//
// The BaseSink:async property can be used to instruct the sink to never perform
// an ASYNC state change. This feature is mostly usable when dealing with
// non-synchronized streams or sparse streams.
type BaseSink struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*BaseSink)(nil)
)

// BaseSinker describes types inherited from class BaseSink.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type BaseSinker interface {
	coreglib.Objector
	baseBaseSink() *BaseSink
}

var _ BaseSinker = (*BaseSink)(nil)

func init() {
	coreglib.RegisterClassInfo[*BaseSink, *BaseSinkClass, BaseSinkOverrides](
		GTypeBaseSink,
		initBaseSinkClass,
		wrapBaseSink,
		defaultBaseSinkOverrides,
	)
}

func initBaseSinkClass(gclass unsafe.Pointer, overrides BaseSinkOverrides, classInitFunc func(*BaseSinkClass)) {
	pclass := (*C.GstBaseSinkClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBaseSink))))

	if overrides.ActivatePull != nil {
		pclass.activate_pull = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_activate_pull)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_event)
	}

	if overrides.Fixate != nil {
		pclass.fixate = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_fixate)
	}

	if overrides.Caps != nil {
		pclass.get_caps = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_get_caps)
	}

	if overrides.Times != nil {
		pclass.get_times = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_get_times)
	}

	if overrides.Prepare != nil {
		pclass.prepare = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_prepare)
	}

	if overrides.PrepareList != nil {
		pclass.prepare_list = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_prepare_list)
	}

	if overrides.Preroll != nil {
		pclass.preroll = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_preroll)
	}

	if overrides.ProposeAllocation != nil {
		pclass.propose_allocation = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_propose_allocation)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_query)
	}

	if overrides.Render != nil {
		pclass.render = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_render)
	}

	if overrides.RenderList != nil {
		pclass.render_list = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_render_list)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_set_caps)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_stop)
	}

	if overrides.Unlock != nil {
		pclass.unlock = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_unlock)
	}

	if overrides.UnlockStop != nil {
		pclass.unlock_stop = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_unlock_stop)
	}

	if overrides.WaitEvent != nil {
		pclass.wait_event = (*[0]byte)(C._gotk4_gstbase1_BaseSinkClass_wait_event)
	}

	if classInitFunc != nil {
		class := (*BaseSinkClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBaseSink(obj *coreglib.Object) *BaseSink {
	return &BaseSink{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalBaseSink(p uintptr) (interface{}, error) {
	return wrapBaseSink(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (sink *BaseSink) baseBaseSink() *BaseSink {
	return sink
}

// BaseBaseSink returns the underlying base object.
func BaseBaseSink(obj BaseSinker) *BaseSink {
	return obj.baseBaseSink()
}

// DoPreroll: if the sink spawns its own thread for pulling buffers from
// upstream it should call this method after it has pulled a buffer. If the
// element needed to preroll, this function will perform the preroll and will
// then block until the element state is changed.
//
// This function should be called with the PREROLL_LOCK held.
//
// The function takes the following parameters:
//
//    - obj: mini object that caused the preroll.
//
// The function returns the following values:
//
//    - flowReturn: GST_FLOW_OK if the preroll completed and processing can
//      continue. Any other return value should be returned from the render
//      vmethod.
//
func (sink *BaseSink) DoPreroll(obj *gst.MiniObject) gst.FlowReturn {
	var _arg0 *C.GstBaseSink   // out
	var _arg1 *C.GstMiniObject // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(obj)))

	_cret = C.gst_base_sink_do_preroll(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(obj)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Blocksize: get the number of bytes that the sink will pull when it is
// operating in pull mode.
//
// The function returns the following values:
//
//    - guint: number of bytes sink will pull in pull mode.
//
func (sink *BaseSink) Blocksize() uint {
	var _arg0 *C.GstBaseSink // out
	var _cret C.guint        // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_blocksize(_arg0)
	runtime.KeepAlive(sink)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DropOutOfSegment checks if sink is currently configured to drop buffers which
// are outside the current segment.
//
// The function returns the following values:
//
//    - ok: TRUE if the sink is configured to drop buffers outside the current
//      segment.
//
func (sink *BaseSink) DropOutOfSegment() bool {
	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_drop_out_of_segment(_arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LastSample: get the last sample that arrived in the sink and was used for
// preroll or for rendering. This property can be used to generate thumbnails.
//
// The Caps on the sample can be used to determine the type of the buffer.
//
// Free-function: gst_sample_unref.
//
// The function returns the following values:
//
//    - sample (optional) gst_sample_unref() after usage. This function returns
//      NULL when no buffer has arrived in the sink yet or when the sink is not
//      in PAUSED or PLAYING.
//
func (sink *BaseSink) LastSample() *gst.Sample {
	var _arg0 *C.GstBaseSink // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_last_sample(_arg0)
	runtime.KeepAlive(sink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// Latency: get the currently configured latency.
//
// The function returns the following values:
//
//    - clockTime: configured latency.
//
func (sink *BaseSink) Latency() gst.ClockTime {
	var _arg0 *C.GstBaseSink // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_latency(_arg0)
	runtime.KeepAlive(sink)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// MaxBitrate: get the maximum amount of bits per second that the sink will
// render.
//
// The function returns the following values:
//
//    - guint64: maximum number of bits per second sink will render.
//
func (sink *BaseSink) MaxBitrate() uint64 {
	var _arg0 *C.GstBaseSink // out
	var _cret C.guint64      // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_max_bitrate(_arg0)
	runtime.KeepAlive(sink)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MaxLateness gets the max lateness value. See gst_base_sink_set_max_lateness()
// for more details.
//
// The function returns the following values:
//
//    - gint64: maximum time in nanoseconds that a buffer can be late before it
//      is dropped and not rendered. A value of -1 means an unlimited time.
//
func (sink *BaseSink) MaxLateness() int64 {
	var _arg0 *C.GstBaseSink // out
	var _cret C.gint64       // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_max_lateness(_arg0)
	runtime.KeepAlive(sink)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ProcessingDeadline: get the processing deadline of sink. see
// gst_base_sink_set_processing_deadline() for more information about the
// processing deadline.
//
// The function returns the following values:
//
//    - clockTime: processing deadline.
//
func (sink *BaseSink) ProcessingDeadline() gst.ClockTime {
	var _arg0 *C.GstBaseSink // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_processing_deadline(_arg0)
	runtime.KeepAlive(sink)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// RenderDelay: get the render delay of sink. see
// gst_base_sink_set_render_delay() for more information about the render delay.
//
// The function returns the following values:
//
//    - clockTime: render delay of sink.
//
func (sink *BaseSink) RenderDelay() gst.ClockTime {
	var _arg0 *C.GstBaseSink // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_render_delay(_arg0)
	runtime.KeepAlive(sink)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Stats: return various BaseSink statistics. This function returns a Structure
// with name application/x-gst-base-sink-stats with the following fields:
//
// - "average-rate" G_TYPE_DOUBLE average frame rate
//
// - "dropped" G_TYPE_UINT64 Number of dropped frames
//
// - "rendered" G_TYPE_UINT64 Number of rendered frames.
//
// The function returns the following values:
//
//    - structure: pointer to Structure.
//
func (sink *BaseSink) Stats() *gst.Structure {
	var _arg0 *C.GstBaseSink  // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_stats(_arg0)
	runtime.KeepAlive(sink)

	var _structure *gst.Structure // out

	_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// Sync checks if sink is currently configured to synchronize against the clock.
//
// The function returns the following values:
//
//    - ok: TRUE if the sink is configured to synchronize against the clock.
//
func (sink *BaseSink) Sync() bool {
	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_sync(_arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ThrottleTime: get the time that will be inserted between frames to control
// the maximum buffers per second.
//
// The function returns the following values:
//
//    - guint64: number of nanoseconds sink will put between frames.
//
func (sink *BaseSink) ThrottleTime() uint64 {
	var _arg0 *C.GstBaseSink // out
	var _cret C.guint64      // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_throttle_time(_arg0)
	runtime.KeepAlive(sink)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// TsOffset: get the synchronisation offset of sink.
//
// The function returns the following values:
//
//    - clockTimeDiff: synchronisation offset.
//
func (sink *BaseSink) TsOffset() gst.ClockTimeDiff {
	var _arg0 *C.GstBaseSink     // out
	var _cret C.GstClockTimeDiff // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_get_ts_offset(_arg0)
	runtime.KeepAlive(sink)

	var _clockTimeDiff gst.ClockTimeDiff // out

	_clockTimeDiff = int64(_cret)
	type _ = gst.ClockTimeDiff
	type _ = int64

	return _clockTimeDiff
}

// IsAsyncEnabled checks if sink is currently configured to perform asynchronous
// state changes to PAUSED.
//
// The function returns the following values:
//
//    - ok: TRUE if the sink is configured to perform asynchronous state changes.
//
func (sink *BaseSink) IsAsyncEnabled() bool {
	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_is_async_enabled(_arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLastSampleEnabled checks if sink is currently configured to store the last
// received sample in the last-sample property.
//
// The function returns the following values:
//
//    - ok: TRUE if the sink is configured to store the last received sample.
//
func (sink *BaseSink) IsLastSampleEnabled() bool {
	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_is_last_sample_enabled(_arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsQosEnabled checks if sink is currently configured to send
// Quality-of-Service events upstream.
//
// The function returns the following values:
//
//    - ok: TRUE if the sink is configured to perform Quality-of-Service.
//
func (sink *BaseSink) IsQosEnabled() bool {
	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_is_qos_enabled(_arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryLatency: query the sink for the latency parameters. The latency will be
// queried from the upstream elements. live will be TRUE if sink is configured
// to synchronize against the clock. upstream_live will be TRUE if an upstream
// element is live.
//
// If both live and upstream_live are TRUE, the sink will want to compensate for
// the latency introduced by the upstream elements by setting the min_latency to
// a strictly positive value.
//
// This function is mostly used by subclasses.
//
// The function returns the following values:
//
//    - live (optional): if the sink is live.
//    - upstreamLive (optional): if an upstream element is live.
//    - minLatency (optional): min latency of the upstream elements.
//    - maxLatency (optional): max latency of the upstream elements.
//    - ok: TRUE if the query succeeded.
//
func (sink *BaseSink) QueryLatency() (live, upstreamLive bool, minLatency, maxLatency gst.ClockTime, ok bool) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // in
	var _arg2 C.gboolean     // in
	var _arg3 C.GstClockTime // in
	var _arg4 C.GstClockTime // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_query_latency(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(sink)

	var _live bool                // out
	var _upstreamLive bool        // out
	var _minLatency gst.ClockTime // out
	var _maxLatency gst.ClockTime // out
	var _ok bool                  // out

	if _arg1 != 0 {
		_live = true
	}
	if _arg2 != 0 {
		_upstreamLive = true
	}
	_minLatency = uint64(_arg3)
	type _ = gst.ClockTime
	type _ = uint64
	_maxLatency = uint64(_arg4)
	type _ = gst.ClockTime
	type _ = uint64
	if _cret != 0 {
		_ok = true
	}

	return _live, _upstreamLive, _minLatency, _maxLatency, _ok
}

// SetAsyncEnabled configures sink to perform all state changes asynchronously.
// When async is disabled, the sink will immediately go to PAUSED instead of
// waiting for a preroll buffer. This feature is useful if the sink does not
// synchronize against the clock or when it is dealing with sparse streams.
//
// The function takes the following parameters:
//
//    - enabled: new async value.
//
func (sink *BaseSink) SetAsyncEnabled(enabled bool) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_base_sink_set_async_enabled(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(enabled)
}

// SetBlocksize: set the number of bytes that the sink will pull when it is
// operating in pull mode.
//
// The function takes the following parameters:
//
//    - blocksize in bytes.
//
func (sink *BaseSink) SetBlocksize(blocksize uint) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint(blocksize)

	C.gst_base_sink_set_blocksize(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(blocksize)
}

// SetDropOutOfSegment: configure sink to drop buffers which are outside the
// current segment.
//
// The function takes the following parameters:
//
//    - dropOutOfSegment: drop buffers outside the segment.
//
func (sink *BaseSink) SetDropOutOfSegment(dropOutOfSegment bool) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	if dropOutOfSegment {
		_arg1 = C.TRUE
	}

	C.gst_base_sink_set_drop_out_of_segment(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(dropOutOfSegment)
}

// SetLastSampleEnabled configures sink to store the last received sample in the
// last-sample property.
//
// The function takes the following parameters:
//
//    - enabled: new enable-last-sample value.
//
func (sink *BaseSink) SetLastSampleEnabled(enabled bool) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_base_sink_set_last_sample_enabled(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(enabled)
}

// SetMaxBitrate: set the maximum amount of bits per second that the sink will
// render.
//
// The function takes the following parameters:
//
//    - maxBitrate: max_bitrate in bits per second.
//
func (sink *BaseSink) SetMaxBitrate(maxBitrate uint64) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.guint64      // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint64(maxBitrate)

	C.gst_base_sink_set_max_bitrate(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(maxBitrate)
}

// SetMaxLateness sets the new max lateness value to max_lateness. This value is
// used to decide if a buffer should be dropped or not based on the buffer
// timestamp and the current clock time. A value of -1 means an unlimited time.
//
// The function takes the following parameters:
//
//    - maxLateness: new max lateness value.
//
func (sink *BaseSink) SetMaxLateness(maxLateness int64) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gint64       // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.gint64(maxLateness)

	C.gst_base_sink_set_max_lateness(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(maxLateness)
}

// SetProcessingDeadline: maximum amount of time (in nanoseconds) that the
// pipeline can take for processing the buffer. This is added to the latency of
// live pipelines.
//
// This function is usually called by subclasses.
//
// The function takes the following parameters:
//
//    - processingDeadline: new processing deadline in nanoseconds.
//
func (sink *BaseSink) SetProcessingDeadline(processingDeadline gst.ClockTime) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint64(processingDeadline)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_base_sink_set_processing_deadline(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(processingDeadline)
}

// SetQosEnabled configures sink to send Quality-of-Service events upstream.
//
// The function takes the following parameters:
//
//    - enabled: new qos value.
//
func (sink *BaseSink) SetQosEnabled(enabled bool) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_base_sink_set_qos_enabled(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(enabled)
}

// SetRenderDelay: set the render delay in sink to delay. The render delay is
// the time between actual rendering of a buffer and its synchronisation time.
// Some devices might delay media rendering which can be compensated for with
// this function.
//
// After calling this function, this sink will report additional latency and
// other sinks will adjust their latency to delay the rendering of their media.
//
// This function is usually called by subclasses.
//
// The function takes the following parameters:
//
//    - delay: new delay.
//
func (sink *BaseSink) SetRenderDelay(delay gst.ClockTime) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint64(delay)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_base_sink_set_render_delay(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(delay)
}

// SetSync configures sink to synchronize on the clock or not. When sync is
// FALSE, incoming samples will be played as fast as possible. If sync is TRUE,
// the timestamps of the incoming buffers will be used to schedule the exact
// render time of its contents.
//
// The function takes the following parameters:
//
//    - sync: new sync value.
//
func (sink *BaseSink) SetSync(sync bool) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	if sync {
		_arg1 = C.TRUE
	}

	C.gst_base_sink_set_sync(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(sync)
}

// SetThrottleTime: set the time that will be inserted between rendered buffers.
// This can be used to control the maximum buffers per second that the sink will
// render.
//
// The function takes the following parameters:
//
//    - throttle time in nanoseconds.
//
func (sink *BaseSink) SetThrottleTime(throttle uint64) {
	var _arg0 *C.GstBaseSink // out
	var _arg1 C.guint64      // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint64(throttle)

	C.gst_base_sink_set_throttle_time(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(throttle)
}

// SetTsOffset: adjust the synchronisation of sink with offset. A negative value
// will render buffers earlier than their timestamp. A positive value will delay
// rendering. This function can be used to fix playback of badly timestamped
// buffers.
//
// The function takes the following parameters:
//
//    - offset: new offset.
//
func (sink *BaseSink) SetTsOffset(offset gst.ClockTimeDiff) {
	var _arg0 *C.GstBaseSink     // out
	var _arg1 C.GstClockTimeDiff // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.gint64(offset)
	type _ = gst.ClockTimeDiff
	type _ = int64

	C.gst_base_sink_set_ts_offset(_arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(offset)
}

// Wait: this function will wait for preroll to complete and will then block
// until time is reached. It is usually called by subclasses that use their own
// internal synchronisation but want to let some synchronization (like EOS) be
// handled by the base class.
//
// This function should only be called with the PREROLL_LOCK held (like when
// receiving an EOS event in the ::event vmethod or when handling buffers in
// ::render).
//
// The time argument should be the running_time of when the timeout should
// happen and will be adjusted with any latency and offset configured in the
// sink.
//
// The function takes the following parameters:
//
//    - time to be reached.
//
// The function returns the following values:
//
//    - jitter (optional) to be filled with time diff, or NULL.
//    - flowReturn: FlowReturn.
//
func (sink *BaseSink) Wait(time gst.ClockTime) (gst.ClockTimeDiff, gst.FlowReturn) {
	var _arg0 *C.GstBaseSink     // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTimeDiff // in
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint64(time)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_base_sink_wait(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(time)

	var _jitter gst.ClockTimeDiff  // out
	var _flowReturn gst.FlowReturn // out

	_jitter = int64(_arg2)
	type _ = gst.ClockTimeDiff
	type _ = int64
	_flowReturn = gst.FlowReturn(_cret)

	return _jitter, _flowReturn
}

// WaitClock: this function will block until time is reached. It is usually
// called by subclasses that use their own internal synchronisation.
//
// If time is not valid, no synchronisation is done and GST_CLOCK_BADTIME is
// returned. Likewise, if synchronisation is disabled in the element or there is
// no clock, no synchronisation is done and GST_CLOCK_BADTIME is returned.
//
// This function should only be called with the PREROLL_LOCK held, like when
// receiving an EOS event in the BaseSinkClass::event vmethod or when receiving
// a buffer in the BaseSinkClass::render vmethod.
//
// The time argument should be the running_time of when this method should
// return and is not adjusted with any latency or offset configured in the sink.
//
// The function takes the following parameters:
//
//    - time to be reached.
//
// The function returns the following values:
//
//    - jitter (optional) to be filled with time diff, or NULL.
//    - clockReturn: ClockReturn.
//
func (sink *BaseSink) WaitClock(time gst.ClockTime) (gst.ClockTimeDiff, gst.ClockReturn) {
	var _arg0 *C.GstBaseSink     // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTimeDiff // in
	var _cret C.GstClockReturn   // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = C.guint64(time)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_base_sink_wait_clock(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(time)

	var _jitter gst.ClockTimeDiff    // out
	var _clockReturn gst.ClockReturn // out

	_jitter = int64(_arg2)
	type _ = gst.ClockTimeDiff
	type _ = int64
	_clockReturn = gst.ClockReturn(_cret)

	return _jitter, _clockReturn
}

// WaitPreroll: if the BaseSinkClass::render method performs its own
// synchronisation against the clock it must unblock when going from PLAYING to
// the PAUSED state and call this method before continuing to render the
// remaining data.
//
// If the BaseSinkClass::render method can block on something else than the
// clock, it must also be ready to unblock immediately on the
// BaseSinkClass::unlock method and cause the BaseSinkClass::render method to
// immediately call this function. In this case, the subclass must be prepared
// to continue rendering where it left off if this function returns GST_FLOW_OK.
//
// This function will block until a state change to PLAYING happens (in which
// case this function returns GST_FLOW_OK) or the processing must be stopped due
// to a state change to READY or a FLUSH event (in which case this function
// returns GST_FLOW_FLUSHING).
//
// This function should only be called with the PREROLL_LOCK held, like in the
// render function.
//
// The function returns the following values:
//
//    - flowReturn: GST_FLOW_OK if the preroll completed and processing can
//      continue. Any other return value should be returned from the render
//      vmethod.
//
func (sink *BaseSink) WaitPreroll() gst.FlowReturn {
	var _arg0 *C.GstBaseSink  // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_base_sink_wait_preroll(_arg0)
	runtime.KeepAlive(sink)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) activatePull(active bool) bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.activate_pull

	var _arg0 *C.GstBaseSink // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gstbase1_BaseSink_virtual_activate_pull(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) event(event *gst.Event) bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.event

	var _arg0 *C.GstBaseSink // out
	var _arg1 *C.GstEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) fixate(caps *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.fixate

	var _arg0 *C.GstBaseSink // out
	var _arg1 *C.GstCaps     // out
	var _cret *C.GstCaps     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_fixate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(caps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) caps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.get_caps

	var _arg0 *C.GstBaseSink // out
	var _arg1 *C.GstCaps     // out
	var _cret *C.GstCaps     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_get_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function takes the following parameters:
//
//    - buffer
//    - start
//    - end
//
func (sink *BaseSink) times(buffer *gst.Buffer, start, end *gst.ClockTime) {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.get_times

	var _arg0 *C.GstBaseSink  // out
	var _arg1 *C.GstBuffer    // out
	var _arg2 *C.GstClockTime // out
	var _arg3 *C.GstClockTime // out

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.guint64)(unsafe.Pointer(start))
	type _ = *gst.ClockTime
	type _ = *uint64
	_arg3 = (*C.guint64)(unsafe.Pointer(end))
	type _ = *gst.ClockTime
	type _ = *uint64

	C._gotk4_gstbase1_BaseSink_virtual_get_times(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) prepare(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.prepare

	var _arg0 *C.GstBaseSink  // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_prepare(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) prepareList(bufferList *gst.BufferList) gst.FlowReturn {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.prepare_list

	var _arg0 *C.GstBaseSink   // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_prepare_list(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(bufferList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) preroll(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.preroll

	var _arg0 *C.GstBaseSink  // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_preroll(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) proposeAllocation(query *gst.Query) bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.propose_allocation

	var _arg0 *C.GstBaseSink // out
	var _arg1 *C.GstQuery    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_propose_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) query(query *gst.Query) bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.query

	var _arg0 *C.GstBaseSink // out
	var _arg1 *C.GstQuery    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) render(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.render

	var _arg0 *C.GstBaseSink  // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_render(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) renderList(bufferList *gst.BufferList) gst.FlowReturn {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.render_list

	var _arg0 *C.GstBaseSink   // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_render_list(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(bufferList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) setCaps(caps *gst.Caps) bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.set_caps

	var _arg0 *C.GstBaseSink // out
	var _arg1 *C.GstCaps     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (sink *BaseSink) start() bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.start

	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (sink *BaseSink) stop() bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.stop

	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (sink *BaseSink) unlock() bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.unlock

	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_unlock(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (sink *BaseSink) unlockStop() bool {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.unlock_stop

	var _arg0 *C.GstBaseSink // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_unlock_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *BaseSink) waitEvent(event *gst.Event) gst.FlowReturn {
	gclass := (*C.GstBaseSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.wait_event

	var _arg0 *C.GstBaseSink  // out
	var _arg1 *C.GstEvent     // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstbase1_BaseSink_virtual_wait_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(event)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// BaseSinkClass subclasses can override any of the available virtual methods or
// not, as needed. At the minimum, the render method should be overridden to
// output/present buffers.
//
// An instance of this type is always passed by reference.
type BaseSinkClass struct {
	*baseSinkClass
}

// baseSinkClass is the struct that's finalized.
type baseSinkClass struct {
	native *C.GstBaseSinkClass
}

// ParentClass: element parent class.
func (b *BaseSinkClass) ParentClass() *gst.ElementClass {
	valptr := &b.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
