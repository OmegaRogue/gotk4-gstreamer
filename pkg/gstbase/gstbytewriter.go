// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/base/base.h>
import "C"

// ByteWriter provides a byte writer and reader that can write/read different
// integer and floating point types to/from a memory buffer. It provides
// functions for writing/reading signed/unsigned, little/big endian integers of
// 8, 16, 24, 32 and 64 bits and functions for reading little/big endian
// floating points numbers of 32 and 64 bits. It also provides functions to
// write/read NUL-terminated strings in various character encodings.
//
// An instance of this type is always passed by reference.
type ByteWriter struct {
	*byteWriter
}

// byteWriter is the struct that's finalized.
type byteWriter struct {
	native *C.GstByteWriter
}

// Parent: ByteReader parent.
func (b *ByteWriter) Parent() *ByteReader {
	valptr := &b.native.parent
	var _v *ByteReader // out
	_v = (*ByteReader)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AllocSize: allocation size of the data.
func (b *ByteWriter) AllocSize() uint {
	valptr := &b.native.alloc_size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Fixed: if TRUE no reallocations are allowed.
func (b *ByteWriter) Fixed() bool {
	valptr := &b.native.fixed
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Owned: if FALSE no reallocations are allowed and copies of data are returned.
func (b *ByteWriter) Owned() bool {
	valptr := &b.native.owned
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// AllocSize: allocation size of the data.
func (b *ByteWriter) SetAllocSize(allocSize uint) {
	valptr := &b.native.alloc_size
	*valptr = C.guint(allocSize)
}

// Fixed: if TRUE no reallocations are allowed.
func (b *ByteWriter) SetFixed(fixed bool) {
	valptr := &b.native.fixed
	if fixed {
		*valptr = C.TRUE
	}
}

// Owned: if FALSE no reallocations are allowed and copies of data are returned.
func (b *ByteWriter) SetOwned(owned bool) {
	valptr := &b.native.owned
	if owned {
		*valptr = C.TRUE
	}
}

// EnsureFreeSpace checks if enough free space from the current write cursor is
// available and reallocates if necessary.
//
// The function takes the following parameters:
//
//    - size: number of bytes that should be available.
//
// The function returns the following values:
//
//    - ok: TRUE if at least size bytes are still available.
//
func (writer *ByteWriter) EnsureFreeSpace(size uint) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint(size)

	_cret = C.gst_byte_writer_ensure_free_space(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Fill writes size bytes containing value to writer.
//
// The function takes the following parameters:
//
//    - value: value to be written.
//    - size: number of bytes to be written.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) Fill(value byte, size uint) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint8         // out
	var _arg2 C.guint          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint8(value)
	_arg2 = C.guint(size)

	_cret = C.gst_byte_writer_fill(_arg0, _arg1, _arg2)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(value)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FreeAndGetBuffer frees writer and all memory allocated by it except the
// current data, which is returned as Buffer.
//
// Free-function: gst_buffer_unref.
//
// The function returns the following values:
//
//    - buffer: current data as buffer. gst_buffer_unref() after usage.
//
func (writer *ByteWriter) FreeAndGetBuffer() *gst.Buffer {
	var _arg0 *C.GstByteWriter // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(writer)), nil)

	_cret = C.gst_byte_writer_free_and_get_buffer(_arg0)
	runtime.KeepAlive(writer)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// FreeAndGetData frees writer and all memory allocated by it except the current
// data, which is returned.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//    - guint8: current data. g_free() after usage.
//
func (writer *ByteWriter) FreeAndGetData() *byte {
	var _arg0 *C.GstByteWriter // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(writer)), nil)

	_cret = C.gst_byte_writer_free_and_get_data(_arg0)
	runtime.KeepAlive(writer)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// Remaining returns the remaining size of data that can still be written. If -1
// is returned the remaining size is only limited by system resources.
//
// The function returns the following values:
//
//    - guint: remaining size of data that can still be written.
//
func (writer *ByteWriter) Remaining() uint {
	var _arg0 *C.GstByteWriter // out
	var _cret C.guint          // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))

	_cret = C.gst_byte_writer_get_remaining(_arg0)
	runtime.KeepAlive(writer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Init initializes writer to an empty instance.
func (writer *ByteWriter) Init() {
	var _arg0 *C.GstByteWriter // out

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))

	C.gst_byte_writer_init(_arg0)
	runtime.KeepAlive(writer)
}

// InitWithData initializes writer with the given memory area. If initialized is
// TRUE it is possible to read size bytes from the ByteWriter from the
// beginning.
//
// The function takes the following parameters:
//
//    - data: memory area for writing.
//    - initialized: if TRUE the complete data can be read from the beginning.
//
func (writer *ByteWriter) InitWithData(data []byte, initialized bool) {
	var _arg0 *C.GstByteWriter // out
	var _arg1 *C.guint8        // out
	var _arg2 C.guint
	var _arg3 C.gboolean // out

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	if initialized {
		_arg3 = C.TRUE
	}

	C.gst_byte_writer_init_with_data(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(data)
	runtime.KeepAlive(initialized)
}

// InitWithSize initializes writer with the given initial data size.
//
// The function takes the following parameters:
//
//    - size: initial size of data.
//    - fixed: if TRUE the data can't be reallocated.
//
func (writer *ByteWriter) InitWithSize(size uint, fixed bool) {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint          // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint(size)
	if fixed {
		_arg2 = C.TRUE
	}

	C.gst_byte_writer_init_with_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(size)
	runtime.KeepAlive(fixed)
}

// PutBuffer writes size bytes of data to writer.
//
// The function takes the following parameters:
//
//    - buffer: source Buffer.
//    - offset to copy from.
//    - size: total size to copy. If -1, all data is copied.
//
// The function returns the following values:
//
//    - ok: TRUE if the data could be written.
//
func (writer *ByteWriter) PutBuffer(buffer *gst.Buffer, offset uint, size int) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 *C.GstBuffer     // out
	var _arg2 C.gsize          // out
	var _arg3 C.gssize         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.gsize(offset)
	_arg3 = C.gssize(size)

	_cret = C.gst_byte_writer_put_buffer(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutData writes size bytes of data to writer.
//
// The function takes the following parameters:
//
//    - data: data to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutData(data []byte) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 *C.guint8        // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_byte_writer_put_data(_arg0, _arg1, _arg2)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutFloat32Be writes a big endian 32 bit float to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutFloat32Be(val float32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gfloat         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gfloat(val)

	_cret = C.gst_byte_writer_put_float32_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutFloat32LE writes a little endian 32 bit float to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutFloat32LE(val float32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gfloat         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gfloat(val)

	_cret = C.gst_byte_writer_put_float32_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutFloat64Be writes a big endian 64 bit float to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutFloat64Be(val float64) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gdouble        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gdouble(val)

	_cret = C.gst_byte_writer_put_float64_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutFloat64LE writes a little endian 64 bit float to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutFloat64LE(val float64) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gdouble        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gdouble(val)

	_cret = C.gst_byte_writer_put_float64_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt16Be writes a signed big endian 16 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt16Be(val int16) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint16         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint16(val)

	_cret = C.gst_byte_writer_put_int16_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt16LE writes a signed little endian 16 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt16LE(val int16) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint16         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint16(val)

	_cret = C.gst_byte_writer_put_int16_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt24Be writes a signed big endian 24 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt24Be(val int32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint32         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint32(val)

	_cret = C.gst_byte_writer_put_int24_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt24LE writes a signed little endian 24 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt24LE(val int32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint32         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint32(val)

	_cret = C.gst_byte_writer_put_int24_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt32Be writes a signed big endian 32 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt32Be(val int32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint32         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint32(val)

	_cret = C.gst_byte_writer_put_int32_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt32LE writes a signed little endian 32 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt32LE(val int32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint32         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint32(val)

	_cret = C.gst_byte_writer_put_int32_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt64Be writes a signed big endian 64 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt64Be(val int64) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint64         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint64(val)

	_cret = C.gst_byte_writer_put_int64_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt64LE writes a signed little endian 64 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt64LE(val int64) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint64         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint64(val)

	_cret = C.gst_byte_writer_put_int64_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutInt8 writes a signed 8 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutInt8(val int8) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.gint8          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.gint8(val)

	_cret = C.gst_byte_writer_put_int8(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutStringUTF16 writes a NUL-terminated UTF16 string to writer (including the
// terminator).
//
// The function takes the following parameters:
//
//    - data: UTF16 string to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutStringUTF16(data []uint16) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	{
		var zero uint16
		data = append(data, zero)
		_arg1 = (*C.guint16)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_byte_writer_put_string_utf16(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutStringUTF32 writes a NUL-terminated UTF32 string to writer (including the
// terminator).
//
// The function takes the following parameters:
//
//    - data: UTF32 string to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutStringUTF32(data []uint32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	{
		var zero uint32
		data = append(data, zero)
		_arg1 = (*C.guint32)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_byte_writer_put_string_utf32(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutStringUTF8 writes a NUL-terminated UTF8 string to writer (including the
// terminator).
//
// The function takes the following parameters:
//
//    - data: UTF8 string to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutStringUTF8(data string) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(data)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_byte_writer_put_string_utf8(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint16Be writes a unsigned big endian 16 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint16Be(val uint16) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint16        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint16(val)

	_cret = C.gst_byte_writer_put_uint16_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint16LE writes a unsigned little endian 16 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint16LE(val uint16) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint16        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint16(val)

	_cret = C.gst_byte_writer_put_uint16_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint24Be writes a unsigned big endian 24 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint24Be(val uint32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint32(val)

	_cret = C.gst_byte_writer_put_uint24_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint24LE writes a unsigned little endian 24 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint24LE(val uint32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint32(val)

	_cret = C.gst_byte_writer_put_uint24_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint32Be writes a unsigned big endian 32 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint32Be(val uint32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint32(val)

	_cret = C.gst_byte_writer_put_uint32_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint32LE writes a unsigned little endian 32 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint32LE(val uint32) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint32(val)

	_cret = C.gst_byte_writer_put_uint32_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint64Be writes a unsigned big endian 64 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint64Be(val uint64) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint64        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint64(val)

	_cret = C.gst_byte_writer_put_uint64_be(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint64LE writes a unsigned little endian 64 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint64LE(val uint64) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint64        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint64(val)

	_cret = C.gst_byte_writer_put_uint64_le(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PutUint8 writes a unsigned 8 bit integer to writer.
//
// The function takes the following parameters:
//
//    - val: value to write.
//
// The function returns the following values:
//
//    - ok: TRUE if the value could be written.
//
func (writer *ByteWriter) PutUint8(val byte) bool {
	var _arg0 *C.GstByteWriter // out
	var _arg1 C.guint8         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))
	_arg1 = C.guint8(val)

	_cret = C.gst_byte_writer_put_uint8(_arg0, _arg1)
	runtime.KeepAlive(writer)
	runtime.KeepAlive(val)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reset resets writer and frees the data if it's owned by writer.
func (writer *ByteWriter) Reset() {
	var _arg0 *C.GstByteWriter // out

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))

	C.gst_byte_writer_reset(_arg0)
	runtime.KeepAlive(writer)
}

// ResetAndGetBuffer resets writer and returns the current data as buffer.
//
// Free-function: gst_buffer_unref.
//
// The function returns the following values:
//
//    - buffer: current data as buffer. gst_buffer_unref() after usage.
//
func (writer *ByteWriter) ResetAndGetBuffer() *gst.Buffer {
	var _arg0 *C.GstByteWriter // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstByteWriter)(gextras.StructNative(unsafe.Pointer(writer)))

	_cret = C.gst_byte_writer_reset_and_get_buffer(_arg0)
	runtime.KeepAlive(writer)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}
