// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
// extern gboolean _gotk4_gstbase1_BaseParseClass_stop(GstBaseParse*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_start(GstBaseParse*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_src_query(GstBaseParse*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_src_event(GstBaseParse*, GstEvent*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_sink_query(GstBaseParse*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_sink_event(GstBaseParse*, GstEvent*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_set_sink_caps(GstBaseParse*, GstCaps*);
// extern gboolean _gotk4_gstbase1_BaseParseClass_convert(GstBaseParse*, GstFormat, gint64, GstFormat, gint64*);
// extern GstFlowReturn _gotk4_gstbase1_BaseParseClass_pre_push_frame(GstBaseParse*, GstBaseParseFrame*);
// extern GstFlowReturn _gotk4_gstbase1_BaseParseClass_handle_frame(GstBaseParse*, GstBaseParseFrame*, gint*);
// extern GstFlowReturn _gotk4_gstbase1_BaseParseClass_detect(GstBaseParse*, GstBuffer*);
// extern GstCaps* _gotk4_gstbase1_BaseParseClass_get_sink_caps(GstBaseParse*, GstCaps*);
// GstCaps* _gotk4_gstbase1_BaseParse_virtual_get_sink_caps(void* fnptr, GstBaseParse* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstBaseParse*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseParse_virtual_detect(void* fnptr, GstBaseParse* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstBaseParse*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseParse_virtual_handle_frame(void* fnptr, GstBaseParse* arg0, GstBaseParseFrame* arg1, gint* arg2) {
//   return ((GstFlowReturn (*)(GstBaseParse*, GstBaseParseFrame*, gint*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gstbase1_BaseParse_virtual_pre_push_frame(void* fnptr, GstBaseParse* arg0, GstBaseParseFrame* arg1) {
//   return ((GstFlowReturn (*)(GstBaseParse*, GstBaseParseFrame*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_convert(void* fnptr, GstBaseParse* arg0, GstFormat arg1, gint64 arg2, GstFormat arg3, gint64* arg4) {
//   return ((gboolean (*)(GstBaseParse*, GstFormat, gint64, GstFormat, gint64*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_set_sink_caps(void* fnptr, GstBaseParse* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstBaseParse*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_sink_event(void* fnptr, GstBaseParse* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstBaseParse*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_sink_query(void* fnptr, GstBaseParse* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseParse*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_src_event(void* fnptr, GstBaseParse* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstBaseParse*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_src_query(void* fnptr, GstBaseParse* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseParse*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_start(void* fnptr, GstBaseParse* arg0) {
//   return ((gboolean (*)(GstBaseParse*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseParse_virtual_stop(void* fnptr, GstBaseParse* arg0) {
//   return ((gboolean (*)(GstBaseParse*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeBaseParse      = coreglib.Type(C.gst_base_parse_get_type())
	GTypeBaseParseFrame = coreglib.Type(C.gst_base_parse_frame_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBaseParse, F: marshalBaseParse},
		coreglib.TypeMarshaler{T: GTypeBaseParseFrame, F: marshalBaseParseFrame},
	})
}

const BASE_PARSE_FLAG_DRAINING = 2
const BASE_PARSE_FLAG_LOST_SYNC = 1

// BaseParseFrameFlags flags to be used in a BaseParseFrame.
type BaseParseFrameFlags C.guint

const (
	// BaseParseFrameFlagNone: no flag.
	BaseParseFrameFlagNone BaseParseFrameFlags = 0b0
	// BaseParseFrameFlagNewFrame: set by baseclass if current frame is passed
	// for processing to the subclass for the first time (and not set on
	// subsequent calls with same data).
	BaseParseFrameFlagNewFrame BaseParseFrameFlags = 0b1
	// BaseParseFrameFlagNoFrame: set to indicate this buffer should not be
	// counted as frame, e.g. if this frame is dependent on a previous one. As
	// it is not counted as a frame, bitrate increases but frame to time
	// conversions are maintained.
	BaseParseFrameFlagNoFrame BaseParseFrameFlags = 0b10
	// BaseParseFrameFlagClip: pre_push_frame can set this to indicate that
	// regular segment clipping can still be performed (as opposed to any custom
	// one having been done).
	BaseParseFrameFlagClip BaseParseFrameFlags = 0b100
	// BaseParseFrameFlagDrop indicates to finish_frame that the the frame
	// should be dropped (and might be handled internally by subclass).
	BaseParseFrameFlagDrop BaseParseFrameFlags = 0b1000
	// BaseParseFrameFlagQueue indicates to finish_frame that the the frame
	// should be queued for now and processed fully later when the first
	// non-queued frame is finished.
	BaseParseFrameFlagQueue BaseParseFrameFlags = 0b10000
)

// String returns the names in string for BaseParseFrameFlags.
func (b BaseParseFrameFlags) String() string {
	if b == 0 {
		return "BaseParseFrameFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(145)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BaseParseFrameFlagNone:
			builder.WriteString("None|")
		case BaseParseFrameFlagNewFrame:
			builder.WriteString("NewFrame|")
		case BaseParseFrameFlagNoFrame:
			builder.WriteString("NoFrame|")
		case BaseParseFrameFlagClip:
			builder.WriteString("Clip|")
		case BaseParseFrameFlagDrop:
			builder.WriteString("Drop|")
		case BaseParseFrameFlagQueue:
			builder.WriteString("Queue|")
		default:
			builder.WriteString(fmt.Sprintf("BaseParseFrameFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BaseParseFrameFlags) Has(other BaseParseFrameFlags) bool {
	return (b & other) == other
}

// BaseParseOverrides contains methods that are overridable.
type BaseParseOverrides struct {
	// The function takes the following parameters:
	//
	//    - srcFormat
	//    - srcValue
	//    - destFormat
	//    - destValue
	//
	// The function returns the following values:
	//
	Convert func(srcFormat gst.Format, srcValue int64, destFormat gst.Format, destValue *int64) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Detect func(buffer *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkCaps func(filter *gst.Caps) *gst.Caps
	// HandleFrame parses the input data into valid frames as defined by
	// subclass which should be passed to gst_base_parse_finish_frame(). The
	// frame's input buffer is guaranteed writable, whereas the input frame
	// ownership is held by caller (so subclass should make a copy if it needs
	// to hang on). Input buffer (data) is provided by baseclass with as much
	// metadata set as possible by baseclass according to upstream information
	// and/or subclass settings, though subclass may still set buffer timestamp
	// and duration if desired.
	//
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	//    - skipsize
	//    - flowReturn
	//
	HandleFrame func(frame *BaseParseFrame) (int, gst.FlowReturn)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	PrePushFrame func(frame *BaseParseFrame) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetSinkCaps func(caps *gst.Caps) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkQuery func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcQuery func(query *gst.Query) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
}

func defaultBaseParseOverrides(v *BaseParse) BaseParseOverrides {
	return BaseParseOverrides{
		Convert:      v.convert,
		Detect:       v.detect,
		SinkCaps:     v.sinkCaps,
		HandleFrame:  v.handleFrame,
		PrePushFrame: v.prePushFrame,
		SetSinkCaps:  v.setSinkCaps,
		SinkEvent:    v.sinkEvent,
		SinkQuery:    v.sinkQuery,
		SrcEvent:     v.srcEvent,
		SrcQuery:     v.srcQuery,
		Start:        v.start,
		Stop:         v.stop,
	}
}

// BaseParse: this base class is for parser elements that process data and
// splits it into separate audio/video/whatever frames.
//
// It provides for:
//
//    * provides one sink pad and one source pad
//    * handles state changes
//    * can operate in pull mode or push mode
//    * handles seeking in both modes
//    * handles events (SEGMENT/EOS/FLUSH)
//    * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
//    * handles flushing
//
// The purpose of this base class is to provide the basic functionality of a
// parser and share a lot of rather complex code.
//
// Description of the parsing mechanism:
//
// Set-up phase
//
//    * BaseParse calls BaseParseClass::start to inform subclass
//      that data processing is about to start now.
//
//    * BaseParse class calls BaseParseClass::set_sink_caps to
//      inform the subclass about incoming sinkpad caps. Subclass could
//      already set the srcpad caps accordingly, but this might be delayed
//      until calling gst_base_parse_finish_frame() with a non-queued frame.
//
//    * At least at this point subclass needs to tell the BaseParse class
//      how big data chunks it wants to receive (minimum frame size ). It can
//      do this with gst_base_parse_set_min_frame_size().
//
//    * BaseParse class sets up appropriate data passing mode (pull/push)
//      and starts to process the data.
//
// Parsing phase
//
//    * BaseParse gathers at least min_frame_size bytes of data either
//      by pulling it from upstream or collecting buffers in an internal
//      Adapter.
//
//    * A buffer of (at least) min_frame_size bytes is passed to subclass
//      with BaseParseClass::handle_frame. Subclass checks the contents
//      and can optionally return T_FLOW_OK along with an amount of data
//      to be skipped to find a valid frame (which will result in a
//      subsequent DISCONT).  If, otherwise, the buffer does not hold a
//      complete frame, BaseParseClass::handle_frame can merely return
//      and will be called again when additional data is available.  In push
//      mode this amounts to an additional input buffer (thus minimal
//      additional latency), in pull mode this amounts to some arbitrary
//      reasonable buffer size increase.
//
//      Of course, gst_base_parse_set_min_frame_size() could also be used if
//      a very specific known amount of additional data is required.  If,
//      however, the buffer holds a complete valid frame, it can pass the
//      size of this frame to gst_base_parse_finish_frame().
//
//      If acting as a converter, it can also merely indicate consumed input
//      data while simultaneously providing custom output data.  Note that
//      baseclass performs some processing (such as tracking overall consumed
//      data rate versus duration) for each finished frame, but other state
//      is only updated upon each call to BaseParseClass::handle_frame
//      (such as tracking upstream input timestamp).
//
//      Subclass is also responsible for setting the buffer metadata
//      (e.g. buffer timestamp and duration, or keyframe if applicable).
//      (although the latter can also be done by BaseParse if it is
//      appropriately configured, see below).  Frame is provided with
//      timestamp derived from upstream (as much as generally possible),
//      duration obtained from configuration (see below), and offset
//      if meaningful (in pull mode).
//
//      Note that BaseParseClass::handle_frame might receive any small
//      amount of input data when leftover data is being drained (e.g. at
//      EOS).
//
//    * As part of finish frame processing, just prior to actually pushing
//      the buffer in question, it is passed to
//      BaseParseClass::pre_push_frame which gives subclass yet one last
//      chance to examine buffer metadata, or to send some custom (tag)
//      events, or to perform custom (segment) filtering.
//
//    * During the parsing process BaseParseClass will handle both srcpad
//      and sinkpad events. They will be passed to subclass if
//      BaseParseClass::sink_event or BaseParseClass::src_event
//      implementations have been provided.
//
//
// Shutdown phase
//
// * BaseParse class calls BaseParseClass::stop to inform the subclass that data
// parsing will be stopped.
//
// Subclass is responsible for providing pad template caps for source and sink
// pads. The pads need to be named "sink" and "src". It also needs to set the
// fixed caps on srcpad, when the format is ensured (e.g. when base class calls
// subclass' BaseParseClass::set_sink_caps function).
//
// This base class uses GST_FORMAT_DEFAULT as a meaning of frames. So, subclass
// conversion routine needs to know that conversion from GST_FORMAT_TIME to
// GST_FORMAT_DEFAULT must return the frame number that can be found from the
// given byte position.
//
// BaseParse uses subclasses conversion methods also for seeking (or otherwise
// uses its own default one, see also below).
//
// Subclass start and stop functions will be called to inform the beginning and
// end of data processing.
//
// Things that subclass need to take care of:
//
// * Provide pad templates * Fixate the source pad caps when appropriate *
// Inform base class how big data chunks should be retrieved. This is done with
// gst_base_parse_set_min_frame_size() function. * Examine data chunks passed to
// subclass with BaseParseClass::handle_frame and pass proper frame(s) to
// gst_base_parse_finish_frame(), and setting src pad caps and timestamps on
// frame. * Provide conversion functions * Update the duration information with
// gst_base_parse_set_duration() * Optionally passthrough using
// gst_base_parse_set_passthrough() * Configure various baseparse parameters
// using gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable() and
// gst_base_parse_set_frame_rate().
//
// * In particular, if subclass is unable to determine a duration, but parsing
// (or specs) yields a frames per seconds rate, then this can be provided to
// BaseParse to enable it to cater for buffer time metadata (which will be taken
// from upstream as much as possible). Internally keeping track of frame
// durations and respective sizes that have been pushed provides BaseParse with
// an estimated bitrate. A default BaseParseClass::convert (used if not
// overridden) will then use these rates to perform obvious conversions. These
// rates are also used to update (estimated) duration at regular frame
// intervals.
type BaseParse struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*BaseParse)(nil)
)

// BaseParser describes types inherited from class BaseParse.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type BaseParser interface {
	coreglib.Objector
	baseBaseParse() *BaseParse
}

var _ BaseParser = (*BaseParse)(nil)

func init() {
	coreglib.RegisterClassInfo[*BaseParse, *BaseParseClass, BaseParseOverrides](
		GTypeBaseParse,
		initBaseParseClass,
		wrapBaseParse,
		defaultBaseParseOverrides,
	)
}

func initBaseParseClass(gclass unsafe.Pointer, overrides BaseParseOverrides, classInitFunc func(*BaseParseClass)) {
	pclass := (*C.GstBaseParseClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBaseParse))))

	if overrides.Convert != nil {
		pclass.convert = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_convert)
	}

	if overrides.Detect != nil {
		pclass.detect = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_detect)
	}

	if overrides.SinkCaps != nil {
		pclass.get_sink_caps = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_get_sink_caps)
	}

	if overrides.HandleFrame != nil {
		pclass.handle_frame = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_handle_frame)
	}

	if overrides.PrePushFrame != nil {
		pclass.pre_push_frame = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_pre_push_frame)
	}

	if overrides.SetSinkCaps != nil {
		pclass.set_sink_caps = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_set_sink_caps)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_sink_event)
	}

	if overrides.SinkQuery != nil {
		pclass.sink_query = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_sink_query)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_src_event)
	}

	if overrides.SrcQuery != nil {
		pclass.src_query = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_src_query)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstbase1_BaseParseClass_stop)
	}

	if classInitFunc != nil {
		class := (*BaseParseClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBaseParse(obj *coreglib.Object) *BaseParse {
	return &BaseParse{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalBaseParse(p uintptr) (interface{}, error) {
	return wrapBaseParse(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (parse *BaseParse) baseBaseParse() *BaseParse {
	return parse
}

// BaseBaseParse returns the underlying base object.
func BaseBaseParse(obj BaseParser) *BaseParse {
	return obj.baseBaseParse()
}

// AddIndexEntry adds an entry to the index associating offset to ts. It is
// recommended to only add keyframe entries. force allows to bypass checks, such
// as whether the stream is (upstream) seekable, another entry is already
// "close" to the new entry, etc.
//
// The function takes the following parameters:
//
//    - offset of entry.
//    - ts: timestamp associated with offset.
//    - key: whether entry refers to keyframe.
//    - force: add entry disregarding sanity checks.
//
// The function returns the following values:
//
//    - ok indicating whether entry was added.
//
func (parse *BaseParse) AddIndexEntry(offset uint64, ts gst.ClockTime, key, force bool) bool {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.guint64       // out
	var _arg2 C.GstClockTime  // out
	var _arg3 C.gboolean      // out
	var _arg4 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint64(ts)
	type _ = gst.ClockTime
	type _ = uint64
	if key {
		_arg3 = C.TRUE
	}
	if force {
		_arg4 = C.TRUE
	}

	_cret = C.gst_base_parse_add_index_entry(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(ts)
	runtime.KeepAlive(key)
	runtime.KeepAlive(force)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ConvertDefault: default implementation of BaseParseClass::convert.
//
// The function takes the following parameters:
//
//    - srcFormat describing the source format.
//    - srcValue: source value to be converted.
//    - destFormat defining the converted format.
//
// The function returns the following values:
//
//    - destValue: pointer where the conversion result will be put.
//    - ok: TRUE if conversion was successful.
//
func (parse *BaseParse) ConvertDefault(srcFormat gst.Format, srcValue int64, destFormat gst.Format) (int64, bool) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.GstFormat     // out
	var _arg2 C.gint64        // out
	var _arg3 C.GstFormat     // out
	var _arg4 C.gint64        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcValue)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_base_parse_convert_default(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcValue)
	runtime.KeepAlive(destFormat)

	var _destValue int64 // out
	var _ok bool         // out

	_destValue = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destValue, _ok
}

// Drain drains the adapter until it is empty. It decreases the min_frame_size
// to match the current adapter size and calls chain method until the adapter is
// emptied or chain returns with error.
func (parse *BaseParse) Drain() {
	var _arg0 *C.GstBaseParse // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))

	C.gst_base_parse_drain(_arg0)
	runtime.KeepAlive(parse)
}

// FinishFrame collects parsed data and pushes this downstream. Source pad caps
// must be set when this is called.
//
// If frame's out_buffer is set, that will be used as subsequent frame data.
// Otherwise, size samples will be taken from the input and used for output, and
// the output's metadata (timestamps etc) will be taken as (optionally) set by
// the subclass on frame's (input) buffer (which is otherwise ignored for any
// but the above purpose/information).
//
// Note that the latter buffer is invalidated by this call, whereas the caller
// retains ownership of frame.
//
// The function takes the following parameters:
//
//    - frame: BaseParseFrame.
//    - size: consumed input data represented by frame.
//
// The function returns the following values:
//
//    - flowReturn that should be escalated to caller (of caller).
//
func (parse *BaseParse) FinishFrame(frame *BaseParseFrame, size int) gst.FlowReturn {
	var _arg0 *C.GstBaseParse      // out
	var _arg1 *C.GstBaseParseFrame // out
	var _arg2 C.gint               // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstBaseParseFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = C.gint(size)

	_cret = C.gst_base_parse_finish_frame(_arg0, _arg1, _arg2)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(size)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushFrame pushes the frame's buffer downstream, sends any pending events and
// does some timestamp and segment handling. Takes ownership of frame's buffer,
// though caller retains ownership of frame.
//
// This must be called with sinkpad STREAM_LOCK held.
//
// The function takes the following parameters:
//
//    - frame: BaseParseFrame.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (parse *BaseParse) PushFrame(frame *BaseParseFrame) gst.FlowReturn {
	var _arg0 *C.GstBaseParse      // out
	var _arg1 *C.GstBaseParseFrame // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstBaseParseFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_base_parse_push_frame(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetAverageBitrate: optionally sets the average bitrate detected in media (if
// non-zero), e.g. based on metadata, as it will be posted to the application.
//
// By default, announced average bitrate is estimated. The average bitrate is
// used to estimate the total duration of the stream and to estimate a seek
// position, if there's no index and the format is syncable (see
// gst_base_parse_set_syncable()).
//
// The function takes the following parameters:
//
//    - bitrate: average bitrate in bits/second.
//
func (parse *BaseParse) SetAverageBitrate(bitrate uint) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.guint(bitrate)

	C.gst_base_parse_set_average_bitrate(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(bitrate)
}

// SetDuration sets the duration of the currently playing media. Subclass can
// use this when it is able to determine duration and/or notices a change in the
// media duration. Alternatively, if interval is non-zero (default), then stream
// duration is determined based on estimated bitrate, and updated every interval
// frames.
//
// The function takes the following parameters:
//
//    - fmt: Format.
//    - duration value.
//    - interval: how often to update the duration estimate based on bitrate, or
//      0.
//
func (parse *BaseParse) SetDuration(fmt gst.Format, duration int64, interval int) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.GstFormat     // out
	var _arg2 C.gint64        // out
	var _arg3 C.gint          // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.GstFormat(fmt)
	_arg2 = C.gint64(duration)
	_arg3 = C.gint(interval)

	C.gst_base_parse_set_duration(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(duration)
	runtime.KeepAlive(interval)
}

// SetFrameRate: if frames per second is configured, parser can take care of
// buffer duration and timestamping. When performing segment clipping, or
// seeking to a specific location, a corresponding decoder might need an initial
// lead_in and a following lead_out number of frames to ensure the desired
// segment is entirely filled upon decoding.
//
// The function takes the following parameters:
//
//    - fpsNum frames per second (numerator).
//    - fpsDen frames per second (denominator).
//    - leadIn frames needed before a segment for subsequent decode.
//    - leadOut frames needed after a segment.
//
func (parse *BaseParse) SetFrameRate(fpsNum, fpsDen, leadIn, leadOut uint) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out
	var _arg3 C.guint         // out
	var _arg4 C.guint         // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.guint(fpsNum)
	_arg2 = C.guint(fpsDen)
	_arg3 = C.guint(leadIn)
	_arg4 = C.guint(leadOut)

	C.gst_base_parse_set_frame_rate(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(fpsNum)
	runtime.KeepAlive(fpsDen)
	runtime.KeepAlive(leadIn)
	runtime.KeepAlive(leadOut)
}

// SetHasTimingInfo: set if frames carry timing information which the subclass
// can (generally) parse and provide. In particular, intrinsic (rather than
// estimated) time can be obtained following a seek.
//
// The function takes the following parameters:
//
//    - hasTiming: whether frames carry timing information.
//
func (parse *BaseParse) SetHasTimingInfo(hasTiming bool) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	if hasTiming {
		_arg1 = C.TRUE
	}

	C.gst_base_parse_set_has_timing_info(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(hasTiming)
}

// SetInferTs: by default, the base class might try to infer PTS from DTS and
// vice versa. While this is generally correct for audio data, it may not be
// otherwise. Sub-classes implementing such formats should disable timestamp
// inferring.
//
// The function takes the following parameters:
//
//    - inferTs: TRUE if parser should infer DTS/PTS from each other.
//
func (parse *BaseParse) SetInferTs(inferTs bool) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	if inferTs {
		_arg1 = C.TRUE
	}

	C.gst_base_parse_set_infer_ts(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(inferTs)
}

// SetLatency sets the minimum and maximum (which may likely be equal) latency
// introduced by the parsing process. If there is such a latency, which depends
// on the particular parsing of the format, it typically corresponds to 1 frame
// duration.
//
// The function takes the following parameters:
//
//    - minLatency: minimum parse latency.
//    - maxLatency: maximum parse latency.
//
func (parse *BaseParse) SetLatency(minLatency, maxLatency gst.ClockTime) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.GstClockTime  // out
	var _arg2 C.GstClockTime  // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.guint64(minLatency)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(maxLatency)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_base_parse_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(minLatency)
	runtime.KeepAlive(maxLatency)
}

// SetMinFrameSize subclass can use this function to tell the base class that it
// needs to be given buffers of at least min_size bytes.
//
// The function takes the following parameters:
//
//    - minSize: minimum size in bytes of the data that this base class should
//      give to subclass.
//
func (parse *BaseParse) SetMinFrameSize(minSize uint) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.guint(minSize)

	C.gst_base_parse_set_min_frame_size(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(minSize)
}

// SetPassthrough: set if the nature of the format or configuration does not
// allow (much) parsing, and the parser should operate in passthrough mode
// (which only applies when operating in push mode). That is, incoming buffers
// are pushed through unmodified, i.e. no BaseParseClass::handle_frame will be
// invoked, but BaseParseClass::pre_push_frame will still be invoked, so
// subclass can perform as much or as little is appropriate for passthrough
// semantics in BaseParseClass::pre_push_frame.
//
// The function takes the following parameters:
//
//    - passthrough: TRUE if parser should run in passthrough mode.
//
func (parse *BaseParse) SetPassthrough(passthrough bool) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	if passthrough {
		_arg1 = C.TRUE
	}

	C.gst_base_parse_set_passthrough(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(passthrough)
}

// SetPtsInterpolation: by default, the base class will guess PTS timestamps
// using a simple interpolation (previous timestamp + duration), which is
// incorrect for data streams with reordering, where PTS can go backward.
// Sub-classes implementing such formats should disable PTS interpolation.
//
// The function takes the following parameters:
//
//    - ptsInterpolate: TRUE if parser should interpolate PTS timestamps.
//
func (parse *BaseParse) SetPtsInterpolation(ptsInterpolate bool) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	if ptsInterpolate {
		_arg1 = C.TRUE
	}

	C.gst_base_parse_set_pts_interpolation(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(ptsInterpolate)
}

// SetSyncable: set if frame starts can be identified. This is set by default
// and determines whether seeking based on bitrate averages is possible for a
// format/stream.
//
// The function takes the following parameters:
//
//    - syncable: set if frame starts can be identified.
//
func (parse *BaseParse) SetSyncable(syncable bool) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	if syncable {
		_arg1 = C.TRUE
	}

	C.gst_base_parse_set_syncable(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(syncable)
}

// SetTsAtOffset: this function should only be called from a handle_frame
// implementation.
//
// BaseParse creates initial timestamps for frames by using the last timestamp
// seen in the stream before the frame starts. In certain cases, the correct
// timestamps will occur in the stream after the start of the frame, but before
// the start of the actual picture data. This function can be used to set the
// timestamps based on the offset into the frame data that the picture starts.
//
// The function takes the following parameters:
//
//    - offset into current buffer.
//
func (parse *BaseParse) SetTsAtOffset(offset uint) {
	var _arg0 *C.GstBaseParse // out
	var _arg1 C.gsize         // out

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.gsize(offset)

	C.gst_base_parse_set_ts_at_offset(_arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(offset)
}

// The function takes the following parameters:
//
//    - srcFormat
//    - srcValue
//    - destFormat
//    - destValue
//
// The function returns the following values:
//
func (parse *BaseParse) convert(srcFormat gst.Format, srcValue int64, destFormat gst.Format, destValue *int64) bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.convert

	var _arg0 *C.GstBaseParse // out
	var _arg1 C.GstFormat     // out
	var _arg2 C.gint64        // out
	var _arg3 C.GstFormat     // out
	var _arg4 *C.gint64       // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcValue)
	_arg3 = C.GstFormat(destFormat)
	_arg4 = (*C.gint64)(unsafe.Pointer(destValue))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_convert(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcValue)
	runtime.KeepAlive(destFormat)
	runtime.KeepAlive(destValue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) detect(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.detect

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_detect(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) sinkCaps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.get_sink_caps

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstCaps      // out
	var _cret *C.GstCaps      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_get_sink_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// handleFrame parses the input data into valid frames as defined by subclass
// which should be passed to gst_base_parse_finish_frame(). The frame's input
// buffer is guaranteed writable, whereas the input frame ownership is held by
// caller (so subclass should make a copy if it needs to hang on). Input buffer
// (data) is provided by baseclass with as much metadata set as possible by
// baseclass according to upstream information and/or subclass settings, though
// subclass may still set buffer timestamp and duration if desired.
//
// The function takes the following parameters:
//
// The function returns the following values:
//
//    - skipsize
//    - flowReturn
//
func (parse *BaseParse) handleFrame(frame *BaseParseFrame) (int, gst.FlowReturn) {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.handle_frame

	var _arg0 *C.GstBaseParse      // out
	var _arg1 *C.GstBaseParseFrame // out
	var _arg2 C.gint               // in
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstBaseParseFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_handle_frame(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(frame)

	var _skipsize int              // out
	var _flowReturn gst.FlowReturn // out

	_skipsize = int(_arg2)
	_flowReturn = gst.FlowReturn(_cret)

	return _skipsize, _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) prePushFrame(frame *BaseParseFrame) gst.FlowReturn {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.pre_push_frame

	var _arg0 *C.GstBaseParse      // out
	var _arg1 *C.GstBaseParseFrame // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstBaseParseFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_pre_push_frame(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) setSinkCaps(caps *gst.Caps) bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.set_sink_caps

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstCaps      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_set_sink_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.sink_event

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstEvent     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) sinkQuery(query *gst.Query) bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.sink_query

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstQuery     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_sink_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.src_event

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstEvent     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (parse *BaseParse) srcQuery(query *gst.Query) bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.src_query

	var _arg0 *C.GstBaseParse // out
	var _arg1 *C.GstQuery     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_src_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parse)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (parse *BaseParse) start() bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.start

	var _arg0 *C.GstBaseParse // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(parse)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (parse *BaseParse) stop() bool {
	gclass := (*C.GstBaseParseClass)(coreglib.PeekParentClass(parse))
	fnarg := gclass.stop

	var _arg0 *C.GstBaseParse // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstBaseParse)(unsafe.Pointer(coreglib.InternObject(parse).Native()))

	_cret = C._gotk4_gstbase1_BaseParse_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(parse)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BaseParseClass subclasses can override any of the available virtual methods
// or not, as needed. At minimum handle_frame needs to be overridden.
//
// An instance of this type is always passed by reference.
type BaseParseClass struct {
	*baseParseClass
}

// baseParseClass is the struct that's finalized.
type baseParseClass struct {
	native *C.GstBaseParseClass
}

// ParentClass: parent class.
func (b *BaseParseClass) ParentClass() *gst.ElementClass {
	valptr := &b.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// BaseParseFrame: frame (context) data passed to each frame parsing virtual
// methods. In addition to providing the data to be checked for a valid frame or
// an already identified frame, it conveys additional metadata or control
// information from and to the subclass w.r.t. the particular frame in question
// (rather than global parameters). Some of these may apply to each parsing
// stage, others only to some a particular one. These parameters are effectively
// zeroed at start of each frame's processing, i.e. parsing virtual method
// invocation sequence.
//
// An instance of this type is always passed by reference.
type BaseParseFrame struct {
	*baseParseFrame
}

// baseParseFrame is the struct that's finalized.
type baseParseFrame struct {
	native *C.GstBaseParseFrame
}

func marshalBaseParseFrame(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &BaseParseFrame{&baseParseFrame{(*C.GstBaseParseFrame)(b)}}, nil
}

// NewBaseParseFrame constructs a struct BaseParseFrame.
func NewBaseParseFrame(buffer *gst.Buffer, flags BaseParseFrameFlags, overhead int) *BaseParseFrame {
	var _arg1 *C.GstBuffer             // out
	var _arg2 C.GstBaseParseFrameFlags // out
	var _arg3 C.gint                   // out
	var _cret *C.GstBaseParseFrame     // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstBaseParseFrameFlags(flags)
	_arg3 = C.gint(overhead)

	_cret = C.gst_base_parse_frame_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(overhead)

	var _baseParseFrame *BaseParseFrame // out

	_baseParseFrame = (*BaseParseFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_baseParseFrame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_base_parse_frame_free((*C.GstBaseParseFrame)(intern.C))
		},
	)

	return _baseParseFrame
}

// Buffer: input data to be parsed for frames.
func (b *BaseParseFrame) Buffer() *gst.Buffer {
	valptr := &b.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// OutBuffer: output data.
func (b *BaseParseFrame) OutBuffer() *gst.Buffer {
	valptr := &b.native.out_buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Flags: combination of input and output BaseParseFrameFlags that convey
// additional context to subclass or allow subclass to tune subsequent BaseParse
// actions.
func (b *BaseParseFrame) Flags() uint {
	valptr := &b.native.flags
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: media specific offset of input frame Note that a converter may have a
// different one on the frame's buffer.
func (b *BaseParseFrame) Offset() uint64 {
	valptr := &b.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Overhead subclass can set this to indicates the metadata overhead for the
// given frame, which is then used to enable more accurate bitrate computations.
// If this is -1, it is assumed that this frame should be skipped in bitrate
// calculation.
func (b *BaseParseFrame) Overhead() int {
	valptr := &b.native.overhead
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Flags: combination of input and output BaseParseFrameFlags that convey
// additional context to subclass or allow subclass to tune subsequent BaseParse
// actions.
func (b *BaseParseFrame) SetFlags(flags uint) {
	valptr := &b.native.flags
	*valptr = C.guint(flags)
}

// Offset: media specific offset of input frame Note that a converter may have a
// different one on the frame's buffer.
func (b *BaseParseFrame) SetOffset(offset uint64) {
	valptr := &b.native.offset
	*valptr = C.guint64(offset)
}

// Overhead subclass can set this to indicates the metadata overhead for the
// given frame, which is then used to enable more accurate bitrate computations.
// If this is -1, it is assumed that this frame should be skipped in bitrate
// calculation.
func (b *BaseParseFrame) SetOverhead(overhead int) {
	valptr := &b.native.overhead
	*valptr = C.gint(overhead)
}

// Copy copies a BaseParseFrame.
//
// The function returns the following values:
//
//    - baseParseFrame: copy of frame.
//
func (frame *BaseParseFrame) Copy() *BaseParseFrame {
	var _arg0 *C.GstBaseParseFrame // out
	var _cret *C.GstBaseParseFrame // in

	_arg0 = (*C.GstBaseParseFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_base_parse_frame_copy(_arg0)
	runtime.KeepAlive(frame)

	var _baseParseFrame *BaseParseFrame // out

	_baseParseFrame = (*BaseParseFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_baseParseFrame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_base_parse_frame_free((*C.GstBaseParseFrame)(intern.C))
		},
	)

	return _baseParseFrame
}

// Init sets a BaseParseFrame to initial state. Currently this means all public
// fields are zero-ed and a private flag is set to make sure
// gst_base_parse_frame_free() only frees the contents but not the actual frame.
// Use this function to initialise a BaseParseFrame allocated on the stack.
func (frame *BaseParseFrame) Init() {
	var _arg0 *C.GstBaseParseFrame // out

	_arg0 = (*C.GstBaseParseFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	C.gst_base_parse_frame_init(_arg0)
	runtime.KeepAlive(frame)
}
