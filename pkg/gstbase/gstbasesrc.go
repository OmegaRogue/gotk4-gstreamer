// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
// extern void _gotk4_gstbase1_BaseSrcClass_get_times(GstBaseSrc*, GstBuffer*, GstClockTime*, GstClockTime*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_unlock_stop(GstBaseSrc*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_unlock(GstBaseSrc*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_stop(GstBaseSrc*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_start(GstBaseSrc*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_set_caps(GstBaseSrc*, GstCaps*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_query(GstBaseSrc*, GstQuery*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_prepare_seek_segment(GstBaseSrc*, GstEvent*, GstSegment*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_negotiate(GstBaseSrc*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_is_seekable(GstBaseSrc*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_get_size(GstBaseSrc*, guint64*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_event(GstBaseSrc*, GstEvent*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_do_seek(GstBaseSrc*, GstSegment*);
// extern gboolean _gotk4_gstbase1_BaseSrcClass_decide_allocation(GstBaseSrc*, GstQuery*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSrcClass_fill(GstBaseSrc*, guint64, guint, GstBuffer*);
// extern GstFlowReturn _gotk4_gstbase1_BaseSrcClass_alloc(GstBaseSrc*, guint64, guint, GstBuffer**);
// extern GstCaps* _gotk4_gstbase1_BaseSrcClass_get_caps(GstBaseSrc*, GstCaps*);
// extern GstCaps* _gotk4_gstbase1_BaseSrcClass_fixate(GstBaseSrc*, GstCaps*);
// GstCaps* _gotk4_gstbase1_BaseSrc_virtual_fixate(void* fnptr, GstBaseSrc* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstBaseSrc*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstCaps* _gotk4_gstbase1_BaseSrc_virtual_get_caps(void* fnptr, GstBaseSrc* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstBaseSrc*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSrc_virtual_alloc(void* fnptr, GstBaseSrc* arg0, guint64 arg1, guint arg2, GstBuffer** arg3) {
//   return ((GstFlowReturn (*)(GstBaseSrc*, guint64, guint, GstBuffer**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstFlowReturn _gotk4_gstbase1_BaseSrc_virtual_fill(void* fnptr, GstBaseSrc* arg0, guint64 arg1, guint arg2, GstBuffer* arg3) {
//   return ((GstFlowReturn (*)(GstBaseSrc*, guint64, guint, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_decide_allocation(void* fnptr, GstBaseSrc* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseSrc*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_do_seek(void* fnptr, GstBaseSrc* arg0, GstSegment* arg1) {
//   return ((gboolean (*)(GstBaseSrc*, GstSegment*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_event(void* fnptr, GstBaseSrc* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstBaseSrc*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_get_size(void* fnptr, GstBaseSrc* arg0, guint64* arg1) {
//   return ((gboolean (*)(GstBaseSrc*, guint64*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_is_seekable(void* fnptr, GstBaseSrc* arg0) {
//   return ((gboolean (*)(GstBaseSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_negotiate(void* fnptr, GstBaseSrc* arg0) {
//   return ((gboolean (*)(GstBaseSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_prepare_seek_segment(void* fnptr, GstBaseSrc* arg0, GstEvent* arg1, GstSegment* arg2) {
//   return ((gboolean (*)(GstBaseSrc*, GstEvent*, GstSegment*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_query(void* fnptr, GstBaseSrc* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstBaseSrc*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_set_caps(void* fnptr, GstBaseSrc* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstBaseSrc*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_start(void* fnptr, GstBaseSrc* arg0) {
//   return ((gboolean (*)(GstBaseSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_stop(void* fnptr, GstBaseSrc* arg0) {
//   return ((gboolean (*)(GstBaseSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_unlock(void* fnptr, GstBaseSrc* arg0) {
//   return ((gboolean (*)(GstBaseSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstbase1_BaseSrc_virtual_unlock_stop(void* fnptr, GstBaseSrc* arg0) {
//   return ((gboolean (*)(GstBaseSrc*))(fnptr))(arg0);
// };
// void _gotk4_gstbase1_BaseSrc_virtual_get_times(void* fnptr, GstBaseSrc* arg0, GstBuffer* arg1, GstClockTime* arg2, GstClockTime* arg3) {
//   ((void (*)(GstBaseSrc*, GstBuffer*, GstClockTime*, GstClockTime*))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeBaseSrc = coreglib.Type(C.gst_base_src_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBaseSrc, F: marshalBaseSrc},
	})
}

// BaseSrcFlags flags that a basesrc element may have.
type BaseSrcFlags C.guint

const (
	// BaseSrcFlagStarting has source is starting.
	BaseSrcFlagStarting BaseSrcFlags = 0b100000000000000
	// BaseSrcFlagStarted has source been started.
	BaseSrcFlagStarted BaseSrcFlags = 0b1000000000000000
	// BaseSrcFlagLast: offset to define more flags.
	BaseSrcFlagLast BaseSrcFlags = 0b100000000000000000000
)

// String returns the names in string for BaseSrcFlags.
func (b BaseSrcFlags) String() string {
	if b == 0 {
		return "BaseSrcFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(54)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BaseSrcFlagStarting:
			builder.WriteString("Starting|")
		case BaseSrcFlagStarted:
			builder.WriteString("Started|")
		case BaseSrcFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BaseSrcFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BaseSrcFlags) Has(other BaseSrcFlags) bool {
	return (b & other) == other
}

// BaseSrcOverrides contains methods that are overridable.
type BaseSrcOverrides struct {
	// Alloc: ask the subclass to allocate an output buffer with offset and
	// size, the default implementation will use the negotiated allocator.
	//
	// The function takes the following parameters:
	//
	//    - offset
	//    - size
	//
	// The function returns the following values:
	//
	//    - buf
	//    - flowReturn
	//
	Alloc func(offset uint64, size uint) (*gst.Buffer, gst.FlowReturn)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DoSeek func(segment *gst.Segment) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Event func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	//    - offset
	//    - size
	//    - buf
	//
	// The function returns the following values:
	//
	Fill func(offset uint64, size uint, buf *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Fixate func(caps *gst.Caps) *gst.Caps
	// Caps: called to get the caps to report.
	//
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Caps func(filter *gst.Caps) *gst.Caps
	// Size: get the total size of the resource in the format set by
	// gst_base_src_set_format().
	//
	// The function returns the following values:
	//
	//    - size
	//    - ok: TRUE if the size is available and has been set.
	//
	Size func() (uint64, bool)
	// Times: given buffer, return start and end time when it should be pushed
	// out. The base class will sync on the clock using these times.
	//
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	//    - start
	//    - end
	//
	Times func(buffer *gst.Buffer) (start, end gst.ClockTime)
	// The function returns the following values:
	//
	IsSeekable func() bool
	// Negotiate negotiates src pad caps with downstream elements. Unmarks
	// GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again if
	// BaseSrcClass::negotiate fails.
	//
	// Do not call this in the BaseSrcClass::fill vmethod. Call this in
	// BaseSrcClass::create or in BaseSrcClass::alloc, _before_ any buffer is
	// allocated.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the negotiation succeeded, else FALSE.
	//
	Negotiate func() bool
	// The function takes the following parameters:
	//
	//    - seek
	//    - segment
	//
	// The function returns the following values:
	//
	PrepareSeekSegment func(seek *gst.Event, segment *gst.Segment) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Query func(query *gst.Query) bool
	// SetCaps: set new caps on the basesrc source pad.
	//
	// The function takes the following parameters:
	//
	//    - caps: Caps.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the caps could be set.
	//
	SetCaps func(caps *gst.Caps) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function returns the following values:
	//
	Unlock func() bool
	// The function returns the following values:
	//
	UnlockStop func() bool
}

func defaultBaseSrcOverrides(v *BaseSrc) BaseSrcOverrides {
	return BaseSrcOverrides{
		Alloc:              v.alloc,
		DecideAllocation:   v.decideAllocation,
		DoSeek:             v.doSeek,
		Event:              v.event,
		Fill:               v.fill,
		Fixate:             v.fixate,
		Caps:               v.caps,
		Size:               v.size,
		Times:              v.times,
		IsSeekable:         v.isSeekable,
		Negotiate:          v.negotiate,
		PrepareSeekSegment: v.prepareSeekSegment,
		Query:              v.query,
		SetCaps:            v.setCaps,
		Start:              v.start,
		Stop:               v.stop,
		Unlock:             v.unlock,
		UnlockStop:         v.unlockStop,
	}
}

// BaseSrc: this is a generic base class for source elements. The following
// types of sources are supported:
//
//    * random access sources like files
//    * seekable sources
//    * live sources
//
// The source can be configured to operate in any Format with the
// gst_base_src_set_format() method. The currently set format determines the
// format of the internal Segment and any GST_EVENT_SEGMENT events. The default
// format for BaseSrc is GST_FORMAT_BYTES.
//
// BaseSrc always supports push mode scheduling. If the following conditions are
// met, it also supports pull mode scheduling:
//
//    * The format is set to GST_FORMAT_BYTES (default).
//    * BaseSrcClass::is_seekable returns TRUE.
//
// If all the conditions are met for operating in pull mode, BaseSrc is
// automatically seekable in push mode as well. The following conditions must be
// met to make the element seekable in push mode when the format is not
// GST_FORMAT_BYTES:
//
// * BaseSrcClass::is_seekable returns TRUE. * BaseSrcClass::query can convert
// all supported seek formats to the internal format as set with
// gst_base_src_set_format(). * BaseSrcClass::do_seek is implemented, performs
// the seek and returns TRUE.
//
// When the element does not meet the requirements to operate in pull mode, the
// offset and length in the BaseSrcClass::create method should be ignored. It is
// recommended to subclass PushSrc instead, in this situation. If the element
// can operate in pull mode but only with specific offsets and lengths, it is
// allowed to generate an error when the wrong values are passed to the
// BaseSrcClass::create function.
//
// BaseSrc has support for live sources. Live sources are sources that when
// paused discard data, such as audio or video capture devices. A typical live
// source also produces data at a fixed rate and thus provides a clock to
// publish this rate. Use gst_base_src_set_live() to activate the live source
// mode.
//
// A live source does not produce data in the PAUSED state. This means that the
// BaseSrcClass::create method will not be called in PAUSED but only in PLAYING.
// To signal the pipeline that the element will not produce data, the return
// value from the READY to PAUSED state will be GST_STATE_CHANGE_NO_PREROLL.
//
// A typical live source will timestamp the buffers it creates with the current
// running time of the pipeline. This is one reason why a live source can only
// produce data in the PLAYING state, when the clock is actually distributed and
// running.
//
// Live sources that synchronize and block on the clock (an audio source, for
// example) can use gst_base_src_wait_playing() when the BaseSrcClass::create
// function was interrupted by a state change to PAUSED.
//
// The BaseSrcClass::get_times method can be used to implement pseudo-live
// sources. It only makes sense to implement the BaseSrcClass::get_times
// function if the source is a live source. The BaseSrcClass::get_times function
// should return timestamps starting from 0, as if it were a non-live source.
// The base class will make sure that the timestamps are transformed into the
// current running_time. The base source will then wait for the calculated
// running_time before pushing out the buffer.
//
// For live sources, the base class will by default report a latency of 0. For
// pseudo live sources, the base class will by default measure the difference
// between the first buffer timestamp and the start time of get_times and will
// report this value as the latency. Subclasses should override the query
// function when this behaviour is not acceptable.
//
// There is only support in BaseSrc for exactly one source pad, which should be
// named "src". A source implementation (subclass of BaseSrc) should install a
// pad template in its class_init function, like so:
//
//    static void
//    my_element_class_init (GstMyElementClass *klass)
//    {
//      GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
//      // srctemplate should be a StaticPadTemplate with direction
//      // GST_PAD_SRC and name "src"
//      gst_element_class_add_static_pad_template (gstelement_class, &srctemplate);
//
//      gst_element_class_set_static_metadata (gstelement_class,
//         "Source name",
//         "Source",
//         "My Source element",
//         "The author <my.sinkmy.email>");
//    }
//
//
// Controlled shutdown of live sources in applications
//
// Applications that record from a live source may want to stop recording in a
// controlled way, so that the recording is stopped, but the data already in the
// pipeline is processed to the end (remember that many live sources would go on
// recording forever otherwise). For that to happen the application needs to
// make the source stop recording and send an EOS event down the pipeline. The
// application would then wait for an EOS message posted on the pipeline's bus
// to know when all data has been processed and the pipeline can safely be
// stopped.
//
// An application may send an EOS event to a source element to make it perform
// the EOS logic (send EOS event downstream or post a GST_MESSAGE_SEGMENT_DONE
// on the bus). This can typically be done with the gst_element_send_event()
// function on the element or its parent bin.
//
// After the EOS has been sent to the element, the application should wait for
// an EOS message to be posted on the pipeline's bus. Once this EOS message is
// received, it may safely shut down the entire pipeline.
type BaseSrc struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*BaseSrc)(nil)
)

// BaseSrcer describes types inherited from class BaseSrc.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type BaseSrcer interface {
	coreglib.Objector
	baseBaseSrc() *BaseSrc
}

var _ BaseSrcer = (*BaseSrc)(nil)

func init() {
	coreglib.RegisterClassInfo[*BaseSrc, *BaseSrcClass, BaseSrcOverrides](
		GTypeBaseSrc,
		initBaseSrcClass,
		wrapBaseSrc,
		defaultBaseSrcOverrides,
	)
}

func initBaseSrcClass(gclass unsafe.Pointer, overrides BaseSrcOverrides, classInitFunc func(*BaseSrcClass)) {
	pclass := (*C.GstBaseSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBaseSrc))))

	if overrides.Alloc != nil {
		pclass.alloc = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_alloc)
	}

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_decide_allocation)
	}

	if overrides.DoSeek != nil {
		pclass.do_seek = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_do_seek)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_event)
	}

	if overrides.Fill != nil {
		pclass.fill = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_fill)
	}

	if overrides.Fixate != nil {
		pclass.fixate = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_fixate)
	}

	if overrides.Caps != nil {
		pclass.get_caps = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_get_caps)
	}

	if overrides.Size != nil {
		pclass.get_size = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_get_size)
	}

	if overrides.Times != nil {
		pclass.get_times = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_get_times)
	}

	if overrides.IsSeekable != nil {
		pclass.is_seekable = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_is_seekable)
	}

	if overrides.Negotiate != nil {
		pclass.negotiate = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_negotiate)
	}

	if overrides.PrepareSeekSegment != nil {
		pclass.prepare_seek_segment = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_prepare_seek_segment)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_query)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_set_caps)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_stop)
	}

	if overrides.Unlock != nil {
		pclass.unlock = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_unlock)
	}

	if overrides.UnlockStop != nil {
		pclass.unlock_stop = (*[0]byte)(C._gotk4_gstbase1_BaseSrcClass_unlock_stop)
	}

	if classInitFunc != nil {
		class := (*BaseSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBaseSrc(obj *coreglib.Object) *BaseSrc {
	return &BaseSrc{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalBaseSrc(p uintptr) (interface{}, error) {
	return wrapBaseSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (src *BaseSrc) baseBaseSrc() *BaseSrc {
	return src
}

// BaseBaseSrc returns the underlying base object.
func BaseBaseSrc(obj BaseSrcer) *BaseSrc {
	return obj.baseBaseSrc()
}

// Allocator lets BaseSrc sub-classes to know the memory allocator used by the
// base class and its params.
//
// Unref the allocator after usage.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) of allocator.
//
func (src *BaseSrc) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstBaseSrc         // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	C.gst_base_src_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(src)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _allocator, _params
}

// Blocksize: get the number of bytes that src will push out with each buffer.
//
// The function returns the following values:
//
//    - guint: number of bytes pushed with each buffer.
//
func (src *BaseSrc) Blocksize() uint {
	var _arg0 *C.GstBaseSrc // out
	var _cret C.guint       // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_get_blocksize(_arg0)
	runtime.KeepAlive(src)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//    - bufferPool (optional): instance of the BufferPool used by the src; unref
//      it after usage.
//
func (src *BaseSrc) BufferPool() *gst.BufferPool {
	var _arg0 *C.GstBaseSrc    // out
	var _cret *C.GstBufferPool // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_get_buffer_pool(_arg0)
	runtime.KeepAlive(src)

	var _bufferPool *gst.BufferPool // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_bufferPool = &gst.BufferPool{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			}
		}
	}

	return _bufferPool
}

// DoTimestamp: query if src timestamps outgoing buffers based on the current
// running_time.
//
// The function returns the following values:
//
//    - ok: TRUE if the base class will automatically timestamp outgoing buffers.
//
func (src *BaseSrc) DoTimestamp() bool {
	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_get_do_timestamp(_arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsAsync: get the current async behaviour of src. See also
// gst_base_src_set_async().
//
// The function returns the following values:
//
//    - ok: TRUE if src is operating in async mode.
//
func (src *BaseSrc) IsAsync() bool {
	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_is_async(_arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLive: check if an element is in live mode.
//
// The function returns the following values:
//
//    - ok: TRUE if element is in live mode.
//
func (src *BaseSrc) IsLive() bool {
	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_is_live(_arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Negotiate negotiates src pad caps with downstream elements. Unmarks
// GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again if
// BaseSrcClass::negotiate fails.
//
// Do not call this in the BaseSrcClass::fill vmethod. Call this in
// BaseSrcClass::create or in BaseSrcClass::alloc, _before_ any buffer is
// allocated.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (src *BaseSrc) Negotiate() bool {
	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_negotiate(_arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewSeamlessSegment: prepare a new seamless segment for emission downstream.
// This function must only be called by derived sub-classes, and only from the
// BaseSrcClass::create function, as the stream-lock needs to be held.
//
// The format for the new segment will be the current format of the source, as
// configured with gst_base_src_set_format()
//
// Deprecated: Use gst_base_src_new_segment().
//
// The function takes the following parameters:
//
//    - start: new start value for the segment.
//    - stop: stop value for the new segment.
//    - time: new time value for the start of the new segment.
//
// The function returns the following values:
//
//    - ok: TRUE if preparation of the seamless segment succeeded.
//
func (src *BaseSrc) NewSeamlessSegment(start, stop, time int64) bool {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.gint64      // out
	var _arg2 C.gint64      // out
	var _arg3 C.gint64      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.gint64(start)
	_arg2 = C.gint64(stop)
	_arg3 = C.gint64(time)

	_cret = C.gst_base_src_new_seamless_segment(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)
	runtime.KeepAlive(time)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewSegment: prepare a new segment for emission downstream. This function must
// only be called by derived sub-classes, and only from the BaseSrcClass::create
// function, as the stream-lock needs to be held.
//
// The format for the segment must be identical with the current format of the
// source, as configured with gst_base_src_set_format().
//
// The format of src must not be GST_FORMAT_UNDEFINED and the format should be
// configured via gst_base_src_set_format() before calling this method.
//
// The function takes the following parameters:
//
//    - segment: pointer to a Segment.
//
// The function returns the following values:
//
//    - ok: TRUE if preparation of new segment succeeded.
//
func (src *BaseSrc) NewSegment(segment *gst.Segment) bool {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstSegment // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C.gst_base_src_new_segment(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(segment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryLatency: query the source for the latency parameters. live will be TRUE
// when src is configured as a live source. min_latency and max_latency will be
// set to the difference between the running time and the timestamp of the first
// buffer.
//
// This function is mostly used by subclasses.
//
// The function returns the following values:
//
//    - live (optional): if the source is live.
//    - minLatency (optional): min latency of the source.
//    - maxLatency (optional): max latency of the source.
//    - ok: TRUE if the query succeeded.
//
func (src *BaseSrc) QueryLatency() (live bool, minLatency, maxLatency gst.ClockTime, ok bool) {
	var _arg0 *C.GstBaseSrc  // out
	var _arg1 C.gboolean     // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_query_latency(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(src)

	var _live bool                // out
	var _minLatency gst.ClockTime // out
	var _maxLatency gst.ClockTime // out
	var _ok bool                  // out

	if _arg1 != 0 {
		_live = true
	}
	_minLatency = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64
	_maxLatency = uint64(_arg3)
	type _ = gst.ClockTime
	type _ = uint64
	if _cret != 0 {
		_ok = true
	}

	return _live, _minLatency, _maxLatency, _ok
}

// SetAsync: configure async behaviour in src, no state change will block. The
// open, close, start, stop, play and pause virtual methods will be executed in
// a different thread and are thus allowed to perform blocking operations. Any
// blocking operation should be unblocked with the unlock vmethod.
//
// The function takes the following parameters:
//
//    - async: new async mode.
//
func (src *BaseSrc) SetAsync(async bool) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if async {
		_arg1 = C.TRUE
	}

	C.gst_base_src_set_async(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(async)
}

// SetAutomaticEos: if automatic_eos is TRUE, src will automatically go EOS if a
// buffer after the total size is returned. By default this is TRUE but sources
// that can't return an authoritative size and only know that they're EOS when
// trying to read more should set this to FALSE.
//
// When src operates in GST_FORMAT_TIME, BaseSrc will send an EOS when a buffer
// outside of the currently configured segment is pushed if automatic_eos is
// TRUE. Since 1.16, if automatic_eos is FALSE an EOS will be pushed only when
// the BaseSrcClass::create implementation returns GST_FLOW_EOS.
//
// The function takes the following parameters:
//
//    - automaticEos: automatic eos.
//
func (src *BaseSrc) SetAutomaticEos(automaticEos bool) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if automaticEos {
		_arg1 = C.TRUE
	}

	C.gst_base_src_set_automatic_eos(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(automaticEos)
}

// SetBlocksize: set the number of bytes that src will push out with each
// buffer. When blocksize is set to -1, a default length will be used.
//
// The function takes the following parameters:
//
//    - blocksize: new blocksize in bytes.
//
func (src *BaseSrc) SetBlocksize(blocksize uint) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.guint(blocksize)

	C.gst_base_src_set_blocksize(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(blocksize)
}

// SetCaps: set new caps on the basesrc source pad.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps could be set.
//
func (src *BaseSrc) SetCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_base_src_set_caps(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDoTimestamp: configure src to automatically timestamp outgoing buffers
// based on the current running_time of the pipeline. This property is mostly
// useful for live sources.
//
// The function takes the following parameters:
//
//    - timestamp: enable or disable timestamping.
//
func (src *BaseSrc) SetDoTimestamp(timestamp bool) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if timestamp {
		_arg1 = C.TRUE
	}

	C.gst_base_src_set_do_timestamp(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(timestamp)
}

// SetDynamicSize: if not dynamic, size is only updated when needed, such as
// when trying to read past current tracked size. Otherwise, size is checked for
// upon each read.
//
// The function takes the following parameters:
//
//    - dynamic: new dynamic size mode.
//
func (src *BaseSrc) SetDynamicSize(dynamic bool) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if dynamic {
		_arg1 = C.TRUE
	}

	C.gst_base_src_set_dynamic_size(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dynamic)
}

// SetFormat sets the default format of the source. This will be the format used
// for sending SEGMENT events and for performing seeks.
//
// If a format of GST_FORMAT_BYTES is set, the element will be able to operate
// in pull mode if the BaseSrcClass::is_seekable returns TRUE.
//
// This function must only be called in states < GST_STATE_PAUSED.
//
// The function takes the following parameters:
//
//    - format to use.
//
func (src *BaseSrc) SetFormat(format gst.Format) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.GstFormat   // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.GstFormat(format)

	C.gst_base_src_set_format(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
}

// SetLive: if the element listens to a live source, live should be set to TRUE.
//
// A live source will not produce data in the PAUSED state and will therefore
// not be able to participate in the PREROLL phase of a pipeline. To signal this
// fact to the application and the pipeline, the state change return value of
// the live source will be GST_STATE_CHANGE_NO_PREROLL.
//
// The function takes the following parameters:
//
//    - live: new live-mode.
//
func (src *BaseSrc) SetLive(live bool) {
	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if live {
		_arg1 = C.TRUE
	}

	C.gst_base_src_set_live(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(live)
}

// StartComplete: complete an asynchronous start operation. When the subclass
// overrides the start method, it should call gst_base_src_start_complete() when
// the start operation completes either from the same thread or from an
// asynchronous helper thread.
//
// The function takes the following parameters:
//
//    - ret: FlowReturn.
//
func (basesrc *BaseSrc) StartComplete(ret gst.FlowReturn) {
	var _arg0 *C.GstBaseSrc   // out
	var _arg1 C.GstFlowReturn // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(basesrc).Native()))
	_arg1 = C.GstFlowReturn(ret)

	C.gst_base_src_start_complete(_arg0, _arg1)
	runtime.KeepAlive(basesrc)
	runtime.KeepAlive(ret)
}

// StartWait: wait until the start operation completes.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (basesrc *BaseSrc) StartWait() gst.FlowReturn {
	var _arg0 *C.GstBaseSrc   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(basesrc).Native()))

	_cret = C.gst_base_src_start_wait(_arg0)
	runtime.KeepAlive(basesrc)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SubmitBufferList subclasses can call this from their create virtual method
// implementation to submit a buffer list to be pushed out later. This is useful
// in cases where the create function wants to produce multiple buffers to be
// pushed out in one go in form of a BufferList, which can reduce overhead
// drastically, especially for packetised inputs (for data streams where the
// packetisation/chunking is not important it is usually more efficient to
// return larger buffers instead).
//
// Subclasses that use this function from their create function must return
// GST_FLOW_OK and no buffer from their create virtual method implementation. If
// a buffer is returned after a buffer list has also been submitted via this
// function the behaviour is undefined.
//
// Subclasses must only call this function once per create function call and
// subclasses must only call this function when the source operates in push
// mode.
//
// The function takes the following parameters:
//
//    - bufferList: BufferList.
//
func (src *BaseSrc) SubmitBufferList(bufferList *gst.BufferList) {
	var _arg0 *C.GstBaseSrc    // out
	var _arg1 *C.GstBufferList // out

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(bufferList)), nil)

	C.gst_base_src_submit_buffer_list(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(bufferList)
}

// WaitPlaying: if the BaseSrcClass::create method performs its own
// synchronisation against the clock it must unblock when going from PLAYING to
// the PAUSED state and call this method before continuing to produce the
// remaining data.
//
// This function will block until a state change to PLAYING happens (in which
// case this function returns GST_FLOW_OK) or the processing must be stopped due
// to a state change to READY or a FLUSH event (in which case this function
// returns GST_FLOW_FLUSHING).
//
// The function returns the following values:
//
//    - flowReturn: GST_FLOW_OK if src is PLAYING and processing can continue.
//      Any other return value should be returned from the create vmethod.
//
func (src *BaseSrc) WaitPlaying() gst.FlowReturn {
	var _arg0 *C.GstBaseSrc   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_base_src_wait_playing(_arg0)
	runtime.KeepAlive(src)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Alloc: ask the subclass to allocate an output buffer with offset and size,
// the default implementation will use the negotiated allocator.
//
// The function takes the following parameters:
//
//    - offset
//    - size
//
// The function returns the following values:
//
//    - buf
//    - flowReturn
//
func (src *BaseSrc) alloc(offset uint64, size uint) (*gst.Buffer, gst.FlowReturn) {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.alloc

	var _arg0 *C.GstBaseSrc   // out
	var _arg1 C.guint64       // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint(size)

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_alloc(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buf *gst.Buffer           // out
	var _flowReturn gst.FlowReturn // out

	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buf)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = gst.FlowReturn(_cret)

	return _buf, _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *BaseSrc) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstQuery   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *BaseSrc) doSeek(segment *gst.Segment) bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.do_seek

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstSegment // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_do_seek(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(segment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *BaseSrc) event(event *gst.Event) bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.event

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - offset
//    - size
//    - buf
//
// The function returns the following values:
//
func (src *BaseSrc) fill(offset uint64, size uint, buf *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.fill

	var _arg0 *C.GstBaseSrc   // out
	var _arg1 C.guint64       // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint(size)
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_fill(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)
	runtime.KeepAlive(buf)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *BaseSrc) fixate(caps *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.fixate

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstCaps    // out
	var _cret *C.GstCaps    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_fixate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(caps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// Caps: called to get the caps to report.
//
// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *BaseSrc) caps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.get_caps

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstCaps    // out
	var _cret *C.GstCaps    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if filter != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_get_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// Size: get the total size of the resource in the format set by
// gst_base_src_set_format().
//
// The function returns the following values:
//
//    - size
//    - ok: TRUE if the size is available and has been set.
//
func (src *BaseSrc) size() (uint64, bool) {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.get_size

	var _arg0 *C.GstBaseSrc // out
	var _arg1 C.guint64     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_get_size(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(src)

	var _size uint64 // out
	var _ok bool     // out

	_size = uint64(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _size, _ok
}

// Times: given buffer, return start and end time when it should be pushed out.
// The base class will sync on the clock using these times.
//
// The function takes the following parameters:
//
// The function returns the following values:
//
//    - start
//    - end
//
func (src *BaseSrc) times(buffer *gst.Buffer) (start, end gst.ClockTime) {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.get_times

	var _arg0 *C.GstBaseSrc  // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C._gotk4_gstbase1_BaseSrc_virtual_get_times(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(buffer)

	var _start gst.ClockTime // out
	var _end gst.ClockTime   // out

	_start = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64
	_end = uint64(_arg3)
	type _ = gst.ClockTime
	type _ = uint64

	return _start, _end
}

// The function returns the following values:
//
func (src *BaseSrc) isSeekable() bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.is_seekable

	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_is_seekable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Negotiate negotiates src pad caps with downstream elements. Unmarks
// GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again if
// BaseSrcClass::negotiate fails.
//
// Do not call this in the BaseSrcClass::fill vmethod. Call this in
// BaseSrcClass::create or in BaseSrcClass::alloc, _before_ any buffer is
// allocated.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (src *BaseSrc) negotiate() bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.negotiate

	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_negotiate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - seek
//    - segment
//
// The function returns the following values:
//
func (src *BaseSrc) prepareSeekSegment(seek *gst.Event, segment *gst.Segment) bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.prepare_seek_segment

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstEvent   // out
	var _arg2 *C.GstSegment // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(seek)))
	_arg2 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_prepare_seek_segment(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(seek)
	runtime.KeepAlive(segment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *BaseSrc) query(query *gst.Query) bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.query

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstQuery   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setCaps: set new caps on the basesrc source pad.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps could be set.
//
func (src *BaseSrc) setCaps(caps *gst.Caps) bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.set_caps

	var _arg0 *C.GstBaseSrc // out
	var _arg1 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (src *BaseSrc) start() bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.start

	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (src *BaseSrc) stop() bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.stop

	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (src *BaseSrc) unlock() bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.unlock

	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_unlock(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (src *BaseSrc) unlockStop() bool {
	gclass := (*C.GstBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.unlock_stop

	var _arg0 *C.GstBaseSrc // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstbase1_BaseSrc_virtual_unlock_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BaseSrcClass subclasses can override any of the available virtual methods or
// not, as needed. At the minimum, the create method should be overridden to
// produce buffers.
//
// An instance of this type is always passed by reference.
type BaseSrcClass struct {
	*baseSrcClass
}

// baseSrcClass is the struct that's finalized.
type baseSrcClass struct {
	native *C.GstBaseSrcClass
}

// ParentClass: element parent class.
func (b *BaseSrcClass) ParentClass() *gst.ElementClass {
	valptr := &b.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
