// Code generated by girgen. DO NOT EDIT.

package gsttag

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/tag/tag.h>
import "C"

// GType values.
var (
	GTypeTagImageType    = coreglib.Type(C.gst_tag_image_type_get_type())
	GTypeTagLicenseFlags = coreglib.Type(C.gst_tag_license_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTagImageType, F: marshalTagImageType},
		coreglib.TypeMarshaler{T: GTypeTagLicenseFlags, F: marshalTagLicenseFlags},
	})
}

// TAG_CAPTURING_CONTRAST: direction of contrast processing applied when
// capturing an image. (string)
//
// The allowed values are: "normal" "soft" "hard".
const TAG_CAPTURING_CONTRAST = "capturing-contrast"

// TAG_CAPTURING_DIGITAL_ZOOM_RATIO: digital zoom ratio used when capturing an
// image. (double).
const TAG_CAPTURING_DIGITAL_ZOOM_RATIO = "capturing-digital-zoom-ratio"

// TAG_CAPTURING_EXPOSURE_COMPENSATION: exposure compensation using when
// capturing an image in EV. (double).
const TAG_CAPTURING_EXPOSURE_COMPENSATION = "capturing-exposure-compensation"

// TAG_CAPTURING_EXPOSURE_MODE: exposure mode used when capturing an image.
// (string)
//
// The allowed values are: "auto-exposure" "manual-exposure" "auto-bracket".
const TAG_CAPTURING_EXPOSURE_MODE = "capturing-exposure-mode"

// TAG_CAPTURING_EXPOSURE_PROGRAM: type of exposure control used when capturing
// an image. (string)
//
// The allowed values are: "undefined" "manual" "normal" - automatically
// controlled "aperture-priority" - user selects aperture value
// "shutter-priority" - user selects shutter speed "creative" - biased towards
// depth of field "action" - biased towards fast shutter speed "portrait" -
// closeup, leaving background out of focus "landscape" - landscape photos,
// background in focus.
const TAG_CAPTURING_EXPOSURE_PROGRAM = "capturing-exposure-program"

// TAG_CAPTURING_FLASH_FIRED: if flash was fired during the capture of an image.
// (boolean)
//
// Note that if this tag isn't present, it should not be assumed that the flash
// did not fire. It should be treated as unknown.
const TAG_CAPTURING_FLASH_FIRED = "capturing-flash-fired"

// TAG_CAPTURING_FLASH_MODE: flash mode selected during the capture of an image.
// (string)
//
// The allowed values are: "auto" "always" "never".
const TAG_CAPTURING_FLASH_MODE = "capturing-flash-mode"

// TAG_CAPTURING_FOCAL_LENGTH: focal length used when capturing an image, in mm.
// (double).
const TAG_CAPTURING_FOCAL_LENGTH = "capturing-focal-length"

// TAG_CAPTURING_FOCAL_RATIO: focal ratio (f-number) used when capturing an
// image. (double)
//
// The value stored is the denominator of the focal ratio (f-number). For
// example, if this tag value is 2, the focal ratio is f/2.
const TAG_CAPTURING_FOCAL_RATIO = "capturing-focal-ratio"

// TAG_CAPTURING_GAIN_ADJUSTMENT: gain adjustment applied to an image. (string)
//
// The allowed values are: "none" "low-gain-up" "high-gain-up" "low-gain-down"
// "high-gain-down".
const TAG_CAPTURING_GAIN_ADJUSTMENT = "capturing-gain-adjustment"

// TAG_CAPTURING_ISO_SPEED: ISO speed used when capturing an image. (integer).
const TAG_CAPTURING_ISO_SPEED = "capturing-iso-speed"

// TAG_CAPTURING_METERING_MODE defines the way a camera determines the exposure.
// (string)
//
// The allowed values are: "unknown" "average" "center-weighted-average" "spot"
// "multi-spot" "pattern" "partial" "other".
const TAG_CAPTURING_METERING_MODE = "capturing-metering-mode"

// TAG_CAPTURING_SATURATION: direction of saturation processing applied when
// capturing an image. (string)
//
// The allowed values are: "normal" "low-saturation" "high-saturation".
const TAG_CAPTURING_SATURATION = "capturing-saturation"

// TAG_CAPTURING_SCENE_CAPTURE_TYPE: scene mode used when capturing an image.
// (string)
//
// The allowed values are: "standard" "landscape" "portrait" "night-scene".
const TAG_CAPTURING_SCENE_CAPTURE_TYPE = "capturing-scene-capture-type"

// TAG_CAPTURING_SHARPNESS: direction of sharpness processing applied when
// capturing an image. (string)
//
// The allowed values are: "normal" "soft" "hard".
const TAG_CAPTURING_SHARPNESS = "capturing-sharpness"

// TAG_CAPTURING_SHUTTER_SPEED: shutter speed used when capturing an image, in
// seconds. (fraction).
const TAG_CAPTURING_SHUTTER_SPEED = "capturing-shutter-speed"

// TAG_CAPTURING_SOURCE indicates the source of capture. The device/medium used
// to do the capture. (string)
//
// Allowed values are: "dsc" (= digital still camera) "transparent-scanner"
// "reflex-scanner" "other".
const TAG_CAPTURING_SOURCE = "capturing-source"

// TAG_CAPTURING_WHITE_BALANCE: white balance mode used when capturing an image.
// (string)
//
// The allowed values are: "auto" "manual" "daylight" "cloudy" "tungsten"
// "fluorescent" "fluorescent h" (newer daylight-calibrated fluorescents)
// "flash".
const TAG_CAPTURING_WHITE_BALANCE = "capturing-white-balance"

// TAG_CDDA_CDDB_DISCID: CDDB disc id in its short form (e.g. 'aa063d0f').
const TAG_CDDA_CDDB_DISCID = "discid"

// TAG_CDDA_CDDB_DISCID_FULL: CDDB disc id including all details.
const TAG_CDDA_CDDB_DISCID_FULL = "discid-full"

// TAG_CDDA_MUSICBRAINZ_DISCID: musicbrainz disc id (e.g.
// 'ahg7JUcfR3vCYBphSDIogOOWrr0-').
const TAG_CDDA_MUSICBRAINZ_DISCID = "musicbrainz-discid"

// TAG_CDDA_MUSICBRAINZ_DISCID_FULL: musicbrainz disc id details.
const TAG_CDDA_MUSICBRAINZ_DISCID_FULL = "musicbrainz-discid-full"

// TAG_CMML_CLIP: annodex CMML clip element tag.
const TAG_CMML_CLIP = "cmml-clip"

// TAG_CMML_HEAD: annodex CMML head element tag.
const TAG_CMML_HEAD = "cmml-head"

// TAG_CMML_STREAM: annodex CMML stream element tag.
const TAG_CMML_STREAM = "cmml-stream"

// TAG_ID3V2_HEADER_SIZE: ID3V2 header size considered minimum input for some
// functions such as gst_tag_list_from_id3v2_tag() and
// gst_tag_get_id3v2_tag_size() for example.
const TAG_ID3V2_HEADER_SIZE = 10

// TAG_IMAGE_HORIZONTAL_PPI: media (image/video) intended horizontal pixel
// density in ppi. (double).
const TAG_IMAGE_HORIZONTAL_PPI = "image-horizontal-ppi"

// TAG_IMAGE_VERTICAL_PPI: media (image/video) intended vertical pixel density
// in ppi. (double).
const TAG_IMAGE_VERTICAL_PPI = "image-vertical-ppi"

// TAG_MUSICBRAINZ_ALBUMARTISTID: musicBrainz album artist ID.
const TAG_MUSICBRAINZ_ALBUMARTISTID = "musicbrainz-albumartistid"

// TAG_MUSICBRAINZ_ALBUMID: musicBrainz album ID.
const TAG_MUSICBRAINZ_ALBUMID = "musicbrainz-albumid"

// TAG_MUSICBRAINZ_ARTISTID: musicBrainz artist ID.
const TAG_MUSICBRAINZ_ARTISTID = "musicbrainz-artistid"

// TAG_MUSICBRAINZ_TRACKID: musicBrainz track ID.
const TAG_MUSICBRAINZ_TRACKID = "musicbrainz-trackid"

// TAG_MUSICBRAINZ_TRMID: musicBrainz track TRM ID.
const TAG_MUSICBRAINZ_TRMID = "musicbrainz-trmid"

// TagImageType: type of image contained in an image tag (specified as
// "image-type" field in the info structure in the image's Sample).
type TagImageType C.gint

const (
	// TagImageTypeNone: no image type. Can be used to tell functions such as
	// gst_tag_image_data_to_image_sample() that no image type should be set.
	TagImageTypeNone TagImageType = -1
	// TagImageTypeUndefined: undefined/other image type.
	TagImageTypeUndefined TagImageType = 0
	// TagImageTypeFrontCover: cover (front).
	TagImageTypeFrontCover TagImageType = 1
	// TagImageTypeBackCover: cover (back).
	TagImageTypeBackCover TagImageType = 2
	// TagImageTypeLeafletPage: leaflet page.
	TagImageTypeLeafletPage TagImageType = 3
	// TagImageTypeMedium: medium (e.g. label side of CD).
	TagImageTypeMedium TagImageType = 4
	// TagImageTypeLeadArtist: lead artist/lead performer/soloist.
	TagImageTypeLeadArtist TagImageType = 5
	// TagImageTypeArtist: artist/performer.
	TagImageTypeArtist TagImageType = 6
	// TagImageTypeConductor: conductor.
	TagImageTypeConductor TagImageType = 7
	// TagImageTypeBandOrchestra: band/orchestra.
	TagImageTypeBandOrchestra TagImageType = 8
	// TagImageTypeComposer: composer.
	TagImageTypeComposer TagImageType = 9
	// TagImageTypeLyricist: lyricist/text writer.
	TagImageTypeLyricist TagImageType = 10
	// TagImageTypeRecordingLocation: recording location.
	TagImageTypeRecordingLocation TagImageType = 11
	// TagImageTypeDuringRecording: during recording.
	TagImageTypeDuringRecording TagImageType = 12
	// TagImageTypeDuringPerformance: during performance.
	TagImageTypeDuringPerformance TagImageType = 13
	// TagImageTypeVideoCapture: movie/video screen capture.
	TagImageTypeVideoCapture TagImageType = 14
	// TagImageTypeFish: fish as funny as the ID3v2 spec.
	TagImageTypeFish TagImageType = 15
	// TagImageTypeIllustration: illustration.
	TagImageTypeIllustration TagImageType = 16
	// TagImageTypeBandArtistLogo: band/artist logotype.
	TagImageTypeBandArtistLogo TagImageType = 17
	// TagImageTypePublisherStudioLogo: publisher/studio logotype.
	TagImageTypePublisherStudioLogo TagImageType = 18
)

func marshalTagImageType(p uintptr) (interface{}, error) {
	return TagImageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagImageType.
func (t TagImageType) String() string {
	switch t {
	case TagImageTypeNone:
		return "None"
	case TagImageTypeUndefined:
		return "Undefined"
	case TagImageTypeFrontCover:
		return "FrontCover"
	case TagImageTypeBackCover:
		return "BackCover"
	case TagImageTypeLeafletPage:
		return "LeafletPage"
	case TagImageTypeMedium:
		return "Medium"
	case TagImageTypeLeadArtist:
		return "LeadArtist"
	case TagImageTypeArtist:
		return "Artist"
	case TagImageTypeConductor:
		return "Conductor"
	case TagImageTypeBandOrchestra:
		return "BandOrchestra"
	case TagImageTypeComposer:
		return "Composer"
	case TagImageTypeLyricist:
		return "Lyricist"
	case TagImageTypeRecordingLocation:
		return "RecordingLocation"
	case TagImageTypeDuringRecording:
		return "DuringRecording"
	case TagImageTypeDuringPerformance:
		return "DuringPerformance"
	case TagImageTypeVideoCapture:
		return "VideoCapture"
	case TagImageTypeFish:
		return "Fish"
	case TagImageTypeIllustration:
		return "Illustration"
	case TagImageTypeBandArtistLogo:
		return "BandArtistLogo"
	case TagImageTypePublisherStudioLogo:
		return "PublisherStudioLogo"
	default:
		return fmt.Sprintf("TagImageType(%d)", t)
	}
}

// TagLicenseFlags: see http://creativecommons.org/ns for more information.
type TagLicenseFlags C.guint

const (
	// TagLicensePermitsReproduction: making multiple copies is allowed.
	TagLicensePermitsReproduction TagLicenseFlags = 0b1
	// TagLicensePermitsDistribution: distribution, public display and public
	// performance are allowed.
	TagLicensePermitsDistribution TagLicenseFlags = 0b10
	// TagLicensePermitsDerivativeWorks: distribution of derivative works is
	// allowed.
	TagLicensePermitsDerivativeWorks TagLicenseFlags = 0b100
	// TagLicensePermitsSharing: commercial derivatives are allowed, but only
	// non-commercial distribution is allowed.
	TagLicensePermitsSharing TagLicenseFlags = 0b1000
	// TagLicenseRequiresNotice: copyright and license notices must be kept
	// intact.
	TagLicenseRequiresNotice TagLicenseFlags = 0b100000000
	// TagLicenseRequiresAttribution: credit must be given to copyright holder
	// and/or author.
	TagLicenseRequiresAttribution TagLicenseFlags = 0b1000000000
	// TagLicenseRequiresShareAlike: derivative works must be licensed under the
	// same terms or compatible terms as the original work.
	TagLicenseRequiresShareAlike TagLicenseFlags = 0b10000000000
	// TagLicenseRequiresSourceCode: source code (the preferred form for making
	// modifications) must be provided when exercising some rights granted by
	// the license.
	TagLicenseRequiresSourceCode TagLicenseFlags = 0b100000000000
	// TagLicenseRequiresCopyleft: derivative and combined works must be
	// licensed under specified terms, similar to those of the original work.
	TagLicenseRequiresCopyleft TagLicenseFlags = 0b1000000000000
	// TagLicenseRequiresLesserCopyleft: derivative works must be licensed under
	// specified terms, with at least the same conditions as the original work;
	// combinations with the work may be licensed under different terms.
	TagLicenseRequiresLesserCopyleft TagLicenseFlags = 0b10000000000000
	// TagLicenseProhibitsCommercialUse: exercising rights for commercial
	// purposes is prohibited.
	TagLicenseProhibitsCommercialUse TagLicenseFlags = 0b10000000000000000
	// TagLicenseProhibitsHighIncomeNationUse: use in a non-developing country
	// is prohibited.
	TagLicenseProhibitsHighIncomeNationUse TagLicenseFlags = 0b100000000000000000
	// TagLicenseCreativeCommonsLicense: license was created by the Creative
	// Commons project.
	TagLicenseCreativeCommonsLicense TagLicenseFlags = 0b1000000000000000000000000
	// TagLicenseFreeSoftwareFoundationLicense: license was created by the Free
	// Software Foundation (FSF).
	TagLicenseFreeSoftwareFoundationLicense TagLicenseFlags = 0b10000000000000000000000000
)

func marshalTagLicenseFlags(p uintptr) (interface{}, error) {
	return TagLicenseFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TagLicenseFlags.
func (t TagLicenseFlags) String() string {
	if t == 0 {
		return "TagLicenseFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TagLicensePermitsReproduction:
			builder.WriteString("PermitsReproduction|")
		case TagLicensePermitsDistribution:
			builder.WriteString("PermitsDistribution|")
		case TagLicensePermitsDerivativeWorks:
			builder.WriteString("PermitsDerivativeWorks|")
		case TagLicensePermitsSharing:
			builder.WriteString("PermitsSharing|")
		case TagLicenseRequiresNotice:
			builder.WriteString("RequiresNotice|")
		case TagLicenseRequiresAttribution:
			builder.WriteString("RequiresAttribution|")
		case TagLicenseRequiresShareAlike:
			builder.WriteString("RequiresShareAlike|")
		case TagLicenseRequiresSourceCode:
			builder.WriteString("RequiresSourceCode|")
		case TagLicenseRequiresCopyleft:
			builder.WriteString("RequiresCopyleft|")
		case TagLicenseRequiresLesserCopyleft:
			builder.WriteString("RequiresLesserCopyleft|")
		case TagLicenseProhibitsCommercialUse:
			builder.WriteString("ProhibitsCommercialUse|")
		case TagLicenseProhibitsHighIncomeNationUse:
			builder.WriteString("ProhibitsHighIncomeNationUse|")
		case TagLicenseCreativeCommonsLicense:
			builder.WriteString("CreativeCommonsLicense|")
		case TagLicenseFreeSoftwareFoundationLicense:
			builder.WriteString("FreeSoftwareFoundationLicense|")
		default:
			builder.WriteString(fmt.Sprintf("TagLicenseFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TagLicenseFlags) Has(other TagLicenseFlags) bool {
	return (t & other) == other
}

// TagCheckLanguageCode: check if a given string contains a known ISO 639
// language code.
//
// This is useful in situations where it's not clear whether a given string is a
// language code (which should be put into a T_TAG_LANGUAGE_CODE tag) or a
// free-form language name descriptor (which should be put into a
// T_TAG_LANGUAGE_NAME tag instead).
//
// The function takes the following parameters:
//
//    - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//    - ok: TRUE if the two- or three-letter language code in lang_code is a
//      valid ISO-639 language code.
//
func TagCheckLanguageCode(langCode string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_check_language_code(_arg1)
	runtime.KeepAlive(langCode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagFreeformStringToUTF8: convenience function to read a string with unknown
// character encoding. If the string is already in UTF-8 encoding, it will be
// returned right away. If not it tries to detect byte-order-mark for UTF-16/32
// cases and use that. Otherwise, the environment will be searched for a number
// of environment variables (whose names are specified in the NULL-terminated
// string array env_vars) containing a list of character encodings to try/use.
// If none are specified, the current locale will be tried. If that also doesn't
// work, WINDOWS-1252/ISO-8859-1 is assumed (which will almost always succeed).
//
// The function takes the following parameters:
//
//    - data: string data.
//    - envVars: a NULL-terminated string array of environment variable names, or
//      NULL.
//
// The function returns the following values:
//
//    - utf8: newly-allocated string in UTF-8 encoding, or NULL.
//
func TagFreeformStringToUTF8(data string, envVars []string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gint
	var _arg3 **C.gchar // out
	var _cret *C.gchar  // in

	_arg2 = (C.gint)(len(data))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(data) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(data)), data)
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg3 = (**C.gchar)(C.calloc(C.size_t((len(envVars) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(envVars)+1)
			var zero *C.gchar
			out[len(envVars)] = zero
			for i := range envVars {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envVars[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_tag_freeform_string_to_utf8(_arg1, _arg2, _arg3)
	runtime.KeepAlive(data)
	runtime.KeepAlive(envVars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TagFromID3Tag looks up the GStreamer tag for a ID3v2 tag.
//
// The function takes the following parameters:
//
//    - id3Tag: ID3v2 tag to convert to GStreamer tag.
//
// The function returns the following values:
//
//    - utf8: corresponding GStreamer tag or NULL if none exists.
//
func TagFromID3Tag(id3Tag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id3Tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_from_id3_tag(_arg1)
	runtime.KeepAlive(id3Tag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagFromID3UserTag looks up the GStreamer tag for an ID3v2 user tag (e.g.
// description in TXXX frame or owner in UFID frame).
//
// The function takes the following parameters:
//
//    - typ: type of ID3v2 user tag (e.g. "TXXX" or "UDIF").
//    - id3UserTag: ID3v2 user tag to convert to GStreamer tag.
//
// The function returns the following values:
//
//    - utf8: corresponding GStreamer tag or NULL if none exists.
//
func TagFromID3UserTag(typ, id3UserTag string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(id3UserTag)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_tag_from_id3_user_tag(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(id3UserTag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagFromVorbisTag looks up the GStreamer tag for a vorbiscomment tag.
//
// The function takes the following parameters:
//
//    - vorbisTag: vorbiscomment tag to convert to GStreamer tag.
//
// The function returns the following values:
//
//    - utf8: corresponding GStreamer tag or NULL if none exists.
//
func TagFromVorbisTag(vorbisTag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(vorbisTag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_from_vorbis_tag(_arg1)
	runtime.KeepAlive(vorbisTag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetID3V2TagSize determines size of an ID3v2 tag on buffer containing at
// least ID3v2 header, i.e. at least T_TAG_ID3V2_HEADER_SIZE (10) bytes;.
//
// The function takes the following parameters:
//
//    - buffer holding ID3v2 tag (or at least the start of one).
//
// The function returns the following values:
//
//    - guint: size of tag, or 0 if header is invalid or too small.
//
func TagGetID3V2TagSize(buffer *gst.Buffer) uint {
	var _arg1 *C.GstBuffer // out
	var _cret C.guint      // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_tag_get_id3v2_tag_size(_arg1)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TagGetLanguageCodeISO6391 returns two-letter ISO-639-1 language code given a
// three-letter ISO-639-2 language code or two-letter ISO-639-1 language code
// (both are accepted for convenience).
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//    - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//    - utf8: two-letter ISO-639-1 language code string that maps to lang_code,
//      or NULL if no mapping is known. The returned string must not be modified
//      or freed.
//
func TagGetLanguageCodeISO6391(langCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_code_iso_639_1(_arg1)
	runtime.KeepAlive(langCode)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLanguageCodeISO6392B returns three-letter ISO-639-2 "bibliographic"
// language code given a two-letter ISO-639-1 language code or a three-letter
// ISO-639-2 language code (both are accepted for convenience).
//
// The "bibliographic" code is derived from the English name of the language
// (e.g. "ger" for German instead of "de" or "deu"). In most scenarios, the
// "terminological" codes are preferred.
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//    - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//    - utf8: three-letter ISO-639-2 language code string that maps to lang_code,
//      or NULL if no mapping is known. The returned string must not be modified
//      or freed.
//
func TagGetLanguageCodeISO6392B(langCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_code_iso_639_2B(_arg1)
	runtime.KeepAlive(langCode)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLanguageCodeISO6392T returns three-letter ISO-639-2 "terminological"
// language code given a two-letter ISO-639-1 language code or a three-letter
// ISO-639-2 language code (both are accepted for convenience).
//
// The "terminological" code is derived from the local name of the language
// (e.g. "deu" for German instead of "ger"). In most scenarios, the
// "terminological" codes are preferred over the "bibliographic" ones.
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//    - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//    - utf8: three-letter ISO-639-2 language code string that maps to lang_code,
//      or NULL if no mapping is known. The returned string must not be modified
//      or freed.
//
func TagGetLanguageCodeISO6392T(langCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_code_iso_639_2T(_arg1)
	runtime.KeepAlive(langCode)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLanguageCodes returns a list of known language codes (in form of
// two-letter ISO-639-1 codes). This is useful for UIs to build a list of
// available languages for tagging purposes (e.g. to tag an audio track
// appropriately in a video or audio editor).
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated string array with two-letter language codes. Free
//      with g_strfreev() when no longer needed.
//
func TagGetLanguageCodes() []string {
	var _cret **C.gchar // in

	_cret = C.gst_tag_get_language_codes()

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TagGetLanguageName returns the name of the language given an ISO-639 language
// code as found in a GST_TAG_LANGUAGE_CODE tag. The name will be translated
// according to the current locale (if the library was built against the
// iso-codes package, otherwise the English name will be returned).
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//    - languageCode: two or three-letter ISO-639 language code.
//
// The function returns the following values:
//
//    - utf8: language name in UTF-8 format, or NULL if language_code could not
//      be mapped to a language name. The returned string must not be modified
//      and does not need to freed; it will stay valid until the application is
//      terminated.
//
func TagGetLanguageName(languageCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(languageCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_name(_arg1)
	runtime.KeepAlive(languageCode)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLicenseDescription: get the description of a license, which is a
// translated description of the license's main features.
//
// The function takes the following parameters:
//
//    - licenseRef: license reference string in form of a URI, e.g.
//      "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//    - utf8: description of the license, or NULL if the license is unknown or a
//      description is not available.
//
func TagGetLicenseDescription(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_description(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLicenseFlags: get the flags of a license, which describe most of the
// features of a license in their most general form.
//
// The function takes the following parameters:
//
//    - licenseRef: license reference string in form of a URI, e.g.
//      "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//    - tagLicenseFlags flags of the license, or 0 if the license is unknown.
//
func TagGetLicenseFlags(licenseRef string) TagLicenseFlags {
	var _arg1 *C.gchar             // out
	var _cret C.GstTagLicenseFlags // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_flags(_arg1)
	runtime.KeepAlive(licenseRef)

	var _tagLicenseFlags TagLicenseFlags // out

	_tagLicenseFlags = TagLicenseFlags(_cret)

	return _tagLicenseFlags
}

// TagGetLicenseJurisdiction: get the jurisdiction code of a license. This is
// usually a two-letter ISO 3166-1 alpha-2 code, but there is also the special
// case of Scotland, for which no code exists and which is thus represented as
// "scotland".
//
// Known jurisdictions: ar, at, au, be, bg, br, ca, ch, cl, cn, co, de, dk, es,
// fi, fr, hr, hu, il, in, it, jp, kr, mk, mt, mx, my, nl, pe, pl, pt, scotland,
// se, si, tw, uk, us, za.
//
// The function takes the following parameters:
//
//    - licenseRef: license reference string in form of a URI, e.g.
//      "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//    - utf8: jurisdiction code of the license, or NULL if the license is unknown
//      or is not specific to a particular jurisdiction.
//
func TagGetLicenseJurisdiction(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_jurisdiction(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLicenseNick: get the nick name of a license, which is a short
// (untranslated) string such as e.g. "CC BY-NC-ND 2.0 UK".
//
// The function takes the following parameters:
//
//    - licenseRef: license reference string in form of a URI, e.g.
//      "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//    - utf8: nick name of the license, or NULL if the license is unknown.
//
func TagGetLicenseNick(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_nick(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLicenseTitle: get the title of a license, which is a short translated
// description of the license's features (generally not very pretty though).
//
// The function takes the following parameters:
//
//    - licenseRef: license reference string in form of a URI, e.g.
//      "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//    - utf8: title of the license, or NULL if the license is unknown or no title
//      is available.
//
func TagGetLicenseTitle(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_title(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLicenseVersion: get the version of a license.
//
// The function takes the following parameters:
//
//    - licenseRef: license reference string in form of a URI, e.g.
//      "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//    - utf8: version of the license, or NULL if the license is not known or has
//      no version.
//
func TagGetLicenseVersion(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_version(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetLicenses returns a list of known license references (in form of URIs).
// This is useful for UIs to build a list of available licenses for tagging
// purposes (e.g. to tag an audio track appropriately in a video or audio
// editor, or an image in a camera application).
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated array of license strings. Free with g_strfreev()
//      when no longer needed.
//
func TagGetLicenses() []string {
	var _cret **C.gchar // in

	_cret = C.gst_tag_get_licenses()

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TagID3GenreCount gets the number of ID3v1 genres that can be identified.
// Winamp genres are included.
//
// The function returns the following values:
//
//    - guint: number of ID3v1 genres that can be identified.
//
func TagID3GenreCount() uint {
	var _cret C.guint // in

	_cret = C.gst_tag_id3_genre_count()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TagID3GenreGet gets the ID3v1 genre name for a given ID.
//
// The function takes the following parameters:
//
//    - id: ID of genre to query.
//
// The function returns the following values:
//
//    - utf8: genre or NULL if no genre is associated with that ID.
//
func TagID3GenreGet(id uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(id)

	_cret = C.gst_tag_id3_genre_get(_arg1)
	runtime.KeepAlive(id)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagImageDataToImageSample: helper function for tag-reading plugins to create
// a Sample suitable to add to a TagList as an image tag (such as T_TAG_IMAGE or
// T_TAG_PREVIEW_IMAGE) from the encoded image data and an (optional) image
// type.
//
// Background: cover art and other images in tags are usually stored as a blob
// of binary image data, often accompanied by a MIME type or some other content
// type string (e.g. 'png', 'jpeg', 'jpg'). Sometimes there is also an 'image
// type' to indicate what kind of image this is (e.g. front cover, back cover,
// artist, etc.). The image data may also be an URI to the image rather than the
// image itself.
//
// In GStreamer, image tags are Sample<!-- -->s containing the raw image data,
// with the sample caps describing the content type of the image (e.g.
// image/jpeg, image/png, text/uri-list). The sample info may contain an
// additional 'image-type' field of TagImageType to describe the type of image
// (front cover, back cover etc.). T_TAG_PREVIEW_IMAGE tags should not carry an
// image type, their type is already indicated via the special tag name.
//
// This function will do various checks and typefind the encoded image data (we
// can't trust the declared mime type).
//
// The function takes the following parameters:
//
//    - imageData: (encoded) image.
//    - imageType: type of the image, or T_TAG_IMAGE_TYPE_UNDEFINED. Pass
//      T_TAG_IMAGE_TYPE_NONE if no image type should be set at all (e.g. for
//      preview images).
//
// The function returns the following values:
//
//    - sample: newly-allocated image sample for use in tag lists, or NULL.
//
func TagImageDataToImageSample(imageData []byte, imageType TagImageType) *gst.Sample {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _arg3 C.GstTagImageType // out
	var _cret *C.GstSample      // in

	_arg2 = (C.guint)(len(imageData))
	if len(imageData) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&imageData[0]))
	}
	_arg3 = C.GstTagImageType(imageType)

	_cret = C.gst_tag_image_data_to_image_sample(_arg1, _arg2, _arg3)
	runtime.KeepAlive(imageData)
	runtime.KeepAlive(imageType)

	var _sample *gst.Sample // out

	_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_sample)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _sample
}

// TagParseExtendedComment: convenience function to parse a
// GST_TAG_EXTENDED_COMMENT string and separate it into its components.
//
// If successful, key, lang and/or value will be set to newly allocated strings
// that you need to free with g_free() when done. key and lang may also be set
// to NULL by this function if there is no key or no language code in the
// extended comment string.
//
// The function takes the following parameters:
//
//    - extComment: extended comment string, see T_TAG_EXTENDED_COMMENT.
//    - failIfNoKey: whether to fail if strings are not in key=value form.
//
// The function returns the following values:
//
//    - key (optional): return location for the comment description key, or NULL.
//    - lang (optional): return location for the comment ISO-639 language code,
//      or NULL.
//    - value: return location for the actual comment string, or NULL.
//    - ok: TRUE if the string could be parsed, otherwise FALSE.
//
func TagParseExtendedComment(extComment string, failIfNoKey bool) (key, lang, value string, ok bool) {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // in
	var _arg3 *C.gchar   // in
	var _arg4 *C.gchar   // in
	var _arg5 C.gboolean // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(extComment)))
	defer C.free(unsafe.Pointer(_arg1))
	if failIfNoKey {
		_arg5 = C.TRUE
	}

	_cret = C.gst_tag_parse_extended_comment(_arg1, &_arg2, &_arg3, &_arg4, _arg5)
	runtime.KeepAlive(extComment)
	runtime.KeepAlive(failIfNoKey)

	var _key string   // out
	var _lang string  // out
	var _value string // out
	var _ok bool      // out

	if _arg2 != nil {
		_key = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_lang = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
	defer C.free(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _key, _lang, _value, _ok
}

// TagRegisterMusicbrainzTags registers additional musicbrainz-specific tags
// with the GStreamer tag system. Plugins and applications that use these tags
// should call this function before using them. Can be called multiple times.
func TagRegisterMusicbrainzTags() {
	C.gst_tag_register_musicbrainz_tags()
}

// TagToID3Tag looks up the ID3v2 tag for a GStreamer tag.
//
// The function takes the following parameters:
//
//    - gstTag: GStreamer tag to convert to vorbiscomment tag.
//
// The function returns the following values:
//
//    - utf8: corresponding ID3v2 tag or NULL if none exists.
//
func TagToID3Tag(gstTag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(gstTag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_to_id3_tag(_arg1)
	runtime.KeepAlive(gstTag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagToVorbisTag looks up the vorbiscomment tag for a GStreamer tag.
//
// The function takes the following parameters:
//
//    - gstTag: GStreamer tag to convert to vorbiscomment tag.
//
// The function returns the following values:
//
//    - utf8: corresponding vorbiscomment tag or NULL if none exists.
//
func TagToVorbisTag(gstTag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(gstTag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_to_vorbis_tag(_arg1)
	runtime.KeepAlive(gstTag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagXmpListSchemas gets the list of supported schemas in the xmp lib.
//
// The function returns the following values:
//
//    - utf8s: NULL terminated array of strings with the schema names.
//
func TagXmpListSchemas() []string {
	var _cret **C.gchar // in

	_cret = C.gst_tag_xmp_list_schemas()

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}
