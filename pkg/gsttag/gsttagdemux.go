// Code generated by girgen. DO NOT EDIT.

package gsttag

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/tag/tag.h>
// extern gboolean _gotk4_gsttag1_TagDemuxClass_identify_tag(GstTagDemux*, GstBuffer*, gboolean, guint*);
// gboolean _gotk4_gsttag1_TagDemux_virtual_identify_tag(void* fnptr, GstTagDemux* arg0, GstBuffer* arg1, gboolean arg2, guint* arg3) {
//   return ((gboolean (*)(GstTagDemux*, GstBuffer*, gboolean, guint*))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeTagDemuxResult = coreglib.Type(C.gst_tag_demux_result_get_type())
	GTypeTagDemux       = coreglib.Type(C.gst_tag_demux_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTagDemuxResult, F: marshalTagDemuxResult},
		coreglib.TypeMarshaler{T: GTypeTagDemux, F: marshalTagDemux},
	})
}

// TagDemuxResult: result values from the parse_tag virtual function.
type TagDemuxResult C.gint

const (
	// TagDemuxResultBrokenTag: cannot parse tag, just skip it.
	TagDemuxResultBrokenTag TagDemuxResult = iota
	// TagDemuxResultAgain: call again with less or more data.
	TagDemuxResultAgain
	// TagDemuxResultOK: parsed tag successfully.
	TagDemuxResultOK
)

func marshalTagDemuxResult(p uintptr) (interface{}, error) {
	return TagDemuxResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagDemuxResult.
func (t TagDemuxResult) String() string {
	switch t {
	case TagDemuxResultBrokenTag:
		return "BrokenTag"
	case TagDemuxResultAgain:
		return "Again"
	case TagDemuxResultOK:
		return "OK"
	default:
		return fmt.Sprintf("TagDemuxResult(%d)", t)
	}
}

// TagDemuxOverrides contains methods that are overridable.
type TagDemuxOverrides struct {
	// The function takes the following parameters:
	//
	//    - buffer
	//    - startTag
	//    - tagSize
	//
	// The function returns the following values:
	//
	IdentifyTag func(buffer *gst.Buffer, startTag bool, tagSize *uint) bool
}

func defaultTagDemuxOverrides(v *TagDemux) TagDemuxOverrides {
	return TagDemuxOverrides{
		IdentifyTag: v.identifyTag,
	}
}

// TagDemux provides a base class for demuxing tags at the beginning or end of a
// stream and handles things like typefinding, querying, seeking, and different
// modes of operation (chain-based, pull_range-based, and providing downstream
// elements with random access if upstream supports that). The tag is stripped
// from the output, and all offsets are adjusted for the tag sizes, so that to
// the downstream element the stream will appear as if there was no tag at all.
// Also, once the tag has been parsed, GstTagDemux will try to determine the
// media type of the resulting stream and add a source pad with the appropriate
// caps in order to facilitate auto-plugging.
//
//
// Deriving from GstTagDemux
//
// Subclasses have to do four things:
//
//    * In their base init function, they must add a pad template for the sink
//      pad to the element class, describing the media type they can parse in
//      the caps of the pad template.
//    * In their class init function, they must override
//      GST_TAG_DEMUX_CLASS(demux_klass)->identify_tag with their own identify
//      function.
//    * In their class init function, they must override
//    GST_TAG_DEMUX_CLASS(demux_klass)->parse_tag with their own parse
//    function.
//    * In their class init function, they must also set
//      GST_TAG_DEMUX_CLASS(demux_klass)->min_start_size and/or
//    GST_TAG_DEMUX_CLASS(demux_klass)->min_end_size to the minimum size required
//    for the identify function to decide whether the stream has a supported tag
//    or not. A class parsing ID3v1 tags, for example, would set min_end_size to
//    128 bytes.
type TagDemux struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*TagDemux)(nil)
)

// TagDemuxer describes types inherited from class TagDemux.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TagDemuxer interface {
	coreglib.Objector
	baseTagDemux() *TagDemux
}

var _ TagDemuxer = (*TagDemux)(nil)

func init() {
	coreglib.RegisterClassInfo[*TagDemux, *TagDemuxClass, TagDemuxOverrides](
		GTypeTagDemux,
		initTagDemuxClass,
		wrapTagDemux,
		defaultTagDemuxOverrides,
	)
}

func initTagDemuxClass(gclass unsafe.Pointer, overrides TagDemuxOverrides, classInitFunc func(*TagDemuxClass)) {
	pclass := (*C.GstTagDemuxClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTagDemux))))

	if overrides.IdentifyTag != nil {
		pclass.identify_tag = (*[0]byte)(C._gotk4_gsttag1_TagDemuxClass_identify_tag)
	}

	if classInitFunc != nil {
		class := (*TagDemuxClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTagDemux(obj *coreglib.Object) *TagDemux {
	return &TagDemux{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTagDemux(p uintptr) (interface{}, error) {
	return wrapTagDemux(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *TagDemux) baseTagDemux() *TagDemux {
	return v
}

// BaseTagDemux returns the underlying base object.
func BaseTagDemux(obj TagDemuxer) *TagDemux {
	return obj.baseTagDemux()
}

// The function takes the following parameters:
//
//    - buffer
//    - startTag
//    - tagSize
//
// The function returns the following values:
//
func (demux *TagDemux) identifyTag(buffer *gst.Buffer, startTag bool, tagSize *uint) bool {
	gclass := (*C.GstTagDemuxClass)(coreglib.PeekParentClass(demux))
	fnarg := gclass.identify_tag

	var _arg0 *C.GstTagDemux // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 C.gboolean     // out
	var _arg3 *C.guint       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTagDemux)(unsafe.Pointer(coreglib.InternObject(demux).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	if startTag {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.guint)(unsafe.Pointer(tagSize))

	_cret = C._gotk4_gsttag1_TagDemux_virtual_identify_tag(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(demux)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startTag)
	runtime.KeepAlive(tagSize)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagDemuxClass structure. See documentation at beginning of section for
// details about what subclasses need to override and do.
//
// An instance of this type is always passed by reference.
type TagDemuxClass struct {
	*tagDemuxClass
}

// tagDemuxClass is the struct that's finalized.
type tagDemuxClass struct {
	native *C.GstTagDemuxClass
}

// ParentClass: parent class.
func (t *TagDemuxClass) ParentClass() *gst.ElementClass {
	valptr := &t.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MinStartSize: minimum size required to identify a tag at the start and
// determine its total size. Set to 0 if not interested in start tags.
// Subclasses should set this in their class_init function.
func (t *TagDemuxClass) MinStartSize() uint {
	valptr := &t.native.min_start_size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// MinEndSize: minimum size required to identify a tag at the end and determine
// its total size. Set to 0 if not interested in end tags. Subclasses should set
// this in their class_init function.
func (t *TagDemuxClass) MinEndSize() uint {
	valptr := &t.native.min_end_size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}
