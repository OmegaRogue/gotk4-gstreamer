// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
// void _gotk4_gstvideo1_Navigation_virtual_send_event(void* fnptr, GstNavigation* arg0, GstStructure* arg1) {
//   ((void (*)(GstNavigation*, GstStructure*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeNavigationCommand     = coreglib.Type(C.gst_navigation_command_get_type())
	GTypeNavigationEventType   = coreglib.Type(C.gst_navigation_event_type_get_type())
	GTypeNavigationMessageType = coreglib.Type(C.gst_navigation_message_type_get_type())
	GTypeNavigationQueryType   = coreglib.Type(C.gst_navigation_query_type_get_type())
	GTypeNavigation            = coreglib.Type(C.gst_navigation_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNavigationCommand, F: marshalNavigationCommand},
		coreglib.TypeMarshaler{T: GTypeNavigationEventType, F: marshalNavigationEventType},
		coreglib.TypeMarshaler{T: GTypeNavigationMessageType, F: marshalNavigationMessageType},
		coreglib.TypeMarshaler{T: GTypeNavigationQueryType, F: marshalNavigationQueryType},
		coreglib.TypeMarshaler{T: GTypeNavigation, F: marshalNavigation},
	})
}

// NavigationCommand: set of commands that may be issued to an element providing
// the Navigation interface. The available commands can be queried via the
// gst_navigation_query_new_commands() query.
//
// For convenience in handling DVD navigation, the MENU commands are aliased as:
// GST_NAVIGATION_COMMAND_DVD_MENU = GST_NAVIGATION_COMMAND_MENU1
// GST_NAVIGATION_COMMAND_DVD_TITLE_MENU = GST_NAVIGATION_COMMAND_MENU2
// GST_NAVIGATION_COMMAND_DVD_ROOT_MENU = GST_NAVIGATION_COMMAND_MENU3
// GST_NAVIGATION_COMMAND_DVD_SUBPICTURE_MENU = GST_NAVIGATION_COMMAND_MENU4
// GST_NAVIGATION_COMMAND_DVD_AUDIO_MENU = GST_NAVIGATION_COMMAND_MENU5
// GST_NAVIGATION_COMMAND_DVD_ANGLE_MENU = GST_NAVIGATION_COMMAND_MENU6
// GST_NAVIGATION_COMMAND_DVD_CHAPTER_MENU = GST_NAVIGATION_COMMAND_MENU7.
type NavigationCommand C.gint

const (
	// NavigationCommandInvalid: invalid command entry.
	NavigationCommandInvalid NavigationCommand = 0
	// NavigationCommandMenu1: execute navigation menu command 1. For DVD, this
	// enters the DVD root menu, or exits back to the title from the menu.
	NavigationCommandMenu1 NavigationCommand = 1
	// NavigationCommandMenu2: execute navigation menu command 2. For DVD, this
	// jumps to the DVD title menu.
	NavigationCommandMenu2 NavigationCommand = 2
	// NavigationCommandMenu3: execute navigation menu command 3. For DVD, this
	// jumps into the DVD root menu.
	NavigationCommandMenu3 NavigationCommand = 3
	// NavigationCommandMenu4: execute navigation menu command 4. For DVD, this
	// jumps to the Subpicture menu.
	NavigationCommandMenu4 NavigationCommand = 4
	// NavigationCommandMenu5: execute navigation menu command 5. For DVD, the
	// jumps to the audio menu.
	NavigationCommandMenu5 NavigationCommand = 5
	// NavigationCommandMenu6: execute navigation menu command 6. For DVD, this
	// jumps to the angles menu.
	NavigationCommandMenu6 NavigationCommand = 6
	// NavigationCommandMenu7: execute navigation menu command 7. For DVD, this
	// jumps to the chapter menu.
	NavigationCommandMenu7 NavigationCommand = 7
	// NavigationCommandLeft: select the next button to the left in a menu, if
	// such a button exists.
	NavigationCommandLeft NavigationCommand = 20
	// NavigationCommandRight: select the next button to the right in a menu, if
	// such a button exists.
	NavigationCommandRight NavigationCommand = 21
	// NavigationCommandUp: select the button above the current one in a menu,
	// if such a button exists.
	NavigationCommandUp NavigationCommand = 22
	// NavigationCommandDown: select the button below the current one in a menu,
	// if such a button exists.
	NavigationCommandDown NavigationCommand = 23
	// NavigationCommandActivate: activate (click) the currently selected button
	// in a menu, if such a button exists.
	NavigationCommandActivate NavigationCommand = 24
	// NavigationCommandPrevAngle: switch to the previous angle in a multiangle
	// feature.
	NavigationCommandPrevAngle NavigationCommand = 30
	// NavigationCommandNextAngle: switch to the next angle in a multiangle
	// feature.
	NavigationCommandNextAngle NavigationCommand = 31
)

func marshalNavigationCommand(p uintptr) (interface{}, error) {
	return NavigationCommand(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NavigationCommand.
func (n NavigationCommand) String() string {
	switch n {
	case NavigationCommandInvalid:
		return "Invalid"
	case NavigationCommandMenu1:
		return "Menu1"
	case NavigationCommandMenu2:
		return "Menu2"
	case NavigationCommandMenu3:
		return "Menu3"
	case NavigationCommandMenu4:
		return "Menu4"
	case NavigationCommandMenu5:
		return "Menu5"
	case NavigationCommandMenu6:
		return "Menu6"
	case NavigationCommandMenu7:
		return "Menu7"
	case NavigationCommandLeft:
		return "Left"
	case NavigationCommandRight:
		return "Right"
	case NavigationCommandUp:
		return "Up"
	case NavigationCommandDown:
		return "Down"
	case NavigationCommandActivate:
		return "Activate"
	case NavigationCommandPrevAngle:
		return "PrevAngle"
	case NavigationCommandNextAngle:
		return "NextAngle"
	default:
		return fmt.Sprintf("NavigationCommand(%d)", n)
	}
}

// NavigationEventType: enum values for the various events that an element
// implementing the GstNavigation interface might send up the pipeline.
type NavigationEventType C.gint

const (
	// NavigationEventInvalid: returned from gst_navigation_event_get_type()
	// when the passed event is not a navigation event.
	NavigationEventInvalid NavigationEventType = iota
	// NavigationEventKeyPress: key press event. Use
	// gst_navigation_event_parse_key_event() to extract the details from the
	// event.
	NavigationEventKeyPress
	// NavigationEventKeyRelease: key release event. Use
	// gst_navigation_event_parse_key_event() to extract the details from the
	// event.
	NavigationEventKeyRelease
	// NavigationEventMouseButtonPress: mouse button press event. Use
	// gst_navigation_event_parse_mouse_button_event() to extract the details
	// from the event.
	NavigationEventMouseButtonPress
	// NavigationEventMouseButtonRelease: mouse button release event. Use
	// gst_navigation_event_parse_mouse_button_event() to extract the details
	// from the event.
	NavigationEventMouseButtonRelease
	// NavigationEventMouseMove: mouse movement event. Use
	// gst_navigation_event_parse_mouse_move_event() to extract the details from
	// the event.
	NavigationEventMouseMove
	// NavigationEventCommand: navigation command event. Use
	// gst_navigation_event_parse_command() to extract the details from the
	// event.
	NavigationEventCommand
	// NavigationEventMouseScroll: mouse scroll event. Use
	// gst_navigation_event_parse_mouse_scroll_event() to extract the details
	// from the event.
	NavigationEventMouseScroll
)

func marshalNavigationEventType(p uintptr) (interface{}, error) {
	return NavigationEventType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NavigationEventType.
func (n NavigationEventType) String() string {
	switch n {
	case NavigationEventInvalid:
		return "Invalid"
	case NavigationEventKeyPress:
		return "KeyPress"
	case NavigationEventKeyRelease:
		return "KeyRelease"
	case NavigationEventMouseButtonPress:
		return "MouseButtonPress"
	case NavigationEventMouseButtonRelease:
		return "MouseButtonRelease"
	case NavigationEventMouseMove:
		return "MouseMove"
	case NavigationEventCommand:
		return "Command"
	case NavigationEventMouseScroll:
		return "MouseScroll"
	default:
		return fmt.Sprintf("NavigationEventType(%d)", n)
	}
}

// NavigationMessageType: set of notifications that may be received on the bus
// when navigation related status changes.
type NavigationMessageType C.gint

const (
	// NavigationMessageInvalid: returned from gst_navigation_message_get_type()
	// when the passed message is not a navigation message.
	NavigationMessageInvalid NavigationMessageType = iota
	// NavigationMessageMouseOver: sent when the mouse moves over or leaves a
	// clickable region of the output, such as a DVD menu button.
	NavigationMessageMouseOver
	// NavigationMessageCommandsChanged: sent when the set of available commands
	// changes and should re-queried by interested applications.
	NavigationMessageCommandsChanged
	// NavigationMessageAnglesChanged: sent when display angles in a multi-angle
	// feature (such as a multiangle DVD) change - either angles have appeared
	// or disappeared.
	NavigationMessageAnglesChanged
	// NavigationMessageEvent: sent when a navigation event was not handled by
	// any element in the pipeline (Since: 1.6).
	NavigationMessageEvent
)

func marshalNavigationMessageType(p uintptr) (interface{}, error) {
	return NavigationMessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NavigationMessageType.
func (n NavigationMessageType) String() string {
	switch n {
	case NavigationMessageInvalid:
		return "Invalid"
	case NavigationMessageMouseOver:
		return "MouseOver"
	case NavigationMessageCommandsChanged:
		return "CommandsChanged"
	case NavigationMessageAnglesChanged:
		return "AnglesChanged"
	case NavigationMessageEvent:
		return "Event"
	default:
		return fmt.Sprintf("NavigationMessageType(%d)", n)
	}
}

// NavigationQueryType types of navigation interface queries.
type NavigationQueryType C.gint

const (
	// NavigationQueryInvalid: invalid query.
	NavigationQueryInvalid NavigationQueryType = iota
	// NavigationQueryCommands: command query.
	NavigationQueryCommands
	// NavigationQueryAngles: viewing angle query.
	NavigationQueryAngles
)

func marshalNavigationQueryType(p uintptr) (interface{}, error) {
	return NavigationQueryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NavigationQueryType.
func (n NavigationQueryType) String() string {
	switch n {
	case NavigationQueryInvalid:
		return "Invalid"
	case NavigationQueryCommands:
		return "Commands"
	case NavigationQueryAngles:
		return "Angles"
	default:
		return fmt.Sprintf("NavigationQueryType(%d)", n)
	}
}

// Navigation interface is used for creating and injecting navigation related
// events such as mouse button presses, cursor motion and key presses. The
// associated library also provides methods for parsing received events, and for
// sending and receiving navigation related bus events. One main usecase is DVD
// menu navigation.
//
// The main parts of the API are:
//
// * The GstNavigation interface, implemented by elements which provide an
// application with the ability to create and inject navigation events into the
// pipeline. * GstNavigation event handling API. GstNavigation events are
// created in response to calls on a GstNavigation interface implementation, and
// sent in the pipeline. Upstream elements can use the navigation event API
// functions to parse the contents of received messages.
//
// * GstNavigation message handling API. GstNavigation messages may be sent on
// the message bus to inform applications of navigation related changes in the
// pipeline, such as the mouse moving over a clickable region, or the set of
// available angles changing.
//
// The GstNavigation message functions provide functions for creating and
// parsing custom bus messages for signaling GstNavigation changes.
//
// Navigation wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Navigation struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Navigation)(nil)
)

// Navigationer describes Navigation's interface methods.
type Navigationer interface {
	coreglib.Objector

	// SendCommand sends the indicated command to the navigation interface.
	SendCommand(command NavigationCommand)
	SendEvent(structure *gst.Structure)
	SendKeyEvent(event, key string)
	// SendMouseEvent sends a mouse event to the navigation interface.
	SendMouseEvent(event string, button int, x, y float64)
	// SendMouseScrollEvent sends a mouse scroll event to the navigation
	// interface.
	SendMouseScrollEvent(x, y, deltaX, deltaY float64)
}

var _ Navigationer = (*Navigation)(nil)

func wrapNavigation(obj *coreglib.Object) *Navigation {
	return &Navigation{
		Object: obj,
	}
}

func marshalNavigation(p uintptr) (interface{}, error) {
	return wrapNavigation(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SendCommand sends the indicated command to the navigation interface.
//
// The function takes the following parameters:
//
//    - command to issue.
//
func (navigation *Navigation) SendCommand(command NavigationCommand) {
	var _arg0 *C.GstNavigation       // out
	var _arg1 C.GstNavigationCommand // out

	_arg0 = (*C.GstNavigation)(unsafe.Pointer(coreglib.InternObject(navigation).Native()))
	_arg1 = C.GstNavigationCommand(command)

	C.gst_navigation_send_command(_arg0, _arg1)
	runtime.KeepAlive(navigation)
	runtime.KeepAlive(command)
}

// The function takes the following parameters:
//
func (navigation *Navigation) SendEvent(structure *gst.Structure) {
	var _arg0 *C.GstNavigation // out
	var _arg1 *C.GstStructure  // out

	_arg0 = (*C.GstNavigation)(unsafe.Pointer(coreglib.InternObject(navigation).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_navigation_send_event(_arg0, _arg1)
	runtime.KeepAlive(navigation)
	runtime.KeepAlive(structure)
}

// The function takes the following parameters:
//
//    - event: type of the key event. Recognised values are "key-press" and
//      "key-release".
//    - key: character representation of the key. This is typically as produced
//      by XKeysymToString.
//
func (navigation *Navigation) SendKeyEvent(event, key string) {
	var _arg0 *C.GstNavigation // out
	var _arg1 *C.char          // out
	var _arg2 *C.char          // out

	_arg0 = (*C.GstNavigation)(unsafe.Pointer(coreglib.InternObject(navigation).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(event)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_navigation_send_key_event(_arg0, _arg1, _arg2)
	runtime.KeepAlive(navigation)
	runtime.KeepAlive(event)
	runtime.KeepAlive(key)
}

// SendMouseEvent sends a mouse event to the navigation interface. Mouse event
// coordinates are sent relative to the display space of the related output
// area. This is usually the size in pixels of the window associated with the
// element implementing the Navigation interface.
//
// The function takes the following parameters:
//
//    - event: type of mouse event, as a text string. Recognised values are
//      "mouse-button-press", "mouse-button-release" and "mouse-move".
//    - button number of the button being pressed or released. Pass 0 for
//      mouse-move events.
//    - x coordinate of the mouse event.
//    - y coordinate of the mouse event.
//
func (navigation *Navigation) SendMouseEvent(event string, button int, x, y float64) {
	var _arg0 *C.GstNavigation // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out

	_arg0 = (*C.GstNavigation)(unsafe.Pointer(coreglib.InternObject(navigation).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(event)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(button)
	_arg3 = C.double(x)
	_arg4 = C.double(y)

	C.gst_navigation_send_mouse_event(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(navigation)
	runtime.KeepAlive(event)
	runtime.KeepAlive(button)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// SendMouseScrollEvent sends a mouse scroll event to the navigation interface.
// Mouse event coordinates are sent relative to the display space of the related
// output area. This is usually the size in pixels of the window associated with
// the element implementing the Navigation interface.
//
// The function takes the following parameters:
//
//    - x coordinate of the mouse event.
//    - y coordinate of the mouse event.
//    - deltaX: delta_x coordinate of the mouse event.
//    - deltaY: delta_y coordinate of the mouse event.
//
func (navigation *Navigation) SendMouseScrollEvent(x, y, deltaX, deltaY float64) {
	var _arg0 *C.GstNavigation // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out

	_arg0 = (*C.GstNavigation)(unsafe.Pointer(coreglib.InternObject(navigation).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)
	_arg3 = C.double(deltaX)
	_arg4 = C.double(deltaY)

	C.gst_navigation_send_mouse_scroll_event(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(navigation)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(deltaX)
	runtime.KeepAlive(deltaY)
}

// The function takes the following parameters:
//
func (navigation *Navigation) sendEvent(structure *gst.Structure) {
	gclass := (*C.GstNavigationInterface)(coreglib.PeekParentClass(navigation))
	fnarg := gclass.send_event

	var _arg0 *C.GstNavigation // out
	var _arg1 *C.GstStructure  // out

	_arg0 = (*C.GstNavigation)(unsafe.Pointer(coreglib.InternObject(navigation).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C._gotk4_gstvideo1_Navigation_virtual_send_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(navigation)
	runtime.KeepAlive(structure)
}

// NavigationEventGetType: inspect a Event and return the NavigationEventType of
// the event, or T_NAVIGATION_EVENT_INVALID if the event is not a Navigation
// event.
//
// The function takes the following parameters:
//
//    - event to inspect.
//
// The function returns the following values:
//
func NavigationEventGetType(event *gst.Event) NavigationEventType {
	var _arg1 *C.GstEvent              // out
	var _cret C.GstNavigationEventType // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_get_type(_arg1)
	runtime.KeepAlive(event)

	var _navigationEventType NavigationEventType // out

	_navigationEventType = NavigationEventType(_cret)

	return _navigationEventType
}

// NavigationEventParseCommand: inspect a Navigation command event and retrieve
// the enum value of the associated command.
//
// The function takes the following parameters:
//
//    - event to inspect.
//
// The function returns the following values:
//
//    - command (optional): pointer to GstNavigationCommand to receive the type
//      of the navigation event.
//    - ok: TRUE if the navigation command could be extracted, otherwise FALSE.
//
func NavigationEventParseCommand(event *gst.Event) (NavigationCommand, bool) {
	var _arg1 *C.GstEvent            // out
	var _arg2 C.GstNavigationCommand // in
	var _cret C.gboolean             // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_parse_command(_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _command NavigationCommand // out
	var _ok bool                   // out

	_command = NavigationCommand(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _command, _ok
}

// The function takes the following parameters:
//
//    - event to inspect.
//
// The function returns the following values:
//
//    - key (optional): pointer to a location to receive the string identifying
//      the key press. The returned string is owned by the event, and valid only
//      until the event is unreffed.
//    - ok
//
func NavigationEventParseKeyEvent(event *gst.Event) (string, bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 *C.gchar    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_parse_key_event(_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _key string // out
	var _ok bool    // out

	if _arg2 != nil {
		_key = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _key, _ok
}

// NavigationEventParseMouseButtonEvent: retrieve the details of either a
// Navigation mouse button press event or a mouse button release event.
// Determine which type the event is using gst_navigation_event_get_type() to
// retrieve the NavigationEventType.
//
// The function takes the following parameters:
//
//    - event to inspect.
//
// The function returns the following values:
//
//    - button (optional): pointer to a gint that will receive the button number
//      associated with the event.
//    - x (optional): pointer to a gdouble to receive the x coordinate of the
//      mouse button event.
//    - y (optional): pointer to a gdouble to receive the y coordinate of the
//      mouse button event.
//    - ok: TRUE if the button number and both coordinates could be extracted,
//      otherwise FALSE.
//
func NavigationEventParseMouseButtonEvent(event *gst.Event) (button int, x, y float64, ok bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 C.gint      // in
	var _arg3 C.gdouble   // in
	var _arg4 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_parse_mouse_button_event(_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _button int // out
	var _x float64  // out
	var _y float64  // out
	var _ok bool    // out

	_button = int(_arg2)
	_x = float64(_arg3)
	_y = float64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _button, _x, _y, _ok
}

// NavigationEventParseMouseMoveEvent: inspect a Navigation mouse movement event
// and extract the coordinates of the event.
//
// The function takes the following parameters:
//
//    - event to inspect.
//
// The function returns the following values:
//
//    - x (optional): pointer to a gdouble to receive the x coordinate of the
//      mouse movement.
//    - y (optional): pointer to a gdouble to receive the y coordinate of the
//      mouse movement.
//    - ok: TRUE if both coordinates could be extracted, otherwise FALSE.
//
func NavigationEventParseMouseMoveEvent(event *gst.Event) (x, y float64, ok bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 C.gdouble   // in
	var _arg3 C.gdouble   // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_navigation_event_parse_mouse_move_event(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(event)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg2)
	_y = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// NavigationMessageGetType: check a bus message to see if it is a Navigation
// event, and return the NavigationMessageType identifying the type of the
// message if so.
//
// The function takes the following parameters:
//
//    - message to inspect.
//
// The function returns the following values:
//
//    - navigationMessageType: type of the Message, or
//      T_NAVIGATION_MESSAGE_INVALID if the message is not a Navigation
//      notification.
//
func NavigationMessageGetType(message *gst.Message) NavigationMessageType {
	var _arg1 *C.GstMessage              // out
	var _cret C.GstNavigationMessageType // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_navigation_message_get_type(_arg1)
	runtime.KeepAlive(message)

	var _navigationMessageType NavigationMessageType // out

	_navigationMessageType = NavigationMessageType(_cret)

	return _navigationMessageType
}

// NavigationMessageNewAnglesChanged creates a new Navigation message with type
// T_NAVIGATION_MESSAGE_ANGLES_CHANGED for notifying an application that the
// current angle, or current number of angles available in a multiangle video
// has changed.
//
// The function takes the following parameters:
//
//    - src to set as source of the new message.
//    - curAngle: currently selected angle.
//    - nAngles: number of viewing angles now available.
//
// The function returns the following values:
//
//    - message: new Message.
//
func NavigationMessageNewAnglesChanged(src gst.GstObjector, curAngle, nAngles uint) *gst.Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.guint       // out
	var _arg3 C.guint       // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = C.guint(curAngle)
	_arg3 = C.guint(nAngles)

	_cret = C.gst_navigation_message_new_angles_changed(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(curAngle)
	runtime.KeepAlive(nAngles)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NavigationMessageNewCommandsChanged creates a new Navigation message with
// type T_NAVIGATION_MESSAGE_COMMANDS_CHANGED.
//
// The function takes the following parameters:
//
//    - src to set as source of the new message.
//
// The function returns the following values:
//
//    - message: new Message.
//
func NavigationMessageNewCommandsChanged(src gst.GstObjector) *gst.Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_navigation_message_new_commands_changed(_arg1)
	runtime.KeepAlive(src)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NavigationMessageNewMouseOver creates a new Navigation message with type
// T_NAVIGATION_MESSAGE_MOUSE_OVER.
//
// The function takes the following parameters:
//
//    - src to set as source of the new message.
//    - active: TRUE if the mouse has entered a clickable area of the display.
//      FALSE if it over a non-clickable area.
//
// The function returns the following values:
//
//    - message: new Message.
//
func NavigationMessageNewMouseOver(src gst.GstObjector, active bool) *gst.Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gboolean    // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if active {
		_arg2 = C.TRUE
	}

	_cret = C.gst_navigation_message_new_mouse_over(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(active)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NavigationMessageParseAnglesChanged: parse a Navigation message of type
// GST_NAVIGATION_MESSAGE_ANGLES_CHANGED and extract the cur_angle and n_angles
// parameters.
//
// The function takes the following parameters:
//
//    - message to inspect.
//
// The function returns the following values:
//
//    - curAngle (optional): pointer to a #guint to receive the new current angle
//      number, or NULL.
//    - nAngles (optional): pointer to a #guint to receive the new angle count,
//      or NULL.
//    - ok: TRUE if the message could be successfully parsed. FALSE if not.
//
func NavigationMessageParseAnglesChanged(message *gst.Message) (curAngle, nAngles uint, ok bool) {
	var _arg1 *C.GstMessage // out
	var _arg2 C.guint       // in
	var _arg3 C.guint       // in
	var _cret C.gboolean    // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_navigation_message_parse_angles_changed(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _curAngle uint // out
	var _nAngles uint  // out
	var _ok bool       // out

	_curAngle = uint(_arg2)
	_nAngles = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _curAngle, _nAngles, _ok
}

// NavigationMessageParseMouseOver: parse a Navigation message of type
// T_NAVIGATION_MESSAGE_MOUSE_OVER and extract the active/inactive flag. If the
// mouse over event is marked active, it indicates that the mouse is over a
// clickable area.
//
// The function takes the following parameters:
//
//    - message to inspect.
//
// The function returns the following values:
//
//    - active (optional): pointer to a gboolean to receive the active/inactive
//      state, or NULL.
//    - ok: TRUE if the message could be successfully parsed. FALSE if not.
//
func NavigationMessageParseMouseOver(message *gst.Message) (active, ok bool) {
	var _arg1 *C.GstMessage // out
	var _arg2 C.gboolean    // in
	var _cret C.gboolean    // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_navigation_message_parse_mouse_over(_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _active bool // out
	var _ok bool     // out

	if _arg2 != 0 {
		_active = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _active, _ok
}

// NavigationQueryGetType: inspect a Query and return the NavigationQueryType
// associated with it if it is a Navigation query.
//
// The function takes the following parameters:
//
//    - query to inspect.
//
// The function returns the following values:
//
//    - navigationQueryType of the query, or T_NAVIGATION_QUERY_INVALID.
//
func NavigationQueryGetType(query *gst.Query) NavigationQueryType {
	var _arg1 *C.GstQuery              // out
	var _cret C.GstNavigationQueryType // in

	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_navigation_query_get_type(_arg1)
	runtime.KeepAlive(query)

	var _navigationQueryType NavigationQueryType // out

	_navigationQueryType = NavigationQueryType(_cret)

	return _navigationQueryType
}

// NavigationQueryNewAngles: create a new Navigation angles query. When
// executed, it will query the pipeline for the set of currently available
// angles, which may be greater than one in a multiangle video.
//
// The function returns the following values:
//
//    - query: new query.
//
func NavigationQueryNewAngles() *gst.Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_navigation_query_new_angles()

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NavigationQueryNewCommands: create a new Navigation commands query. When
// executed, it will query the pipeline for the set of currently available
// commands.
//
// The function returns the following values:
//
//    - query: new query.
//
func NavigationQueryNewCommands() *gst.Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_navigation_query_new_commands()

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NavigationQueryParseAngles: parse the current angle number in the Navigation
// angles query into the #guint pointed to by the cur_angle variable, and the
// number of available angles into the #guint pointed to by the n_angles
// variable.
//
// The function takes the following parameters:
//
//    - query: Query.
//
// The function returns the following values:
//
//    - curAngle (optional): pointer to a #guint into which to store the
//      currently selected angle value from the query, or NULL.
//    - nAngles (optional): pointer to a #guint into which to store the number of
//      angles value from the query, or NULL.
//    - ok: TRUE if the query could be successfully parsed. FALSE if not.
//
func NavigationQueryParseAngles(query *gst.Query) (curAngle, nAngles uint, ok bool) {
	var _arg1 *C.GstQuery // out
	var _arg2 C.guint     // in
	var _arg3 C.guint     // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_navigation_query_parse_angles(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)

	var _curAngle uint // out
	var _nAngles uint  // out
	var _ok bool       // out

	_curAngle = uint(_arg2)
	_nAngles = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _curAngle, _nAngles, _ok
}

// NavigationQueryParseCommandsLength: parse the number of commands in the
// Navigation commands query.
//
// The function takes the following parameters:
//
//    - query: Query.
//
// The function returns the following values:
//
//    - nCmds (optional): number of commands in this query.
//    - ok: TRUE if the query could be successfully parsed. FALSE if not.
//
func NavigationQueryParseCommandsLength(query *gst.Query) (uint, bool) {
	var _arg1 *C.GstQuery // out
	var _arg2 C.guint     // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_navigation_query_parse_commands_length(_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _nCmds uint // out
	var _ok bool    // out

	_nCmds = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _nCmds, _ok
}

// NavigationQueryParseCommandsNth: parse the Navigation command query and
// retrieve the nth command from it into cmd. If the list contains less elements
// than nth, cmd will be set to T_NAVIGATION_COMMAND_INVALID.
//
// The function takes the following parameters:
//
//    - query: Query.
//    - nth command to retrieve.
//
// The function returns the following values:
//
//    - cmd (optional): pointer to store the nth command into.
//    - ok: TRUE if the query could be successfully parsed. FALSE if not.
//
func NavigationQueryParseCommandsNth(query *gst.Query, nth uint) (NavigationCommand, bool) {
	var _arg1 *C.GstQuery            // out
	var _arg2 C.guint                // out
	var _arg3 C.GstNavigationCommand // in
	var _cret C.gboolean             // in

	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg2 = C.guint(nth)

	_cret = C.gst_navigation_query_parse_commands_nth(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(nth)

	var _cmd NavigationCommand // out
	var _ok bool               // out

	_cmd = NavigationCommand(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _cmd, _ok
}

// NavigationQuerySetAngles: set the Navigation angles query result field in
// query.
//
// The function takes the following parameters:
//
//    - query: Query.
//    - curAngle: current viewing angle to set.
//    - nAngles: number of viewing angles to set.
//
func NavigationQuerySetAngles(query *gst.Query, curAngle, nAngles uint) {
	var _arg1 *C.GstQuery // out
	var _arg2 C.guint     // out
	var _arg3 C.guint     // out

	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg2 = C.guint(curAngle)
	_arg3 = C.guint(nAngles)

	C.gst_navigation_query_set_angles(_arg1, _arg2, _arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(curAngle)
	runtime.KeepAlive(nAngles)
}

// NavigationQuerySetCommandsv: set the Navigation command query result fields
// in query. The number of commands passed must be equal to n_commands.
//
// The function takes the following parameters:
//
//    - query: Query.
//    - cmds: array containing n_cmds GstNavigationCommand values.
//
func NavigationQuerySetCommandsv(query *gst.Query, cmds []NavigationCommand) {
	var _arg1 *C.GstQuery             // out
	var _arg3 *C.GstNavigationCommand // out
	var _arg2 C.gint

	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg2 = (C.gint)(len(cmds))
	if len(cmds) > 0 {
		_arg3 = (*C.GstNavigationCommand)(unsafe.Pointer(&cmds[0]))
	}

	C.gst_navigation_query_set_commandsv(_arg1, _arg2, _arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(cmds)
}

// NavigationInterface: navigation interface.
//
// An instance of this type is always passed by reference.
type NavigationInterface struct {
	*navigationInterface
}

// navigationInterface is the struct that's finalized.
type navigationInterface struct {
	native *C.GstNavigationInterface
}
