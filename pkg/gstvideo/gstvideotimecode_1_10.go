// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoTimeCodeFlags = coreglib.Type(C.gst_video_time_code_flags_get_type())
	GTypeVideoTimeCode      = coreglib.Type(C.gst_video_time_code_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoTimeCodeFlags, F: marshalVideoTimeCodeFlags},
		coreglib.TypeMarshaler{T: GTypeVideoTimeCode, F: marshalVideoTimeCode},
	})
}

// VideoTimeCodeFlags flags related to the time code information. For drop
// frame, only 30000/1001 and 60000/1001 frame rates are supported.
type VideoTimeCodeFlags C.guint

const (
	// VideoTimeCodeFlagsNone: no flags.
	VideoTimeCodeFlagsNone VideoTimeCodeFlags = 0b0
	// VideoTimeCodeFlagsDropFrame: whether we have drop frame rate.
	VideoTimeCodeFlagsDropFrame VideoTimeCodeFlags = 0b1
	// VideoTimeCodeFlagsInterlaced: whether we have interlaced video.
	VideoTimeCodeFlagsInterlaced VideoTimeCodeFlags = 0b10
)

func marshalVideoTimeCodeFlags(p uintptr) (interface{}, error) {
	return VideoTimeCodeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoTimeCodeFlags.
func (v VideoTimeCodeFlags) String() string {
	if v == 0 {
		return "VideoTimeCodeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(79)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoTimeCodeFlagsNone:
			builder.WriteString("None|")
		case VideoTimeCodeFlagsDropFrame:
			builder.WriteString("DropFrame|")
		case VideoTimeCodeFlagsInterlaced:
			builder.WriteString("Interlaced|")
		default:
			builder.WriteString(fmt.Sprintf("VideoTimeCodeFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoTimeCodeFlags) Has(other VideoTimeCodeFlags) bool {
	return (v & other) == other
}

// VideoTimeCode: field_count must be 0 for progressive video and 1 or 2 for
// interlaced.
//
// A representation of a SMPTE time code.
//
// hours must be positive and less than 24. Will wrap around otherwise. minutes
// and seconds must be positive and less than 60. frames must be less than or
// equal to config.fps_n / config.fps_d These values are *NOT* automatically
// normalized.
//
// An instance of this type is always passed by reference.
type VideoTimeCode struct {
	*videoTimeCode
}

// videoTimeCode is the struct that's finalized.
type videoTimeCode struct {
	native *C.GstVideoTimeCode
}

func marshalVideoTimeCode(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VideoTimeCode{&videoTimeCode{(*C.GstVideoTimeCode)(b)}}, nil
}

// NewVideoTimeCode constructs a struct VideoTimeCode.
func NewVideoTimeCode(fpsN uint, fpsD uint, latestDailyJam *glib.DateTime, flags VideoTimeCodeFlags, hours uint, minutes uint, seconds uint, frames uint, fieldCount uint) *VideoTimeCode {
	var _arg1 C.guint                 // out
	var _arg2 C.guint                 // out
	var _arg3 *C.GDateTime            // out
	var _arg4 C.GstVideoTimeCodeFlags // out
	var _arg5 C.guint                 // out
	var _arg6 C.guint                 // out
	var _arg7 C.guint                 // out
	var _arg8 C.guint                 // out
	var _arg9 C.guint                 // out
	var _cret *C.GstVideoTimeCode     // in

	_arg1 = C.guint(fpsN)
	_arg2 = C.guint(fpsD)
	_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(latestDailyJam)))
	_arg4 = C.GstVideoTimeCodeFlags(flags)
	_arg5 = C.guint(hours)
	_arg6 = C.guint(minutes)
	_arg7 = C.guint(seconds)
	_arg8 = C.guint(frames)
	_arg9 = C.guint(fieldCount)

	_cret = C.gst_video_time_code_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(fpsN)
	runtime.KeepAlive(fpsD)
	runtime.KeepAlive(latestDailyJam)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(hours)
	runtime.KeepAlive(minutes)
	runtime.KeepAlive(seconds)
	runtime.KeepAlive(frames)
	runtime.KeepAlive(fieldCount)

	var _videoTimeCode *VideoTimeCode // out

	_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
		},
	)

	return _videoTimeCode
}

// NewVideoTimeCodeEmpty constructs a struct VideoTimeCode.
func NewVideoTimeCodeEmpty() *VideoTimeCode {
	var _cret *C.GstVideoTimeCode // in

	_cret = C.gst_video_time_code_new_empty()

	var _videoTimeCode *VideoTimeCode // out

	_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
		},
	)

	return _videoTimeCode
}

// NewVideoTimeCodeFromDateTime constructs a struct VideoTimeCode.
func NewVideoTimeCodeFromDateTime(fpsN uint, fpsD uint, dt *glib.DateTime, flags VideoTimeCodeFlags, fieldCount uint) *VideoTimeCode {
	var _arg1 C.guint                 // out
	var _arg2 C.guint                 // out
	var _arg3 *C.GDateTime            // out
	var _arg4 C.GstVideoTimeCodeFlags // out
	var _arg5 C.guint                 // out
	var _cret *C.GstVideoTimeCode     // in

	_arg1 = C.guint(fpsN)
	_arg2 = C.guint(fpsD)
	_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(dt)))
	_arg4 = C.GstVideoTimeCodeFlags(flags)
	_arg5 = C.guint(fieldCount)

	_cret = C.gst_video_time_code_new_from_date_time(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(fpsN)
	runtime.KeepAlive(fpsD)
	runtime.KeepAlive(dt)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(fieldCount)

	var _videoTimeCode *VideoTimeCode // out

	_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
		},
	)

	return _videoTimeCode
}

// NewVideoTimeCodeFromDateTimeFull constructs a struct VideoTimeCode.
func NewVideoTimeCodeFromDateTimeFull(fpsN uint, fpsD uint, dt *glib.DateTime, flags VideoTimeCodeFlags, fieldCount uint) *VideoTimeCode {
	var _arg1 C.guint                 // out
	var _arg2 C.guint                 // out
	var _arg3 *C.GDateTime            // out
	var _arg4 C.GstVideoTimeCodeFlags // out
	var _arg5 C.guint                 // out
	var _cret *C.GstVideoTimeCode     // in

	_arg1 = C.guint(fpsN)
	_arg2 = C.guint(fpsD)
	_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(dt)))
	_arg4 = C.GstVideoTimeCodeFlags(flags)
	_arg5 = C.guint(fieldCount)

	_cret = C.gst_video_time_code_new_from_date_time_full(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(fpsN)
	runtime.KeepAlive(fpsD)
	runtime.KeepAlive(dt)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(fieldCount)

	var _videoTimeCode *VideoTimeCode // out

	_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
		},
	)

	return _videoTimeCode
}

// NewVideoTimeCodeFromString constructs a struct VideoTimeCode.
func NewVideoTimeCodeFromString(tcStr string) *VideoTimeCode {
	var _arg1 *C.gchar            // out
	var _cret *C.GstVideoTimeCode // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tcStr)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_video_time_code_new_from_string(_arg1)
	runtime.KeepAlive(tcStr)

	var _videoTimeCode *VideoTimeCode // out

	if _cret != nil {
		_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
			},
		)
	}

	return _videoTimeCode
}

// Config: corresponding VideoTimeCodeConfig.
func (v *VideoTimeCode) Config() *VideoTimeCodeConfig {
	valptr := &v.native.config
	var _v *VideoTimeCodeConfig // out
	_v = (*VideoTimeCodeConfig)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Hours hours field of VideoTimeCode.
func (v *VideoTimeCode) Hours() uint {
	valptr := &v.native.hours
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Minutes minutes field of VideoTimeCode.
func (v *VideoTimeCode) Minutes() uint {
	valptr := &v.native.minutes
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Seconds seconds field of VideoTimeCode.
func (v *VideoTimeCode) Seconds() uint {
	valptr := &v.native.seconds
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Frames frames field of VideoTimeCode.
func (v *VideoTimeCode) Frames() uint {
	valptr := &v.native.frames
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// FieldCount: interlaced video field count.
func (v *VideoTimeCode) FieldCount() uint {
	valptr := &v.native.field_count
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Hours hours field of VideoTimeCode.
func (v *VideoTimeCode) SetHours(hours uint) {
	valptr := &v.native.hours
	*valptr = C.guint(hours)
}

// Minutes minutes field of VideoTimeCode.
func (v *VideoTimeCode) SetMinutes(minutes uint) {
	valptr := &v.native.minutes
	*valptr = C.guint(minutes)
}

// Seconds seconds field of VideoTimeCode.
func (v *VideoTimeCode) SetSeconds(seconds uint) {
	valptr := &v.native.seconds
	*valptr = C.guint(seconds)
}

// Frames frames field of VideoTimeCode.
func (v *VideoTimeCode) SetFrames(frames uint) {
	valptr := &v.native.frames
	*valptr = C.guint(frames)
}

// FieldCount: interlaced video field count.
func (v *VideoTimeCode) SetFieldCount(fieldCount uint) {
	valptr := &v.native.field_count
	*valptr = C.guint(fieldCount)
}

// AddFrames adds or subtracts frames amount of frames to tc. tc needs to
// contain valid data, as verified by gst_video_time_code_is_valid().
//
// The function takes the following parameters:
//
//    - frames: how many frames to add or subtract.
//
func (tc *VideoTimeCode) AddFrames(frames int64) {
	var _arg0 *C.GstVideoTimeCode // out
	var _arg1 C.gint64            // out

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))
	_arg1 = C.gint64(frames)

	C.gst_video_time_code_add_frames(_arg0, _arg1)
	runtime.KeepAlive(tc)
	runtime.KeepAlive(frames)
}

// AddInterval: this makes a component-wise addition of tc_inter to tc. For
// example, adding ("01:02:03:04", "00:01:00:00") will return "01:03:03:04".
// When it comes to drop-frame timecodes, adding ("00:00:00;00", "00:01:00:00")
// will return "00:01:00;02" because of drop-frame oddities. However, adding
// ("00:09:00;02", "00:01:00:00") will return "00:10:00;00" because this time we
// can have an exact minute.
//
// The function takes the following parameters:
//
//    - tcInter to add to tc. The interval must contain valid values, except that
//      for drop-frame timecode, it may also contain timecodes which would
//      normally be dropped. These are then corrected to the next reasonable
//      timecode.
//
// The function returns the following values:
//
//    - videoTimeCode (optional): new VideoTimeCode with tc_inter added or NULL
//      if the interval can't be added.
//
func (tc *VideoTimeCode) AddInterval(tcInter *VideoTimeCodeInterval) *VideoTimeCode {
	var _arg0 *C.GstVideoTimeCode         // out
	var _arg1 *C.GstVideoTimeCodeInterval // out
	var _cret *C.GstVideoTimeCode         // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))
	_arg1 = (*C.GstVideoTimeCodeInterval)(gextras.StructNative(unsafe.Pointer(tcInter)))

	_cret = C.gst_video_time_code_add_interval(_arg0, _arg1)
	runtime.KeepAlive(tc)
	runtime.KeepAlive(tcInter)

	var _videoTimeCode *VideoTimeCode // out

	if _cret != nil {
		_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
			},
		)
	}

	return _videoTimeCode
}

// Clear initializes tc with empty/zero/NULL values and frees any memory it
// might currently use.
func (tc *VideoTimeCode) Clear() {
	var _arg0 *C.GstVideoTimeCode // out

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	C.gst_video_time_code_clear(_arg0)
	runtime.KeepAlive(tc)
}

// Compare compares tc1 and tc2. If both have latest daily jam information, it
// is taken into account. Otherwise, it is assumed that the daily jam of both
// tc1 and tc2 was at the same time. Both time codes must be valid.
//
// The function takes the following parameters:
//
//    - tc2: another valid VideoTimeCode.
//
// The function returns the following values:
//
//    - gint: 1 if tc1 is after tc2, -1 if tc1 is before tc2, 0 otherwise.
//
func (tc1 *VideoTimeCode) Compare(tc2 *VideoTimeCode) int {
	var _arg0 *C.GstVideoTimeCode // out
	var _arg1 *C.GstVideoTimeCode // out
	var _cret C.gint              // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc1)))
	_arg1 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc2)))

	_cret = C.gst_video_time_code_compare(_arg0, _arg1)
	runtime.KeepAlive(tc1)
	runtime.KeepAlive(tc2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//    - videoTimeCode: new VideoTimeCode with the same values as tc.
//
func (tc *VideoTimeCode) Copy() *VideoTimeCode {
	var _arg0 *C.GstVideoTimeCode // out
	var _cret *C.GstVideoTimeCode // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	_cret = C.gst_video_time_code_copy(_arg0)
	runtime.KeepAlive(tc)

	var _videoTimeCode *VideoTimeCode // out

	_videoTimeCode = (*VideoTimeCode)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoTimeCode)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_time_code_free((*C.GstVideoTimeCode)(intern.C))
		},
	)

	return _videoTimeCode
}

// The function returns the following values:
//
//    - guint64: how many frames have passed since the daily jam of tc.
//
func (tc *VideoTimeCode) FramesSinceDailyJam() uint64 {
	var _arg0 *C.GstVideoTimeCode // out
	var _cret C.guint64           // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	_cret = C.gst_video_time_code_frames_since_daily_jam(_arg0)
	runtime.KeepAlive(tc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// IncrementFrame adds one frame to tc.
func (tc *VideoTimeCode) IncrementFrame() {
	var _arg0 *C.GstVideoTimeCode // out

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	C.gst_video_time_code_increment_frame(_arg0)
	runtime.KeepAlive(tc)
}

// Init: field_count is 0 for progressive, 1 or 2 for interlaced.
// latest_daiy_jam reference is stolen from caller.
//
// Initializes tc with the given values. The values are not checked for being in
// a valid range. To see if your timecode actually has valid content, use
// gst_video_time_code_is_valid().
//
// The function takes the following parameters:
//
//    - fpsN: numerator of the frame rate.
//    - fpsD: denominator of the frame rate.
//    - latestDailyJam (optional): latest daily jam of the VideoTimeCode.
//    - flags: VideoTimeCodeFlags.
//    - hours field of VideoTimeCode.
//    - minutes field of VideoTimeCode.
//    - seconds field of VideoTimeCode.
//    - frames field of VideoTimeCode.
//    - fieldCount: interlaced video field count.
//
func (tc *VideoTimeCode) Init(fpsN uint, fpsD uint, latestDailyJam *glib.DateTime, flags VideoTimeCodeFlags, hours uint, minutes uint, seconds uint, frames uint, fieldCount uint) {
	var _arg0 *C.GstVideoTimeCode     // out
	var _arg1 C.guint                 // out
	var _arg2 C.guint                 // out
	var _arg3 *C.GDateTime            // out
	var _arg4 C.GstVideoTimeCodeFlags // out
	var _arg5 C.guint                 // out
	var _arg6 C.guint                 // out
	var _arg7 C.guint                 // out
	var _arg8 C.guint                 // out
	var _arg9 C.guint                 // out

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))
	_arg1 = C.guint(fpsN)
	_arg2 = C.guint(fpsD)
	if latestDailyJam != nil {
		_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(latestDailyJam)))
	}
	_arg4 = C.GstVideoTimeCodeFlags(flags)
	_arg5 = C.guint(hours)
	_arg6 = C.guint(minutes)
	_arg7 = C.guint(seconds)
	_arg8 = C.guint(frames)
	_arg9 = C.guint(fieldCount)

	C.gst_video_time_code_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(tc)
	runtime.KeepAlive(fpsN)
	runtime.KeepAlive(fpsD)
	runtime.KeepAlive(latestDailyJam)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(hours)
	runtime.KeepAlive(minutes)
	runtime.KeepAlive(seconds)
	runtime.KeepAlive(frames)
	runtime.KeepAlive(fieldCount)
}

// InitFromDateTime: resulting config->latest_daily_jam is set to midnight, and
// timecode is set to the given time.
//
// Will assert on invalid parameters, use
// gst_video_time_code_init_from_date_time_full() for being able to handle
// invalid parameters.
//
// The function takes the following parameters:
//
//    - fpsN: numerator of the frame rate.
//    - fpsD: denominator of the frame rate.
//    - dt to convert.
//    - flags: VideoTimeCodeFlags.
//    - fieldCount: interlaced video field count.
//
func (tc *VideoTimeCode) InitFromDateTime(fpsN uint, fpsD uint, dt *glib.DateTime, flags VideoTimeCodeFlags, fieldCount uint) {
	var _arg0 *C.GstVideoTimeCode     // out
	var _arg1 C.guint                 // out
	var _arg2 C.guint                 // out
	var _arg3 *C.GDateTime            // out
	var _arg4 C.GstVideoTimeCodeFlags // out
	var _arg5 C.guint                 // out

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))
	_arg1 = C.guint(fpsN)
	_arg2 = C.guint(fpsD)
	_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(dt)))
	_arg4 = C.GstVideoTimeCodeFlags(flags)
	_arg5 = C.guint(fieldCount)

	C.gst_video_time_code_init_from_date_time(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(tc)
	runtime.KeepAlive(fpsN)
	runtime.KeepAlive(fpsD)
	runtime.KeepAlive(dt)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(fieldCount)
}

// InitFromDateTimeFull: resulting config->latest_daily_jam is set to midnight,
// and timecode is set to the given time.
//
// The function takes the following parameters:
//
//    - fpsN: numerator of the frame rate.
//    - fpsD: denominator of the frame rate.
//    - dt to convert.
//    - flags: VideoTimeCodeFlags.
//    - fieldCount: interlaced video field count.
//
// The function returns the following values:
//
//    - ok: TRUE if tc could be correctly initialized to a valid timecode.
//
func (tc *VideoTimeCode) InitFromDateTimeFull(fpsN uint, fpsD uint, dt *glib.DateTime, flags VideoTimeCodeFlags, fieldCount uint) bool {
	var _arg0 *C.GstVideoTimeCode     // out
	var _arg1 C.guint                 // out
	var _arg2 C.guint                 // out
	var _arg3 *C.GDateTime            // out
	var _arg4 C.GstVideoTimeCodeFlags // out
	var _arg5 C.guint                 // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))
	_arg1 = C.guint(fpsN)
	_arg2 = C.guint(fpsD)
	_arg3 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(dt)))
	_arg4 = C.GstVideoTimeCodeFlags(flags)
	_arg5 = C.guint(fieldCount)

	_cret = C.gst_video_time_code_init_from_date_time_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(tc)
	runtime.KeepAlive(fpsN)
	runtime.KeepAlive(fpsD)
	runtime.KeepAlive(dt)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(fieldCount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: whether tc is a valid timecode (supported frame rate,
//      hours/minutes/seconds/frames not overflowing).
//
func (tc *VideoTimeCode) IsValid() bool {
	var _arg0 *C.GstVideoTimeCode // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	_cret = C.gst_video_time_code_is_valid(_arg0)
	runtime.KeepAlive(tc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - guint64: how many nsec have passed since the daily jam of tc.
//
func (tc *VideoTimeCode) NsecSinceDailyJam() uint64 {
	var _arg0 *C.GstVideoTimeCode // out
	var _cret C.guint64           // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	_cret = C.gst_video_time_code_nsec_since_daily_jam(_arg0)
	runtime.KeepAlive(tc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToDateTime: tc.config->latest_daily_jam is required to be non-NULL.
//
// The function returns the following values:
//
//    - dateTime (optional) representation of tc or NULL if tc has no daily jam.
//
func (tc *VideoTimeCode) ToDateTime() *glib.DateTime {
	var _arg0 *C.GstVideoTimeCode // out
	var _cret *C.GDateTime        // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	_cret = C.gst_video_time_code_to_date_time(_arg0)
	runtime.KeepAlive(tc)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// The function returns the following values:
//
//    - utf8: SMPTE ST 2059-1:2015 string representation of tc. That will take
//      the form hh:mm:ss:ff. The last separator (between seconds and frames) may
//      vary:
//
//      ';' for drop-frame, non-interlaced content and for drop-frame interlaced
//      field 2 ',' for drop-frame interlaced field 1 ':' for non-drop-frame,
//      non-interlaced content and for non-drop-frame interlaced field 2 '.' for
//      non-drop-frame interlaced field 1.
//
func (tc *VideoTimeCode) String() string {
	var _arg0 *C.GstVideoTimeCode // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstVideoTimeCode)(gextras.StructNative(unsafe.Pointer(tc)))

	_cret = C.gst_video_time_code_to_string(_arg0)
	runtime.KeepAlive(tc)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VideoTimeCodeConfig: supported frame rates: 30000/1001, 60000/1001 (both with
// and without drop frame), and integer frame rates e.g. 25/1, 30/1, 50/1, 60/1.
//
// The configuration of the time code.
//
// An instance of this type is always passed by reference.
type VideoTimeCodeConfig struct {
	*videoTimeCodeConfig
}

// videoTimeCodeConfig is the struct that's finalized.
type videoTimeCodeConfig struct {
	native *C.GstVideoTimeCodeConfig
}

// FPSN: numerator of the frame rate.
func (v *VideoTimeCodeConfig) FPSN() uint {
	valptr := &v.native.fps_n
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// FPSD: denominator of the frame rate.
func (v *VideoTimeCodeConfig) FPSD() uint {
	valptr := &v.native.fps_d
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Flags: corresponding VideoTimeCodeFlags.
func (v *VideoTimeCodeConfig) Flags() VideoTimeCodeFlags {
	valptr := &v.native.flags
	var _v VideoTimeCodeFlags // out
	_v = VideoTimeCodeFlags(*valptr)
	return _v
}

// LatestDailyJam: latest daily jam information, if present, or NULL.
func (v *VideoTimeCodeConfig) LatestDailyJam() *glib.DateTime {
	valptr := &v.native.latest_daily_jam
	var _v *glib.DateTime // out
	_v = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	C.g_date_time_ref(*valptr)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_v)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)
	return _v
}

// FPSN: numerator of the frame rate.
func (v *VideoTimeCodeConfig) SetFPSN(fpsN uint) {
	valptr := &v.native.fps_n
	*valptr = C.guint(fpsN)
}

// FPSD: denominator of the frame rate.
func (v *VideoTimeCodeConfig) SetFPSD(fpsD uint) {
	valptr := &v.native.fps_d
	*valptr = C.guint(fpsD)
}
