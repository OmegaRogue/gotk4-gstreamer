// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoAncillaryDID16  = coreglib.Type(C.gst_video_ancillary_di_d16_get_type())
	GTypeVideoCaptionType     = coreglib.Type(C.gst_video_caption_type_get_type())
	GTypeVideoVBIParserResult = coreglib.Type(C.gst_video_vbi_parser_result_get_type())
	GTypeVideoVBIEncoder      = coreglib.Type(C.gst_video_vbi_encoder_get_type())
	GTypeVideoVBIParser       = coreglib.Type(C.gst_video_vbi_parser_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoAncillaryDID16, F: marshalVideoAncillaryDID16},
		coreglib.TypeMarshaler{T: GTypeVideoCaptionType, F: marshalVideoCaptionType},
		coreglib.TypeMarshaler{T: GTypeVideoVBIParserResult, F: marshalVideoVBIParserResult},
		coreglib.TypeMarshaler{T: GTypeVideoVBIEncoder, F: marshalVideoVBIEncoder},
		coreglib.TypeMarshaler{T: GTypeVideoVBIParser, F: marshalVideoVBIParser},
	})
}

// VideoAncillaryDID16: some know types of Ancillary Data identifiers.
type VideoAncillaryDID16 C.gint

const (
	// VideoAncillaryDid16S334Eia708: CEA 708 Ancillary data according to SMPTE
	// 334.
	VideoAncillaryDid16S334Eia708 VideoAncillaryDID16 = 24833
	// VideoAncillaryDid16S334Eia608: CEA 608 Ancillary data according to SMPTE
	// 334.
	VideoAncillaryDid16S334Eia608 VideoAncillaryDID16 = 24834
	// VideoAncillaryDid16S20163AfdBar: AFD/Bar Ancillary data according to
	// SMPTE 2016-3 (Since: 1.18).
	VideoAncillaryDid16S20163AfdBar VideoAncillaryDID16 = 16645
)

func marshalVideoAncillaryDID16(p uintptr) (interface{}, error) {
	return VideoAncillaryDID16(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoAncillaryDID16.
func (v VideoAncillaryDID16) String() string {
	switch v {
	case VideoAncillaryDid16S334Eia708:
		return "S334Eia708"
	case VideoAncillaryDid16S334Eia608:
		return "S334Eia608"
	case VideoAncillaryDid16S20163AfdBar:
		return "S20163AfdBar"
	default:
		return fmt.Sprintf("VideoAncillaryDID16(%d)", v)
	}
}

// VideoCaptionType various known types of Closed Caption (CC).
type VideoCaptionType C.gint

const (
	// VideoCaptionTypeUnknown: unknown type of CC.
	VideoCaptionTypeUnknown VideoCaptionType = iota
	// VideoCaptionTypeCea608Raw: CEA-608 as byte pairs. Note that this format
	// is not recommended since is does not specify to which field the caption
	// comes from and therefore assumes it comes from the first field (and that
	// there is no information on the second field). Use
	// GST_VIDEO_CAPTION_TYPE_CEA708_RAW if you wish to store CEA-608 from two
	// fields and prefix each byte pair with 0xFC for the first field and 0xFD
	// for the second field.
	VideoCaptionTypeCea608Raw
	// VideoCaptionTypeCea608S3341A: CEA-608 as byte triplets as defined in
	// SMPTE S334-1 Annex A. The second and third byte of the byte triplet is
	// the raw CEA608 data, the first byte is a bitfield: The top/7th bit is 0
	// for the second field, 1 for the first field, bit 6 and 5 are 0 and bits 4
	// to 0 are a 5 bit unsigned integer that represents the line offset
	// relative to the base-line of the original image format (line 9 for
	// 525-line field 1, line 272 for 525-line field 2, line 5 for 625-line
	// field 1 and line 318 for 625-line field 2).
	VideoCaptionTypeCea608S3341A
	// VideoCaptionTypeCea708Raw: CEA-708 as cc_data byte triplets. They can
	// also contain 608-in-708 and the first byte of each triplet has to be
	// inspected for detecting the type.
	VideoCaptionTypeCea708Raw
	// VideoCaptionTypeCea708Cdp: CEA-708 (and optionally CEA-608) in a CDP
	// (Caption Distribution Packet) defined by SMPTE S-334-2. Contains the
	// whole CDP (starting with 0x9669).
	VideoCaptionTypeCea708Cdp
)

func marshalVideoCaptionType(p uintptr) (interface{}, error) {
	return VideoCaptionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoCaptionType.
func (v VideoCaptionType) String() string {
	switch v {
	case VideoCaptionTypeUnknown:
		return "Unknown"
	case VideoCaptionTypeCea608Raw:
		return "Cea608Raw"
	case VideoCaptionTypeCea608S3341A:
		return "Cea608S3341A"
	case VideoCaptionTypeCea708Raw:
		return "Cea708Raw"
	case VideoCaptionTypeCea708Cdp:
		return "Cea708Cdp"
	default:
		return fmt.Sprintf("VideoCaptionType(%d)", v)
	}
}

// VideoCaptionTypeFromCaps parses fixed Closed Caption Caps and returns the
// corresponding caption type, or GST_VIDEO_CAPTION_TYPE_UNKNOWN.
//
// The function takes the following parameters:
//
//    - caps: fixed Caps to parse.
//
// The function returns the following values:
//
//    - videoCaptionType: VideoCaptionType.
//
func VideoCaptionTypeFromCaps(caps *gst.Caps) VideoCaptionType {
	var _arg1 *C.GstCaps            // out
	var _cret C.GstVideoCaptionType // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_video_caption_type_from_caps(_arg1)
	runtime.KeepAlive(caps)

	var _videoCaptionType VideoCaptionType // out

	_videoCaptionType = VideoCaptionType(_cret)

	return _videoCaptionType
}

// VideoCaptionTypeToCaps creates new caps corresponding to type.
//
// The function takes the following parameters:
//
//    - typ: VideoCaptionType.
//
// The function returns the following values:
//
//    - caps: new Caps.
//
func VideoCaptionTypeToCaps(typ VideoCaptionType) *gst.Caps {
	var _arg1 C.GstVideoCaptionType // out
	var _cret *C.GstCaps            // in

	_arg1 = C.GstVideoCaptionType(typ)

	_cret = C.gst_video_caption_type_to_caps(_arg1)
	runtime.KeepAlive(typ)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// VideoVBIParserResult: return values for VideoVBIParser.
type VideoVBIParserResult C.gint

const (
	// VideoVbiParserResultDone: no line were provided, or no more Ancillary
	// data was found.
	VideoVbiParserResultDone VideoVBIParserResult = iota
	// VideoVbiParserResultOK was found.
	VideoVbiParserResultOK
	// VideoVbiParserResultError: error occurred.
	VideoVbiParserResultError
)

func marshalVideoVBIParserResult(p uintptr) (interface{}, error) {
	return VideoVBIParserResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoVBIParserResult.
func (v VideoVBIParserResult) String() string {
	switch v {
	case VideoVbiParserResultDone:
		return "Done"
	case VideoVbiParserResultOK:
		return "OK"
	case VideoVbiParserResultError:
		return "Error"
	default:
		return fmt.Sprintf("VideoVBIParserResult(%d)", v)
	}
}

// BufferAddVideoCaptionMeta attaches VideoCaptionMeta metadata to buffer with
// the given parameters.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - captionType: type of Closed Caption to add.
//    - data: closed Caption data.
//
// The function returns the following values:
//
//    - videoCaptionMeta on buffer.
//
func BufferAddVideoCaptionMeta(buffer *gst.Buffer, captionType VideoCaptionType, data []byte) *VideoCaptionMeta {
	var _arg1 *C.GstBuffer          // out
	var _arg2 C.GstVideoCaptionType // out
	var _arg3 *C.guint8             // out
	var _arg4 C.gsize
	var _cret *C.GstVideoCaptionMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstVideoCaptionType(captionType)
	_arg4 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg3 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_buffer_add_video_caption_meta(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(captionType)
	runtime.KeepAlive(data)

	var _videoCaptionMeta *VideoCaptionMeta // out

	_videoCaptionMeta = (*VideoCaptionMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoCaptionMeta
}

// VideoAncillary: video Ancillary data, according to SMPTE-291M specification.
//
// Note that the contents of the data are always stored as 8bit data (i.e. do
// not contain the parity check bits).
//
// An instance of this type is always passed by reference.
type VideoAncillary struct {
	*videoAncillary
}

// videoAncillary is the struct that's finalized.
type videoAncillary struct {
	native *C.GstVideoAncillary
}

// VideoCaptionMeta: extra buffer metadata providing Closed Caption.
//
// An instance of this type is always passed by reference.
type VideoCaptionMeta struct {
	*videoCaptionMeta
}

// videoCaptionMeta is the struct that's finalized.
type videoCaptionMeta struct {
	native *C.GstVideoCaptionMeta
}

// VideoVBIEncoder: encoder for writing ancillary data to the Vertical Blanking
// Interval lines of component signals.
//
// An instance of this type is always passed by reference.
type VideoVBIEncoder struct {
	*videoVBIEncoder
}

// videoVBIEncoder is the struct that's finalized.
type videoVBIEncoder struct {
	native *C.GstVideoVBIEncoder
}

func marshalVideoVBIEncoder(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VideoVBIEncoder{&videoVBIEncoder{(*C.GstVideoVBIEncoder)(b)}}, nil
}

// NewVideoVBIEncoder constructs a struct VideoVBIEncoder.
func NewVideoVBIEncoder(format VideoFormat, pixelWidth uint32) *VideoVBIEncoder {
	var _arg1 C.GstVideoFormat      // out
	var _arg2 C.guint32             // out
	var _cret *C.GstVideoVBIEncoder // in

	_arg1 = C.GstVideoFormat(format)
	_arg2 = C.guint32(pixelWidth)

	_cret = C.gst_video_vbi_encoder_new(_arg1, _arg2)
	runtime.KeepAlive(format)
	runtime.KeepAlive(pixelWidth)

	var _videoVBIEncoder *VideoVBIEncoder // out

	_videoVBIEncoder = (*VideoVBIEncoder)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoVBIEncoder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_vbi_encoder_free((*C.GstVideoVBIEncoder)(intern.C))
		},
	)

	return _videoVBIEncoder
}

// AddAncillary stores Video Ancillary data, according to SMPTE-291M
// specification.
//
// Note that the contents of the data are always read as 8bit data (i.e. do not
// contain the parity check bits).
//
// The function takes the following parameters:
//
//    - composite: TRUE if composite ADF should be created, component otherwise.
//    - DID: data Identifier.
//    - SDIDBlockNumber: secondary Data Identifier (if type 2) or the Data Block
//      Number (if type 1).
//    - data: user data content of the Ancillary packet. Does not contain the
//      ADF, DID, SDID nor CS.
//
// The function returns the following values:
//
//    - ok: TRUE if enough space was left in the current line, FALSE otherwise.
//
func (encoder *VideoVBIEncoder) AddAncillary(composite bool, DID byte, SDIDBlockNumber byte, data []byte) bool {
	var _arg0 *C.GstVideoVBIEncoder // out
	var _arg1 C.gboolean            // out
	var _arg2 C.guint8              // out
	var _arg3 C.guint8              // out
	var _arg4 *C.guint8             // out
	var _arg5 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstVideoVBIEncoder)(gextras.StructNative(unsafe.Pointer(encoder)))
	if composite {
		_arg1 = C.TRUE
	}
	_arg2 = C.guint8(DID)
	_arg3 = C.guint8(SDIDBlockNumber)
	_arg5 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_video_vbi_encoder_add_ancillary(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(composite)
	runtime.KeepAlive(DID)
	runtime.KeepAlive(SDIDBlockNumber)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (encoder *VideoVBIEncoder) Copy() *VideoVBIEncoder {
	var _arg0 *C.GstVideoVBIEncoder // out
	var _cret *C.GstVideoVBIEncoder // in

	_arg0 = (*C.GstVideoVBIEncoder)(gextras.StructNative(unsafe.Pointer(encoder)))

	_cret = C.gst_video_vbi_encoder_copy(_arg0)
	runtime.KeepAlive(encoder)

	var _videoVBIEncoder *VideoVBIEncoder // out

	_videoVBIEncoder = (*VideoVBIEncoder)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoVBIEncoder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_vbi_encoder_free((*C.GstVideoVBIEncoder)(intern.C))
		},
	)

	return _videoVBIEncoder
}

// The function takes the following parameters:
//
func (encoder *VideoVBIEncoder) WriteLine(data *byte) {
	var _arg0 *C.GstVideoVBIEncoder // out
	var _arg1 *C.guint8             // out

	_arg0 = (*C.GstVideoVBIEncoder)(gextras.StructNative(unsafe.Pointer(encoder)))
	_arg1 = (*C.guint8)(unsafe.Pointer(data))

	C.gst_video_vbi_encoder_write_line(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(data)
}

// VideoVBIParser: parser for detecting and extracting GstVideoAncillary data
// from Vertical Blanking Interval lines of component signals.
//
// An instance of this type is always passed by reference.
type VideoVBIParser struct {
	*videoVBIParser
}

// videoVBIParser is the struct that's finalized.
type videoVBIParser struct {
	native *C.GstVideoVBIParser
}

func marshalVideoVBIParser(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VideoVBIParser{&videoVBIParser{(*C.GstVideoVBIParser)(b)}}, nil
}

// NewVideoVBIParser constructs a struct VideoVBIParser.
func NewVideoVBIParser(format VideoFormat, pixelWidth uint32) *VideoVBIParser {
	var _arg1 C.GstVideoFormat     // out
	var _arg2 C.guint32            // out
	var _cret *C.GstVideoVBIParser // in

	_arg1 = C.GstVideoFormat(format)
	_arg2 = C.guint32(pixelWidth)

	_cret = C.gst_video_vbi_parser_new(_arg1, _arg2)
	runtime.KeepAlive(format)
	runtime.KeepAlive(pixelWidth)

	var _videoVBIParser *VideoVBIParser // out

	_videoVBIParser = (*VideoVBIParser)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoVBIParser)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_vbi_parser_free((*C.GstVideoVBIParser)(intern.C))
		},
	)

	return _videoVBIParser
}

// The function returns the following values:
//
func (parser *VideoVBIParser) Copy() *VideoVBIParser {
	var _arg0 *C.GstVideoVBIParser // out
	var _cret *C.GstVideoVBIParser // in

	_arg0 = (*C.GstVideoVBIParser)(gextras.StructNative(unsafe.Pointer(parser)))

	_cret = C.gst_video_vbi_parser_copy(_arg0)
	runtime.KeepAlive(parser)

	var _videoVBIParser *VideoVBIParser // out

	_videoVBIParser = (*VideoVBIParser)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoVBIParser)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_vbi_parser_free((*C.GstVideoVBIParser)(intern.C))
		},
	)

	return _videoVBIParser
}

// Ancillary: parse the line provided previously by
// gst_video_vbi_parser_add_line().
//
// The function returns the following values:
//
//    - anc to start the eventual ancillary data.
//    - videoVBIParserResult: GST_VIDEO_VBI_PARSER_RESULT_OK if ancillary data
//      was found and anc was filled. GST_VIDEO_VBI_PARSER_RESULT_DONE if there
//      wasn't any data.
//
func (parser *VideoVBIParser) Ancillary() (*VideoAncillary, VideoVBIParserResult) {
	var _arg0 *C.GstVideoVBIParser      // out
	var _arg1 C.GstVideoAncillary       // in
	var _cret C.GstVideoVBIParserResult // in

	_arg0 = (*C.GstVideoVBIParser)(gextras.StructNative(unsafe.Pointer(parser)))

	_cret = C.gst_video_vbi_parser_get_ancillary(_arg0, &_arg1)
	runtime.KeepAlive(parser)

	var _anc *VideoAncillary                       // out
	var _videoVBIParserResult VideoVBIParserResult // out

	_anc = (*VideoAncillary)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_videoVBIParserResult = VideoVBIParserResult(_cret)

	return _anc, _videoVBIParserResult
}
