// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoAFDSpec  = coreglib.Type(C.gst_video_afd_spec_get_type())
	GTypeVideoAFDValue = coreglib.Type(C.gst_video_afd_value_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoAFDSpec, F: marshalVideoAFDSpec},
		coreglib.TypeMarshaler{T: GTypeVideoAFDValue, F: marshalVideoAFDValue},
	})
}

// VideoAFDSpec: enumeration of the different standards that may apply to AFD
// data:
//
// 0) ETSI/DVB:
// https://www.etsi.org/deliver/etsi_ts/101100_101199/101154/02.01.01_60/ts_101154v020101p.pdf
//
// 1) ATSC A/53:
// https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf
//
// 2) SMPTE ST2016-1:.
type VideoAFDSpec C.gint

const (
	// VideoAfdSpecDvbEtsi: AFD value is from DVB/ETSI standard.
	VideoAfdSpecDvbEtsi VideoAFDSpec = iota
	// VideoAfdSpecAtscA53: AFD value is from ATSC A/53 standard.
	VideoAfdSpecAtscA53
	VideoAfdSpecSmpteSt20161
)

func marshalVideoAFDSpec(p uintptr) (interface{}, error) {
	return VideoAFDSpec(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoAFDSpec.
func (v VideoAFDSpec) String() string {
	switch v {
	case VideoAfdSpecDvbEtsi:
		return "DvbEtsi"
	case VideoAfdSpecAtscA53:
		return "AtscA53"
	case VideoAfdSpecSmpteSt20161:
		return "SmpteSt20161"
	default:
		return fmt.Sprintf("VideoAFDSpec(%d)", v)
	}
}

// VideoAFDValue: enumeration of the various values for Active Format
// Description (AFD)
//
// AFD should be included in video user data whenever the rectangular picture
// area containing useful information does not extend to the full height or
// width of the coded frame. AFD data may also be included in user data when the
// rectangular picture area containing useful information extends to the full
// height and width of the coded frame.
//
// For details, see Table 6.14 Active Format in:
//
// ATSC Digital Television Standard: Part 4 – MPEG-2 Video System
// Characteristics
//
// https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf
//
// and Active Format Description in Complete list of AFD codes
//
// https://en.wikipedia.org/wiki/Active_Format_DescriptionAFD_codes
//
// and SMPTE ST2016-1
//
// Notes:
//
// 1) AFD 0 is undefined for ATSC and SMPTE ST2016-1, indicating that AFD data
// is not available: If Bar Data is not present, AFD '0000' indicates that exact
// information is not available and the active image should be assumed to be the
// same as the coded frame. AFD '0000'. AFD '0000' accompanied by Bar Data
// signals that the active image’s aspect ratio is narrower than 16:9, but is
// not 4:3 or 14:9. As the exact aspect ratio cannot be conveyed by AFD alone,
// wherever possible, AFD ‘0000’ should be accompanied by Bar Data to define the
// exact vertical or horizontal extent of the active image. 2) AFD 0 is reserved
// for DVB/ETSI 3) values 1, 5, 6, 7, and 12 are reserved for both ATSC and
// DVB/ETSI 4) values 2 and 3 are not recommended for ATSC, but are valid for
// DVB/ETSI.
type VideoAFDValue C.gint

const (
	// VideoAfdUnavailable: unavailable (see note 0 below).
	VideoAfdUnavailable VideoAFDValue = 0
	// VideoAfd169_TopAligned: for 4:3 coded frame, letterbox 16:9 image, at top
	// of the coded frame. For 16:9 coded frame, full frame 16:9 image, the same
	// as the coded frame.
	VideoAfd169_TopAligned VideoAFDValue = 2
	// VideoAfd149_TopAligned: for 4:3 coded frame, letterbox 14:9 image, at top
	// of the coded frame. For 16:9 coded frame, pillarbox 14:9 image,
	// horizontally centered in the coded frame.
	VideoAfd149_TopAligned VideoAFDValue = 3
	// VideoAfdGreaterThan169: for 4:3 coded frame, letterbox image with an
	// aspect ratio greater than 16:9, vertically centered in the coded frame.
	// For 16:9 coded frame, letterbox image with an aspect ratio greater than
	// 16:9.
	VideoAfdGreaterThan169 VideoAFDValue = 4
	// VideoAfd43_Full169_Full: for 4:3 coded frame, full frame 4:3 image, the
	// same as the coded frame. For 16:9 coded frame, full frame 16:9 image, the
	// same as the coded frame.
	VideoAfd43_Full169_Full VideoAFDValue = 8
	// VideoAfd43_Full43_Pillar: for 4:3 coded frame, full frame 4:3 image, the
	// same as the coded frame. For 16:9 coded frame, pillarbox 4:3 image,
	// horizontally centered in the coded frame.
	VideoAfd43_Full43_Pillar VideoAFDValue = 9
	// VideoAfd169_Letter169_Full: for 4:3 coded frame, letterbox 16:9 image,
	// vertically centered in the coded frame with all image areas protected.
	// For 16:9 coded frame, full frame 16:9 image, with all image areas
	// protected.
	VideoAfd169_Letter169_Full VideoAFDValue = 10
	// VideoAfd149_Letter149_Pillar: for 4:3 coded frame, letterbox 14:9 image,
	// vertically centered in the coded frame. For 16:9 coded frame, pillarbox
	// 14:9 image, horizontally centered in the coded frame.
	VideoAfd149_Letter149_Pillar VideoAFDValue = 11
	// VideoAfd43_Full149_Center: for 4:3 coded frame, full frame 4:3 image,
	// with alternative 14:9 center. For 16:9 coded frame, pillarbox 4:3 image,
	// with alternative 14:9 center.
	VideoAfd43_Full149_Center VideoAFDValue = 13
	// VideoAfd169_Letter149_Center: for 4:3 coded frame, letterbox 16:9 image,
	// with alternative 14:9 center. For 16:9 coded frame, full frame 16:9
	// image, with alternative 14:9 center.
	VideoAfd169_Letter149_Center VideoAFDValue = 14
	// VideoAfd169_Letter43_Center: for 4:3 coded frame, letterbox 16:9 image,
	// with alternative 4:3 center. For 16:9 coded frame, full frame 16:9 image,
	// with alternative 4:3 center.
	VideoAfd169_Letter43_Center VideoAFDValue = 15
)

func marshalVideoAFDValue(p uintptr) (interface{}, error) {
	return VideoAFDValue(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoAFDValue.
func (v VideoAFDValue) String() string {
	switch v {
	case VideoAfdUnavailable:
		return "Unavailable"
	case VideoAfd169_TopAligned:
		return "169_TopAligned"
	case VideoAfd149_TopAligned:
		return "149_TopAligned"
	case VideoAfdGreaterThan169:
		return "GreaterThan169"
	case VideoAfd43_Full169_Full:
		return "43_Full169_Full"
	case VideoAfd43_Full43_Pillar:
		return "43_Full43_Pillar"
	case VideoAfd169_Letter169_Full:
		return "169_Letter169_Full"
	case VideoAfd149_Letter149_Pillar:
		return "149_Letter149_Pillar"
	case VideoAfd43_Full149_Center:
		return "43_Full149_Center"
	case VideoAfd169_Letter149_Center:
		return "169_Letter149_Center"
	case VideoAfd169_Letter43_Center:
		return "169_Letter43_Center"
	default:
		return fmt.Sprintf("VideoAFDValue(%d)", v)
	}
}

// BufferAddVideoAfdMeta attaches VideoAFDMeta metadata to buffer with the given
// parameters.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - field: 0 for progressive or field 1 and 1 for field 2.
//    - spec that applies to AFD value.
//    - afd AFD enumeration.
//
// The function returns the following values:
//
//    - videoAFDMeta on buffer.
//
func BufferAddVideoAfdMeta(buffer *gst.Buffer, field byte, spec VideoAFDSpec, afd VideoAFDValue) *VideoAFDMeta {
	var _arg1 *C.GstBuffer       // out
	var _arg2 C.guint8           // out
	var _arg3 C.GstVideoAFDSpec  // out
	var _arg4 C.GstVideoAFDValue // out
	var _cret *C.GstVideoAFDMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.guint8(field)
	_arg3 = C.GstVideoAFDSpec(spec)
	_arg4 = C.GstVideoAFDValue(afd)

	_cret = C.gst_buffer_add_video_afd_meta(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(field)
	runtime.KeepAlive(spec)
	runtime.KeepAlive(afd)

	var _videoAFDMeta *VideoAFDMeta // out

	_videoAFDMeta = (*VideoAFDMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoAFDMeta
}

// BufferAddVideoBarMeta attaches VideoBarMeta metadata to buffer with the given
// parameters.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - field: 0 for progressive or field 1 and 1 for field 2.
//    - isLetterbox: if true then bar data specifies letterbox, otherwise
//      pillarbox.
//    - barData1: if is_letterbox is true, then the value specifies the last line
//      of a horizontal letterbox bar area at top of reconstructed frame.
//      Otherwise, it specifies the last horizontal luminance sample of a
//      vertical pillarbox bar area at the left side of the reconstructed frame.
//    - barData2: if is_letterbox is true, then the value specifies the first
//      line of a horizontal letterbox bar area at bottom of reconstructed frame.
//      Otherwise, it specifies the first horizontal luminance sample of a
//      vertical pillarbox bar area at the right side of the reconstructed frame.
//
// The function returns the following values:
//
//    - videoBarMeta on buffer.
//
//
//      See Table 6.11 Bar Data Syntax
//
//      https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf.
//
func BufferAddVideoBarMeta(buffer *gst.Buffer, field byte, isLetterbox bool, barData1, barData2 uint) *VideoBarMeta {
	var _arg1 *C.GstBuffer       // out
	var _arg2 C.guint8           // out
	var _arg3 C.gboolean         // out
	var _arg4 C.guint            // out
	var _arg5 C.guint            // out
	var _cret *C.GstVideoBarMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.guint8(field)
	if isLetterbox {
		_arg3 = C.TRUE
	}
	_arg4 = C.guint(barData1)
	_arg5 = C.guint(barData2)

	_cret = C.gst_buffer_add_video_bar_meta(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(field)
	runtime.KeepAlive(isLetterbox)
	runtime.KeepAlive(barData1)
	runtime.KeepAlive(barData2)

	var _videoBarMeta *VideoBarMeta // out

	_videoBarMeta = (*VideoBarMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoBarMeta
}

// VideoAFDMeta: active Format Description (AFD)
//
// For details, see Table 6.14 Active Format in:
//
// ATSC Digital Television Standard: Part 4 – MPEG-2 Video System
// Characteristics
//
// https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf
//
// and Active Format Description in Complete list of AFD codes
//
// https://en.wikipedia.org/wiki/Active_Format_DescriptionAFD_codes
//
// and SMPTE ST2016-1
//
// An instance of this type is always passed by reference.
type VideoAFDMeta struct {
	*videoAFDMeta
}

// videoAFDMeta is the struct that's finalized.
type videoAFDMeta struct {
	native *C.GstVideoAFDMeta
}

// Meta: parent Meta.
func (v *VideoAFDMeta) Meta() *gst.Meta {
	valptr := &v.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Field: 0 for progressive or field 1 and 1 for field 2.
func (v *VideoAFDMeta) Field() byte {
	valptr := &v.native.field
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Spec that applies to afd.
func (v *VideoAFDMeta) Spec() VideoAFDSpec {
	valptr := &v.native.spec
	var _v VideoAFDSpec // out
	_v = VideoAFDSpec(*valptr)
	return _v
}

// Afd AFD value.
func (v *VideoAFDMeta) Afd() VideoAFDValue {
	valptr := &v.native.afd
	var _v VideoAFDValue // out
	_v = VideoAFDValue(*valptr)
	return _v
}

// Field: 0 for progressive or field 1 and 1 for field 2.
func (v *VideoAFDMeta) SetField(field byte) {
	valptr := &v.native.field
	*valptr = C.guint8(field)
}

// VideoBarMeta: bar data should be included in video user data whenever the
// rectangular picture area containing useful information does not extend to the
// full height or width of the coded frame and AFD alone is insufficient to
// describe the extent of the image.
//
// Note: either vertical or horizontal bars are specified, but not both.
//
// For more details, see:
//
// https://www.atsc.org/wp-content/uploads/2015/03/a_53-Part-4-2009.pdf
//
// and SMPTE ST2016-1
//
// An instance of this type is always passed by reference.
type VideoBarMeta struct {
	*videoBarMeta
}

// videoBarMeta is the struct that's finalized.
type videoBarMeta struct {
	native *C.GstVideoBarMeta
}

// Meta: parent Meta.
func (v *VideoBarMeta) Meta() *gst.Meta {
	valptr := &v.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Field: 0 for progressive or field 1 and 1 for field 2.
func (v *VideoBarMeta) Field() byte {
	valptr := &v.native.field
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// IsLetterbox: if true then bar data specifies letterbox, otherwise pillarbox.
func (v *VideoBarMeta) IsLetterbox() bool {
	valptr := &v.native.is_letterbox
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// BarData1: if is_letterbox is true, then the value specifies the last line of
// a horizontal letterbox bar area at top of reconstructed frame. Otherwise, it
// specifies the last horizontal luminance sample of a vertical pillarbox bar
// area at the left side of the reconstructed frame.
func (v *VideoBarMeta) BarData1() uint {
	valptr := &v.native.bar_data1
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// BarData2: if is_letterbox is true, then the value specifies the first line of
// a horizontal letterbox bar area at bottom of reconstructed frame. Otherwise,
// it specifies the first horizontal luminance sample of a vertical pillarbox
// bar area at the right side of the reconstructed frame.
func (v *VideoBarMeta) BarData2() uint {
	valptr := &v.native.bar_data2
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Field: 0 for progressive or field 1 and 1 for field 2.
func (v *VideoBarMeta) SetField(field byte) {
	valptr := &v.native.field
	*valptr = C.guint8(field)
}

// IsLetterbox: if true then bar data specifies letterbox, otherwise pillarbox.
func (v *VideoBarMeta) SetIsLetterbox(isLetterbox bool) {
	valptr := &v.native.is_letterbox
	if isLetterbox {
		*valptr = C.TRUE
	}
}

// BarData1: if is_letterbox is true, then the value specifies the last line of
// a horizontal letterbox bar area at top of reconstructed frame. Otherwise, it
// specifies the last horizontal luminance sample of a vertical pillarbox bar
// area at the left side of the reconstructed frame.
func (v *VideoBarMeta) SetBarData1(barData1 uint) {
	valptr := &v.native.bar_data1
	*valptr = C.guint(barData1)
}

// BarData2: if is_letterbox is true, then the value specifies the first line of
// a horizontal letterbox bar area at bottom of reconstructed frame. Otherwise,
// it specifies the first horizontal luminance sample of a vertical pillarbox
// bar area at the right side of the reconstructed frame.
func (v *VideoBarMeta) SetBarData2(barData2 uint) {
	valptr := &v.native.bar_data2
	*valptr = C.guint(barData2)
}
