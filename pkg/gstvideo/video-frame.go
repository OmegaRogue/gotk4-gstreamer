// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoBufferFlags = coreglib.Type(C.gst_video_buffer_flags_get_type())
	GTypeVideoFrameFlags  = coreglib.Type(C.gst_video_frame_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoBufferFlags, F: marshalVideoBufferFlags},
		coreglib.TypeMarshaler{T: GTypeVideoFrameFlags, F: marshalVideoFrameFlags},
	})
}

// VideoBufferFlags: additional video buffer flags. These flags can potentially
// be used on any buffers carrying closed caption data, or video data - even
// encoded data.
//
// Note that these are only valid for Caps of type: video/... and caption/...
// They can conflict with other extended buffer flags.
type VideoBufferFlags C.guint

const (
	// VideoBufferFlagTff: if the Buffer is interlaced, then the first field in
	// the video frame is the top field. If unset, the bottom field is first.
	VideoBufferFlagTff VideoBufferFlags = 0b1000000000000000000000
	// VideoBufferFlagRff: if the Buffer is interlaced, then the first field (as
	// defined by the GST_VIDEO_BUFFER_FLAG_TFF flag setting) is repeated.
	VideoBufferFlagRff VideoBufferFlags = 0b10000000000000000000000
	// VideoBufferFlagMultipleView contains one or more specific views, such as
	// left or right eye view. This flags is set on any buffer that contains
	// non-mono content - even for streams that contain only a single viewpoint.
	// In mixed mono / non-mono streams, the absence of the flag marks mono
	// buffers.
	VideoBufferFlagMultipleView VideoBufferFlags = 0b1000000000000000000000000
	// VideoBufferFlagMarker contains the end of a video field or frame boundary
	// such as the last subframe or packet (Since: 1.18).
	VideoBufferFlagMarker VideoBufferFlags = 0b1000000000
	// VideoBufferFlagInterlaced: if the Buffer is interlaced. In mixed
	// interlace-mode, this flags specifies if the frame is interlaced or
	// progressive.
	VideoBufferFlagInterlaced VideoBufferFlags = 0b100000000000000000000
	// VideoBufferFlagOnefield: if the Buffer is interlaced, then only the first
	// field (as defined by the GST_VIDEO_BUFFER_FLAG_TFF flag setting) is to be
	// displayed (Since: 1.16).
	VideoBufferFlagOnefield VideoBufferFlags = 0b100000000000000000000000
	// VideoBufferFlagFirstInBundle: when conveying stereo/multiview content
	// with frame-by-frame methods, this flag marks the first buffer in a bundle
	// of frames that belong together.
	VideoBufferFlagFirstInBundle VideoBufferFlags = 0b10000000000000000000000000
	// VideoBufferFlagTopField: video frame has the top field only. This is the
	// same as GST_VIDEO_BUFFER_FLAG_TFF | GST_VIDEO_BUFFER_FLAG_ONEFIELD
	// (Since: 1.16). Use GST_VIDEO_BUFFER_IS_TOP_FIELD() to check for this
	// flag.
	VideoBufferFlagTopField VideoBufferFlags = 0b101000000000000000000000
	// VideoBufferFlagBottomField: video frame has the bottom field only. This
	// is the same as GST_VIDEO_BUFFER_FLAG_ONEFIELD (GST_VIDEO_BUFFER_FLAG_TFF
	// flag unset) (Since: 1.16). Use GST_VIDEO_BUFFER_IS_BOTTOM_FIELD() to
	// check for this flag.
	VideoBufferFlagBottomField VideoBufferFlags = 0b100000000000000000000000
	// VideoBufferFlagLast: offset to define more flags.
	VideoBufferFlagLast VideoBufferFlags = 0b10000000000000000000000000000
)

func marshalVideoBufferFlags(p uintptr) (interface{}, error) {
	return VideoBufferFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoBufferFlags.
func (v VideoBufferFlags) String() string {
	if v == 0 {
		return "VideoBufferFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(237)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoBufferFlagTff:
			builder.WriteString("Tff|")
		case VideoBufferFlagRff:
			builder.WriteString("Rff|")
		case VideoBufferFlagMultipleView:
			builder.WriteString("MultipleView|")
		case VideoBufferFlagMarker:
			builder.WriteString("Marker|")
		case VideoBufferFlagInterlaced:
			builder.WriteString("Interlaced|")
		case VideoBufferFlagOnefield:
			builder.WriteString("Onefield|")
		case VideoBufferFlagFirstInBundle:
			builder.WriteString("FirstInBundle|")
		case VideoBufferFlagTopField:
			builder.WriteString("TopField|")
		case VideoBufferFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("VideoBufferFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoBufferFlags) Has(other VideoBufferFlags) bool {
	return (v & other) == other
}

// VideoFrameFlags: extra video frame flags.
type VideoFrameFlags C.guint

const (
	// VideoFrameFlagNone: no flags.
	VideoFrameFlagNone VideoFrameFlags = 0b0
	// VideoFrameFlagInterlaced: video frame is interlaced. In mixed
	// interlace-mode, this flag specifies if the frame is interlaced or
	// progressive.
	VideoFrameFlagInterlaced VideoFrameFlags = 0b1
	// VideoFrameFlagOnefield: video frame has one field.
	VideoFrameFlagOnefield VideoFrameFlags = 0b1000
	// VideoFrameFlagMultipleView: video contains one or more non-mono views.
	VideoFrameFlagMultipleView VideoFrameFlags = 0b10000
	// VideoFrameFlagFirstInBundle: video frame is the first in a set of
	// corresponding views provided as sequential frames.
	VideoFrameFlagFirstInBundle VideoFrameFlags = 0b100000
	// VideoFrameFlagTopField: video frame has the top field only. This is the
	// same as GST_VIDEO_FRAME_FLAG_TFF | GST_VIDEO_FRAME_FLAG_ONEFIELD (Since:
	// 1.16).
	VideoFrameFlagTopField VideoFrameFlags = 0b1010
	// VideoFrameFlagTff: video frame has the top field first.
	VideoFrameFlagTff VideoFrameFlags = 0b10
	// VideoFrameFlagRff: video frame has the repeat flag.
	VideoFrameFlagRff VideoFrameFlags = 0b100
	// VideoFrameFlagBottomField: video frame has the bottom field only. This is
	// the same as GST_VIDEO_FRAME_FLAG_ONEFIELD (GST_VIDEO_FRAME_FLAG_TFF flag
	// unset) (Since: 1.16).
	VideoFrameFlagBottomField VideoFrameFlags = 0b1000
)

func marshalVideoFrameFlags(p uintptr) (interface{}, error) {
	return VideoFrameFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoFrameFlags.
func (v VideoFrameFlags) String() string {
	if v == 0 {
		return "VideoFrameFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(206)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoFrameFlagNone:
			builder.WriteString("None|")
		case VideoFrameFlagInterlaced:
			builder.WriteString("Interlaced|")
		case VideoFrameFlagOnefield:
			builder.WriteString("Onefield|")
		case VideoFrameFlagMultipleView:
			builder.WriteString("MultipleView|")
		case VideoFrameFlagFirstInBundle:
			builder.WriteString("FirstInBundle|")
		case VideoFrameFlagTopField:
			builder.WriteString("TopField|")
		case VideoFrameFlagTff:
			builder.WriteString("Tff|")
		case VideoFrameFlagRff:
			builder.WriteString("Rff|")
		default:
			builder.WriteString(fmt.Sprintf("VideoFrameFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoFrameFlags) Has(other VideoFrameFlags) bool {
	return (v & other) == other
}

// VideoFrame: video frame obtained from gst_video_frame_map()
//
// An instance of this type is always passed by reference.
type VideoFrame struct {
	*videoFrame
}

// videoFrame is the struct that's finalized.
type videoFrame struct {
	native *C.GstVideoFrame
}

// Info: VideoInfo.
func (v *VideoFrame) Info() *VideoInfo {
	valptr := &v.native.info
	var _v *VideoInfo // out
	_v = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Flags for the frame.
func (v *VideoFrame) Flags() VideoFrameFlags {
	valptr := &v.native.flags
	var _v VideoFrameFlags // out
	_v = VideoFrameFlags(*valptr)
	return _v
}

// Buffer: mapped buffer.
func (v *VideoFrame) Buffer() *gst.Buffer {
	valptr := &v.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Meta: pointer to metadata if any.
func (v *VideoFrame) Meta() unsafe.Pointer {
	valptr := &v.native.meta
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// ID: id of the mapped frame. the id can for example be used to identify the
// frame in case of multiview video.
func (v *VideoFrame) ID() int {
	valptr := &v.native.id
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Data pointers to the plane data.
func (v *VideoFrame) Data() [4]unsafe.Pointer {
	valptr := &v.native.data
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// Map mappings of the planes.
func (v *VideoFrame) Map() [4]gst.MapInfo {
	valptr := &v.native._map
	var _v [4]gst.MapInfo // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = *(*gst.MapInfo)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}
	return _v
}

// ID: id of the mapped frame. the id can for example be used to identify the
// frame in case of multiview video.
func (v *VideoFrame) SetID(id int) {
	valptr := &v.native.id
	*valptr = C.gint(id)
}

// Copy the contents from src to dest.
//
// Note: Since: 1.18, dest dimensions are allowed to be smaller than src
// dimensions.
//
// The function takes the following parameters:
//
//    - src: VideoFrame.
//
// The function returns the following values:
//
//    - ok: TRUE if the contents could be copied.
//
func (dest *VideoFrame) Copy(src *VideoFrame) bool {
	var _arg0 *C.GstVideoFrame // out
	var _arg1 *C.GstVideoFrame // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg1 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(src)))

	_cret = C.gst_video_frame_copy(_arg0, _arg1)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyPlane: copy the plane with index plane from src to dest.
//
// Note: Since: 1.18, dest dimensions are allowed to be smaller than src
// dimensions.
//
// The function takes the following parameters:
//
//    - src: VideoFrame.
//    - plane: plane.
//
// The function returns the following values:
//
//    - ok: TRUE if the contents could be copied.
//
func (dest *VideoFrame) CopyPlane(src *VideoFrame, plane uint) bool {
	var _arg0 *C.GstVideoFrame // out
	var _arg1 *C.GstVideoFrame // out
	var _arg2 C.guint          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg1 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(src)))
	_arg2 = C.guint(plane)

	_cret = C.gst_video_frame_copy_plane(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(plane)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unmap the memory previously mapped with gst_video_frame_map.
func (frame *VideoFrame) Unmap() {
	var _arg0 *C.GstVideoFrame // out

	_arg0 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	C.gst_video_frame_unmap(_arg0)
	runtime.KeepAlive(frame)
}

// VideoFrameMap: use info and buffer to fill in the values of frame. frame is
// usually allocated on the stack, and you will pass the address to the
// VideoFrame structure allocated on the stack; gst_video_frame_map() will then
// fill in the structures with the various video-specific information you need
// to access the pixels of the video buffer. You can then use accessor macros
// such as GST_VIDEO_FRAME_COMP_DATA(), GST_VIDEO_FRAME_PLANE_DATA(),
// GST_VIDEO_FRAME_COMP_STRIDE(), GST_VIDEO_FRAME_PLANE_STRIDE() etc. to get to
// the pixels.
//
//      GstVideoFrame vframe;
//      ...
//      // set RGB pixels to black one at a time
//      if (gst_video_frame_map (&vframe, video_info, video_buffer, GST_MAP_WRITE)) {
//        guint8 *pixels = GST_VIDEO_FRAME_PLANE_DATA (vframe, 0);
//        guint stride = GST_VIDEO_FRAME_PLANE_STRIDE (vframe, 0);
//        guint pixel_stride = GST_VIDEO_FRAME_COMP_PSTRIDE (vframe, 0);
//
//        for (h = 0; h < height; ++h) {
//          for (w = 0; w < width; ++w) {
//            guint8 *pixel = pixels + h * stride + w * pixel_stride;
//
//            memset (pixel, 0, pixel_stride);
//          }
//        }
//
//        gst_video_frame_unmap (&vframe);
//      }
//      ...
//
// All video planes of buffer will be mapped and the pointers will be set in
// frame->data.
//
// The purpose of this function is to make it easy for you to get to the video
// pixels in a generic way, without you having to worry too much about details
// such as whether the video data is allocated in one contiguous memory chunk or
// multiple memory chunks (e.g. one for each plane); or if custom strides and
// custom plane offsets are used or not (as signalled by GstVideoMeta on each
// buffer). This function will just fill the VideoFrame structure with the right
// values and if you use the accessor macros everything will just work and you
// can access the data easily. It also maps the underlying memory chunks for
// you.
//
// The function takes the following parameters:
//
//    - info: VideoInfo.
//    - buffer to map.
//    - flags: MapFlags.
//
// The function returns the following values:
//
//    - frame: pointer to VideoFrame.
//    - ok: TRUE on success.
//
func VideoFrameMap(info *VideoInfo, buffer *gst.Buffer, flags gst.MapFlags) (*VideoFrame, bool) {
	var _arg1 C.GstVideoFrame // in
	var _arg2 *C.GstVideoInfo // out
	var _arg3 *C.GstBuffer    // out
	var _arg4 C.GstMapFlags   // out
	var _cret C.gboolean      // in

	_arg2 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg4 = C.GstMapFlags(flags)

	_cret = C.gst_video_frame_map(&_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(info)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _frame *VideoFrame // out
	var _ok bool           // out

	_frame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _frame, _ok
}

// VideoFrameMapID: use info and buffer to fill in the values of frame with the
// video frame information of frame id.
//
// When id is -1, the default frame is mapped. When id != -1, this function will
// return FALSE when there is no GstVideoMeta with that id.
//
// All video planes of buffer will be mapped and the pointers will be set in
// frame->data.
//
// The function takes the following parameters:
//
//    - info: VideoInfo.
//    - buffer to map.
//    - id: frame id to map.
//    - flags: MapFlags.
//
// The function returns the following values:
//
//    - frame: pointer to VideoFrame.
//    - ok: TRUE on success.
//
func VideoFrameMapID(info *VideoInfo, buffer *gst.Buffer, id int, flags gst.MapFlags) (*VideoFrame, bool) {
	var _arg1 C.GstVideoFrame // in
	var _arg2 *C.GstVideoInfo // out
	var _arg3 *C.GstBuffer    // out
	var _arg4 C.gint          // out
	var _arg5 C.GstMapFlags   // out
	var _cret C.gboolean      // in

	_arg2 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg4 = C.gint(id)
	_arg5 = C.GstMapFlags(flags)

	_cret = C.gst_video_frame_map_id(&_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(info)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(id)
	runtime.KeepAlive(flags)

	var _frame *VideoFrame // out
	var _ok bool           // out

	_frame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _frame, _ok
}
