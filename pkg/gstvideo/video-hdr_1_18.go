// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/video/video.h>
import "C"

// VideoContentLightLevel: content light level information specified in
// CEA-861.3, Appendix A.
//
// An instance of this type is always passed by reference.
type VideoContentLightLevel struct {
	*videoContentLightLevel
}

// videoContentLightLevel is the struct that's finalized.
type videoContentLightLevel struct {
	native *C.GstVideoContentLightLevel
}

// MaxContentLightLevel: maximum content light level (abbreviated to MaxCLL) in
// candelas per square meter (cd/m^2 and nit).
func (v *VideoContentLightLevel) MaxContentLightLevel() uint16 {
	valptr := &v.native.max_content_light_level
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// MaxFrameAverageLightLevel: maximum frame average light level (abbreviated to
// MaxFLL) in candelas per square meter (cd/m^2 and nit).
func (v *VideoContentLightLevel) MaxFrameAverageLightLevel() uint16 {
	valptr := &v.native.max_frame_average_light_level
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// MaxContentLightLevel: maximum content light level (abbreviated to MaxCLL) in
// candelas per square meter (cd/m^2 and nit).
func (v *VideoContentLightLevel) SetMaxContentLightLevel(maxContentLightLevel uint16) {
	valptr := &v.native.max_content_light_level
	*valptr = C.guint16(maxContentLightLevel)
}

// MaxFrameAverageLightLevel: maximum frame average light level (abbreviated to
// MaxFLL) in candelas per square meter (cd/m^2 and nit).
func (v *VideoContentLightLevel) SetMaxFrameAverageLightLevel(maxFrameAverageLightLevel uint16) {
	valptr := &v.native.max_frame_average_light_level
	*valptr = C.guint16(maxFrameAverageLightLevel)
}

// AddToCaps: parse caps and update linfo.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if linfo was successfully set to caps.
//
func (linfo *VideoContentLightLevel) AddToCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstVideoContentLightLevel // out
	var _arg1 *C.GstCaps                   // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(linfo)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_video_content_light_level_add_to_caps(_arg0, _arg1)
	runtime.KeepAlive(linfo)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FromCaps: parse caps and update linfo.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: if caps has VideoContentLightLevel and could be parsed.
//
func (linfo *VideoContentLightLevel) FromCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstVideoContentLightLevel // out
	var _arg1 *C.GstCaps                   // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(linfo)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_video_content_light_level_from_caps(_arg0, _arg1)
	runtime.KeepAlive(linfo)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FromString: parse the value of content-light-level caps field and update
// minfo with the parsed values.
//
// The function takes the following parameters:
//
//    - level string from caps.
//
// The function returns the following values:
//
//    - ok: TRUE if linfo points to valid VideoContentLightLevel.
//
func (linfo *VideoContentLightLevel) FromString(level string) bool {
	var _arg0 *C.GstVideoContentLightLevel // out
	var _arg1 *C.gchar                     // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(linfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(level)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_video_content_light_level_from_string(_arg0, _arg1)
	runtime.KeepAlive(linfo)
	runtime.KeepAlive(level)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Init: initialize linfo.
func (linfo *VideoContentLightLevel) Init() {
	var _arg0 *C.GstVideoContentLightLevel // out

	_arg0 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(linfo)))

	C.gst_video_content_light_level_init(_arg0)
	runtime.KeepAlive(linfo)
}

// IsEqual checks equality between linfo and other.
//
// The function takes the following parameters:
//
//    - other: VideoContentLightLevel.
//
// The function returns the following values:
//
//    - ok: TRUE if linfo and other are equal.
//
func (linfo *VideoContentLightLevel) IsEqual(other *VideoContentLightLevel) bool {
	var _arg0 *C.GstVideoContentLightLevel // out
	var _arg1 *C.GstVideoContentLightLevel // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(linfo)))
	_arg1 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(other)))

	_cret = C.gst_video_content_light_level_is_equal(_arg0, _arg1)
	runtime.KeepAlive(linfo)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String: convert linfo to its string representation.
//
// The function returns the following values:
//
//    - utf8: string representation of linfo.
//
func (linfo *VideoContentLightLevel) String() string {
	var _arg0 *C.GstVideoContentLightLevel // out
	var _cret *C.gchar                     // in

	_arg0 = (*C.GstVideoContentLightLevel)(gextras.StructNative(unsafe.Pointer(linfo)))

	_cret = C.gst_video_content_light_level_to_string(_arg0)
	runtime.KeepAlive(linfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VideoMasteringDisplayInfo: mastering display color volume information defined
// by SMPTE ST 2086 (a.k.a static HDR metadata).
//
// An instance of this type is always passed by reference.
type VideoMasteringDisplayInfo struct {
	*videoMasteringDisplayInfo
}

// videoMasteringDisplayInfo is the struct that's finalized.
type videoMasteringDisplayInfo struct {
	native *C.GstVideoMasteringDisplayInfo
}

// DisplayPrimaries: xy coordinates of primaries in the CIE 1931 color space.
// the index 0 contains red, 1 is for green and 2 is for blue. each value is
// normalized to 50000 (meaning that in unit of 0.00002).
func (v *VideoMasteringDisplayInfo) DisplayPrimaries() [3]VideoMasteringDisplayInfoCoordinates {
	valptr := &v.native.display_primaries
	var _v [3]VideoMasteringDisplayInfoCoordinates // out
	{
		src := &*valptr
		for i := 0; i < 3; i++ {
			_v[i] = *(*VideoMasteringDisplayInfoCoordinates)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}
	return _v
}

// WhitePoint: xy coordinates of white point in the CIE 1931 color space. each
// value is normalized to 50000 (meaning that in unit of 0.00002).
func (v *VideoMasteringDisplayInfo) WhitePoint() *VideoMasteringDisplayInfoCoordinates {
	valptr := &v.native.white_point
	var _v *VideoMasteringDisplayInfoCoordinates // out
	_v = (*VideoMasteringDisplayInfoCoordinates)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MaxDisplayMasteringLuminance: maximum value of display luminance in unit of
// 0.0001 candelas per square metre (cd/m^2 and nit).
func (v *VideoMasteringDisplayInfo) MaxDisplayMasteringLuminance() uint32 {
	valptr := &v.native.max_display_mastering_luminance
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// MinDisplayMasteringLuminance: minimum value of display luminance in unit of
// 0.0001 candelas per square metre (cd/m^2 and nit).
func (v *VideoMasteringDisplayInfo) MinDisplayMasteringLuminance() uint32 {
	valptr := &v.native.min_display_mastering_luminance
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// MaxDisplayMasteringLuminance: maximum value of display luminance in unit of
// 0.0001 candelas per square metre (cd/m^2 and nit).
func (v *VideoMasteringDisplayInfo) SetMaxDisplayMasteringLuminance(maxDisplayMasteringLuminance uint32) {
	valptr := &v.native.max_display_mastering_luminance
	*valptr = C.guint32(maxDisplayMasteringLuminance)
}

// MinDisplayMasteringLuminance: minimum value of display luminance in unit of
// 0.0001 candelas per square metre (cd/m^2 and nit).
func (v *VideoMasteringDisplayInfo) SetMinDisplayMasteringLuminance(minDisplayMasteringLuminance uint32) {
	valptr := &v.native.min_display_mastering_luminance
	*valptr = C.guint32(minDisplayMasteringLuminance)
}

// AddToCaps: set string representation of minfo to caps.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if minfo was successfully set to caps.
//
func (minfo *VideoMasteringDisplayInfo) AddToCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstVideoMasteringDisplayInfo // out
	var _arg1 *C.GstCaps                      // out
	var _cret C.gboolean                      // in

	_arg0 = (*C.GstVideoMasteringDisplayInfo)(gextras.StructNative(unsafe.Pointer(minfo)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_video_mastering_display_info_add_to_caps(_arg0, _arg1)
	runtime.KeepAlive(minfo)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FromCaps: parse caps and update minfo.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if caps has VideoMasteringDisplayInfo and could be parsed.
//
func (minfo *VideoMasteringDisplayInfo) FromCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstVideoMasteringDisplayInfo // out
	var _arg1 *C.GstCaps                      // out
	var _cret C.gboolean                      // in

	_arg0 = (*C.GstVideoMasteringDisplayInfo)(gextras.StructNative(unsafe.Pointer(minfo)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_video_mastering_display_info_from_caps(_arg0, _arg1)
	runtime.KeepAlive(minfo)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Init: initialize minfo.
func (minfo *VideoMasteringDisplayInfo) Init() {
	var _arg0 *C.GstVideoMasteringDisplayInfo // out

	_arg0 = (*C.GstVideoMasteringDisplayInfo)(gextras.StructNative(unsafe.Pointer(minfo)))

	C.gst_video_mastering_display_info_init(_arg0)
	runtime.KeepAlive(minfo)
}

// IsEqual checks equality between minfo and other.
//
// The function takes the following parameters:
//
//    - other: VideoMasteringDisplayInfo.
//
// The function returns the following values:
//
//    - ok: TRUE if minfo and other are equal.
//
func (minfo *VideoMasteringDisplayInfo) IsEqual(other *VideoMasteringDisplayInfo) bool {
	var _arg0 *C.GstVideoMasteringDisplayInfo // out
	var _arg1 *C.GstVideoMasteringDisplayInfo // out
	var _cret C.gboolean                      // in

	_arg0 = (*C.GstVideoMasteringDisplayInfo)(gextras.StructNative(unsafe.Pointer(minfo)))
	_arg1 = (*C.GstVideoMasteringDisplayInfo)(gextras.StructNative(unsafe.Pointer(other)))

	_cret = C.gst_video_mastering_display_info_is_equal(_arg0, _arg1)
	runtime.KeepAlive(minfo)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String: convert minfo to its string representation.
//
// The function returns the following values:
//
//    - utf8: string representation of minfo.
//
func (minfo *VideoMasteringDisplayInfo) String() string {
	var _arg0 *C.GstVideoMasteringDisplayInfo // out
	var _cret *C.gchar                        // in

	_arg0 = (*C.GstVideoMasteringDisplayInfo)(gextras.StructNative(unsafe.Pointer(minfo)))

	_cret = C.gst_video_mastering_display_info_to_string(_arg0)
	runtime.KeepAlive(minfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VideoMasteringDisplayInfoFromString: extract VideoMasteringDisplayInfo from
// mastering.
//
// The function takes the following parameters:
//
//    - mastering representing VideoMasteringDisplayInfo.
//
// The function returns the following values:
//
//    - minfo: VideoMasteringDisplayInfo.
//    - ok: TRUE if minfo was filled with mastering.
//
func VideoMasteringDisplayInfoFromString(mastering string) (*VideoMasteringDisplayInfo, bool) {
	var _arg1 C.GstVideoMasteringDisplayInfo // in
	var _arg2 *C.gchar                       // out
	var _cret C.gboolean                     // in

	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(mastering)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_video_mastering_display_info_from_string(&_arg1, _arg2)
	runtime.KeepAlive(mastering)

	var _minfo *VideoMasteringDisplayInfo // out
	var _ok bool                          // out

	_minfo = (*VideoMasteringDisplayInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _minfo, _ok
}

// VideoMasteringDisplayInfoCoordinates: used to represent display_primaries and
// white_point of VideoMasteringDisplayInfo struct. See
// VideoMasteringDisplayInfo
//
// An instance of this type is always passed by reference.
type VideoMasteringDisplayInfoCoordinates struct {
	*videoMasteringDisplayInfoCoordinates
}

// videoMasteringDisplayInfoCoordinates is the struct that's finalized.
type videoMasteringDisplayInfoCoordinates struct {
	native *C.GstVideoMasteringDisplayInfoCoordinates
}

// NewVideoMasteringDisplayInfoCoordinates creates a new VideoMasteringDisplayInfoCoordinates instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewVideoMasteringDisplayInfoCoordinates(x, y uint16) VideoMasteringDisplayInfoCoordinates {
	var f0 C.guint16 // out
	f0 = C.guint16(x)
	var f1 C.guint16 // out
	f1 = C.guint16(y)

	v := C.GstVideoMasteringDisplayInfoCoordinates{
		x: f0,
		y: f1,
	}

	return *(*VideoMasteringDisplayInfoCoordinates)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// X: x coordinate of CIE 1931 color space in unit of 0.00002.
func (v *VideoMasteringDisplayInfoCoordinates) X() uint16 {
	valptr := &v.native.x
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// Y: y coordinate of CIE 1931 color space in unit of 0.00002.
func (v *VideoMasteringDisplayInfoCoordinates) Y() uint16 {
	valptr := &v.native.y
	var _v uint16 // out
	_v = uint16(*valptr)
	return _v
}

// X: x coordinate of CIE 1931 color space in unit of 0.00002.
func (v *VideoMasteringDisplayInfoCoordinates) SetX(x uint16) {
	valptr := &v.native.x
	*valptr = C.guint16(x)
}

// Y: y coordinate of CIE 1931 color space in unit of 0.00002.
func (v *VideoMasteringDisplayInfoCoordinates) SetY(y uint16) {
	valptr := &v.native.y
	*valptr = C.guint16(y)
}
