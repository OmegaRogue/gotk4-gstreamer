// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_transform_meta(GstVideoEncoder*, GstVideoCodecFrame*, GstMeta*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_stop(GstVideoEncoder*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_start(GstVideoEncoder*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_src_query(GstVideoEncoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_src_event(GstVideoEncoder*, GstEvent*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_sink_query(GstVideoEncoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_sink_event(GstVideoEncoder*, GstEvent*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_set_format(GstVideoEncoder*, GstVideoCodecState*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_reset(GstVideoEncoder*, gboolean);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_propose_allocation(GstVideoEncoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_open(GstVideoEncoder*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_negotiate(GstVideoEncoder*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_flush(GstVideoEncoder*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_decide_allocation(GstVideoEncoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoEncoderClass_close(GstVideoEncoder*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoEncoderClass_pre_push(GstVideoEncoder*, GstVideoCodecFrame*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoEncoderClass_handle_frame(GstVideoEncoder*, GstVideoCodecFrame*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoEncoderClass_finish(GstVideoEncoder*);
// extern GstCaps* _gotk4_gstvideo1_VideoEncoderClass_getcaps(GstVideoEncoder*, GstCaps*);
// GstCaps* _gotk4_gstvideo1_VideoEncoder_virtual_getcaps(void* fnptr, GstVideoEncoder* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstVideoEncoder*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoEncoder_virtual_finish(void* fnptr, GstVideoEncoder* arg0) {
//   return ((GstFlowReturn (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoEncoder_virtual_handle_frame(void* fnptr, GstVideoEncoder* arg0, GstVideoCodecFrame* arg1) {
//   return ((GstFlowReturn (*)(GstVideoEncoder*, GstVideoCodecFrame*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoEncoder_virtual_pre_push(void* fnptr, GstVideoEncoder* arg0, GstVideoCodecFrame* arg1) {
//   return ((GstFlowReturn (*)(GstVideoEncoder*, GstVideoCodecFrame*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_close(void* fnptr, GstVideoEncoder* arg0) {
//   return ((gboolean (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_decide_allocation(void* fnptr, GstVideoEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_flush(void* fnptr, GstVideoEncoder* arg0) {
//   return ((gboolean (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_negotiate(void* fnptr, GstVideoEncoder* arg0) {
//   return ((gboolean (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_open(void* fnptr, GstVideoEncoder* arg0) {
//   return ((gboolean (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_propose_allocation(void* fnptr, GstVideoEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_reset(void* fnptr, GstVideoEncoder* arg0, gboolean arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_set_format(void* fnptr, GstVideoEncoder* arg0, GstVideoCodecState* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstVideoCodecState*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_sink_event(void* fnptr, GstVideoEncoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_sink_query(void* fnptr, GstVideoEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_src_event(void* fnptr, GstVideoEncoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_src_query(void* fnptr, GstVideoEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_start(void* fnptr, GstVideoEncoder* arg0) {
//   return ((gboolean (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_stop(void* fnptr, GstVideoEncoder* arg0) {
//   return ((gboolean (*)(GstVideoEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoEncoder_virtual_transform_meta(void* fnptr, GstVideoEncoder* arg0, GstVideoCodecFrame* arg1, GstMeta* arg2) {
//   return ((gboolean (*)(GstVideoEncoder*, GstVideoCodecFrame*, GstMeta*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeVideoEncoder = coreglib.Type(C.gst_video_encoder_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoEncoder, F: marshalVideoEncoder},
	})
}

// VIDEO_ENCODER_SINK_NAME: name of the templates for the sink pad.
const VIDEO_ENCODER_SINK_NAME = "sink"

// VIDEO_ENCODER_SRC_NAME: name of the templates for the source pad.
const VIDEO_ENCODER_SRC_NAME = "src"

// VideoEncoderOverrides contains methods that are overridable.
type VideoEncoderOverrides struct {
	// The function returns the following values:
	//
	Close func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	// The function returns the following values:
	//
	Finish func() gst.FlowReturn
	// The function returns the following values:
	//
	Flush func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	caps func(filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	HandleFrame func(frame *VideoCodecFrame) gst.FlowReturn
	// Negotiate with downstream elements to currently configured
	// VideoCodecState. Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But
	// mark it again if negotiate fails.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the negotiation succeeded, else FALSE.
	//
	Negotiate func() bool
	// The function returns the following values:
	//
	Open func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	PrePush func(frame *VideoCodecFrame) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProposeAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Reset func(hard bool) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetFormat func(state *VideoCodecState) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkQuery func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcQuery func(query *gst.Query) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function takes the following parameters:
	//
	//    - frame
	//    - meta
	//
	// The function returns the following values:
	//
	TransformMeta func(frame *VideoCodecFrame, meta *gst.Meta) bool
}

func defaultVideoEncoderOverrides(v *VideoEncoder) VideoEncoderOverrides {
	return VideoEncoderOverrides{
		Close:             v.close,
		DecideAllocation:  v.decideAllocation,
		Finish:            v.finish,
		Flush:             v.flush,
		caps:              v.caps,
		HandleFrame:       v.handleFrame,
		Negotiate:         v.negotiate,
		Open:              v.open,
		PrePush:           v.prePush,
		ProposeAllocation: v.proposeAllocation,
		Reset:             v.reset,
		SetFormat:         v.setFormat,
		SinkEvent:         v.sinkEvent,
		SinkQuery:         v.sinkQuery,
		SrcEvent:          v.srcEvent,
		SrcQuery:          v.srcQuery,
		Start:             v.start,
		Stop:              v.stop,
		TransformMeta:     v.transformMeta,
	}
}

// VideoEncoder: this base class is for video encoders turning raw video into
// encoded video data.
//
// GstVideoEncoder and subclass should cooperate as follows.
//
// Configuration
//
//    * Initially, GstVideoEncoder calls start when the encoder element
//      is activated, which allows subclass to perform any global setup.
//    * GstVideoEncoder calls set_format to inform subclass of the format
//      of input video data that it is about to receive.  Subclass should
//      setup for encoding and configure base class as appropriate
//      (e.g. latency). While unlikely, it might be called more than once,
//      if changing input parameters require reconfiguration.  Baseclass
//      will ensure that processing of current configuration is finished.
//    * GstVideoEncoder calls stop at end of all processing.
//
// Data processing
//
//    * Base class collects input data and metadata into a frame and hands
//      this to subclass' handle_frame.
//
//    * If codec processing results in encoded data, subclass should call
//      gst_video_encoder_finish_frame to have encoded data pushed
//      downstream.
//
//    * If implemented, baseclass calls subclass pre_push just prior to
//      pushing to allow subclasses to modify some metadata on the buffer.
//      If it returns GST_FLOW_OK, the buffer is pushed downstream.
//
//    * GstVideoEncoderClass will handle both srcpad and sinkpad events.
//      Sink events will be passed to subclass if event callback has been
//      provided.
//
// Shutdown phase
//
//    * GstVideoEncoder class calls stop to inform the subclass that data
//      parsing will be stopped.
//
// Subclass is responsible for providing pad template caps for source and sink
// pads. The pads need to be named "sink" and "src". It should also be able to
// provide fixed src pad caps in getcaps by the time it calls
// gst_video_encoder_finish_frame.
//
// Things that subclass need to take care of:
//
//     * Provide pad templates
//     * Provide source pad caps before pushing the first buffer
//     * Accept data in handle_frame and provide encoded results to
//        gst_video_encoder_finish_frame.
//
//    The VideoEncoder:qos property will enable the Quality-of-Service features of the encoder which gather statistics about the real-time performance of the downstream elements. If enabled, subclasses can use gst_video_encoder_get_max_encode_time() to check if input frames are already late and drop them right away to give a chance to the pipeline to catch up.
type VideoEncoder struct {
	_ [0]func() // equal guard
	gst.Element

	gst.Preset
}

var (
	_ gst.Elementer = (*VideoEncoder)(nil)
)

// VideoEncoderer describes types inherited from class VideoEncoder.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type VideoEncoderer interface {
	coreglib.Objector
	baseVideoEncoder() *VideoEncoder
}

var _ VideoEncoderer = (*VideoEncoder)(nil)

func init() {
	coreglib.RegisterClassInfo[*VideoEncoder, *VideoEncoderClass, VideoEncoderOverrides](
		GTypeVideoEncoder,
		initVideoEncoderClass,
		wrapVideoEncoder,
		defaultVideoEncoderOverrides,
	)
}

func initVideoEncoderClass(gclass unsafe.Pointer, overrides VideoEncoderOverrides, classInitFunc func(*VideoEncoderClass)) {
	pclass := (*C.GstVideoEncoderClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVideoEncoder))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_close)
	}

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_decide_allocation)
	}

	if overrides.Finish != nil {
		pclass.finish = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_finish)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_flush)
	}

	if overrides.caps != nil {
		pclass.getcaps = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_getcaps)
	}

	if overrides.HandleFrame != nil {
		pclass.handle_frame = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_handle_frame)
	}

	if overrides.Negotiate != nil {
		pclass.negotiate = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_negotiate)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_open)
	}

	if overrides.PrePush != nil {
		pclass.pre_push = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_pre_push)
	}

	if overrides.ProposeAllocation != nil {
		pclass.propose_allocation = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_propose_allocation)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_reset)
	}

	if overrides.SetFormat != nil {
		pclass.set_format = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_set_format)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_sink_event)
	}

	if overrides.SinkQuery != nil {
		pclass.sink_query = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_sink_query)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_src_event)
	}

	if overrides.SrcQuery != nil {
		pclass.src_query = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_src_query)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_stop)
	}

	if overrides.TransformMeta != nil {
		pclass.transform_meta = (*[0]byte)(C._gotk4_gstvideo1_VideoEncoderClass_transform_meta)
	}

	if classInitFunc != nil {
		class := (*VideoEncoderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideoEncoder(obj *coreglib.Object) *VideoEncoder {
	return &VideoEncoder{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
		Preset: gst.Preset{
			Object: obj,
		},
	}
}

func marshalVideoEncoder(p uintptr) (interface{}, error) {
	return wrapVideoEncoder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (encoder *VideoEncoder) baseVideoEncoder() *VideoEncoder {
	return encoder
}

// BaseVideoEncoder returns the underlying base object.
func BaseVideoEncoder(obj VideoEncoderer) *VideoEncoder {
	return obj.baseVideoEncoder()
}

// AllocateOutputBuffer: helper function that allocates a buffer to hold an
// encoded video frame for encoder's current VideoCodecState.
//
// The function takes the following parameters:
//
//    - size of the buffer.
//
// The function returns the following values:
//
//    - buffer: allocated buffer.
//
func (encoder *VideoEncoder) AllocateOutputBuffer(size uint) *gst.Buffer {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.gsize            // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = C.gsize(size)

	_cret = C.gst_video_encoder_allocate_output_buffer(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// AllocateOutputFrame: helper function that allocates a buffer to hold an
// encoded video frame for encoder's current VideoCodecState. Subclass should
// already have configured video state and set src pad caps.
//
// The buffer allocated here is owned by the frame and you should only keep
// references to the frame, not the buffer.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//    - size of the buffer.
//
// The function returns the following values:
//
//    - flowReturn: GST_FLOW_OK if an output buffer could be allocated.
//
func (encoder *VideoEncoder) AllocateOutputFrame(frame *VideoCodecFrame, size uint) gst.FlowReturn {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _arg2 C.gsize               // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = C.gsize(size)

	_cret = C.gst_video_encoder_allocate_output_frame(_arg0, _arg1, _arg2)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(size)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// FinishFrame: frame must have a valid encoded data buffer, whose metadata
// fields are then appropriately set according to frame data or no buffer at all
// if the frame should be dropped. It is subsequently pushed downstream or
// provided to pre_push. In any case, the frame is considered finished and
// released.
//
// After calling this function the output buffer of the frame is to be
// considered read-only. This function will also change the metadata of the
// buffer.
//
// The function takes the following parameters:
//
//    - frame: encoded VideoCodecFrame.
//
// The function returns the following values:
//
//    - flowReturn resulting from sending data downstream.
//
func (encoder *VideoEncoder) FinishFrame(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_encoder_finish_frame(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// FinishSubframe: if multiple subframes are produced for one input frame then
// use this method for each subframe, except for the last one. Before calling
// this function, you need to fill frame->output_buffer with the encoded buffer
// to push.
//
// You must call #gst_video_encoder_finish_frame() for the last sub-frame to
// tell the encoder that the frame has been fully encoded.
//
// This function will change the metadata of frame and frame->output_buffer will
// be pushed downstream.
//
// The function takes the following parameters:
//
//    - frame being encoded.
//
// The function returns the following values:
//
//    - flowReturn resulting from pushing the buffer downstream.
//
func (encoder *VideoEncoder) FinishSubframe(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_encoder_finish_subframe(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Allocator lets VideoEncoder sub-classes to know the memory allocator used by
// the base class and its params.
//
// Unref the allocator after use it.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) the AllocationParams of allocator.
//
func (encoder *VideoEncoder) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	C.gst_video_encoder_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(encoder)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_params)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocator, _params
}

// Frame: get a pending unfinished VideoCodecFrame.
//
// The function takes the following parameters:
//
//    - frameNumber: system_frame_number of a frame.
//
// The function returns the following values:
//
//    - videoCodecFrame: pending unfinished VideoCodecFrame identified by
//      frame_number.
//
func (encoder *VideoEncoder) Frame(frameNumber int) *VideoCodecFrame {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 C.int                 // out
	var _cret *C.GstVideoCodecFrame // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = C.int(frameNumber)

	_cret = C.gst_video_encoder_get_frame(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frameNumber)

	var _videoCodecFrame *VideoCodecFrame // out

	_videoCodecFrame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecFrame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	return _videoCodecFrame
}

// Frames: get all pending unfinished VideoCodecFrame.
//
// The function returns the following values:
//
//    - list: pending unfinished VideoCodecFrame.
//
func (encoder *VideoEncoder) Frames() []*VideoCodecFrame {
	var _arg0 *C.GstVideoEncoder // out
	var _cret *C.GList           // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C.gst_video_encoder_get_frames(_arg0)
	runtime.KeepAlive(encoder)

	var _list []*VideoCodecFrame // out

	_list = make([]*VideoCodecFrame, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstVideoCodecFrame)(v)
		var dst *VideoCodecFrame // out
		dst = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// Latency: query the configured encoding latency. Results will be returned via
// min_latency and max_latency.
//
// The function returns the following values:
//
//    - minLatency (optional) address of variable in which to store the
//      configured minimum latency, or NULL.
//    - maxLatency (optional) address of variable in which to store the
//      configured maximum latency, or NULL.
//
func (encoder *VideoEncoder) Latency() (minLatency, maxLatency gst.ClockTime) {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.GstClockTime     // in
	var _arg2 C.GstClockTime     // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	C.gst_video_encoder_get_latency(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(encoder)

	var _minLatency gst.ClockTime // out
	var _maxLatency gst.ClockTime // out

	_minLatency = uint64(_arg1)
	type _ = gst.ClockTime
	type _ = uint64
	_maxLatency = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64

	return _minLatency, _maxLatency
}

// MaxEncodeTime determines maximum possible encoding time for frame that will
// allow it to encode and arrive in time (as determined by QoS events). In
// particular, a negative result means encoding in time is no longer possible
// and should therefore occur as soon/skippy as possible.
//
// If no QoS events have been received from downstream, or if VideoEncoder:qos
// is disabled this function returns MAXINT64.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//
// The function returns the following values:
//
//    - clockTimeDiff: max decoding time.
//
func (encoder *VideoEncoder) MaxEncodeTime(frame *VideoCodecFrame) gst.ClockTimeDiff {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstClockTimeDiff    // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_encoder_get_max_encode_time(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)

	var _clockTimeDiff gst.ClockTimeDiff // out

	_clockTimeDiff = int64(_cret)
	type _ = gst.ClockTimeDiff
	type _ = int64

	return _clockTimeDiff
}

// MinForceKeyUnitInterval returns the minimum force-keyunit interval, see
// gst_video_encoder_set_min_force_key_unit_interval() for more details.
//
// The function returns the following values:
//
//    - clockTime: minimum force-keyunit interval.
//
func (encoder *VideoEncoder) MinForceKeyUnitInterval() gst.ClockTime {
	var _arg0 *C.GstVideoEncoder // out
	var _cret C.GstClockTime     // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C.gst_video_encoder_get_min_force_key_unit_interval(_arg0)
	runtime.KeepAlive(encoder)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// OldestFrame: get the oldest unfinished pending VideoCodecFrame.
//
// The function returns the following values:
//
//    - videoCodecFrame: oldest unfinished pending VideoCodecFrame.
//
func (encoder *VideoEncoder) OldestFrame() *VideoCodecFrame {
	var _arg0 *C.GstVideoEncoder    // out
	var _cret *C.GstVideoCodecFrame // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C.gst_video_encoder_get_oldest_frame(_arg0)
	runtime.KeepAlive(encoder)

	var _videoCodecFrame *VideoCodecFrame // out

	_videoCodecFrame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecFrame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	return _videoCodecFrame
}

// OutputState: get the current VideoCodecState.
//
// The function returns the following values:
//
//    - videoCodecState describing format of video data.
//
func (encoder *VideoEncoder) OutputState() *VideoCodecState {
	var _arg0 *C.GstVideoEncoder    // out
	var _cret *C.GstVideoCodecState // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C.gst_video_encoder_get_output_state(_arg0)
	runtime.KeepAlive(encoder)

	var _videoCodecState *VideoCodecState // out

	_videoCodecState = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecState)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	return _videoCodecState
}

// IsQosEnabled checks if encoder is currently configured to handle
// Quality-of-Service events from downstream.
//
// The function returns the following values:
//
//    - ok: TRUE if the encoder is configured to perform Quality-of-Service.
//
func (encoder *VideoEncoder) IsQosEnabled() bool {
	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C.gst_video_encoder_is_qos_enabled(_arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Negotiate with downstream elements to currently configured VideoCodecState.
// Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
// negotiate fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (encoder *VideoEncoder) Negotiate() bool {
	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C.gst_video_encoder_negotiate(_arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyGetcaps returns caps that express caps (or sink template caps if caps ==
// NULL) restricted to resolution/format/... combinations supported by
// downstream elements (e.g. muxers).
//
// The function takes the following parameters:
//
//    - caps (optional): initial caps.
//    - filter (optional) caps.
//
// The function returns the following values:
//
//    - ret owned by caller.
//
func (enc *VideoEncoder) ProxyGetcaps(caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstCaps         // out
	var _arg2 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	if filter != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_video_encoder_proxy_getcaps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// SetHeaders: set the codec headers to be sent downstream whenever requested.
//
// The function takes the following parameters:
//
//    - headers: list of Buffer containing the codec header.
//
func (encoder *VideoEncoder) SetHeaders(headers []*gst.Buffer) {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GList           // out

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	for i := len(headers) - 1; i >= 0; i-- {
		src := headers[i]
		var dst *C.GstBuffer // out
		dst = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}

	C.gst_video_encoder_set_headers(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(headers)
}

// SetLatency informs baseclass of encoding latency.
//
// The function takes the following parameters:
//
//    - minLatency: minimum latency.
//    - maxLatency: maximum latency.
//
func (encoder *VideoEncoder) SetLatency(minLatency, maxLatency gst.ClockTime) {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTime     // out

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = C.guint64(minLatency)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(maxLatency)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_video_encoder_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(minLatency)
	runtime.KeepAlive(maxLatency)
}

// SetMinForceKeyUnitInterval sets the minimum interval for requesting keyframes
// based on force-keyunit events. Setting this to 0 will allow to handle every
// event, setting this to GST_CLOCK_TIME_NONE causes force-keyunit events to be
// ignored.
//
// The function takes the following parameters:
//
//    - interval: minimum interval.
//
func (encoder *VideoEncoder) SetMinForceKeyUnitInterval(interval gst.ClockTime) {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.GstClockTime     // out

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = C.guint64(interval)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_video_encoder_set_min_force_key_unit_interval(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(interval)
}

// SetMinPts: request minimal value for PTS passed to handle_frame.
//
// For streams with reordered frames this can be used to ensure that there is
// enough time to accommodate first DTS, which may be less than first PTS.
//
// The function takes the following parameters:
//
//    - minPts: minimal PTS that will be passed to handle_frame.
//
func (encoder *VideoEncoder) SetMinPts(minPts gst.ClockTime) {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.GstClockTime     // out

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = C.guint64(minPts)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_video_encoder_set_min_pts(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(minPts)
}

// SetOutputState creates a new VideoCodecState with the specified caps as the
// output state for the encoder. Any previously set output state on encoder will
// be replaced by the newly created one.
//
// The specified caps should not contain any resolution, pixel-aspect-ratio,
// framerate, codec-data, .... Those should be specified instead in the returned
// VideoCodecState.
//
// If the subclass wishes to copy over existing fields (like pixel aspect ratio,
// or framerate) from an existing VideoCodecState, it can be provided as a
// reference.
//
// If the subclass wishes to override some fields from the output state (like
// pixel-aspect-ratio or framerate) it can do so on the returned
// VideoCodecState.
//
// The new output state will only take effect (set on pads and buffers) starting
// from the next call to #gst_video_encoder_finish_frame().
//
// The function takes the following parameters:
//
//    - caps to use for the output.
//    - reference (optional): optional reference GstVideoCodecState.
//
// The function returns the following values:
//
//    - videoCodecState: newly configured output state.
//
func (encoder *VideoEncoder) SetOutputState(caps *gst.Caps, reference *VideoCodecState) *VideoCodecState {
	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstCaps            // out
	var _arg2 *C.GstVideoCodecState // out
	var _cret *C.GstVideoCodecState // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)
	if reference != nil {
		_arg2 = (*C.GstVideoCodecState)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gst_video_encoder_set_output_state(_arg0, _arg1, _arg2)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(reference)

	var _videoCodecState *VideoCodecState // out

	_videoCodecState = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecState)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	return _videoCodecState
}

// SetQosEnabled configures encoder to handle Quality-of-Service events from
// downstream.
//
// The function takes the following parameters:
//
//    - enabled: new qos value.
//
func (encoder *VideoEncoder) SetQosEnabled(enabled bool) {
	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_video_encoder_set_qos_enabled(_arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(enabled)
}

// The function returns the following values:
//
func (encoder *VideoEncoder) close() bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.close

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (encoder *VideoEncoder) finish() gst.FlowReturn {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.finish

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_finish(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function returns the following values:
//
func (encoder *VideoEncoder) flush() bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.flush

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_flush(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *VideoEncoder) caps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.getcaps

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_getcaps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) handleFrame(frame *VideoCodecFrame) gst.FlowReturn {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.handle_frame

	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_handle_frame(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Negotiate: negotiate with downstream elements to currently configured
// VideoCodecState. Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark
// it again if negotiate fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (encoder *VideoEncoder) negotiate() bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.negotiate

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_negotiate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (encoder *VideoEncoder) open() bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.open

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) prePush(frame *VideoCodecFrame) gst.FlowReturn {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.pre_push

	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_pre_push(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) proposeAllocation(query *gst.Query) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.propose_allocation

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_propose_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) reset(hard bool) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.reset

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 C.gboolean         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	if hard {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_reset(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(hard)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) setFormat(state *VideoCodecState) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.set_format

	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecState // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecState)(gextras.StructNative(unsafe.Pointer(state)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_set_format(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.sink_event

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) sinkQuery(query *gst.Query) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.sink_query

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_sink_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.src_event

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *VideoEncoder) srcQuery(query *gst.Query) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.src_query

	var _arg0 *C.GstVideoEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_src_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (encoder *VideoEncoder) start() bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.start

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (encoder *VideoEncoder) stop() bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.stop

	var _arg0 *C.GstVideoEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(encoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - frame
//    - meta
//
// The function returns the following values:
//
func (encoder *VideoEncoder) transformMeta(frame *VideoCodecFrame, meta *gst.Meta) bool {
	gclass := (*C.GstVideoEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.transform_meta

	var _arg0 *C.GstVideoEncoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _arg2 *C.GstMeta            // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstVideoEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C._gotk4_gstvideo1_VideoEncoder_virtual_transform_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(meta)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VideoEncoderClass subclasses can override any of the available virtual
// methods or not, as needed. At minimum handle_frame needs to be overridden,
// and set_format and get_caps are likely needed as well.
//
// An instance of this type is always passed by reference.
type VideoEncoderClass struct {
	*videoEncoderClass
}

// videoEncoderClass is the struct that's finalized.
type videoEncoderClass struct {
	native *C.GstVideoEncoderClass
}
