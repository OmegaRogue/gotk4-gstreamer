// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"image/color"
	"math"
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <gst/video/video.h>
import "C"

// VideoFormatGetPalette: get the default palette of format. This the palette
// used in the pack function for paletted formats.
//
// The function takes the following parameters:
//
//    - format: VideoFormat.
//
// The function returns the following values:
//
//    - size of the palette in bytes.
//    - gpointer (optional): default palette of format or NULL when format does
//      not have a palette.
//
func VideoFormatGetPalette(format VideoFormat) (uint, unsafe.Pointer) {
	var _arg1 C.GstVideoFormat // out
	var _arg2 C.gsize          // in
	var _cret C.gconstpointer  // in

	_arg1 = C.GstVideoFormat(format)

	_cret = C.gst_video_format_get_palette(_arg1, &_arg2)
	runtime.KeepAlive(format)

	var _size uint               // out
	var _gpointer unsafe.Pointer // out

	_size = uint(_arg2)
	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _size, _gpointer
}

func (v VideoFormat) Palette() color.Palette {
	size, ptr := VideoFormatGetPalette(v)
	if ptr == nil {
		return nil
	}
	paletteBytes := make([]uint8, int64(size))
	for i, t := range (*[(math.MaxInt32 - 1) / unsafe.Sizeof(uint8(0))]uint8)(ptr)[:int(size):int(size)] {
		paletteBytes[i] = t
	}
	return bytesToColorPalette(paletteBytes)
}
func bytesToColorPalette(in []uint8) color.Palette {
	palette := make([]color.Color, len(in)/4)
	for i := 0; i < len(in); i += 4 {
		palette[i/4] = color.RGBA{R: in[i], G: in[i+1], B: in[i+2], A: in[i+3]}
	}
	return palette
}
