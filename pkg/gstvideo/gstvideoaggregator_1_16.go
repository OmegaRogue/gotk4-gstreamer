// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
// extern void _gotk4_gstvideo1_VideoAggregatorPadClass_update_conversion_info(GstVideoAggregatorPad*);
// extern void _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_start(GstVideoAggregatorPad*, GstVideoAggregator*, GstBuffer*, GstVideoFrame*);
// extern void _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_finish(GstVideoAggregatorPad*, GstVideoAggregator*, GstVideoFrame*);
// extern void _gotk4_gstvideo1_VideoAggregatorPadClass_clean_frame(GstVideoAggregatorPad*, GstVideoAggregator*, GstVideoFrame*);
// extern void _gotk4_gstvideo1_VideoAggregatorConvertPadClass_create_conversion_info(GstVideoAggregatorConvertPad*, GstVideoAggregator*, GstVideoInfo*);
// extern gboolean _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame(GstVideoAggregatorPad*, GstVideoAggregator*, GstBuffer*, GstVideoFrame*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoAggregatorClass_aggregate_frames(GstVideoAggregator*, GstBuffer*);
// extern GstCaps* _gotk4_gstvideo1_VideoAggregatorClass_update_caps(GstVideoAggregator*, GstCaps*);
// GstCaps* _gotk4_gstvideo1_VideoAggregator_virtual_update_caps(void* fnptr, GstVideoAggregator* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstVideoAggregator*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoAggregator_virtual_aggregate_frames(void* fnptr, GstVideoAggregator* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstVideoAggregator*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoAggregatorPad_virtual_prepare_frame(void* fnptr, GstVideoAggregatorPad* arg0, GstVideoAggregator* arg1, GstBuffer* arg2, GstVideoFrame* arg3) {
//   return ((gboolean (*)(GstVideoAggregatorPad*, GstVideoAggregator*, GstBuffer*, GstVideoFrame*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstvideo1_VideoAggregatorConvertPad_virtual_create_conversion_info(void* fnptr, GstVideoAggregatorConvertPad* arg0, GstVideoAggregator* arg1, GstVideoInfo* arg2) {
//   ((void (*)(GstVideoAggregatorConvertPad*, GstVideoAggregator*, GstVideoInfo*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstvideo1_VideoAggregatorPad_virtual_clean_frame(void* fnptr, GstVideoAggregatorPad* arg0, GstVideoAggregator* arg1, GstVideoFrame* arg2) {
//   ((void (*)(GstVideoAggregatorPad*, GstVideoAggregator*, GstVideoFrame*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstvideo1_VideoAggregatorPad_virtual_prepare_frame_finish(void* fnptr, GstVideoAggregatorPad* arg0, GstVideoAggregator* arg1, GstVideoFrame* arg2) {
//   ((void (*)(GstVideoAggregatorPad*, GstVideoAggregator*, GstVideoFrame*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstvideo1_VideoAggregatorPad_virtual_prepare_frame_start(void* fnptr, GstVideoAggregatorPad* arg0, GstVideoAggregator* arg1, GstBuffer* arg2, GstVideoFrame* arg3) {
//   ((void (*)(GstVideoAggregatorPad*, GstVideoAggregator*, GstBuffer*, GstVideoFrame*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstvideo1_VideoAggregatorPad_virtual_update_conversion_info(void* fnptr, GstVideoAggregatorPad* arg0) {
//   ((void (*)(GstVideoAggregatorPad*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeVideoAggregator           = coreglib.Type(C.gst_video_aggregator_get_type())
	GTypeVideoAggregatorConvertPad = coreglib.Type(C.gst_video_aggregator_convert_pad_get_type())
	GTypeVideoAggregatorPad        = coreglib.Type(C.gst_video_aggregator_pad_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoAggregator, F: marshalVideoAggregator},
		coreglib.TypeMarshaler{T: GTypeVideoAggregatorConvertPad, F: marshalVideoAggregatorConvertPad},
		coreglib.TypeMarshaler{T: GTypeVideoAggregatorPad, F: marshalVideoAggregatorPad},
	})
}

// VideoAggregatorOverrides contains methods that are overridable.
type VideoAggregatorOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	AggregateFrames func(outbuffer *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	UpdateCaps func(caps *gst.Caps) *gst.Caps
}

func defaultVideoAggregatorOverrides(v *VideoAggregator) VideoAggregatorOverrides {
	return VideoAggregatorOverrides{
		AggregateFrames: v.aggregateFrames,
		UpdateCaps:      v.updateCaps,
	}
}

// VideoAggregator can accept AYUV, ARGB and BGRA video streams. For each of the
// requested sink pads it will compare the incoming geometry and framerate to
// define the output parameters. Indeed output video frames will have the
// geometry of the biggest incoming video stream and the framerate of the
// fastest incoming one.
//
// VideoAggregator will do colorspace conversion.
//
// Zorder for each input stream can be configured on the VideoAggregatorPad.
type VideoAggregator struct {
	_ [0]func() // equal guard
	gstbase.Aggregator
}

var (
	_ gstbase.Aggregatorrer = (*VideoAggregator)(nil)
)

// VideoAggregatorrer describes types inherited from class VideoAggregator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type VideoAggregatorrer interface {
	coreglib.Objector
	baseVideoAggregator() *VideoAggregator
}

var _ VideoAggregatorrer = (*VideoAggregator)(nil)

func init() {
	coreglib.RegisterClassInfo[*VideoAggregator, *VideoAggregatorClass, VideoAggregatorOverrides](
		GTypeVideoAggregator,
		initVideoAggregatorClass,
		wrapVideoAggregator,
		defaultVideoAggregatorOverrides,
	)
}

func initVideoAggregatorClass(gclass unsafe.Pointer, overrides VideoAggregatorOverrides, classInitFunc func(*VideoAggregatorClass)) {
	pclass := (*C.GstVideoAggregatorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVideoAggregator))))

	if overrides.AggregateFrames != nil {
		pclass.aggregate_frames = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorClass_aggregate_frames)
	}

	if overrides.UpdateCaps != nil {
		pclass.update_caps = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorClass_update_caps)
	}

	if classInitFunc != nil {
		class := (*VideoAggregatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideoAggregator(obj *coreglib.Object) *VideoAggregator {
	return &VideoAggregator{
		Aggregator: gstbase.Aggregator{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalVideoAggregator(p uintptr) (interface{}, error) {
	return wrapVideoAggregator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (vagg *VideoAggregator) baseVideoAggregator() *VideoAggregator {
	return vagg
}

// BaseVideoAggregator returns the underlying base object.
func BaseVideoAggregator(obj VideoAggregatorrer) *VideoAggregator {
	return obj.baseVideoAggregator()
}

// ExecutionTaskPool: returned TaskPool is used internally for performing
// parallel video format conversions/scaling/etc during the
// VideoAggregatorPadClass::prepare_frame_start() process. Subclasses can add
// their own operation to perform using the returned TaskPool during
// VideoAggregatorClass::aggregate_frames().
//
// The function returns the following values:
//
//    - taskPool that can be used by subclasses for performing concurrent
//      operations.
//
func (vagg *VideoAggregator) ExecutionTaskPool() *gst.TaskPool {
	var _arg0 *C.GstVideoAggregator // out
	var _cret *C.GstTaskPool        // in

	_arg0 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(vagg).Native()))

	_cret = C.gst_video_aggregator_get_execution_task_pool(_arg0)
	runtime.KeepAlive(vagg)

	var _taskPool *gst.TaskPool // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_taskPool = &gst.TaskPool{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _taskPool
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (videoaggregator *VideoAggregator) aggregateFrames(outbuffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstVideoAggregatorClass)(coreglib.PeekParentClass(videoaggregator))
	fnarg := gclass.aggregate_frames

	var _arg0 *C.GstVideoAggregator // out
	var _arg1 *C.GstBuffer          // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(videoaggregator).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuffer)))

	_cret = C._gotk4_gstvideo1_VideoAggregator_virtual_aggregate_frames(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(videoaggregator)
	runtime.KeepAlive(outbuffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (videoaggregator *VideoAggregator) updateCaps(caps *gst.Caps) *gst.Caps {
	gclass := (*C.GstVideoAggregatorClass)(coreglib.PeekParentClass(videoaggregator))
	fnarg := gclass.update_caps

	var _arg0 *C.GstVideoAggregator // out
	var _arg1 *C.GstCaps            // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(videoaggregator).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstvideo1_VideoAggregator_virtual_update_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(videoaggregator)
	runtime.KeepAlive(caps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// VideoAggregatorConvertPadOverrides contains methods that are overridable.
type VideoAggregatorConvertPadOverrides struct {
	// The function takes the following parameters:
	//
	//    - agg
	//    - conversionInfo
	//
	CreateConversionInfo func(agg VideoAggregatorrer, conversionInfo *VideoInfo)
}

func defaultVideoAggregatorConvertPadOverrides(v *VideoAggregatorConvertPad) VideoAggregatorConvertPadOverrides {
	return VideoAggregatorConvertPadOverrides{
		CreateConversionInfo: v.createConversionInfo,
	}
}

// VideoAggregatorConvertPad: implementation of GstPad that can be used with
// VideoAggregator.
//
// See VideoAggregator for more details.
type VideoAggregatorConvertPad struct {
	_ [0]func() // equal guard
	VideoAggregatorPad
}

var (
	_ gst.GstObjector = (*VideoAggregatorConvertPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*VideoAggregatorConvertPad, *VideoAggregatorConvertPadClass, VideoAggregatorConvertPadOverrides](
		GTypeVideoAggregatorConvertPad,
		initVideoAggregatorConvertPadClass,
		wrapVideoAggregatorConvertPad,
		defaultVideoAggregatorConvertPadOverrides,
	)
}

func initVideoAggregatorConvertPadClass(gclass unsafe.Pointer, overrides VideoAggregatorConvertPadOverrides, classInitFunc func(*VideoAggregatorConvertPadClass)) {
	pclass := (*C.GstVideoAggregatorConvertPadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVideoAggregatorConvertPad))))

	if overrides.CreateConversionInfo != nil {
		pclass.create_conversion_info = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorConvertPadClass_create_conversion_info)
	}

	if classInitFunc != nil {
		class := (*VideoAggregatorConvertPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideoAggregatorConvertPad(obj *coreglib.Object) *VideoAggregatorConvertPad {
	return &VideoAggregatorConvertPad{
		VideoAggregatorPad: VideoAggregatorPad{
			AggregatorPad: gstbase.AggregatorPad{
				Pad: gst.Pad{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalVideoAggregatorConvertPad(p uintptr) (interface{}, error) {
	return wrapVideoAggregatorConvertPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// UpdateConversionInfo requests the pad to check and update the converter
// before the next usage to update for any changes that have happened.
func (pad *VideoAggregatorConvertPad) UpdateConversionInfo() {
	var _arg0 *C.GstVideoAggregatorConvertPad // out

	_arg0 = (*C.GstVideoAggregatorConvertPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_video_aggregator_convert_pad_update_conversion_info(_arg0)
	runtime.KeepAlive(pad)
}

// The function takes the following parameters:
//
//    - agg
//    - conversionInfo
//
func (pad *VideoAggregatorConvertPad) createConversionInfo(agg VideoAggregatorrer, conversionInfo *VideoInfo) {
	gclass := (*C.GstVideoAggregatorConvertPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.create_conversion_info

	var _arg0 *C.GstVideoAggregatorConvertPad // out
	var _arg1 *C.GstVideoAggregator           // out
	var _arg2 *C.GstVideoInfo                 // out

	_arg0 = (*C.GstVideoAggregatorConvertPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(agg).Native()))
	_arg2 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(conversionInfo)))

	C._gotk4_gstvideo1_VideoAggregatorConvertPad_virtual_create_conversion_info(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(agg)
	runtime.KeepAlive(conversionInfo)
}

// VideoAggregatorPadOverrides contains methods that are overridable.
type VideoAggregatorPadOverrides struct {
	// The function takes the following parameters:
	//
	//    - videoaggregator
	//    - preparedFrame
	//
	CleanFrame func(videoaggregator VideoAggregatorrer, preparedFrame *VideoFrame)
	// The function takes the following parameters:
	//
	//    - videoaggregator
	//    - buffer
	//    - preparedFrame
	//
	// The function returns the following values:
	//
	PrepareFrame func(videoaggregator VideoAggregatorrer, buffer *gst.Buffer, preparedFrame *VideoFrame) bool
	// PrepareFrameFinish: finish preparing prepared_frame.
	//
	// If overriden, prepare_frame_start must also be overriden.
	//
	// The function takes the following parameters:
	//
	//    - videoaggregator: parent VideoAggregator.
	//    - preparedFrame to prepare into.
	//
	PrepareFrameFinish func(videoaggregator VideoAggregatorrer, preparedFrame *VideoFrame)
	// PrepareFrameStart: begin preparing the frame from the pad buffer and sets
	// it to prepared_frame.
	//
	// If overriden, prepare_frame_finish must also be overriden.
	//
	// The function takes the following parameters:
	//
	//    - videoaggregator: parent VideoAggregator.
	//    - buffer: input Buffer to prepare.
	//    - preparedFrame to prepare into.
	//
	PrepareFrameStart    func(videoaggregator VideoAggregatorrer, buffer *gst.Buffer, preparedFrame *VideoFrame)
	UpdateConversionInfo func()
}

func defaultVideoAggregatorPadOverrides(v *VideoAggregatorPad) VideoAggregatorPadOverrides {
	return VideoAggregatorPadOverrides{
		CleanFrame:           v.cleanFrame,
		PrepareFrame:         v.prepareFrame,
		PrepareFrameFinish:   v.prepareFrameFinish,
		PrepareFrameStart:    v.prepareFrameStart,
		UpdateConversionInfo: v.updateConversionInfo,
	}
}

type VideoAggregatorPad struct {
	_ [0]func() // equal guard
	gstbase.AggregatorPad
}

var (
	_ gst.GstObjector = (*VideoAggregatorPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*VideoAggregatorPad, *VideoAggregatorPadClass, VideoAggregatorPadOverrides](
		GTypeVideoAggregatorPad,
		initVideoAggregatorPadClass,
		wrapVideoAggregatorPad,
		defaultVideoAggregatorPadOverrides,
	)
}

func initVideoAggregatorPadClass(gclass unsafe.Pointer, overrides VideoAggregatorPadOverrides, classInitFunc func(*VideoAggregatorPadClass)) {
	pclass := (*C.GstVideoAggregatorPadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVideoAggregatorPad))))

	if overrides.CleanFrame != nil {
		pclass.clean_frame = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorPadClass_clean_frame)
	}

	if overrides.PrepareFrame != nil {
		pclass.prepare_frame = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame)
	}

	if overrides.PrepareFrameFinish != nil {
		pclass.prepare_frame_finish = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_finish)
	}

	if overrides.PrepareFrameStart != nil {
		pclass.prepare_frame_start = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_start)
	}

	if overrides.UpdateConversionInfo != nil {
		pclass.update_conversion_info = (*[0]byte)(C._gotk4_gstvideo1_VideoAggregatorPadClass_update_conversion_info)
	}

	if classInitFunc != nil {
		class := (*VideoAggregatorPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideoAggregatorPad(obj *coreglib.Object) *VideoAggregatorPad {
	return &VideoAggregatorPad{
		AggregatorPad: gstbase.AggregatorPad{
			Pad: gst.Pad{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalVideoAggregatorPad(p uintptr) (interface{}, error) {
	return wrapVideoAggregatorPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CurrentBuffer returns the currently queued buffer that is going to be used
// for the current output frame.
//
// This must only be called from the VideoAggregatorClass::aggregate_frames
// virtual method, or from the VideoAggregatorPadClass::prepare_frame virtual
// method of the aggregator pads.
//
// The return value is only valid until VideoAggregatorClass::aggregate_frames
// or VideoAggregatorPadClass::prepare_frame returns.
//
// The function returns the following values:
//
//    - buffer: currently queued buffer.
//
func (pad *VideoAggregatorPad) CurrentBuffer() *gst.Buffer {
	var _arg0 *C.GstVideoAggregatorPad // out
	var _cret *C.GstBuffer             // in

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_video_aggregator_pad_get_current_buffer(_arg0)
	runtime.KeepAlive(pad)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _buffer
}

// PreparedFrame returns the currently prepared video frame that has to be
// aggregated into the current output frame.
//
// This must only be called from the VideoAggregatorClass::aggregate_frames
// virtual method, or from the VideoAggregatorPadClass::prepare_frame virtual
// method of the aggregator pads.
//
// The return value is only valid until VideoAggregatorClass::aggregate_frames
// or VideoAggregatorPadClass::prepare_frame returns.
//
// The function returns the following values:
//
//    - videoFrame: currently prepared video frame.
//
func (pad *VideoAggregatorPad) PreparedFrame() *VideoFrame {
	var _arg0 *C.GstVideoAggregatorPad // out
	var _cret *C.GstVideoFrame         // in

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_video_aggregator_pad_get_prepared_frame(_arg0)
	runtime.KeepAlive(pad)

	var _videoFrame *VideoFrame // out

	_videoFrame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoFrame
}

// HasCurrentBuffer checks if the pad currently has a buffer queued that is
// going to be used for the current output frame.
//
// This must only be called from the VideoAggregatorClass::aggregate_frames
// virtual method, or from the VideoAggregatorPadClass::prepare_frame virtual
// method of the aggregator pads.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad has currently a buffer queued.
//
func (pad *VideoAggregatorPad) HasCurrentBuffer() bool {
	var _arg0 *C.GstVideoAggregatorPad // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_video_aggregator_pad_has_current_buffer(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetNeedsAlpha allows selecting that this pad requires an output format with
// alpha.
//
// The function takes the following parameters:
//
//    - needsAlpha: TRUE if this pad requires alpha output.
//
func (pad *VideoAggregatorPad) SetNeedsAlpha(needsAlpha bool) {
	var _arg0 *C.GstVideoAggregatorPad // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if needsAlpha {
		_arg1 = C.TRUE
	}

	C.gst_video_aggregator_pad_set_needs_alpha(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(needsAlpha)
}

// The function takes the following parameters:
//
//    - videoaggregator
//    - preparedFrame
//
func (pad *VideoAggregatorPad) cleanFrame(videoaggregator VideoAggregatorrer, preparedFrame *VideoFrame) {
	gclass := (*C.GstVideoAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.clean_frame

	var _arg0 *C.GstVideoAggregatorPad // out
	var _arg1 *C.GstVideoAggregator    // out
	var _arg2 *C.GstVideoFrame         // out

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(videoaggregator).Native()))
	_arg2 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(preparedFrame)))

	C._gotk4_gstvideo1_VideoAggregatorPad_virtual_clean_frame(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(videoaggregator)
	runtime.KeepAlive(preparedFrame)
}

// The function takes the following parameters:
//
//    - videoaggregator
//    - buffer
//    - preparedFrame
//
// The function returns the following values:
//
func (pad *VideoAggregatorPad) prepareFrame(videoaggregator VideoAggregatorrer, buffer *gst.Buffer, preparedFrame *VideoFrame) bool {
	gclass := (*C.GstVideoAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.prepare_frame

	var _arg0 *C.GstVideoAggregatorPad // out
	var _arg1 *C.GstVideoAggregator    // out
	var _arg2 *C.GstBuffer             // out
	var _arg3 *C.GstVideoFrame         // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(videoaggregator).Native()))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg3 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(preparedFrame)))

	_cret = C._gotk4_gstvideo1_VideoAggregatorPad_virtual_prepare_frame(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(videoaggregator)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(preparedFrame)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// prepareFrameFinish: finish preparing prepared_frame.
//
// If overriden, prepare_frame_start must also be overriden.
//
// The function takes the following parameters:
//
//    - videoaggregator: parent VideoAggregator.
//    - preparedFrame to prepare into.
//
func (pad *VideoAggregatorPad) prepareFrameFinish(videoaggregator VideoAggregatorrer, preparedFrame *VideoFrame) {
	gclass := (*C.GstVideoAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.prepare_frame_finish

	var _arg0 *C.GstVideoAggregatorPad // out
	var _arg1 *C.GstVideoAggregator    // out
	var _arg2 *C.GstVideoFrame         // out

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(videoaggregator).Native()))
	_arg2 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(preparedFrame)))

	C._gotk4_gstvideo1_VideoAggregatorPad_virtual_prepare_frame_finish(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(videoaggregator)
	runtime.KeepAlive(preparedFrame)
}

// prepareFrameStart: begin preparing the frame from the pad buffer and sets it
// to prepared_frame.
//
// If overriden, prepare_frame_finish must also be overriden.
//
// The function takes the following parameters:
//
//    - videoaggregator: parent VideoAggregator.
//    - buffer: input Buffer to prepare.
//    - preparedFrame to prepare into.
//
func (pad *VideoAggregatorPad) prepareFrameStart(videoaggregator VideoAggregatorrer, buffer *gst.Buffer, preparedFrame *VideoFrame) {
	gclass := (*C.GstVideoAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.prepare_frame_start

	var _arg0 *C.GstVideoAggregatorPad // out
	var _arg1 *C.GstVideoAggregator    // out
	var _arg2 *C.GstBuffer             // out
	var _arg3 *C.GstVideoFrame         // out

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstVideoAggregator)(unsafe.Pointer(coreglib.InternObject(videoaggregator).Native()))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg3 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(preparedFrame)))

	C._gotk4_gstvideo1_VideoAggregatorPad_virtual_prepare_frame_start(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(videoaggregator)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(preparedFrame)
}

func (pad *VideoAggregatorPad) updateConversionInfo() {
	gclass := (*C.GstVideoAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.update_conversion_info

	var _arg0 *C.GstVideoAggregatorPad // out

	_arg0 = (*C.GstVideoAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gstvideo1_VideoAggregatorPad_virtual_update_conversion_info(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pad)
}

// VideoAggregatorClass: instance of this type is always passed by reference.
type VideoAggregatorClass struct {
	*videoAggregatorClass
}

// videoAggregatorClass is the struct that's finalized.
type videoAggregatorClass struct {
	native *C.GstVideoAggregatorClass
}

// VideoAggregatorConvertPadClass: instance of this type is always passed by
// reference.
type VideoAggregatorConvertPadClass struct {
	*videoAggregatorConvertPadClass
}

// videoAggregatorConvertPadClass is the struct that's finalized.
type videoAggregatorConvertPadClass struct {
	native *C.GstVideoAggregatorConvertPadClass
}

func (v *VideoAggregatorConvertPadClass) ParentClass() *VideoAggregatorPadClass {
	valptr := &v.native.parent_class
	var _v *VideoAggregatorPadClass // out
	_v = (*VideoAggregatorPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// VideoAggregatorPadClass: instance of this type is always passed by reference.
type VideoAggregatorPadClass struct {
	*videoAggregatorPadClass
}

// videoAggregatorPadClass is the struct that's finalized.
type videoAggregatorPadClass struct {
	native *C.GstVideoAggregatorPadClass
}

func (v *VideoAggregatorPadClass) ParentClass() *gstbase.AggregatorPadClass {
	valptr := &v.native.parent_class
	var _v *gstbase.AggregatorPadClass // out
	_v = (*gstbase.AggregatorPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (v *VideoAggregatorPadClass) GstReserved() [18]unsafe.Pointer {
	valptr := &v.native._gst_reserved
	var _v [18]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 18; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
