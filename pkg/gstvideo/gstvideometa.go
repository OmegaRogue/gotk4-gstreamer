// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoGLTextureOrientation = coreglib.Type(C.gst_video_gl_texture_orientation_get_type())
	GTypeVideoGLTextureType        = coreglib.Type(C.gst_video_gl_texture_type_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoGLTextureOrientation, F: marshalVideoGLTextureOrientation},
		coreglib.TypeMarshaler{T: GTypeVideoGLTextureType, F: marshalVideoGLTextureType},
	})
}

const CAPS_FEATURE_META_GST_VIDEO_GL_TEXTURE_UPLOAD_META = "meta:GstVideoGLTextureUploadMeta"
const CAPS_FEATURE_META_GST_VIDEO_META = "meta:GstVideoMeta"

// VideoGLTextureOrientation: orientation of the GL texture.
type VideoGLTextureOrientation C.gint

const (
	// VideoGLTextureOrientationXNormalYNormal: top line first in memory, left
	// row first.
	VideoGLTextureOrientationXNormalYNormal VideoGLTextureOrientation = iota
	// VideoGLTextureOrientationXNormalYFlip: bottom line first in memory, left
	// row first.
	VideoGLTextureOrientationXNormalYFlip
	// VideoGLTextureOrientationXFlipYNormal: top line first in memory, right
	// row first.
	VideoGLTextureOrientationXFlipYNormal
	// VideoGLTextureOrientationXFlipYFlip: bottom line first in memory, right
	// row first.
	VideoGLTextureOrientationXFlipYFlip
)

func marshalVideoGLTextureOrientation(p uintptr) (interface{}, error) {
	return VideoGLTextureOrientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoGLTextureOrientation.
func (v VideoGLTextureOrientation) String() string {
	switch v {
	case VideoGLTextureOrientationXNormalYNormal:
		return "NormalYNormal"
	case VideoGLTextureOrientationXNormalYFlip:
		return "NormalYFlip"
	case VideoGLTextureOrientationXFlipYNormal:
		return "FlipYNormal"
	case VideoGLTextureOrientationXFlipYFlip:
		return "FlipYFlip"
	default:
		return fmt.Sprintf("VideoGLTextureOrientation(%d)", v)
	}
}

// VideoGLTextureType: GL texture type.
type VideoGLTextureType C.gint

const (
	// VideoGLTextureTypeLuminance: luminance texture, GL_LUMINANCE.
	VideoGLTextureTypeLuminance VideoGLTextureType = iota
	// VideoGLTextureTypeLuminanceAlpha: luminance-alpha texture,
	// GL_LUMINANCE_ALPHA.
	VideoGLTextureTypeLuminanceAlpha
	// VideoGLTextureTypeRGB16: RGB 565 texture, GL_RGB.
	VideoGLTextureTypeRGB16
	// VideoGLTextureTypeRGB: RGB texture, GL_RGB.
	VideoGLTextureTypeRGB
	// VideoGLTextureTypeRGBA: RGBA texture, GL_RGBA.
	VideoGLTextureTypeRGBA
	// VideoGLTextureTypeR: r texture, GL_RED_EXT.
	VideoGLTextureTypeR
	// VideoGLTextureTypeRg: RG texture, GL_RG_EXT.
	VideoGLTextureTypeRg
)

func marshalVideoGLTextureType(p uintptr) (interface{}, error) {
	return VideoGLTextureType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoGLTextureType.
func (v VideoGLTextureType) String() string {
	switch v {
	case VideoGLTextureTypeLuminance:
		return "Luminance"
	case VideoGLTextureTypeLuminanceAlpha:
		return "LuminanceAlpha"
	case VideoGLTextureTypeRGB16:
		return "RGB16"
	case VideoGLTextureTypeRGB:
		return "RGB"
	case VideoGLTextureTypeRGBA:
		return "RGBA"
	case VideoGLTextureTypeR:
		return "R"
	case VideoGLTextureTypeRg:
		return "Rg"
	default:
		return fmt.Sprintf("VideoGLTextureType(%d)", v)
	}
}

// BufferAddVideoMeta attaches GstVideoMeta metadata to buffer with the given
// parameters and the default offsets and strides for format and width x height.
//
// This function calculates the default offsets and strides and then calls
// gst_buffer_add_video_meta_full() with them.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - flags: VideoFrameFlags.
//    - format: VideoFormat.
//    - width: width.
//    - height: height.
//
// The function returns the following values:
//
//    - videoMeta on buffer.
//
func BufferAddVideoMeta(buffer *gst.Buffer, flags VideoFrameFlags, format VideoFormat, width, height uint) *VideoMeta {
	var _arg1 *C.GstBuffer         // out
	var _arg2 C.GstVideoFrameFlags // out
	var _arg3 C.GstVideoFormat     // out
	var _arg4 C.guint              // out
	var _arg5 C.guint              // out
	var _cret *C.GstVideoMeta      // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstVideoFrameFlags(flags)
	_arg3 = C.GstVideoFormat(format)
	_arg4 = C.guint(width)
	_arg5 = C.guint(height)

	_cret = C.gst_buffer_add_video_meta(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(format)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _videoMeta *VideoMeta // out

	_videoMeta = (*VideoMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoMeta
}

// BufferAddVideoMetaFull attaches GstVideoMeta metadata to buffer with the
// given parameters.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - flags: VideoFrameFlags.
//    - format: VideoFormat.
//    - width: width.
//    - height: height.
//    - nPlanes: number of planes.
//    - offset of each plane.
//    - stride of each plane.
//
// The function returns the following values:
//
//    - videoMeta on buffer.
//
func BufferAddVideoMetaFull(buffer *gst.Buffer, flags VideoFrameFlags, format VideoFormat, width, height, nPlanes uint, offset [4]uint, stride [4]int) *VideoMeta {
	var _arg1 *C.GstBuffer         // out
	var _arg2 C.GstVideoFrameFlags // out
	var _arg3 C.GstVideoFormat     // out
	var _arg4 C.guint              // out
	var _arg5 C.guint              // out
	var _arg6 C.guint              // out
	var _arg7 *C.gsize             // out
	var _arg8 *C.gint              // out
	var _cret *C.GstVideoMeta      // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstVideoFrameFlags(flags)
	_arg3 = C.GstVideoFormat(format)
	_arg4 = C.guint(width)
	_arg5 = C.guint(height)
	_arg6 = C.guint(nPlanes)
	_arg7 = (*C.gsize)(unsafe.Pointer(&offset))
	{
		var out [4]C.gint
		_arg8 = &out[0]
		for i := 0; i < 4; i++ {
			out[i] = C.gint(stride[i])
		}
	}

	_cret = C.gst_buffer_add_video_meta_full(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(format)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(nPlanes)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(stride)

	var _videoMeta *VideoMeta // out

	_videoMeta = (*VideoMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoMeta
}

// BufferAddVideoRegionOfInterestMeta attaches VideoRegionOfInterestMeta
// metadata to buffer with the given parameters.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - roiType: type of the region of interest (e.g. "face").
//    - x: x position.
//    - y: y position.
//    - w: width.
//    - h: height.
//
// The function returns the following values:
//
//    - videoRegionOfInterestMeta on buffer.
//
func BufferAddVideoRegionOfInterestMeta(buffer *gst.Buffer, roiType string, x, y, w, h uint) *VideoRegionOfInterestMeta {
	var _arg1 *C.GstBuffer                    // out
	var _arg2 *C.gchar                        // out
	var _arg3 C.guint                         // out
	var _arg4 C.guint                         // out
	var _arg5 C.guint                         // out
	var _arg6 C.guint                         // out
	var _cret *C.GstVideoRegionOfInterestMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(roiType)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(x)
	_arg4 = C.guint(y)
	_arg5 = C.guint(w)
	_arg6 = C.guint(h)

	_cret = C.gst_buffer_add_video_region_of_interest_meta(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(roiType)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(w)
	runtime.KeepAlive(h)

	var _videoRegionOfInterestMeta *VideoRegionOfInterestMeta // out

	_videoRegionOfInterestMeta = (*VideoRegionOfInterestMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoRegionOfInterestMeta
}

// BufferAddVideoRegionOfInterestMetaID attaches VideoRegionOfInterestMeta
// metadata to buffer with the given parameters.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - roiType: type of the region of interest (e.g. "face").
//    - x: x position.
//    - y: y position.
//    - w: width.
//    - h: height.
//
// The function returns the following values:
//
//    - videoRegionOfInterestMeta on buffer.
//
func BufferAddVideoRegionOfInterestMetaID(buffer *gst.Buffer, roiType glib.Quark, x, y, w, h uint) *VideoRegionOfInterestMeta {
	var _arg1 *C.GstBuffer                    // out
	var _arg2 C.GQuark                        // out
	var _arg3 C.guint                         // out
	var _arg4 C.guint                         // out
	var _arg5 C.guint                         // out
	var _arg6 C.guint                         // out
	var _cret *C.GstVideoRegionOfInterestMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.guint32(roiType)
	type _ = glib.Quark
	type _ = uint32
	_arg3 = C.guint(x)
	_arg4 = C.guint(y)
	_arg5 = C.guint(w)
	_arg6 = C.guint(h)

	_cret = C.gst_buffer_add_video_region_of_interest_meta_id(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(roiType)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(w)
	runtime.KeepAlive(h)

	var _videoRegionOfInterestMeta *VideoRegionOfInterestMeta // out

	_videoRegionOfInterestMeta = (*VideoRegionOfInterestMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoRegionOfInterestMeta
}

// BufferGetVideoMeta: find the VideoMeta on buffer with the lowest id.
//
// Buffers can contain multiple VideoMeta metadata items when dealing with
// multiview buffers.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//
// The function returns the following values:
//
//    - videoMeta with lowest id (usually 0) or NULL when there is no such
//      metadata on buffer.
//
func BufferGetVideoMeta(buffer *gst.Buffer) *VideoMeta {
	var _arg1 *C.GstBuffer    // out
	var _cret *C.GstVideoMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_video_meta(_arg1)
	runtime.KeepAlive(buffer)

	var _videoMeta *VideoMeta // out

	_videoMeta = (*VideoMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoMeta
}

// BufferGetVideoMetaID: find the VideoMeta on buffer with the given id.
//
// Buffers can contain multiple VideoMeta metadata items when dealing with
// multiview buffers.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - id: metadata id.
//
// The function returns the following values:
//
//    - videoMeta with id or NULL when there is no such metadata on buffer.
//
func BufferGetVideoMetaID(buffer *gst.Buffer, id int) *VideoMeta {
	var _arg1 *C.GstBuffer    // out
	var _arg2 C.gint          // out
	var _cret *C.GstVideoMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.gint(id)

	_cret = C.gst_buffer_get_video_meta_id(_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(id)

	var _videoMeta *VideoMeta // out

	_videoMeta = (*VideoMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoMeta
}

// BufferGetVideoRegionOfInterestMetaID: find the VideoRegionOfInterestMeta on
// buffer with the given id.
//
// Buffers can contain multiple VideoRegionOfInterestMeta metadata items if
// multiple regions of interests are marked on a frame.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - id: metadata id.
//
// The function returns the following values:
//
//    - videoRegionOfInterestMeta with id or NULL when there is no such metadata
//      on buffer.
//
func BufferGetVideoRegionOfInterestMetaID(buffer *gst.Buffer, id int) *VideoRegionOfInterestMeta {
	var _arg1 *C.GstBuffer                    // out
	var _arg2 C.gint                          // out
	var _cret *C.GstVideoRegionOfInterestMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.gint(id)

	_cret = C.gst_buffer_get_video_region_of_interest_meta_id(_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(id)

	var _videoRegionOfInterestMeta *VideoRegionOfInterestMeta // out

	_videoRegionOfInterestMeta = (*VideoRegionOfInterestMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoRegionOfInterestMeta
}

// The function returns the following values:
//
func VideoCropMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_video_crop_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// The function returns the following values:
//
func VideoGLTextureUploadMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_video_gl_texture_upload_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// The function returns the following values:
//
func VideoMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_video_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// The function returns the following values:
//
func VideoRegionOfInterestMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_video_region_of_interest_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// The function returns the following values:
//
func VideoTimeCodeMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_video_time_code_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// VideoCropMeta: extra buffer metadata describing image cropping.
//
// An instance of this type is always passed by reference.
type VideoCropMeta struct {
	*videoCropMeta
}

// videoCropMeta is the struct that's finalized.
type videoCropMeta struct {
	native *C.GstVideoCropMeta
}

// Meta: parent Meta.
func (v *VideoCropMeta) Meta() *gst.Meta {
	valptr := &v.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// X: horizontal offset.
func (v *VideoCropMeta) X() uint {
	valptr := &v.native.x
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Y: vertical offset.
func (v *VideoCropMeta) Y() uint {
	valptr := &v.native.y
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Width: cropped width.
func (v *VideoCropMeta) Width() uint {
	valptr := &v.native.width
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Height: cropped height.
func (v *VideoCropMeta) Height() uint {
	valptr := &v.native.height
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// X: horizontal offset.
func (v *VideoCropMeta) SetX(x uint) {
	valptr := &v.native.x
	*valptr = C.guint(x)
}

// Y: vertical offset.
func (v *VideoCropMeta) SetY(y uint) {
	valptr := &v.native.y
	*valptr = C.guint(y)
}

// Width: cropped width.
func (v *VideoCropMeta) SetWidth(width uint) {
	valptr := &v.native.width
	*valptr = C.guint(width)
}

// Height: cropped height.
func (v *VideoCropMeta) SetHeight(height uint) {
	valptr := &v.native.height
	*valptr = C.guint(height)
}

// The function returns the following values:
//
func VideoCropMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_video_crop_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// VideoGLTextureUploadMeta: extra buffer metadata for uploading a buffer to an
// OpenGL texture ID. The caller of gst_video_gl_texture_upload_meta_upload()
// must have OpenGL set up and call this from a thread where it is valid to
// upload something to an OpenGL texture.
//
// An instance of this type is always passed by reference.
type VideoGLTextureUploadMeta struct {
	*videoGLTextureUploadMeta
}

// videoGLTextureUploadMeta is the struct that's finalized.
type videoGLTextureUploadMeta struct {
	native *C.GstVideoGLTextureUploadMeta
}

// Meta: parent Meta.
func (v *VideoGLTextureUploadMeta) Meta() *gst.Meta {
	valptr := &v.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TextureOrientation: orientation of the textures.
func (v *VideoGLTextureUploadMeta) TextureOrientation() VideoGLTextureOrientation {
	valptr := &v.native.texture_orientation
	var _v VideoGLTextureOrientation // out
	_v = VideoGLTextureOrientation(*valptr)
	return _v
}

// NTextures: number of textures that are generated.
func (v *VideoGLTextureUploadMeta) NTextures() uint {
	valptr := &v.native.n_textures
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TextureType: type of each texture.
func (v *VideoGLTextureUploadMeta) TextureType() [4]VideoGLTextureType {
	valptr := &v.native.texture_type
	var _v [4]VideoGLTextureType // out
	_v = *(*[4]VideoGLTextureType)(unsafe.Pointer(&*valptr))
	return _v
}

// NTextures: number of textures that are generated.
func (v *VideoGLTextureUploadMeta) SetNTextures(nTextures uint) {
	valptr := &v.native.n_textures
	*valptr = C.guint(nTextures)
}

// Upload uploads the buffer which owns the meta to a specific texture ID.
//
// The function takes the following parameters:
//
//    - textureId: texture IDs to upload to.
//
// The function returns the following values:
//
//    - ok: TRUE if uploading succeeded, FALSE otherwise.
//
func (meta *VideoGLTextureUploadMeta) Upload(textureId *uint) bool {
	var _arg0 *C.GstVideoGLTextureUploadMeta // out
	var _arg1 *C.guint                       // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.GstVideoGLTextureUploadMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = (*C.guint)(unsafe.Pointer(textureId))

	_cret = C.gst_video_gl_texture_upload_meta_upload(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(textureId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func VideoGLTextureUploadMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_video_gl_texture_upload_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// VideoMeta: extra buffer metadata describing image properties
//
// This meta can also be used by downstream elements to specifiy their buffer
// layout requirements for upstream. Upstream should try to fit those
// requirements, if possible, in order to prevent buffer copies.
//
// This is done by passing a custom Structure to gst_query_add_allocation_meta()
// when handling the ALLOCATION query. This structure should be named
// 'video-meta' and can have the following fields:
//
// - padding-top (uint): extra pixels on the top
//
// - padding-bottom (uint): extra pixels on the bottom
//
// - padding-left (uint): extra pixels on the left side
//
// - padding-right (uint): extra pixels on the right side The padding fields
// have the same semantic as VideoMeta.alignment and so represent the paddings
// requested on produced video buffers.
//
// An instance of this type is always passed by reference.
type VideoMeta struct {
	*videoMeta
}

// videoMeta is the struct that's finalized.
type videoMeta struct {
	native *C.GstVideoMeta
}

// Meta: parent Meta.
func (v *VideoMeta) Meta() *gst.Meta {
	valptr := &v.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Buffer: buffer this metadata belongs to.
func (v *VideoMeta) Buffer() *gst.Buffer {
	valptr := &v.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Flags: additional video flags.
func (v *VideoMeta) Flags() VideoFrameFlags {
	valptr := &v.native.flags
	var _v VideoFrameFlags // out
	_v = VideoFrameFlags(*valptr)
	return _v
}

// Format: video format.
func (v *VideoMeta) Format() VideoFormat {
	valptr := &v.native.format
	var _v VideoFormat // out
	_v = VideoFormat(*valptr)
	return _v
}

// ID: identifier of the frame.
func (v *VideoMeta) ID() int {
	valptr := &v.native.id
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width: video width.
func (v *VideoMeta) Width() uint {
	valptr := &v.native.width
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Height: video height.
func (v *VideoMeta) Height() uint {
	valptr := &v.native.height
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// NPlanes: number of planes in the image.
func (v *VideoMeta) NPlanes() uint {
	valptr := &v.native.n_planes
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: array of offsets for the planes. This field might not always be
// valid, it is used by the default implementation of map.
func (v *VideoMeta) Offset() [4]uint {
	valptr := &v.native.offset
	var _v [4]uint // out
	_v = *(*[4]uint)(unsafe.Pointer(&*valptr))
	return _v
}

// Stride: array of strides for the planes. This field might not always be
// valid, it is used by the default implementation of map.
func (v *VideoMeta) Stride() [4]int {
	valptr := &v.native.stride
	var _v [4]int // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = int(src[i])
		}
	}
	return _v
}

// Alignment paddings and alignment constraints of the video buffer. It is up to
// the caller of gst_buffer_add_video_meta_full() to set it using
// gst_video_meta_set_alignment(), if they did not it defaults to no padding and
// no alignment. Since: 1.18.
func (v *VideoMeta) Alignment() *VideoAlignment {
	valptr := &v.native.alignment
	var _v *VideoAlignment // out
	_v = (*VideoAlignment)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ID: identifier of the frame.
func (v *VideoMeta) SetID(id int) {
	valptr := &v.native.id
	*valptr = C.gint(id)
}

// Width: video width.
func (v *VideoMeta) SetWidth(width uint) {
	valptr := &v.native.width
	*valptr = C.guint(width)
}

// Height: video height.
func (v *VideoMeta) SetHeight(height uint) {
	valptr := &v.native.height
	*valptr = C.guint(height)
}

// NPlanes: number of planes in the image.
func (v *VideoMeta) SetNPlanes(nPlanes uint) {
	valptr := &v.native.n_planes
	*valptr = C.guint(nPlanes)
}

// PlaneHeight: compute the padded height of each plane from meta (padded size
// divided by stride).
//
// It is not valid to call this function with a meta associated to a TILED video
// format.
//
// The function returns the following values:
//
//    - planeHeight: array used to store the plane height.
//    - ok: TRUE if meta's alignment is valid and plane_height has been updated,
//      FALSE otherwise.
//
func (meta *VideoMeta) PlaneHeight() ([4]uint, bool) {
	var _arg0 *C.GstVideoMeta // out
	var _arg1 [4]C.guint      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstVideoMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_video_meta_get_plane_height(_arg0, &_arg1[0])
	runtime.KeepAlive(meta)

	var _planeHeight [4]uint // out
	var _ok bool             // out

	{
		src := &_arg1
		for i := 0; i < 4; i++ {
			_planeHeight[i] = uint(src[i])
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _planeHeight, _ok
}

// PlaneSize: compute the size, in bytes, of each video plane described in meta
// including any padding and alignment constraint defined in meta->alignment.
//
// The function returns the following values:
//
//    - planeSize: array used to store the plane sizes.
//    - ok: TRUE if meta's alignment is valid and plane_size has been updated,
//      FALSE otherwise.
//
func (meta *VideoMeta) PlaneSize() ([4]uint, bool) {
	var _arg0 *C.GstVideoMeta // out
	var _arg1 [4]C.gsize      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstVideoMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_video_meta_get_plane_size(_arg0, &_arg1[0])
	runtime.KeepAlive(meta)

	var _planeSize [4]uint // out
	var _ok bool           // out

	_planeSize = *(*[4]uint)(unsafe.Pointer(&_arg1))
	if _cret != 0 {
		_ok = true
	}

	return _planeSize, _ok
}

// Map the video plane with index plane in meta and return a pointer to the
// first byte of the plane and the stride of the plane.
//
// The function takes the following parameters:
//
//    - plane: plane.
//    - info: MapInfo.
//    - flags: GstMapFlags.
//
// The function returns the following values:
//
//    - data (optional) of plane.
//    - stride of plane.
//    - ok: TRUE if the map operation was successful.
//
func (meta *VideoMeta) Map(plane uint, info *gst.MapInfo, flags gst.MapFlags) (unsafe.Pointer, int, bool) {
	var _arg0 *C.GstVideoMeta // out
	var _arg1 C.guint         // out
	var _arg2 *C.GstMapInfo   // out
	var _arg3 C.gpointer      // in
	var _arg4 C.gint          // in
	var _arg5 C.GstMapFlags   // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstVideoMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = C.guint(plane)
	_arg2 = (*C.GstMapInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg5 = C.GstMapFlags(flags)

	_cret = C.gst_video_meta_map(_arg0, _arg1, _arg2, &_arg3, &_arg4, _arg5)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)

	var _data unsafe.Pointer // out
	var _stride int          // out
	var _ok bool             // out

	_data = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	_stride = int(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _data, _stride, _ok
}

// SetAlignment: set the alignment of meta to alignment. This function checks
// that the paddings defined in alignment are compatible with the strides
// defined in meta and will fail to update if they are not.
//
// The function takes the following parameters:
//
//    - alignment: VideoAlignment.
//
// The function returns the following values:
//
//    - ok: TRUE if alignment's meta has been updated, FALSE if not.
//
func (meta *VideoMeta) SetAlignment(alignment *VideoAlignment) bool {
	var _arg0 *C.GstVideoMeta     // out
	var _arg1 C.GstVideoAlignment // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstVideoMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = *(*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(alignment)))

	_cret = C.gst_video_meta_set_alignment(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(alignment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unmap a previously mapped plane with gst_video_meta_map().
//
// The function takes the following parameters:
//
//    - plane: plane.
//    - info: MapInfo.
//
// The function returns the following values:
//
//    - ok: TRUE if the memory was successfully unmapped.
//
func (meta *VideoMeta) Unmap(plane uint, info *gst.MapInfo) bool {
	var _arg0 *C.GstVideoMeta // out
	var _arg1 C.guint         // out
	var _arg2 *C.GstMapInfo   // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstVideoMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = C.guint(plane)
	_arg2 = (*C.GstMapInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_video_meta_unmap(_arg0, _arg1, _arg2)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func VideoMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_video_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// VideoMetaTransform: extra data passed to a video transform
// MetaTransformFunction such as: "gst-video-scale".
//
// An instance of this type is always passed by reference.
type VideoMetaTransform struct {
	*videoMetaTransform
}

// videoMetaTransform is the struct that's finalized.
type videoMetaTransform struct {
	native *C.GstVideoMetaTransform
}

// InInfo: input VideoInfo.
func (v *VideoMetaTransform) InInfo() *VideoInfo {
	valptr := &v.native.in_info
	var _v *VideoInfo // out
	_v = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// OutInfo: output VideoInfo.
func (v *VideoMetaTransform) OutInfo() *VideoInfo {
	valptr := &v.native.out_info
	var _v *VideoInfo // out
	_v = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// VideoMetaTransformScaleGetQuark: get the #GQuark for the "gst-video-scale"
// metadata transform operation.
//
// The function returns the following values:
//
//    - quark: #GQuark.
//
func VideoMetaTransformScaleGetQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_video_meta_transform_scale_get_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// VideoRegionOfInterestMeta: extra buffer metadata describing an image region
// of interest
//
// An instance of this type is always passed by reference.
type VideoRegionOfInterestMeta struct {
	*videoRegionOfInterestMeta
}

// videoRegionOfInterestMeta is the struct that's finalized.
type videoRegionOfInterestMeta struct {
	native *C.GstVideoRegionOfInterestMeta
}

// Meta: parent Meta.
func (v *VideoRegionOfInterestMeta) Meta() *gst.Meta {
	valptr := &v.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// RoiType: GQuark describing the semantic of the Roi (f.i. a face, a
// pedestrian).
func (v *VideoRegionOfInterestMeta) RoiType() glib.Quark {
	valptr := &v.native.roi_type
	var _v glib.Quark // out
	_v = uint32(*valptr)
	type _ = glib.Quark
	type _ = uint32
	return _v
}

// ID: identifier of this particular ROI.
func (v *VideoRegionOfInterestMeta) ID() int {
	valptr := &v.native.id
	var _v int // out
	_v = int(*valptr)
	return _v
}

// ParentID: identifier of its parent ROI, used f.i. for ROI hierarchisation.
func (v *VideoRegionOfInterestMeta) ParentID() int {
	valptr := &v.native.parent_id
	var _v int // out
	_v = int(*valptr)
	return _v
}

// X: x component of upper-left corner.
func (v *VideoRegionOfInterestMeta) X() uint {
	valptr := &v.native.x
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Y: y component of upper-left corner.
func (v *VideoRegionOfInterestMeta) Y() uint {
	valptr := &v.native.y
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// W: bounding box width.
func (v *VideoRegionOfInterestMeta) W() uint {
	valptr := &v.native.w
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// H: bounding box height.
func (v *VideoRegionOfInterestMeta) H() uint {
	valptr := &v.native.h
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// ID: identifier of this particular ROI.
func (v *VideoRegionOfInterestMeta) SetID(id int) {
	valptr := &v.native.id
	*valptr = C.gint(id)
}

// ParentID: identifier of its parent ROI, used f.i. for ROI hierarchisation.
func (v *VideoRegionOfInterestMeta) SetParentID(parentId int) {
	valptr := &v.native.parent_id
	*valptr = C.gint(parentId)
}

// X: x component of upper-left corner.
func (v *VideoRegionOfInterestMeta) SetX(x uint) {
	valptr := &v.native.x
	*valptr = C.guint(x)
}

// Y: y component of upper-left corner.
func (v *VideoRegionOfInterestMeta) SetY(y uint) {
	valptr := &v.native.y
	*valptr = C.guint(y)
}

// W: bounding box width.
func (v *VideoRegionOfInterestMeta) SetW(w uint) {
	valptr := &v.native.w
	*valptr = C.guint(w)
}

// H: bounding box height.
func (v *VideoRegionOfInterestMeta) SetH(h uint) {
	valptr := &v.native.h
	*valptr = C.guint(h)
}

// AddParam: attach element-specific parameters to meta meant to be used by
// downstream elements which may handle this ROI. The name of s is used to
// identify the element these parameters are meant for.
//
// This is typically used to tell encoders how they should encode this specific
// region. For example, a structure named "roi/x264enc" could be used to give
// the QP offsets this encoder should use when encoding the region described in
// meta. Multiple parameters can be defined for the same meta so different
// encoders can be supported by cross platform applications).
//
// The function takes the following parameters:
//
//    - s: Structure.
//
func (meta *VideoRegionOfInterestMeta) AddParam(s *gst.Structure) {
	var _arg0 *C.GstVideoRegionOfInterestMeta // out
	var _arg1 *C.GstStructure                 // out

	_arg0 = (*C.GstVideoRegionOfInterestMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(s)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(s)), nil)

	C.gst_video_region_of_interest_meta_add_param(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(s)
}

// Param: retrieve the parameter for meta having name as structure name, or NULL
// if there is none.
//
// The function takes the following parameters:
//
//    - name: name.
//
// The function returns the following values:
//
//    - structure (optional): Structure.
//
func (meta *VideoRegionOfInterestMeta) Param(name string) *gst.Structure {
	var _arg0 *C.GstVideoRegionOfInterestMeta // out
	var _arg1 *C.gchar                        // out
	var _cret *C.GstStructure                 // in

	_arg0 = (*C.GstVideoRegionOfInterestMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_video_region_of_interest_meta_get_param(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(name)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// The function returns the following values:
//
func VideoRegionOfInterestMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_video_region_of_interest_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// The function returns the following values:
//
func VideoTimeCodeMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_video_time_code_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}
