// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoBufferPool = coreglib.Type(C.gst_video_buffer_pool_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoBufferPool, F: marshalVideoBufferPool},
	})
}

// BUFFER_POOL_OPTION_VIDEO_ALIGNMENT: bufferpool option to enable extra
// padding. When a bufferpool supports this option,
// gst_buffer_pool_config_set_video_alignment() can be called.
//
// When this option is enabled on the bufferpool,
// T_BUFFER_POOL_OPTION_VIDEO_META should also be enabled.
const BUFFER_POOL_OPTION_VIDEO_ALIGNMENT = "GstBufferPoolOptionVideoAlignment"

// BUFFER_POOL_OPTION_VIDEO_META: option that can be activated on bufferpool to
// request video metadata on buffers from the pool.
const BUFFER_POOL_OPTION_VIDEO_META = "GstBufferPoolOptionVideoMeta"

// BufferPoolConfigGetVideoAlignment: get the video alignment from the
// bufferpool configuration config in in align.
//
// The function takes the following parameters:
//
//    - config: Structure.
//    - align: VideoAlignment.
//
// The function returns the following values:
//
//    - ok: TRUE if config could be parsed correctly.
//
func BufferPoolConfigGetVideoAlignment(config *gst.Structure, align *VideoAlignment) bool {
	var _arg1 *C.GstStructure      // out
	var _arg2 *C.GstVideoAlignment // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(align)))

	_cret = C.gst_buffer_pool_config_get_video_alignment(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(align)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferPoolConfigSetVideoAlignment: set the video alignment in align to the
// bufferpool configuration config.
//
// The function takes the following parameters:
//
//    - config: Structure.
//    - align: VideoAlignment.
//
func BufferPoolConfigSetVideoAlignment(config *gst.Structure, align *VideoAlignment) {
	var _arg1 *C.GstStructure      // out
	var _arg2 *C.GstVideoAlignment // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(align)))

	C.gst_buffer_pool_config_set_video_alignment(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(align)
}

// VideoBufferPoolOverrides contains methods that are overridable.
type VideoBufferPoolOverrides struct {
}

func defaultVideoBufferPoolOverrides(v *VideoBufferPool) VideoBufferPoolOverrides {
	return VideoBufferPoolOverrides{}
}

type VideoBufferPool struct {
	_ [0]func() // equal guard
	gst.BufferPool
}

var (
	_ gst.GstObjector = (*VideoBufferPool)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*VideoBufferPool, *VideoBufferPoolClass, VideoBufferPoolOverrides](
		GTypeVideoBufferPool,
		initVideoBufferPoolClass,
		wrapVideoBufferPool,
		defaultVideoBufferPoolOverrides,
	)
}

func initVideoBufferPoolClass(gclass unsafe.Pointer, overrides VideoBufferPoolOverrides, classInitFunc func(*VideoBufferPoolClass)) {
	if classInitFunc != nil {
		class := (*VideoBufferPoolClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideoBufferPool(obj *coreglib.Object) *VideoBufferPool {
	return &VideoBufferPool{
		BufferPool: gst.BufferPool{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalVideoBufferPool(p uintptr) (interface{}, error) {
	return wrapVideoBufferPool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewVideoBufferPool: create a new bufferpool that can allocate video frames.
// This bufferpool supports all the video bufferpool options.
//
// The function returns the following values:
//
//    - videoBufferPool: new BufferPool to allocate video frames.
//
func NewVideoBufferPool() *VideoBufferPool {
	var _cret *C.GstBufferPool // in

	_cret = C.gst_video_buffer_pool_new()

	var _videoBufferPool *VideoBufferPool // out

	_videoBufferPool = wrapVideoBufferPool(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _videoBufferPool
}

// VideoBufferPoolClass: instance of this type is always passed by reference.
type VideoBufferPoolClass struct {
	*videoBufferPoolClass
}

// videoBufferPoolClass is the struct that's finalized.
type videoBufferPoolClass struct {
	native *C.GstVideoBufferPoolClass
}

func (v *VideoBufferPoolClass) ParentClass() *gst.BufferPoolClass {
	valptr := &v.native.parent_class
	var _v *gst.BufferPoolClass // out
	_v = (*gst.BufferPoolClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
