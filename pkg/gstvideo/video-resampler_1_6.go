// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoResamplerMethod = coreglib.Type(C.gst_video_resampler_method_get_type())
	GTypeVideoResamplerFlags  = coreglib.Type(C.gst_video_resampler_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoResamplerMethod, F: marshalVideoResamplerMethod},
		coreglib.TypeMarshaler{T: GTypeVideoResamplerFlags, F: marshalVideoResamplerFlags},
	})
}

// VideoResamplerMethod: different subsampling and upsampling methods.
type VideoResamplerMethod C.gint

const (
	// VideoResamplerMethodNearest duplicates the samples when upsampling and
	// drops when downsampling.
	VideoResamplerMethodNearest VideoResamplerMethod = iota
	// VideoResamplerMethodLinear uses linear interpolation to reconstruct
	// missing samples and averaging to downsample.
	VideoResamplerMethodLinear
	// VideoResamplerMethodCubic uses cubic interpolation.
	VideoResamplerMethodCubic
	// VideoResamplerMethodSinc uses sinc interpolation.
	VideoResamplerMethodSinc
	// VideoResamplerMethodLanczos uses lanczos interpolation.
	VideoResamplerMethodLanczos
)

func marshalVideoResamplerMethod(p uintptr) (interface{}, error) {
	return VideoResamplerMethod(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoResamplerMethod.
func (v VideoResamplerMethod) String() string {
	switch v {
	case VideoResamplerMethodNearest:
		return "Nearest"
	case VideoResamplerMethodLinear:
		return "Linear"
	case VideoResamplerMethodCubic:
		return "Cubic"
	case VideoResamplerMethodSinc:
		return "Sinc"
	case VideoResamplerMethodLanczos:
		return "Lanczos"
	default:
		return fmt.Sprintf("VideoResamplerMethod(%d)", v)
	}
}

// VideoResamplerFlags: different resampler flags.
type VideoResamplerFlags C.guint

const (
	// VideoResamplerFlagNone: no flags.
	VideoResamplerFlagNone VideoResamplerFlags = 0b0
	// VideoResamplerFlagHalfTaps: when no taps are given, half the number of
	// calculated taps. This can be used when making scalers for the different
	// fields of an interlaced picture. Since: 1.10.
	VideoResamplerFlagHalfTaps VideoResamplerFlags = 0b1
)

func marshalVideoResamplerFlags(p uintptr) (interface{}, error) {
	return VideoResamplerFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoResamplerFlags.
func (v VideoResamplerFlags) String() string {
	if v == 0 {
		return "VideoResamplerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(49)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoResamplerFlagNone:
			builder.WriteString("None|")
		case VideoResamplerFlagHalfTaps:
			builder.WriteString("HalfTaps|")
		default:
			builder.WriteString(fmt.Sprintf("VideoResamplerFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoResamplerFlags) Has(other VideoResamplerFlags) bool {
	return (v & other) == other
}

// VideoResampler is a structure which holds the information required to perform
// various kinds of resampling filtering.
//
// An instance of this type is always passed by reference.
type VideoResampler struct {
	*videoResampler
}

// videoResampler is the struct that's finalized.
type videoResampler struct {
	native *C.GstVideoResampler
}

// InSize: input size.
func (v *VideoResampler) InSize() int {
	valptr := &v.native.in_size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// OutSize: output size.
func (v *VideoResampler) OutSize() int {
	valptr := &v.native.out_size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// MaxTaps: maximum number of taps.
func (v *VideoResampler) MaxTaps() uint {
	valptr := &v.native.max_taps
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// NPhases: number of phases.
func (v *VideoResampler) NPhases() uint {
	valptr := &v.native.n_phases
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: array with the source offset for each output element.
func (v *VideoResampler) Offset() *uint32 {
	valptr := &v.native.offset
	var _v *uint32 // out
	_v = (*uint32)(unsafe.Pointer(*valptr))
	return _v
}

// Phase: array with the phase to use for each output element.
func (v *VideoResampler) Phase() *uint32 {
	valptr := &v.native.phase
	var _v *uint32 // out
	_v = (*uint32)(unsafe.Pointer(*valptr))
	return _v
}

// NTaps: array with new number of taps for each phase.
func (v *VideoResampler) NTaps() *uint32 {
	valptr := &v.native.n_taps
	var _v *uint32 // out
	_v = (*uint32)(unsafe.Pointer(*valptr))
	return _v
}

// Taps taps for all phases.
func (v *VideoResampler) Taps() *float64 {
	valptr := &v.native.taps
	var _v *float64 // out
	_v = (*float64)(unsafe.Pointer(*valptr))
	return _v
}

// InSize: input size.
func (v *VideoResampler) SetInSize(inSize int) {
	valptr := &v.native.in_size
	*valptr = C.gint(inSize)
}

// OutSize: output size.
func (v *VideoResampler) SetOutSize(outSize int) {
	valptr := &v.native.out_size
	*valptr = C.gint(outSize)
}

// MaxTaps: maximum number of taps.
func (v *VideoResampler) SetMaxTaps(maxTaps uint) {
	valptr := &v.native.max_taps
	*valptr = C.guint(maxTaps)
}

// NPhases: number of phases.
func (v *VideoResampler) SetNPhases(nPhases uint) {
	valptr := &v.native.n_phases
	*valptr = C.guint(nPhases)
}

// Clear a previously initialized VideoResampler resampler.
func (resampler *VideoResampler) Clear() {
	var _arg0 *C.GstVideoResampler // out

	_arg0 = (*C.GstVideoResampler)(gextras.StructNative(unsafe.Pointer(resampler)))

	C.gst_video_resampler_clear(_arg0)
	runtime.KeepAlive(resampler)
}

// The function takes the following parameters:
//
//    - method
//    - flags
//    - nPhases
//    - nTaps
//    - shift
//    - inSize
//    - outSize
//    - options
//
// The function returns the following values:
//
func (resampler *VideoResampler) Init(method VideoResamplerMethod, flags VideoResamplerFlags, nPhases uint, nTaps uint, shift float64, inSize uint, outSize uint, options *gst.Structure) bool {
	var _arg0 *C.GstVideoResampler      // out
	var _arg1 C.GstVideoResamplerMethod // out
	var _arg2 C.GstVideoResamplerFlags  // out
	var _arg3 C.guint                   // out
	var _arg4 C.guint                   // out
	var _arg5 C.gdouble                 // out
	var _arg6 C.guint                   // out
	var _arg7 C.guint                   // out
	var _arg8 *C.GstStructure           // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstVideoResampler)(gextras.StructNative(unsafe.Pointer(resampler)))
	_arg1 = C.GstVideoResamplerMethod(method)
	_arg2 = C.GstVideoResamplerFlags(flags)
	_arg3 = C.guint(nPhases)
	_arg4 = C.guint(nTaps)
	_arg5 = C.gdouble(shift)
	_arg6 = C.guint(inSize)
	_arg7 = C.guint(outSize)
	_arg8 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(options)))

	_cret = C.gst_video_resampler_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(resampler)
	runtime.KeepAlive(method)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(nPhases)
	runtime.KeepAlive(nTaps)
	runtime.KeepAlive(shift)
	runtime.KeepAlive(inSize)
	runtime.KeepAlive(outSize)
	runtime.KeepAlive(options)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
