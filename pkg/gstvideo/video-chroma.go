// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoChromaMethod = coreglib.Type(C.gst_video_chroma_method_get_type())
	GTypeVideoChromaFlags  = coreglib.Type(C.gst_video_chroma_flags_get_type())
	GTypeVideoChromaSite   = coreglib.Type(C.gst_video_chroma_site_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoChromaMethod, F: marshalVideoChromaMethod},
		coreglib.TypeMarshaler{T: GTypeVideoChromaFlags, F: marshalVideoChromaFlags},
		coreglib.TypeMarshaler{T: GTypeVideoChromaSite, F: marshalVideoChromaSite},
	})
}

// VideoChromaMethod: different subsampling and upsampling methods.
type VideoChromaMethod C.gint

const (
	// VideoChromaMethodNearest duplicates the chroma samples when upsampling
	// and drops when subsampling.
	VideoChromaMethodNearest VideoChromaMethod = iota
	// VideoChromaMethodLinear uses linear interpolation to reconstruct missing
	// chroma and averaging to subsample.
	VideoChromaMethodLinear
)

func marshalVideoChromaMethod(p uintptr) (interface{}, error) {
	return VideoChromaMethod(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoChromaMethod.
func (v VideoChromaMethod) String() string {
	switch v {
	case VideoChromaMethodNearest:
		return "Nearest"
	case VideoChromaMethodLinear:
		return "Linear"
	default:
		return fmt.Sprintf("VideoChromaMethod(%d)", v)
	}
}

// VideoChromaFlags: extra flags that influence the result from
// gst_video_chroma_resample_new().
type VideoChromaFlags C.guint

const (
	// VideoChromaFlagNone: no flags.
	VideoChromaFlagNone VideoChromaFlags = 0b0
	// VideoChromaFlagInterlaced: input is interlaced.
	VideoChromaFlagInterlaced VideoChromaFlags = 0b1
)

func marshalVideoChromaFlags(p uintptr) (interface{}, error) {
	return VideoChromaFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoChromaFlags.
func (v VideoChromaFlags) String() string {
	if v == 0 {
		return "VideoChromaFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(45)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoChromaFlagNone:
			builder.WriteString("None|")
		case VideoChromaFlagInterlaced:
			builder.WriteString("Interlaced|")
		default:
			builder.WriteString(fmt.Sprintf("VideoChromaFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoChromaFlags) Has(other VideoChromaFlags) bool {
	return (v & other) == other
}

// VideoChromaSite various Chroma sitings.
type VideoChromaSite C.guint

const (
	// VideoChromaSiteUnknown: unknown cositing.
	VideoChromaSiteUnknown VideoChromaSite = 0b0
	// VideoChromaSiteNone: no cositing.
	VideoChromaSiteNone VideoChromaSite = 0b1
	// VideoChromaSiteHCosited: chroma is horizontally cosited.
	VideoChromaSiteHCosited VideoChromaSite = 0b10
	// VideoChromaSiteVCosited: chroma is vertically cosited.
	VideoChromaSiteVCosited VideoChromaSite = 0b100
	// VideoChromaSiteAltLine: choma samples are sited on alternate lines.
	VideoChromaSiteAltLine VideoChromaSite = 0b1000
	// VideoChromaSiteCosited: chroma samples cosited with luma samples.
	VideoChromaSiteCosited VideoChromaSite = 0b110
	// VideoChromaSiteJPEG: jpeg style cositing, also for mpeg1 and mjpeg.
	VideoChromaSiteJPEG VideoChromaSite = 0b1
	// VideoChromaSiteMpeg2: mpeg2 style cositing.
	VideoChromaSiteMpeg2 VideoChromaSite = 0b10
	// VideoChromaSiteDv: DV style cositing.
	VideoChromaSiteDv VideoChromaSite = 0b1110
)

func marshalVideoChromaSite(p uintptr) (interface{}, error) {
	return VideoChromaSite(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoChromaSite.
func (v VideoChromaSite) String() string {
	if v == 0 {
		return "VideoChromaSite(0)"
	}

	var builder strings.Builder
	builder.Grow(195)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoChromaSiteUnknown:
			builder.WriteString("Unknown|")
		case VideoChromaSiteNone:
			builder.WriteString("None|")
		case VideoChromaSiteHCosited:
			builder.WriteString("HCosited|")
		case VideoChromaSiteVCosited:
			builder.WriteString("VCosited|")
		case VideoChromaSiteAltLine:
			builder.WriteString("AltLine|")
		case VideoChromaSiteCosited:
			builder.WriteString("Cosited|")
		case VideoChromaSiteDv:
			builder.WriteString("Dv|")
		default:
			builder.WriteString(fmt.Sprintf("VideoChromaSite(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoChromaSite) Has(other VideoChromaSite) bool {
	return (v & other) == other
}

// VideoChromaFromString: convert s to a VideoChromaSite
//
// Deprecated: Use gst_video_chroma_site_from_string() instead.
//
// The function takes the following parameters:
//
//    - s: chromasite string.
//
// The function returns the following values:
//
//    - videoChromaSite or GST_VIDEO_CHROMA_SITE_UNKNOWN when s does not contain
//      a valid chroma description.
//
func VideoChromaFromString(s string) VideoChromaSite {
	var _arg1 *C.gchar             // out
	var _cret C.GstVideoChromaSite // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_video_chroma_from_string(_arg1)
	runtime.KeepAlive(s)

	var _videoChromaSite VideoChromaSite // out

	_videoChromaSite = VideoChromaSite(_cret)

	return _videoChromaSite
}

// VideoChromaToString converts site to its string representation.
//
// Deprecated: Use gst_video_chroma_site_to_string() instead.
//
// The function takes the following parameters:
//
//    - site: VideoChromaSite.
//
// The function returns the following values:
//
//    - utf8: string describing site.
//
func VideoChromaToString(site VideoChromaSite) string {
	var _arg1 C.GstVideoChromaSite // out
	var _cret *C.gchar             // in

	_arg1 = C.GstVideoChromaSite(site)

	_cret = C.gst_video_chroma_to_string(_arg1)
	runtime.KeepAlive(site)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}
