// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoFormat      = coreglib.Type(C.gst_video_format_get_type())
	GTypeVideoFormatFlags = coreglib.Type(C.gst_video_format_flags_get_type())
	GTypeVideoPackFlags   = coreglib.Type(C.gst_video_pack_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoFormat, F: marshalVideoFormat},
		coreglib.TypeMarshaler{T: GTypeVideoFormatFlags, F: marshalVideoFormatFlags},
		coreglib.TypeMarshaler{T: GTypeVideoPackFlags, F: marshalVideoPackFlags},
	})
}

const VIDEO_COMP_A = 3
const VIDEO_COMP_B = 2
const VIDEO_COMP_G = 1
const VIDEO_COMP_INDEX = 0
const VIDEO_COMP_PALETTE = 1
const VIDEO_COMP_R = 0
const VIDEO_COMP_U = 1
const VIDEO_COMP_V = 2
const VIDEO_COMP_Y = 0

// VIDEO_FORMATS_ALL: list of all video formats, for use in template caps
// strings.
//
// Formats are sorted by decreasing "quality", using these criteria by priority:
// - number of components - depth - subsampling factor of the width -
// subsampling factor of the height - number of planes - native endianness
// preferred - pixel stride - poffset - prefer non-complex formats - prefer YUV
// formats over RGB ones - prefer I420 over YV12 - format name.
const VIDEO_FORMATS_ALL = "{ ABGR64_BE, BGRA64_BE, AYUV64, ARGB64_BE, ARGB64, RGBA64_BE, ABGR64_LE, BGRA64_LE, ARGB64_LE, RGBA64_LE, GBRA_12BE, GBRA_12LE, Y412_BE, Y412_LE, A444_10BE, GBRA_10BE, A444_10LE, GBRA_10LE, A422_10BE, A422_10LE, A420_10BE, A420_10LE, Y410, RGB10A2_LE, BGR10A2_LE, GBRA, ABGR, VUYA, BGRA, AYUV, ARGB, RGBA, A420, AV12, Y444_16BE, Y444_16LE, v216, P016_BE, P016_LE, Y444_12BE, GBR_12BE, Y444_12LE, GBR_12LE, I422_12BE, I422_12LE, Y212_BE, Y212_LE, I420_12BE, I420_12LE, P012_BE, P012_LE, Y444_10BE, GBR_10BE, Y444_10LE, GBR_10LE, r210, I422_10BE, I422_10LE, NV16_10LE32, Y210, v210, UYVP, I420_10BE, I420_10LE, P010_10BE, P010_10LE, NV12_10LE32, NV12_10LE40, Y444, RGBP, GBR, BGRP, NV24, xBGR, BGRx, xRGB, RGBx, BGR, IYU2, v308, RGB, Y42B, NV61, NV16, VYUY, UYVY, YVYU, YUY2, I420, YV12, NV21, NV12, NV12_64Z32, NV12_4L4, NV12_32L32, Y41B, IYU1, YVU9, YUV9, RGB16, BGR16, RGB15, BGR15, RGB8P, GRAY16_BE, GRAY16_LE, GRAY10_LE32, GRAY8 }"
const VIDEO_FPS_RANGE = "(fraction) [ 0, max ]"
const VIDEO_MAX_COMPONENTS = 4
const VIDEO_MAX_PLANES = 4
const VIDEO_SIZE_RANGE = "(int) [ 1, max ]"

// VideoFormat: enum value describing the most common video formats.
//
// See the GStreamer raw video format design document
// (https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats)
// for details about the layout and packing of these formats in memory.
type VideoFormat C.gint

const (
	// VideoFormatUnknown: unknown or unset video format id.
	VideoFormatUnknown VideoFormat = iota
	// VideoFormatEncoded: encoded video format. Only ever use that in caps for
	// special video formats in combination with non-system memory
	// GstCapsFeatures where it does not make sense to specify a real video
	// format.
	VideoFormatEncoded
	// VideoFormatI420: planar 4:2:0 YUV.
	VideoFormatI420
	// VideoFormatYV12: planar 4:2:0 YVU (like I420 but UV planes swapped).
	VideoFormatYV12
	// VideoFormatYuy2: packed 4:2:2 YUV (Y0-U0-Y1-V0 Y2-U2-Y3-V2 Y4 ...).
	VideoFormatYuy2
	// VideoFormatUyvy: packed 4:2:2 YUV (U0-Y0-V0-Y1 U2-Y2-V2-Y3 U4 ...).
	VideoFormatUyvy
	// VideoFormatAyuv: packed 4:4:4 YUV with alpha channel (A0-Y0-U0-V0 ...).
	VideoFormatAyuv
	// VideoFormatRgbx: sparse rgb packed into 32 bit, space last.
	VideoFormatRgbx
	// VideoFormatBgrx: sparse reverse rgb packed into 32 bit, space last.
	VideoFormatBgrx
	// VideoFormatXrgb: sparse rgb packed into 32 bit, space first.
	VideoFormatXrgb
	// VideoFormatXbgr: sparse reverse rgb packed into 32 bit, space first.
	VideoFormatXbgr
	// VideoFormatRGBA: rgb with alpha channel last.
	VideoFormatRGBA
	// VideoFormatBgra: reverse rgb with alpha channel last.
	VideoFormatBgra
	// VideoFormatARGB: rgb with alpha channel first.
	VideoFormatARGB
	// VideoFormatAbgr: reverse rgb with alpha channel first.
	VideoFormatAbgr
	// VideoFormatRGB: RGB packed into 24 bits without padding (R-G-B-R-G-B).
	VideoFormatRGB
	// VideoFormatBGR: reverse RGB packed into 24 bits without padding
	// (B-G-R-B-G-R).
	VideoFormatBGR
	// VideoFormatY41B: planar 4:1:1 YUV.
	VideoFormatY41B
	// VideoFormatY42B: planar 4:2:2 YUV.
	VideoFormatY42B
	// VideoFormatYvyu: packed 4:2:2 YUV (Y0-V0-Y1-U0 Y2-V2-Y3-U2 Y4 ...).
	VideoFormatYvyu
	// VideoFormatY444: planar 4:4:4 YUV.
	VideoFormatY444
	// VideoFormatV210: packed 4:2:2 10-bit YUV, complex format.
	VideoFormatV210
	// VideoFormatV216: packed 4:2:2 16-bit YUV, Y0-U0-Y1-V1 order.
	VideoFormatV216
	// VideoFormatNv12: planar 4:2:0 YUV with interleaved UV plane.
	VideoFormatNv12
	// VideoFormatNv21: planar 4:2:0 YUV with interleaved VU plane.
	VideoFormatNv21
	// VideoFormatGray8: 8-bit grayscale.
	VideoFormatGray8
	// VideoFormatGray16Be: 16-bit grayscale, most significant byte first.
	VideoFormatGray16Be
	// VideoFormatGray16LE: 16-bit grayscale, least significant byte first.
	VideoFormatGray16LE
	// VideoFormatV308: packed 4:4:4 YUV (Y-U-V ...).
	VideoFormatV308
	// VideoFormatRGB16: rgb 5-6-5 bits per component.
	VideoFormatRGB16
	// VideoFormatBGR16: reverse rgb 5-6-5 bits per component.
	VideoFormatBGR16
	// VideoFormatRGB15: rgb 5-5-5 bits per component.
	VideoFormatRGB15
	// VideoFormatBGR15: reverse rgb 5-5-5 bits per component.
	VideoFormatBGR15
	// VideoFormatUyvp: packed 10-bit 4:2:2 YUV (U0-Y0-V0-Y1 U2-Y2-V2-Y3 U4
	// ...).
	VideoFormatUyvp
	// VideoFormatA420: planar 4:4:2:0 AYUV.
	VideoFormatA420
	// VideoFormatRGB8P: 8-bit paletted RGB.
	VideoFormatRGB8P
	// VideoFormatYuv9: planar 4:1:0 YUV.
	VideoFormatYuv9
	// VideoFormatYvu9: planar 4:1:0 YUV (like YUV9 but UV planes swapped).
	VideoFormatYvu9
	// VideoFormatIyu1: packed 4:1:1 YUV (Cb-Y0-Y1-Cr-Y2-Y3 ...).
	VideoFormatIyu1
	// VideoFormatARGB64: rgb with alpha channel first, 16 bits (native
	// endianness) per channel.
	VideoFormatARGB64
	// VideoFormatAyuv64: packed 4:4:4 YUV with alpha channel, 16 bits (native
	// endianness) per channel (A0-Y0-U0-V0 ...).
	VideoFormatAyuv64
	// VideoFormatR210: packed 4:4:4 RGB, 10 bits per channel.
	VideoFormatR210
	// VideoFormatI42010Be: planar 4:2:0 YUV, 10 bits per channel.
	VideoFormatI42010Be
	// VideoFormatI42010LE: planar 4:2:0 YUV, 10 bits per channel.
	VideoFormatI42010LE
	// VideoFormatI42210Be: planar 4:2:2 YUV, 10 bits per channel.
	VideoFormatI42210Be
	// VideoFormatI42210LE: planar 4:2:2 YUV, 10 bits per channel.
	VideoFormatI42210LE
	// VideoFormatY44410Be: planar 4:4:4 YUV, 10 bits per channel (Since: 1.2).
	VideoFormatY44410Be
	// VideoFormatY44410LE: planar 4:4:4 YUV, 10 bits per channel (Since: 1.2).
	VideoFormatY44410LE
	// VideoFormatGbr: planar 4:4:4 RGB, 8 bits per channel (Since: 1.2).
	VideoFormatGbr
	// VideoFormatGbr10Be: planar 4:4:4 RGB, 10 bits per channel (Since: 1.2).
	VideoFormatGbr10Be
	// VideoFormatGbr10LE: planar 4:4:4 RGB, 10 bits per channel (Since: 1.2).
	VideoFormatGbr10LE
	// VideoFormatNv16: planar 4:2:2 YUV with interleaved UV plane (Since: 1.2).
	VideoFormatNv16
	// VideoFormatNv24: planar 4:4:4 YUV with interleaved UV plane (Since: 1.2).
	VideoFormatNv24
	// VideoFormatNv1264Z32: NV12 with 64x32 tiling in zigzag pattern (Since:
	// 1.4).
	VideoFormatNv1264Z32
	// VideoFormatA42010Be: planar 4:4:2:0 YUV, 10 bits per channel (Since:
	// 1.6).
	VideoFormatA42010Be
	// VideoFormatA42010LE: planar 4:4:2:0 YUV, 10 bits per channel (Since:
	// 1.6).
	VideoFormatA42010LE
	// VideoFormatA42210Be: planar 4:4:2:2 YUV, 10 bits per channel (Since:
	// 1.6).
	VideoFormatA42210Be
	// VideoFormatA42210LE: planar 4:4:2:2 YUV, 10 bits per channel (Since:
	// 1.6).
	VideoFormatA42210LE
	// VideoFormatA44410Be: planar 4:4:4:4 YUV, 10 bits per channel (Since:
	// 1.6).
	VideoFormatA44410Be
	// VideoFormatA44410LE: planar 4:4:4:4 YUV, 10 bits per channel (Since:
	// 1.6).
	VideoFormatA44410LE
	// VideoFormatNv61: planar 4:2:2 YUV with interleaved VU plane (Since: 1.6).
	VideoFormatNv61
	// VideoFormatP01010Be: planar 4:2:0 YUV with interleaved UV plane, 10 bits
	// per channel (Since: 1.10).
	VideoFormatP01010Be
	// VideoFormatP01010LE: planar 4:2:0 YUV with interleaved UV plane, 10 bits
	// per channel (Since: 1.10).
	VideoFormatP01010LE
	// VideoFormatIyu2: packed 4:4:4 YUV (U-Y-V ...) (Since: 1.10).
	VideoFormatIyu2
	// VideoFormatVyuy: packed 4:2:2 YUV (V0-Y0-U0-Y1 V2-Y2-U2-Y3 V4 ...).
	VideoFormatVyuy
	// VideoFormatGbra: planar 4:4:4:4 ARGB, 8 bits per channel (Since: 1.12).
	VideoFormatGbra
	// VideoFormatGbra10Be: planar 4:4:4:4 ARGB, 10 bits per channel (Since:
	// 1.12).
	VideoFormatGbra10Be
	// VideoFormatGbra10LE: planar 4:4:4:4 ARGB, 10 bits per channel (Since:
	// 1.12).
	VideoFormatGbra10LE
	// VideoFormatGbr12Be: planar 4:4:4 RGB, 12 bits per channel (Since: 1.12).
	VideoFormatGbr12Be
	// VideoFormatGbr12LE: planar 4:4:4 RGB, 12 bits per channel (Since: 1.12).
	VideoFormatGbr12LE
	// VideoFormatGbra12Be: planar 4:4:4:4 ARGB, 12 bits per channel (Since:
	// 1.12).
	VideoFormatGbra12Be
	// VideoFormatGbra12LE: planar 4:4:4:4 ARGB, 12 bits per channel (Since:
	// 1.12).
	VideoFormatGbra12LE
	// VideoFormatI42012Be: planar 4:2:0 YUV, 12 bits per channel (Since: 1.12).
	VideoFormatI42012Be
	// VideoFormatI42012LE: planar 4:2:0 YUV, 12 bits per channel (Since: 1.12).
	VideoFormatI42012LE
	// VideoFormatI42212Be: planar 4:2:2 YUV, 12 bits per channel (Since: 1.12).
	VideoFormatI42212Be
	// VideoFormatI42212LE: planar 4:2:2 YUV, 12 bits per channel (Since: 1.12).
	VideoFormatI42212LE
	// VideoFormatY44412Be: planar 4:4:4 YUV, 12 bits per channel (Since: 1.12).
	VideoFormatY44412Be
	// VideoFormatY44412LE: planar 4:4:4 YUV, 12 bits per channel (Since: 1.12).
	VideoFormatY44412LE
	// VideoFormatGray10LE32: 10-bit grayscale, packed into 32bit words (2 bits
	// padding) (Since: 1.14).
	VideoFormatGray10LE32
	// VideoFormatNv1210LE32: 10-bit variant of GST_VIDEO_FORMAT_NV12, packed
	// into 32bit words (MSB 2 bits padding) (Since: 1.14).
	VideoFormatNv1210LE32
	// VideoFormatNv1610LE32: 10-bit variant of GST_VIDEO_FORMAT_NV16, packed
	// into 32bit words (MSB 2 bits padding) (Since: 1.14).
	VideoFormatNv1610LE32
	// VideoFormatNv1210LE40: fully packed variant of NV12_10LE32 (Since: 1.16).
	VideoFormatNv1210LE40
	// VideoFormatY210: packed 4:2:2 YUV, 10 bits per channel (Since: 1.16).
	VideoFormatY210
	// VideoFormatY410: packed 4:4:4 YUV, 10 bits per channel(A-V-Y-U...)
	// (Since: 1.16).
	VideoFormatY410
	// VideoFormatVuya: packed 4:4:4 YUV with alpha channel (V0-U0-Y0-A0...)
	// (Since: 1.16).
	VideoFormatVuya
	// VideoFormatBGR10A2LE: packed 4:4:4 RGB with alpha channel(B-G-R-A), 10
	// bits for R/G/B channel and MSB 2 bits for alpha channel (Since: 1.16).
	VideoFormatBGR10A2LE
	// VideoFormatRGB10A2LE: packed 4:4:4 RGB with alpha channel(R-G-B-A), 10
	// bits for R/G/B channel and MSB 2 bits for alpha channel (Since: 1.18).
	VideoFormatRGB10A2LE
	// VideoFormatY44416Be: planar 4:4:4 YUV, 16 bits per channel (Since: 1.18).
	VideoFormatY44416Be
	// VideoFormatY44416LE: planar 4:4:4 YUV, 16 bits per channel (Since: 1.18).
	VideoFormatY44416LE
	// VideoFormatP016Be: planar 4:2:0 YUV with interleaved UV plane, 16 bits
	// per channel (Since: 1.18).
	VideoFormatP016Be
	// VideoFormatP016LE: planar 4:2:0 YUV with interleaved UV plane, 16 bits
	// per channel (Since: 1.18).
	VideoFormatP016LE
	// VideoFormatP012Be: planar 4:2:0 YUV with interleaved UV plane, 12 bits
	// per channel (Since: 1.18).
	VideoFormatP012Be
	// VideoFormatP012LE: planar 4:2:0 YUV with interleaved UV plane, 12 bits
	// per channel (Since: 1.18).
	VideoFormatP012LE
	// VideoFormatY212Be: packed 4:2:2 YUV, 12 bits per channel (Y-U-Y-V)
	// (Since: 1.18).
	VideoFormatY212Be
	// VideoFormatY212LE: packed 4:2:2 YUV, 12 bits per channel (Y-U-Y-V)
	// (Since: 1.18).
	VideoFormatY212LE
	// VideoFormatY412Be: packed 4:4:4:4 YUV, 12 bits per channel(U-Y-V-A...)
	// (Since: 1.18).
	VideoFormatY412Be
	// VideoFormatY412LE: packed 4:4:4:4 YUV, 12 bits per channel(U-Y-V-A...)
	// (Since: 1.18).
	VideoFormatY412LE
	// VideoFormatNv124L4: NV12 with 4x4 tiles in linear order.
	VideoFormatNv124L4
	// VideoFormatNv1232L32: NV12 with 32x32 tiles in linear order.
	VideoFormatNv1232L32
	// VideoFormatRgbp: planar 4:4:4 RGB, R-G-B order.
	VideoFormatRgbp
	// VideoFormatBgrp: planar 4:4:4 RGB, B-G-R order.
	VideoFormatBgrp
	// VideoFormatAv12: planar 4:2:0 YUV with interleaved UV plane with alpha as
	// 3rd plane.
	VideoFormatAv12
	// VideoFormatARGB64LE: RGB with alpha channel first, 16 bits (little
	// endian) per channel.
	VideoFormatARGB64LE
	// VideoFormatARGB64Be: RGB with alpha channel first, 16 bits (big endian)
	// per channel.
	VideoFormatARGB64Be
	// VideoFormatRGBA64LE: RGB with alpha channel last, 16 bits (little endian)
	// per channel.
	VideoFormatRGBA64LE
	// VideoFormatRGBA64Be: RGB with alpha channel last, 16 bits (big endian)
	// per channel.
	VideoFormatRGBA64Be
	// VideoFormatBgra64LE: reverse RGB with alpha channel last, 16 bits (little
	// endian) per channel.
	VideoFormatBgra64LE
	// VideoFormatBgra64Be: reverse RGB with alpha channel last, 16 bits (big
	// endian) per channel.
	VideoFormatBgra64Be
	// VideoFormatAbgr64LE: reverse RGB with alpha channel first, 16 bits
	// (little endian) per channel.
	VideoFormatAbgr64LE
	// VideoFormatAbgr64Be: reverse RGB with alpha channel first, 16 bits (big
	// endian) per channel.
	VideoFormatAbgr64Be
)

func marshalVideoFormat(p uintptr) (interface{}, error) {
	return VideoFormat(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for VideoFormat.
func (v VideoFormat) String() string {
	switch v {
	case VideoFormatUnknown:
		return "Unknown"
	case VideoFormatEncoded:
		return "Encoded"
	case VideoFormatI420:
		return "I420"
	case VideoFormatYV12:
		return "YV12"
	case VideoFormatYuy2:
		return "Yuy2"
	case VideoFormatUyvy:
		return "Uyvy"
	case VideoFormatAyuv:
		return "Ayuv"
	case VideoFormatRgbx:
		return "Rgbx"
	case VideoFormatBgrx:
		return "Bgrx"
	case VideoFormatXrgb:
		return "Xrgb"
	case VideoFormatXbgr:
		return "Xbgr"
	case VideoFormatRGBA:
		return "RGBA"
	case VideoFormatBgra:
		return "Bgra"
	case VideoFormatARGB:
		return "ARGB"
	case VideoFormatAbgr:
		return "Abgr"
	case VideoFormatRGB:
		return "RGB"
	case VideoFormatBGR:
		return "BGR"
	case VideoFormatY41B:
		return "Y41B"
	case VideoFormatY42B:
		return "Y42B"
	case VideoFormatYvyu:
		return "Yvyu"
	case VideoFormatY444:
		return "Y444"
	case VideoFormatV210:
		return "V210"
	case VideoFormatV216:
		return "V216"
	case VideoFormatNv12:
		return "Nv12"
	case VideoFormatNv21:
		return "Nv21"
	case VideoFormatGray8:
		return "Gray8"
	case VideoFormatGray16Be:
		return "Gray16Be"
	case VideoFormatGray16LE:
		return "Gray16LE"
	case VideoFormatV308:
		return "V308"
	case VideoFormatRGB16:
		return "RGB16"
	case VideoFormatBGR16:
		return "BGR16"
	case VideoFormatRGB15:
		return "RGB15"
	case VideoFormatBGR15:
		return "BGR15"
	case VideoFormatUyvp:
		return "Uyvp"
	case VideoFormatA420:
		return "A420"
	case VideoFormatRGB8P:
		return "RGB8P"
	case VideoFormatYuv9:
		return "Yuv9"
	case VideoFormatYvu9:
		return "Yvu9"
	case VideoFormatIyu1:
		return "Iyu1"
	case VideoFormatARGB64:
		return "ARGB64"
	case VideoFormatAyuv64:
		return "Ayuv64"
	case VideoFormatR210:
		return "R210"
	case VideoFormatI42010Be:
		return "I42010Be"
	case VideoFormatI42010LE:
		return "I42010LE"
	case VideoFormatI42210Be:
		return "I42210Be"
	case VideoFormatI42210LE:
		return "I42210LE"
	case VideoFormatY44410Be:
		return "Y44410Be"
	case VideoFormatY44410LE:
		return "Y44410LE"
	case VideoFormatGbr:
		return "Gbr"
	case VideoFormatGbr10Be:
		return "Gbr10Be"
	case VideoFormatGbr10LE:
		return "Gbr10LE"
	case VideoFormatNv16:
		return "Nv16"
	case VideoFormatNv24:
		return "Nv24"
	case VideoFormatNv1264Z32:
		return "Nv1264Z32"
	case VideoFormatA42010Be:
		return "A42010Be"
	case VideoFormatA42010LE:
		return "A42010LE"
	case VideoFormatA42210Be:
		return "A42210Be"
	case VideoFormatA42210LE:
		return "A42210LE"
	case VideoFormatA44410Be:
		return "A44410Be"
	case VideoFormatA44410LE:
		return "A44410LE"
	case VideoFormatNv61:
		return "Nv61"
	case VideoFormatP01010Be:
		return "P01010Be"
	case VideoFormatP01010LE:
		return "P01010LE"
	case VideoFormatIyu2:
		return "Iyu2"
	case VideoFormatVyuy:
		return "Vyuy"
	case VideoFormatGbra:
		return "Gbra"
	case VideoFormatGbra10Be:
		return "Gbra10Be"
	case VideoFormatGbra10LE:
		return "Gbra10LE"
	case VideoFormatGbr12Be:
		return "Gbr12Be"
	case VideoFormatGbr12LE:
		return "Gbr12LE"
	case VideoFormatGbra12Be:
		return "Gbra12Be"
	case VideoFormatGbra12LE:
		return "Gbra12LE"
	case VideoFormatI42012Be:
		return "I42012Be"
	case VideoFormatI42012LE:
		return "I42012LE"
	case VideoFormatI42212Be:
		return "I42212Be"
	case VideoFormatI42212LE:
		return "I42212LE"
	case VideoFormatY44412Be:
		return "Y44412Be"
	case VideoFormatY44412LE:
		return "Y44412LE"
	case VideoFormatGray10LE32:
		return "Gray10LE32"
	case VideoFormatNv1210LE32:
		return "Nv1210LE32"
	case VideoFormatNv1610LE32:
		return "Nv1610LE32"
	case VideoFormatNv1210LE40:
		return "Nv1210LE40"
	case VideoFormatY210:
		return "Y210"
	case VideoFormatY410:
		return "Y410"
	case VideoFormatVuya:
		return "Vuya"
	case VideoFormatBGR10A2LE:
		return "BGR10A2LE"
	case VideoFormatRGB10A2LE:
		return "RGB10A2LE"
	case VideoFormatY44416Be:
		return "Y44416Be"
	case VideoFormatY44416LE:
		return "Y44416LE"
	case VideoFormatP016Be:
		return "P016Be"
	case VideoFormatP016LE:
		return "P016LE"
	case VideoFormatP012Be:
		return "P012Be"
	case VideoFormatP012LE:
		return "P012LE"
	case VideoFormatY212Be:
		return "Y212Be"
	case VideoFormatY212LE:
		return "Y212LE"
	case VideoFormatY412Be:
		return "Y412Be"
	case VideoFormatY412LE:
		return "Y412LE"
	case VideoFormatNv124L4:
		return "Nv124L4"
	case VideoFormatNv1232L32:
		return "Nv1232L32"
	case VideoFormatRgbp:
		return "Rgbp"
	case VideoFormatBgrp:
		return "Bgrp"
	case VideoFormatAv12:
		return "Av12"
	case VideoFormatARGB64LE:
		return "ARGB64LE"
	case VideoFormatARGB64Be:
		return "ARGB64Be"
	case VideoFormatRGBA64LE:
		return "RGBA64LE"
	case VideoFormatRGBA64Be:
		return "RGBA64Be"
	case VideoFormatBgra64LE:
		return "Bgra64LE"
	case VideoFormatBgra64Be:
		return "Bgra64Be"
	case VideoFormatAbgr64LE:
		return "Abgr64LE"
	case VideoFormatAbgr64Be:
		return "Abgr64Be"
	default:
		return fmt.Sprintf("VideoFormat(%d)", v)
	}
}

// VideoFormatFromFourcc converts a FOURCC value into the corresponding
// VideoFormat. If the FOURCC cannot be represented by VideoFormat,
// T_VIDEO_FORMAT_UNKNOWN is returned.
//
// The function takes the following parameters:
//
//    - fourcc: FOURCC value representing raw YUV video.
//
// The function returns the following values:
//
//    - videoFormat describing the FOURCC value.
//
func VideoFormatFromFourcc(fourcc uint32) VideoFormat {
	var _arg1 C.guint32        // out
	var _cret C.GstVideoFormat // in

	_arg1 = C.guint32(fourcc)

	_cret = C.gst_video_format_from_fourcc(_arg1)
	runtime.KeepAlive(fourcc)

	var _videoFormat VideoFormat // out

	_videoFormat = VideoFormat(_cret)

	return _videoFormat
}

// VideoFormatFromMasks: find the VideoFormat for the given parameters.
//
// The function takes the following parameters:
//
//    - depth: amount of bits used for a pixel.
//    - bpp: amount of bits used to store a pixel. This value is bigger than
//      depth.
//    - endianness of the masks, LITTLE_ENDIAN or BIG_ENDIAN.
//    - redMask: red mask.
//    - greenMask: green mask.
//    - blueMask: blue mask.
//    - alphaMask: alpha mask, or 0 if no alpha mask.
//
// The function returns the following values:
//
//    - videoFormat or GST_VIDEO_FORMAT_UNKNOWN when the parameters to not
//      specify a known format.
//
func VideoFormatFromMasks(depth, bpp, endianness int, redMask, greenMask, blueMask, alphaMask uint) VideoFormat {
	var _arg1 C.gint           // out
	var _arg2 C.gint           // out
	var _arg3 C.gint           // out
	var _arg4 C.guint          // out
	var _arg5 C.guint          // out
	var _arg6 C.guint          // out
	var _arg7 C.guint          // out
	var _cret C.GstVideoFormat // in

	_arg1 = C.gint(depth)
	_arg2 = C.gint(bpp)
	_arg3 = C.gint(endianness)
	_arg4 = C.guint(redMask)
	_arg5 = C.guint(greenMask)
	_arg6 = C.guint(blueMask)
	_arg7 = C.guint(alphaMask)

	_cret = C.gst_video_format_from_masks(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(depth)
	runtime.KeepAlive(bpp)
	runtime.KeepAlive(endianness)
	runtime.KeepAlive(redMask)
	runtime.KeepAlive(greenMask)
	runtime.KeepAlive(blueMask)
	runtime.KeepAlive(alphaMask)

	var _videoFormat VideoFormat // out

	_videoFormat = VideoFormat(_cret)

	return _videoFormat
}

// VideoFormatFromString: convert the format string to its VideoFormat.
//
// The function takes the following parameters:
//
//    - format string.
//
// The function returns the following values:
//
//    - videoFormat for format or GST_VIDEO_FORMAT_UNKNOWN when the string is not
//      a known format.
//
func VideoFormatFromString(format string) VideoFormat {
	var _arg1 *C.gchar         // out
	var _cret C.GstVideoFormat // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(format)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_video_format_from_string(_arg1)
	runtime.KeepAlive(format)

	var _videoFormat VideoFormat // out

	_videoFormat = VideoFormat(_cret)

	return _videoFormat
}

// VideoFormatGetInfo: get the VideoFormatInfo for format.
//
// The function takes the following parameters:
//
//    - format: VideoFormat.
//
// The function returns the following values:
//
//    - videoFormatInfo for format.
//
func VideoFormatGetInfo(format VideoFormat) *VideoFormatInfo {
	var _arg1 C.GstVideoFormat      // out
	var _cret *C.GstVideoFormatInfo // in

	_arg1 = C.GstVideoFormat(format)

	_cret = C.gst_video_format_get_info(_arg1)
	runtime.KeepAlive(format)

	var _videoFormatInfo *VideoFormatInfo // out

	_videoFormatInfo = (*VideoFormatInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _videoFormatInfo
}

// VideoFormatToFourcc converts a VideoFormat value into the corresponding
// FOURCC. Only a few YUV formats have corresponding FOURCC values. If format
// has no corresponding FOURCC value, 0 is returned.
//
// The function takes the following parameters:
//
//    - format video format.
//
// The function returns the following values:
//
//    - guint32: FOURCC corresponding to format.
//
func VideoFormatToFourcc(format VideoFormat) uint32 {
	var _arg1 C.GstVideoFormat // out
	var _cret C.guint32        // in

	_arg1 = C.GstVideoFormat(format)

	_cret = C.gst_video_format_to_fourcc(_arg1)
	runtime.KeepAlive(format)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// VideoFormatToString returns a string containing a descriptive name for the
// VideoFormat if there is one, or NULL otherwise.
//
// The function takes the following parameters:
//
//    - format video format.
//
// The function returns the following values:
//
//    - utf8: name corresponding to format.
//
func VideoFormatToString(format VideoFormat) string {
	var _arg1 C.GstVideoFormat // out
	var _cret *C.gchar         // in

	_arg1 = C.GstVideoFormat(format)

	_cret = C.gst_video_format_to_string(_arg1)
	runtime.KeepAlive(format)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// VideoFormatFlags: different video flags that a format info can have.
type VideoFormatFlags C.guint

const (
	// VideoFormatFlagYuv: video format is YUV, components are numbered 0=Y,
	// 1=U, 2=V.
	VideoFormatFlagYuv VideoFormatFlags = 0b1
	// VideoFormatFlagRGB: video format is RGB, components are numbered 0=R,
	// 1=G, 2=B.
	VideoFormatFlagRGB VideoFormatFlags = 0b10
	// VideoFormatFlagGray: video is gray, there is one gray component with
	// index 0.
	VideoFormatFlagGray VideoFormatFlags = 0b100
	// VideoFormatFlagAlpha: video format has an alpha components with the
	// number 3.
	VideoFormatFlagAlpha VideoFormatFlags = 0b1000
	// VideoFormatFlagLE: video format has data stored in little endianness.
	VideoFormatFlagLE VideoFormatFlags = 0b10000
	// VideoFormatFlagPalette: video format has a palette. The palette is stored
	// in the second plane and indexes are stored in the first plane.
	VideoFormatFlagPalette VideoFormatFlags = 0b100000
	// VideoFormatFlagComplex: video format has a complex layout that can't be
	// described with the usual information in the VideoFormatInfo.
	VideoFormatFlagComplex VideoFormatFlags = 0b1000000
	// VideoFormatFlagUnpack: this format can be used in a VideoFormatUnpack and
	// VideoFormatPack function.
	VideoFormatFlagUnpack VideoFormatFlags = 0b10000000
	// VideoFormatFlagTiled: format is tiled, there is tiling information in the
	// last plane.
	VideoFormatFlagTiled VideoFormatFlags = 0b100000000
)

func marshalVideoFormatFlags(p uintptr) (interface{}, error) {
	return VideoFormatFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoFormatFlags.
func (v VideoFormatFlags) String() string {
	if v == 0 {
		return "VideoFormatFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(185)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoFormatFlagYuv:
			builder.WriteString("Yuv|")
		case VideoFormatFlagRGB:
			builder.WriteString("RGB|")
		case VideoFormatFlagGray:
			builder.WriteString("Gray|")
		case VideoFormatFlagAlpha:
			builder.WriteString("Alpha|")
		case VideoFormatFlagLE:
			builder.WriteString("LE|")
		case VideoFormatFlagPalette:
			builder.WriteString("Palette|")
		case VideoFormatFlagComplex:
			builder.WriteString("Complex|")
		case VideoFormatFlagUnpack:
			builder.WriteString("Unpack|")
		case VideoFormatFlagTiled:
			builder.WriteString("Tiled|")
		default:
			builder.WriteString(fmt.Sprintf("VideoFormatFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoFormatFlags) Has(other VideoFormatFlags) bool {
	return (v & other) == other
}

// VideoPackFlags: different flags that can be used when packing and unpacking.
type VideoPackFlags C.guint

const (
	// VideoPackFlagNone: no flag.
	VideoPackFlagNone VideoPackFlags = 0b0
	// VideoPackFlagTruncateRange: when the source has a smaller depth than the
	// target format, set the least significant bits of the target to 0. This is
	// likely slightly faster but less accurate. When this flag is not
	// specified, the most significant bits of the source are duplicated in the
	// least significant bits of the destination.
	VideoPackFlagTruncateRange VideoPackFlags = 0b1
	// VideoPackFlagInterlaced: source is interlaced. The unpacked format will
	// be interlaced as well with each line containing information from
	// alternating fields. (Since: 1.2).
	VideoPackFlagInterlaced VideoPackFlags = 0b10
)

func marshalVideoPackFlags(p uintptr) (interface{}, error) {
	return VideoPackFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoPackFlags.
func (v VideoPackFlags) String() string {
	if v == 0 {
		return "VideoPackFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(68)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoPackFlagNone:
			builder.WriteString("None|")
		case VideoPackFlagTruncateRange:
			builder.WriteString("TruncateRange|")
		case VideoPackFlagInterlaced:
			builder.WriteString("Interlaced|")
		default:
			builder.WriteString(fmt.Sprintf("VideoPackFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoPackFlags) Has(other VideoPackFlags) bool {
	return (v & other) == other
}

// VideoFormatInfo: information for a video format.
//
// An instance of this type is always passed by reference.
type VideoFormatInfo struct {
	*videoFormatInfo
}

// videoFormatInfo is the struct that's finalized.
type videoFormatInfo struct {
	native *C.GstVideoFormatInfo
}

// Component: fill components with the number of all the components packed in
// plane p for the format info. A value of -1 in components indicates that no
// more components are packed in the plane.
//
// The function takes the following parameters:
//
//    - plane number.
//
// The function returns the following values:
//
//    - components: array used to store component numbers.
//
func (info *VideoFormatInfo) Component(plane uint) int {
	var _arg0 *C.GstVideoFormatInfo // out
	var _arg1 C.guint               // out
	var _arg2 C.gint                // in

	_arg0 = (*C.GstVideoFormatInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = C.guint(plane)

	C.gst_video_format_info_component(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(plane)

	var _components int // out

	_components = int(_arg2)

	return _components
}
