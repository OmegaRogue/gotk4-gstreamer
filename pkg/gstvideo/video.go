// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/video/video.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gstvideo1_VideoConvertSampleCallback(GstSample*, GError*, gpointer);
import "C"

type VideoConvertSampleCallback func(sample *gst.Sample, err error)

// VideoCalculateDisplayRatio: given the Pixel Aspect Ratio and size of an input
// video frame, and the pixel aspect ratio of the intended display device,
// calculates the actual display ratio the video will be rendered with.
//
// The function takes the following parameters:
//
//    - videoWidth: width of the video frame in pixels.
//    - videoHeight: height of the video frame in pixels.
//    - videoParN: numerator of the pixel aspect ratio of the input video.
//    - videoParD: denominator of the pixel aspect ratio of the input video.
//    - displayParN: numerator of the pixel aspect ratio of the display device.
//    - displayParD: denominator of the pixel aspect ratio of the display device.
//
// The function returns the following values:
//
//    - darN: numerator of the calculated display_ratio.
//    - darD: denominator of the calculated display_ratio.
//    - ok: boolean indicating success and a calculated Display Ratio in the
//      dar_n and dar_d parameters. The return value is FALSE in the case of
//      integer overflow or other error.
//
func VideoCalculateDisplayRatio(videoWidth, videoHeight, videoParN, videoParD, displayParN, displayParD uint) (darN, darD uint, ok bool) {
	var _arg1 C.guint    // in
	var _arg2 C.guint    // in
	var _arg3 C.guint    // out
	var _arg4 C.guint    // out
	var _arg5 C.guint    // out
	var _arg6 C.guint    // out
	var _arg7 C.guint    // out
	var _arg8 C.guint    // out
	var _cret C.gboolean // in

	_arg3 = C.guint(videoWidth)
	_arg4 = C.guint(videoHeight)
	_arg5 = C.guint(videoParN)
	_arg6 = C.guint(videoParD)
	_arg7 = C.guint(displayParN)
	_arg8 = C.guint(displayParD)

	_cret = C.gst_video_calculate_display_ratio(&_arg1, &_arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(videoWidth)
	runtime.KeepAlive(videoHeight)
	runtime.KeepAlive(videoParN)
	runtime.KeepAlive(videoParD)
	runtime.KeepAlive(displayParN)
	runtime.KeepAlive(displayParD)

	var _darN uint // out
	var _darD uint // out
	var _ok bool   // out

	_darN = uint(_arg1)
	_darD = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _darN, _darD, _ok
}

// VideoConvertSample converts a raw video buffer into the specified output
// caps.
//
// The output caps can be any raw video formats or any image formats (jpeg, png,
// ...).
//
// The width, height and pixel-aspect-ratio can also be specified in the output
// caps.
//
// The function takes the following parameters:
//
//    - sample: Sample.
//    - toCaps to convert to.
//    - timeout: maximum amount of time allowed for the processing.
//
// The function returns the following values:
//
//    - ret: converted Sample, or NULL if an error happened (in which case err
//      will point to the #GError).
//
func VideoConvertSample(sample *gst.Sample, toCaps *gst.Caps, timeout gst.ClockTime) (*gst.Sample, error) {
	var _arg1 *C.GstSample   // out
	var _arg2 *C.GstCaps     // out
	var _arg3 C.GstClockTime // out
	var _cret *C.GstSample   // in
	var _cerr *C.GError      // in

	_arg1 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(toCaps)))
	_arg3 = C.guint64(timeout)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_video_convert_sample(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(toCaps)
	runtime.KeepAlive(timeout)

	var _ret *gst.Sample // out
	var _goerr error     // out

	_ret = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _ret, _goerr
}

// VideoConvertSampleAsync converts a raw video buffer into the specified output
// caps.
//
// The output caps can be any raw video formats or any image formats (jpeg, png,
// ...).
//
// The width, height and pixel-aspect-ratio can also be specified in the output
// caps.
//
// callback will be called after conversion, when an error occurred or if
// conversion didn't finish after timeout. callback will always be called from
// the thread default GMainContext, see g_main_context_get_thread_default(). If
// GLib before 2.22 is used, this will always be the global default main
// context.
//
// destroy_notify will be called after the callback was called and user_data is
// not needed anymore.
//
// The function takes the following parameters:
//
//    - sample: Sample.
//    - toCaps to convert to.
//    - timeout: maximum amount of time allowed for the processing.
//    - callback: GstVideoConvertSampleCallback that will be called after
//      conversion.
//
func VideoConvertSampleAsync(sample *gst.Sample, toCaps *gst.Caps, timeout gst.ClockTime, callback VideoConvertSampleCallback) {
	var _arg1 *C.GstSample                    // out
	var _arg2 *C.GstCaps                      // out
	var _arg3 C.GstClockTime                  // out
	var _arg4 C.GstVideoConvertSampleCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg1 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(toCaps)))
	_arg3 = C.guint64(timeout)
	type _ = gst.ClockTime
	type _ = uint64
	_arg4 = (*[0]byte)(C._gotk4_gstvideo1_VideoConvertSampleCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gst_video_convert_sample_async(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(toCaps)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(callback)
}

// VideoAlignment: extra alignment parameters for the memory of video buffers.
// This structure is usually used to configure the bufferpool if it supports the
// T_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT.
//
// An instance of this type is always passed by reference.
type VideoAlignment struct {
	*videoAlignment
}

// videoAlignment is the struct that's finalized.
type videoAlignment struct {
	native *C.GstVideoAlignment
}

// PaddingTop: extra pixels on the top.
func (v *VideoAlignment) PaddingTop() uint {
	valptr := &v.native.padding_top
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// PaddingBottom: extra pixels on the bottom.
func (v *VideoAlignment) PaddingBottom() uint {
	valptr := &v.native.padding_bottom
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// PaddingLeft: extra pixels on the left side.
func (v *VideoAlignment) PaddingLeft() uint {
	valptr := &v.native.padding_left
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// PaddingRight: extra pixels on the right side.
func (v *VideoAlignment) PaddingRight() uint {
	valptr := &v.native.padding_right
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// StrideAlign: array with extra alignment requirements for the strides.
func (v *VideoAlignment) StrideAlign() [4]uint {
	valptr := &v.native.stride_align
	var _v [4]uint // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = uint(src[i])
		}
	}
	return _v
}

// PaddingTop: extra pixels on the top.
func (v *VideoAlignment) SetPaddingTop(paddingTop uint) {
	valptr := &v.native.padding_top
	*valptr = C.guint(paddingTop)
}

// PaddingBottom: extra pixels on the bottom.
func (v *VideoAlignment) SetPaddingBottom(paddingBottom uint) {
	valptr := &v.native.padding_bottom
	*valptr = C.guint(paddingBottom)
}

// PaddingLeft: extra pixels on the left side.
func (v *VideoAlignment) SetPaddingLeft(paddingLeft uint) {
	valptr := &v.native.padding_left
	*valptr = C.guint(paddingLeft)
}

// PaddingRight: extra pixels on the right side.
func (v *VideoAlignment) SetPaddingRight(paddingRight uint) {
	valptr := &v.native.padding_right
	*valptr = C.guint(paddingRight)
}

// Reset: set align to its default values with no padding and no alignment.
func (align *VideoAlignment) Reset() {
	var _arg0 *C.GstVideoAlignment // out

	_arg0 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(align)))

	C.gst_video_alignment_reset(_arg0)
	runtime.KeepAlive(align)
}
