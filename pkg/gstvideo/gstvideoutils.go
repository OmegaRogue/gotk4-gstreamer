// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
import "C"

// GType values.
var (
	GTypeVideoCodecFrameFlags = coreglib.Type(C.gst_video_codec_frame_flags_get_type())
	GTypeVideoCodecFrame      = coreglib.Type(C.gst_video_codec_frame_get_type())
	GTypeVideoCodecState      = coreglib.Type(C.gst_video_codec_state_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoCodecFrameFlags, F: marshalVideoCodecFrameFlags},
		coreglib.TypeMarshaler{T: GTypeVideoCodecFrame, F: marshalVideoCodecFrame},
		coreglib.TypeMarshaler{T: GTypeVideoCodecState, F: marshalVideoCodecState},
	})
}

// VideoCodecFrameFlags flags for VideoCodecFrame.
type VideoCodecFrameFlags C.guint

const (
	// VideoCodecFrameFlagDecodeOnly is the frame only meant to be decoded.
	VideoCodecFrameFlagDecodeOnly VideoCodecFrameFlags = 0b1
	// VideoCodecFrameFlagSyncPoint is the frame a synchronization point
	// (keyframe).
	VideoCodecFrameFlagSyncPoint VideoCodecFrameFlags = 0b10
	// VideoCodecFrameFlagForceKeyframe: should the output frame be made a
	// keyframe.
	VideoCodecFrameFlagForceKeyframe VideoCodecFrameFlags = 0b100
	// VideoCodecFrameFlagForceKeyframeHeaders: should the encoder output stream
	// headers.
	VideoCodecFrameFlagForceKeyframeHeaders VideoCodecFrameFlags = 0b1000
	// VideoCodecFrameFlagCorrupted: buffer data is corrupted.
	VideoCodecFrameFlagCorrupted VideoCodecFrameFlags = 0b10000
)

func marshalVideoCodecFrameFlags(p uintptr) (interface{}, error) {
	return VideoCodecFrameFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for VideoCodecFrameFlags.
func (v VideoCodecFrameFlags) String() string {
	if v == 0 {
		return "VideoCodecFrameFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(160)

	for v != 0 {
		next := v & (v - 1)
		bit := v - next

		switch bit {
		case VideoCodecFrameFlagDecodeOnly:
			builder.WriteString("DecodeOnly|")
		case VideoCodecFrameFlagSyncPoint:
			builder.WriteString("SyncPoint|")
		case VideoCodecFrameFlagForceKeyframe:
			builder.WriteString("ForceKeyframe|")
		case VideoCodecFrameFlagForceKeyframeHeaders:
			builder.WriteString("ForceKeyframeHeaders|")
		case VideoCodecFrameFlagCorrupted:
			builder.WriteString("Corrupted|")
		default:
			builder.WriteString(fmt.Sprintf("VideoCodecFrameFlags(0b%b)|", bit))
		}

		v = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if v contains other.
func (v VideoCodecFrameFlags) Has(other VideoCodecFrameFlags) bool {
	return (v & other) == other
}

// VideoCodecFrame represents a video frame both in raw and encoded form.
//
// An instance of this type is always passed by reference.
type VideoCodecFrame struct {
	*videoCodecFrame
}

// videoCodecFrame is the struct that's finalized.
type videoCodecFrame struct {
	native *C.GstVideoCodecFrame
}

func marshalVideoCodecFrame(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VideoCodecFrame{&videoCodecFrame{(*C.GstVideoCodecFrame)(b)}}, nil
}

// SystemFrameNumber: unique identifier for the frame. Use this if you need to
// get hold of the frame later (like when data is being decoded). Typical usage
// in decoders is to set this on the opaque value provided to the library and
// get back the frame using gst_video_decoder_get_frame().
func (v *VideoCodecFrame) SystemFrameNumber() uint32 {
	valptr := &v.native.system_frame_number
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// Dts: decoding timestamp.
func (v *VideoCodecFrame) Dts() gst.ClockTime {
	valptr := &v.native.dts
	var _v gst.ClockTime // out
	_v = uint64(*valptr)
	type _ = gst.ClockTime
	type _ = uint64
	return _v
}

// Pts: presentation timestamp.
func (v *VideoCodecFrame) Pts() gst.ClockTime {
	valptr := &v.native.pts
	var _v gst.ClockTime // out
	_v = uint64(*valptr)
	type _ = gst.ClockTime
	type _ = uint64
	return _v
}

// Duration of the frame.
func (v *VideoCodecFrame) Duration() gst.ClockTime {
	valptr := &v.native.duration
	var _v gst.ClockTime // out
	_v = uint64(*valptr)
	type _ = gst.ClockTime
	type _ = uint64
	return _v
}

// DistanceFromSync: distance in frames from the last synchronization point.
func (v *VideoCodecFrame) DistanceFromSync() int {
	valptr := &v.native.distance_from_sync
	var _v int // out
	_v = int(*valptr)
	return _v
}

// InputBuffer: input Buffer that created this frame. The buffer is owned by the
// frame and references to the frame instead of the buffer should be kept.
func (v *VideoCodecFrame) InputBuffer() *gst.Buffer {
	valptr := &v.native.input_buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// OutputBuffer: output Buffer. Implementations should set this either directly,
// or by using the gst_video_decoder_allocate_output_frame() or
// gst_video_decoder_allocate_output_buffer() methods. The buffer is owned by
// the frame and references to the frame instead of the buffer should be kept.
func (v *VideoCodecFrame) OutputBuffer() *gst.Buffer {
	valptr := &v.native.output_buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Deadline: running time when the frame will be used.
func (v *VideoCodecFrame) Deadline() gst.ClockTime {
	valptr := &v.native.deadline
	var _v gst.ClockTime // out
	_v = uint64(*valptr)
	type _ = gst.ClockTime
	type _ = uint64
	return _v
}

// SystemFrameNumber: unique identifier for the frame. Use this if you need to
// get hold of the frame later (like when data is being decoded). Typical usage
// in decoders is to set this on the opaque value provided to the library and
// get back the frame using gst_video_decoder_get_frame().
func (v *VideoCodecFrame) SetSystemFrameNumber(systemFrameNumber uint32) {
	valptr := &v.native.system_frame_number
	*valptr = C.guint32(systemFrameNumber)
}

// DistanceFromSync: distance in frames from the last synchronization point.
func (v *VideoCodecFrame) SetDistanceFromSync(distanceFromSync int) {
	valptr := &v.native.distance_from_sync
	*valptr = C.int(distanceFromSync)
}

// UserData gets private data set on the frame by the subclass via
// gst_video_codec_frame_set_user_data() previously.
//
// The function returns the following values:
//
//    - gpointer (optional): previously set user_data.
//
func (frame *VideoCodecFrame) UserData() unsafe.Pointer {
	var _arg0 *C.GstVideoCodecFrame // out
	var _cret C.gpointer            // in

	_arg0 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_codec_frame_get_user_data(_arg0)
	runtime.KeepAlive(frame)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// VideoCodecState: structure representing the state of an incoming or outgoing
// video stream for encoders and decoders.
//
// Decoders and encoders will receive such a state through their respective
// set_format vmethods.
//
// Decoders and encoders can set the downstream state, by using the
// gst_video_decoder_set_output_state() or gst_video_encoder_set_output_state()
// methods.
//
// An instance of this type is always passed by reference.
type VideoCodecState struct {
	*videoCodecState
}

// videoCodecState is the struct that's finalized.
type videoCodecState struct {
	native *C.GstVideoCodecState
}

func marshalVideoCodecState(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &VideoCodecState{&videoCodecState{(*C.GstVideoCodecState)(b)}}, nil
}

// Info describing the stream.
func (v *VideoCodecState) Info() *VideoInfo {
	valptr := &v.native.info
	var _v *VideoInfo // out
	_v = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Caps used in the caps negotiation of the pad.
func (v *VideoCodecState) Caps() *gst.Caps {
	valptr := &v.native.caps
	var _v *gst.Caps // out
	_v = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// CodecData corresponding to the 'codec_data' field of a stream, or NULL.
func (v *VideoCodecState) CodecData() *gst.Buffer {
	valptr := &v.native.codec_data
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// AllocationCaps for allocation query and pool negotiation. Since: 1.10.
func (v *VideoCodecState) AllocationCaps() *gst.Caps {
	valptr := &v.native.allocation_caps
	var _v *gst.Caps // out
	_v = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// MasteringDisplayInfo: mastering display color volume information (HDR
// metadata) for the stream.
func (v *VideoCodecState) MasteringDisplayInfo() *VideoMasteringDisplayInfo {
	valptr := &v.native.mastering_display_info
	var _v *VideoMasteringDisplayInfo // out
	_v = (*VideoMasteringDisplayInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// ContentLightLevel: content light level information for the stream.
func (v *VideoCodecState) ContentLightLevel() *VideoContentLightLevel {
	valptr := &v.native.content_light_level
	var _v *VideoContentLightLevel // out
	_v = (*VideoContentLightLevel)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}
