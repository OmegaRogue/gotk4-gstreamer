// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/video/video.h>
import "C"

// VideoEventIsForceKeyUnit checks if an event is a force key unit event.
// Returns true for both upstream and downstream force key unit events.
//
// The function takes the following parameters:
//
//    - event to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the event is a valid force key unit event.
//
func VideoEventIsForceKeyUnit(event *gst.Event) bool {
	var _arg1 *C.GstEvent // out
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_video_event_is_force_key_unit(_arg1)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VideoEventNewDownstreamForceKeyUnit creates a new downstream force key unit
// event. A downstream force key unit event can be sent down the pipeline to
// request downstream elements to produce a key unit. A downstream force key
// unit event must also be sent when handling an upstream force key unit event
// to notify downstream that the latter has been handled.
//
// To parse an event created by gst_video_event_new_downstream_force_key_unit()
// use gst_video_event_parse_downstream_force_key_unit().
//
// The function takes the following parameters:
//
//    - timestamp of the buffer that starts a new key unit.
//    - streamTime: stream_time of the buffer that starts a new key unit.
//    - runningTime: running_time of the buffer that starts a new key unit.
//    - allHeaders: TRUE to produce headers when starting a new key unit.
//    - count: integer that can be used to number key units.
//
// The function returns the following values:
//
//    - event: new GstEvent.
//
func VideoEventNewDownstreamForceKeyUnit(timestamp, streamTime, runningTime gst.ClockTime, allHeaders bool, count uint) *gst.Event {
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.gboolean     // out
	var _arg5 C.guint        // out
	var _cret *C.GstEvent    // in

	_arg1 = C.guint64(timestamp)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(streamTime)
	type _ = gst.ClockTime
	type _ = uint64
	_arg3 = C.guint64(runningTime)
	type _ = gst.ClockTime
	type _ = uint64
	if allHeaders {
		_arg4 = C.TRUE
	}
	_arg5 = C.guint(count)

	_cret = C.gst_video_event_new_downstream_force_key_unit(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(streamTime)
	runtime.KeepAlive(runningTime)
	runtime.KeepAlive(allHeaders)
	runtime.KeepAlive(count)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// VideoEventNewStillFrame creates a new Still Frame event. If in_still is TRUE,
// then the event represents the start of a still frame sequence. If it is
// FALSE, then the event ends a still frame sequence.
//
// To parse an event created by gst_video_event_new_still_frame() use
// gst_video_event_parse_still_frame().
//
// The function takes the following parameters:
//
//    - inStill: boolean value for the still-frame state of the event.
//
// The function returns the following values:
//
//    - event: new GstEvent.
//
func VideoEventNewStillFrame(inStill bool) *gst.Event {
	var _arg1 C.gboolean  // out
	var _cret *C.GstEvent // in

	if inStill {
		_arg1 = C.TRUE
	}

	_cret = C.gst_video_event_new_still_frame(_arg1)
	runtime.KeepAlive(inStill)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// VideoEventNewUpstreamForceKeyUnit creates a new upstream force key unit
// event. An upstream force key unit event can be sent to request upstream
// elements to produce a key unit.
//
// running_time can be set to request a new key unit at a specific running_time.
// If set to GST_CLOCK_TIME_NONE, upstream elements will produce a new key unit
// as soon as possible.
//
// To parse an event created by gst_video_event_new_downstream_force_key_unit()
// use gst_video_event_parse_downstream_force_key_unit().
//
// The function takes the following parameters:
//
//    - runningTime: running_time at which a new key unit should be produced.
//    - allHeaders: TRUE to produce headers when starting a new key unit.
//    - count: integer that can be used to number key units.
//
// The function returns the following values:
//
//    - event: new GstEvent.
//
func VideoEventNewUpstreamForceKeyUnit(runningTime gst.ClockTime, allHeaders bool, count uint) *gst.Event {
	var _arg1 C.GstClockTime // out
	var _arg2 C.gboolean     // out
	var _arg3 C.guint        // out
	var _cret *C.GstEvent    // in

	_arg1 = C.guint64(runningTime)
	type _ = gst.ClockTime
	type _ = uint64
	if allHeaders {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint(count)

	_cret = C.gst_video_event_new_upstream_force_key_unit(_arg1, _arg2, _arg3)
	runtime.KeepAlive(runningTime)
	runtime.KeepAlive(allHeaders)
	runtime.KeepAlive(count)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// VideoEventParseDownstreamForceKeyUnit: get timestamp, stream-time,
// running-time, all-headers and count in the force key unit event. See
// gst_video_event_new_downstream_force_key_unit() for a full description of the
// downstream force key unit event.
//
// running_time will be adjusted for any pad offsets of pads it was passing
// through.
//
// The function takes the following parameters:
//
//    - event to parse.
//
// The function returns the following values:
//
//    - timestamp: pointer to the timestamp in the event.
//    - streamTime: pointer to the stream-time in the event.
//    - runningTime: pointer to the running-time in the event.
//    - allHeaders: pointer to the all_headers flag in the event.
//    - count: pointer to the count field of the event.
//    - ok: TRUE if the event is a valid downstream force key unit event.
//
func VideoEventParseDownstreamForceKeyUnit(event *gst.Event) (timestamp, streamTime, runningTime gst.ClockTime, allHeaders bool, count uint, ok bool) {
	var _arg1 *C.GstEvent    // out
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in
	var _arg4 C.GstClockTime // in
	var _arg5 C.gboolean     // in
	var _arg6 C.guint        // in
	var _cret C.gboolean     // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_video_event_parse_downstream_force_key_unit(_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(event)

	var _timestamp gst.ClockTime   // out
	var _streamTime gst.ClockTime  // out
	var _runningTime gst.ClockTime // out
	var _allHeaders bool           // out
	var _count uint                // out
	var _ok bool                   // out

	_timestamp = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64
	_streamTime = uint64(_arg3)
	type _ = gst.ClockTime
	type _ = uint64
	_runningTime = uint64(_arg4)
	type _ = gst.ClockTime
	type _ = uint64
	if _arg5 != 0 {
		_allHeaders = true
	}
	_count = uint(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _timestamp, _streamTime, _runningTime, _allHeaders, _count, _ok
}

// VideoEventParseStillFrame: parse a Event, identify if it is a Still Frame
// event, and return the still-frame state from the event if it is. If the event
// represents the start of a still frame, the in_still variable will be set to
// TRUE, otherwise FALSE. It is OK to pass NULL for the in_still variable order
// to just check whether the event is a valid still-frame event.
//
// Create a still frame event using gst_video_event_new_still_frame().
//
// The function takes the following parameters:
//
//    - event to parse.
//
// The function returns the following values:
//
//    - inStill: A boolean to receive the still-frame status from the event, or
//      NULL.
//    - ok: TRUE if the event is a valid still-frame event. FALSE if not.
//
func VideoEventParseStillFrame(event *gst.Event) (inStill, ok bool) {
	var _arg1 *C.GstEvent // out
	var _arg2 C.gboolean  // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_video_event_parse_still_frame(_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _inStill bool // out
	var _ok bool      // out

	if _arg2 != 0 {
		_inStill = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _inStill, _ok
}

// VideoEventParseUpstreamForceKeyUnit: get running-time, all-headers and count
// in the force key unit event. See
// gst_video_event_new_upstream_force_key_unit() for a full description of the
// upstream force key unit event.
//
// Create an upstream force key unit event using
// gst_video_event_new_upstream_force_key_unit()
//
// running_time will be adjusted for any pad offsets of pads it was passing
// through.
//
// The function takes the following parameters:
//
//    - event to parse.
//
// The function returns the following values:
//
//    - runningTime: pointer to the running_time in the event.
//    - allHeaders: pointer to the all_headers flag in the event.
//    - count: pointer to the count field in the event.
//    - ok: TRUE if the event is a valid upstream force-key-unit event. FALSE if
//      not.
//
func VideoEventParseUpstreamForceKeyUnit(event *gst.Event) (runningTime gst.ClockTime, allHeaders bool, count uint, ok bool) {
	var _arg1 *C.GstEvent    // out
	var _arg2 C.GstClockTime // in
	var _arg3 C.gboolean     // in
	var _arg4 C.guint        // in
	var _cret C.gboolean     // in

	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_video_event_parse_upstream_force_key_unit(_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _runningTime gst.ClockTime // out
	var _allHeaders bool           // out
	var _count uint                // out
	var _ok bool                   // out

	_runningTime = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64
	if _arg3 != 0 {
		_allHeaders = true
	}
	_count = uint(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _runningTime, _allHeaders, _count, _ok
}
