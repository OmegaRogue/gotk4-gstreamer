// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/video/video.h>
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_transform_meta(GstVideoDecoder*, GstVideoCodecFrame*, GstMeta*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_stop(GstVideoDecoder*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_start(GstVideoDecoder*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_src_query(GstVideoDecoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_src_event(GstVideoDecoder*, GstEvent*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_sink_query(GstVideoDecoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_sink_event(GstVideoDecoder*, GstEvent*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_set_format(GstVideoDecoder*, GstVideoCodecState*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_reset(GstVideoDecoder*, gboolean);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_propose_allocation(GstVideoDecoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_open(GstVideoDecoder*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_negotiate(GstVideoDecoder*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_handle_missing_data(GstVideoDecoder*, GstClockTime, GstClockTime);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_flush(GstVideoDecoder*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_decide_allocation(GstVideoDecoder*, GstQuery*);
// extern gboolean _gotk4_gstvideo1_VideoDecoderClass_close(GstVideoDecoder*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoDecoderClass_parse(GstVideoDecoder*, GstVideoCodecFrame*, GstAdapter*, gboolean);
// extern GstFlowReturn _gotk4_gstvideo1_VideoDecoderClass_handle_frame(GstVideoDecoder*, GstVideoCodecFrame*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoDecoderClass_finish(GstVideoDecoder*);
// extern GstFlowReturn _gotk4_gstvideo1_VideoDecoderClass_drain(GstVideoDecoder*);
// extern GstCaps* _gotk4_gstvideo1_VideoDecoderClass_getcaps(GstVideoDecoder*, GstCaps*);
// GstCaps* _gotk4_gstvideo1_VideoDecoder_virtual_getcaps(void* fnptr, GstVideoDecoder* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstVideoDecoder*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoDecoder_virtual_drain(void* fnptr, GstVideoDecoder* arg0) {
//   return ((GstFlowReturn (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoDecoder_virtual_finish(void* fnptr, GstVideoDecoder* arg0) {
//   return ((GstFlowReturn (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoDecoder_virtual_handle_frame(void* fnptr, GstVideoDecoder* arg0, GstVideoCodecFrame* arg1) {
//   return ((GstFlowReturn (*)(GstVideoDecoder*, GstVideoCodecFrame*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstvideo1_VideoDecoder_virtual_parse(void* fnptr, GstVideoDecoder* arg0, GstVideoCodecFrame* arg1, GstAdapter* arg2, gboolean arg3) {
//   return ((GstFlowReturn (*)(GstVideoDecoder*, GstVideoCodecFrame*, GstAdapter*, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_close(void* fnptr, GstVideoDecoder* arg0) {
//   return ((gboolean (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_decide_allocation(void* fnptr, GstVideoDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_flush(void* fnptr, GstVideoDecoder* arg0) {
//   return ((gboolean (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_handle_missing_data(void* fnptr, GstVideoDecoder* arg0, GstClockTime arg1, GstClockTime arg2) {
//   return ((gboolean (*)(GstVideoDecoder*, GstClockTime, GstClockTime))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_negotiate(void* fnptr, GstVideoDecoder* arg0) {
//   return ((gboolean (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_open(void* fnptr, GstVideoDecoder* arg0) {
//   return ((gboolean (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_propose_allocation(void* fnptr, GstVideoDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_reset(void* fnptr, GstVideoDecoder* arg0, gboolean arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_set_format(void* fnptr, GstVideoDecoder* arg0, GstVideoCodecState* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstVideoCodecState*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_sink_event(void* fnptr, GstVideoDecoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_sink_query(void* fnptr, GstVideoDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_src_event(void* fnptr, GstVideoDecoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_src_query(void* fnptr, GstVideoDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstVideoDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_start(void* fnptr, GstVideoDecoder* arg0) {
//   return ((gboolean (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_stop(void* fnptr, GstVideoDecoder* arg0) {
//   return ((gboolean (*)(GstVideoDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstvideo1_VideoDecoder_virtual_transform_meta(void* fnptr, GstVideoDecoder* arg0, GstVideoCodecFrame* arg1, GstMeta* arg2) {
//   return ((gboolean (*)(GstVideoDecoder*, GstVideoCodecFrame*, GstMeta*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeVideoDecoder = coreglib.Type(C.gst_video_decoder_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVideoDecoder, F: marshalVideoDecoder},
	})
}

// VIDEO_DECODER_MAX_ERRORS: default maximum number of errors tolerated before
// signaling error.
const VIDEO_DECODER_MAX_ERRORS = 10

// VIDEO_DECODER_SINK_NAME: name of the templates for the sink pad.
const VIDEO_DECODER_SINK_NAME = "sink"

// VIDEO_DECODER_SRC_NAME: name of the templates for the source pad.
const VIDEO_DECODER_SRC_NAME = "src"

// VideoDecoderOverrides contains methods that are overridable.
type VideoDecoderOverrides struct {
	// The function returns the following values:
	//
	Close func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	// The function returns the following values:
	//
	Drain func() gst.FlowReturn
	// The function returns the following values:
	//
	Finish func() gst.FlowReturn
	// The function returns the following values:
	//
	Flush func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	caps func(filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	//    - frame to handle.
	//
	// The function returns the following values:
	//
	HandleFrame func(frame *VideoCodecFrame) gst.FlowReturn
	// The function takes the following parameters:
	//
	//    - timestamp: timestamp of the missing data.
	//    - duration: duration of the missing data.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the decoder should be drained afterwards.
	//
	HandleMissingData func(timestamp, duration gst.ClockTime) bool
	// Negotiate with downstream elements to currently configured
	// VideoCodecState. Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But
	// mark it again if negotiate fails.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the negotiation succeeded, else FALSE.
	//
	Negotiate func() bool
	// The function returns the following values:
	//
	Open func() bool
	// The function takes the following parameters:
	//
	//    - frame
	//    - adapter
	//    - atEos
	//
	// The function returns the following values:
	//
	Parse func(frame *VideoCodecFrame, adapter *gstbase.Adapter, atEos bool) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProposeAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Reset func(hard bool) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetFormat func(state *VideoCodecState) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkQuery func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcQuery func(query *gst.Query) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function takes the following parameters:
	//
	//    - frame
	//    - meta
	//
	// The function returns the following values:
	//
	TransformMeta func(frame *VideoCodecFrame, meta *gst.Meta) bool
}

func defaultVideoDecoderOverrides(v *VideoDecoder) VideoDecoderOverrides {
	return VideoDecoderOverrides{
		Close:             v.close,
		DecideAllocation:  v.decideAllocation,
		Drain:             v.drain,
		Finish:            v.finish,
		Flush:             v.flush,
		caps:              v.caps,
		HandleFrame:       v.handleFrame,
		HandleMissingData: v.handleMissingData,
		Negotiate:         v.negotiate,
		Open:              v.open,
		Parse:             v.parse,
		ProposeAllocation: v.proposeAllocation,
		Reset:             v.reset,
		SetFormat:         v.setFormat,
		SinkEvent:         v.sinkEvent,
		SinkQuery:         v.sinkQuery,
		SrcEvent:          v.srcEvent,
		SrcQuery:          v.srcQuery,
		Start:             v.start,
		Stop:              v.stop,
		TransformMeta:     v.transformMeta,
	}
}

// VideoDecoder: this base class is for video decoders turning encoded data into
// raw video frames.
//
// The GstVideoDecoder base class and derived subclasses should cooperate as
// follows:
//
// Configuration
//
//    * Initially, GstVideoDecoder calls start when the decoder element
//      is activated, which allows the subclass to perform any global setup.
//
//    * GstVideoDecoder calls set_format to inform the subclass of caps
//      describing input video data that it is about to receive, including
//      possibly configuration data.
//      While unlikely, it might be called more than once, if changing input
//      parameters require reconfiguration.
//
//    * Incoming data buffers are processed as needed, described in Data
//      Processing below.
//
//    * GstVideoDecoder calls stop at end of all processing.
//
// Data processing
//
//    * The base class gathers input data, and optionally allows subclass
//      to parse this into subsequently manageable chunks, typically
//      corresponding to and referred to as 'frames'.
//
//    * Each input frame is provided in turn to the subclass' handle_frame
//      callback.
//    * When the subclass enables the subframe mode with gst_video_decoder_set_subframe_mode,
//      the base class will provide to the subclass the same input frame with
//      different input buffers to the subclass handle_frame
//      callback. During this call, the subclass needs to take
//      ownership of the input_buffer as GstVideoCodecFrame.input_buffer
//      will have been changed before the next subframe buffer is received.
//      The subclass will call gst_video_decoder_have_last_subframe
//      when a new input frame can be created by the base class.
//      Every subframe will share the same GstVideoCodecFrame.output_buffer
//      to write the decoding result. The subclass is responsible to protect
//      its access.
//
//    * If codec processing results in decoded data, the subclass should call
//      gst_video_decoder_finish_frame to have decoded data pushed
//      downstream. In subframe mode
//      the subclass should call gst_video_decoder_finish_subframe until the
//      last subframe where it should call gst_video_decoder_finish_frame.
//      The subclass can detect the last subframe using GST_VIDEO_BUFFER_FLAG_MARKER
//      on buffers or using its own logic to collect the subframes.
//      In case of decoding failure, the subclass must call
//      gst_video_decoder_drop_frame or gst_video_decoder_drop_subframe,
//      to allow the base class to do timestamp and offset tracking, and possibly
//      to requeue the frame for a later attempt in the case of reverse playback.
//
// Shutdown phase
//
//    * The GstVideoDecoder class calls stop to inform the subclass that data
//      parsing will be stopped.
//
// Additional Notes
//
//    * Seeking/Flushing
//
//      * When the pipeline is seeked or otherwise flushed, the subclass is
//        informed via a call to its reset callback, with the hard parameter
//        set to true. This indicates the subclass should drop any internal data
//        queues and timestamps and prepare for a fresh set of buffers to arrive
//        for parsing and decoding.
//
//    * End Of Stream
//
//      * At end-of-stream, the subclass parse function may be called some final
//        times with the at_eos parameter set to true, indicating that the element
//        should not expect any more data to be arriving, and it should parse and
//        remaining frames and call gst_video_decoder_have_frame() if possible.
//
// The subclass is responsible for providing pad template caps for source and
// sink pads. The pads need to be named "sink" and "src". It also needs to
// provide information about the output caps, when they are known. This may be
// when the base class calls the subclass' set_format function, though it might
// be during decoding, before calling gst_video_decoder_finish_frame. This is
// done via gst_video_decoder_set_output_state
//
// The subclass is also responsible for providing (presentation) timestamps
// (likely based on corresponding input ones). If that is not applicable or
// possible, the base class provides limited framerate based interpolation.
//
// Similarly, the base class provides some limited (legacy) seeking support if
// specifically requested by the subclass, as full-fledged support should rather
// be left to upstream demuxer, parser or alike. This simple approach caters for
// seeking and duration reporting using estimated input bitrates. To enable it,
// a subclass should call gst_video_decoder_set_estimate_rate to enable handling
// of incoming byte-streams.
//
// The base class provides some support for reverse playback, in particular in
// case incoming data is not packetized or upstream does not provide fragments
// on keyframe boundaries. However, the subclass should then be prepared for the
// parsing and frame processing stage to occur separately (in normal forward
// processing, the latter immediately follows the former), The subclass also
// needs to ensure the parsing stage properly marks keyframes, unless it knows
// the upstream elements will do so properly for incoming data.
//
// The bare minimum that a functional subclass needs to implement is:
//
//    * Provide pad templates
//    * Inform the base class of output caps via
//       gst_video_decoder_set_output_state
//
//    * Parse input data, if it is not considered packetized from upstream
//       Data will be provided to parse which should invoke
//       gst_video_decoder_add_to_frame and gst_video_decoder_have_frame to
//       separate the data belonging to each video frame.
//
//    * Accept data in handle_frame and provide decoded results to
//       gst_video_decoder_finish_frame, or call gst_video_decoder_drop_frame.
type VideoDecoder struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*VideoDecoder)(nil)
)

// VideoDecoderer describes types inherited from class VideoDecoder.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type VideoDecoderer interface {
	coreglib.Objector
	baseVideoDecoder() *VideoDecoder
}

var _ VideoDecoderer = (*VideoDecoder)(nil)

func init() {
	coreglib.RegisterClassInfo[*VideoDecoder, *VideoDecoderClass, VideoDecoderOverrides](
		GTypeVideoDecoder,
		initVideoDecoderClass,
		wrapVideoDecoder,
		defaultVideoDecoderOverrides,
	)
}

func initVideoDecoderClass(gclass unsafe.Pointer, overrides VideoDecoderOverrides, classInitFunc func(*VideoDecoderClass)) {
	pclass := (*C.GstVideoDecoderClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVideoDecoder))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_close)
	}

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_decide_allocation)
	}

	if overrides.Drain != nil {
		pclass.drain = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_drain)
	}

	if overrides.Finish != nil {
		pclass.finish = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_finish)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_flush)
	}

	if overrides.caps != nil {
		pclass.getcaps = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_getcaps)
	}

	if overrides.HandleFrame != nil {
		pclass.handle_frame = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_handle_frame)
	}

	if overrides.HandleMissingData != nil {
		pclass.handle_missing_data = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_handle_missing_data)
	}

	if overrides.Negotiate != nil {
		pclass.negotiate = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_negotiate)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_open)
	}

	if overrides.Parse != nil {
		pclass.parse = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_parse)
	}

	if overrides.ProposeAllocation != nil {
		pclass.propose_allocation = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_propose_allocation)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_reset)
	}

	if overrides.SetFormat != nil {
		pclass.set_format = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_set_format)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_sink_event)
	}

	if overrides.SinkQuery != nil {
		pclass.sink_query = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_sink_query)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_src_event)
	}

	if overrides.SrcQuery != nil {
		pclass.src_query = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_src_query)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_stop)
	}

	if overrides.TransformMeta != nil {
		pclass.transform_meta = (*[0]byte)(C._gotk4_gstvideo1_VideoDecoderClass_transform_meta)
	}

	if classInitFunc != nil {
		class := (*VideoDecoderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideoDecoder(obj *coreglib.Object) *VideoDecoder {
	return &VideoDecoder{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalVideoDecoder(p uintptr) (interface{}, error) {
	return wrapVideoDecoder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (decoder *VideoDecoder) baseVideoDecoder() *VideoDecoder {
	return decoder
}

// BaseVideoDecoder returns the underlying base object.
func BaseVideoDecoder(obj VideoDecoderer) *VideoDecoder {
	return obj.baseVideoDecoder()
}

// AddToFrame removes next n_bytes of input data and adds it to currently parsed
// frame.
//
// The function takes the following parameters:
//
//    - nBytes: number of bytes to add.
//
func (decoder *VideoDecoder) AddToFrame(nBytes int) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.int              // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = C.int(nBytes)

	C.gst_video_decoder_add_to_frame(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(nBytes)
}

// AllocateOutputBuffer: helper function that allocates a buffer to hold a video
// frame for decoder's current VideoCodecState.
//
// You should use gst_video_decoder_allocate_output_frame() instead of this
// function, if possible at all.
//
// The function returns the following values:
//
//    - buffer: allocated buffer, or NULL if no buffer could be allocated (e.g.
//      when downstream is flushing or shutting down).
//
func (decoder *VideoDecoder) AllocateOutputBuffer() *gst.Buffer {
	var _arg0 *C.GstVideoDecoder // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_allocate_output_buffer(_arg0)
	runtime.KeepAlive(decoder)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// AllocateOutputFrame: helper function that allocates a buffer to hold a video
// frame for decoder's current VideoCodecState. Subclass should already have
// configured video state and set src pad caps.
//
// The buffer allocated here is owned by the frame and you should only keep
// references to the frame, not the buffer.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//
// The function returns the following values:
//
//    - flowReturn: GST_FLOW_OK if an output buffer could be allocated.
//
func (decoder *VideoDecoder) AllocateOutputFrame(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_allocate_output_frame(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// AllocateOutputFrameWithParams: same as
// #gst_video_decoder_allocate_output_frame except it allows passing
// BufferPoolAcquireParams to the sub call gst_buffer_pool_acquire_buffer.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//    - params: BufferPoolAcquireParams.
//
// The function returns the following values:
//
//    - flowReturn: GST_FLOW_OK if an output buffer could be allocated.
//
func (decoder *VideoDecoder) AllocateOutputFrameWithParams(frame *VideoCodecFrame, params *gst.BufferPoolAcquireParams) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder            // out
	var _arg1 *C.GstVideoCodecFrame         // out
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))

	_cret = C.gst_video_decoder_allocate_output_frame_with_params(_arg0, _arg1, _arg2)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(params)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// DropFrame: similar to gst_video_decoder_finish_frame(), but drops frame in
// any case and posts a QoS message with the frame's details on the bus. In any
// case, the frame is considered finished and released.
//
// The function takes the following parameters:
//
//    - frame to drop.
//
// The function returns the following values:
//
//    - flowReturn usually GST_FLOW_OK.
//
func (dec *VideoDecoder) DropFrame(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_drop_frame(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// DropSubframe drops input data. The frame is not considered finished until the
// whole frame is finished or dropped by the subclass.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//
// The function returns the following values:
//
//    - flowReturn usually GST_FLOW_OK.
//
func (dec *VideoDecoder) DropSubframe(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_drop_subframe(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// FinishFrame: frame should have a valid decoded data buffer, whose metadata
// fields are then appropriately set according to frame data and pushed
// downstream. If no output data is provided, frame is considered skipped. In
// any case, the frame is considered finished and released.
//
// After calling this function the output buffer of the frame is to be
// considered read-only. This function will also change the metadata of the
// buffer.
//
// The function takes the following parameters:
//
//    - frame: decoded VideoCodecFrame.
//
// The function returns the following values:
//
//    - flowReturn resulting from sending data downstream.
//
func (decoder *VideoDecoder) FinishFrame(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_finish_frame(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// FinishSubframe: indicate that a subframe has been finished to be decoded by
// the subclass. This method should be called for all subframes except the last
// subframe where gst_video_decoder_finish_frame should be called instead.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//
// The function returns the following values:
//
//    - flowReturn usually GST_FLOW_OK.
//
func (decoder *VideoDecoder) FinishSubframe(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_finish_subframe(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Allocator lets VideoDecoder sub-classes to know the memory allocator used by
// the base class and its params.
//
// Unref the allocator after use it.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) the AllocationParams of allocator.
//
func (decoder *VideoDecoder) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	C.gst_video_decoder_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(decoder)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_params)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocator, _params
}

// The function returns the following values:
//
//    - bufferPool: instance of the BufferPool used by the decoder; free it after
//      use it.
//
func (decoder *VideoDecoder) BufferPool() *gst.BufferPool {
	var _arg0 *C.GstVideoDecoder // out
	var _cret *C.GstBufferPool   // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_buffer_pool(_arg0)
	runtime.KeepAlive(decoder)

	var _bufferPool *gst.BufferPool // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_bufferPool = &gst.BufferPool{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _bufferPool
}

// The function returns the following values:
//
//    - gint: currently configured byte to time conversion setting.
//
func (dec *VideoDecoder) EstimateRate() int {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_video_decoder_get_estimate_rate(_arg0)
	runtime.KeepAlive(dec)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Frame: get a pending unfinished VideoCodecFrame.
//
// The function takes the following parameters:
//
//    - frameNumber: system_frame_number of a frame.
//
// The function returns the following values:
//
//    - videoCodecFrame: pending unfinished VideoCodecFrame identified by
//      frame_number.
//
func (decoder *VideoDecoder) Frame(frameNumber int) *VideoCodecFrame {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 C.int                 // out
	var _cret *C.GstVideoCodecFrame // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = C.int(frameNumber)

	_cret = C.gst_video_decoder_get_frame(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frameNumber)

	var _videoCodecFrame *VideoCodecFrame // out

	_videoCodecFrame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecFrame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	return _videoCodecFrame
}

// Frames: get all pending unfinished VideoCodecFrame.
//
// The function returns the following values:
//
//    - list: pending unfinished VideoCodecFrame.
//
func (decoder *VideoDecoder) Frames() []*VideoCodecFrame {
	var _arg0 *C.GstVideoDecoder // out
	var _cret *C.GList           // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_frames(_arg0)
	runtime.KeepAlive(decoder)

	var _list []*VideoCodecFrame // out

	_list = make([]*VideoCodecFrame, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstVideoCodecFrame)(v)
		var dst *VideoCodecFrame // out
		dst = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// InputSubframeIndex queries the number of the last subframe received by the
// decoder baseclass in the frame.
//
// The function takes the following parameters:
//
//    - frame to update.
//
// The function returns the following values:
//
//    - guint: current subframe index received in subframe mode, 1 otherwise.
//
func (decoder *VideoDecoder) InputSubframeIndex(frame *VideoCodecFrame) uint {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.guint               // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_get_input_subframe_index(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Latency: query the configured decoder latency. Results will be returned via
// min_latency and max_latency.
//
// The function returns the following values:
//
//    - minLatency (optional) address of variable in which to store the
//      configured minimum latency, or NULL.
//    - maxLatency (optional) address of variable in which to store the
//      configured mximum latency, or NULL.
//
func (decoder *VideoDecoder) Latency() (minLatency, maxLatency gst.ClockTime) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.GstClockTime     // in
	var _arg2 C.GstClockTime     // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	C.gst_video_decoder_get_latency(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(decoder)

	var _minLatency gst.ClockTime // out
	var _maxLatency gst.ClockTime // out

	_minLatency = uint64(_arg1)
	type _ = gst.ClockTime
	type _ = uint64
	_maxLatency = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64

	return _minLatency, _maxLatency
}

// MaxDecodeTime determines maximum possible decoding time for frame that will
// allow it to decode and arrive in time (as determined by QoS events). In
// particular, a negative result means decoding in time is no longer possible
// and should therefore occur as soon/skippy as possible.
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//
// The function returns the following values:
//
//    - clockTimeDiff: max decoding time.
//
func (decoder *VideoDecoder) MaxDecodeTime(frame *VideoCodecFrame) gst.ClockTimeDiff {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstClockTimeDiff    // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_get_max_decode_time(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _clockTimeDiff gst.ClockTimeDiff // out

	_clockTimeDiff = int64(_cret)
	type _ = gst.ClockTimeDiff
	type _ = int64

	return _clockTimeDiff
}

// The function returns the following values:
//
//    - gint: currently configured decoder tolerated error count.
//
func (dec *VideoDecoder) MaxErrors() int {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_video_decoder_get_max_errors(_arg0)
	runtime.KeepAlive(dec)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NeedsFormat queries decoder required format handling.
//
// The function returns the following values:
//
//    - ok: TRUE if required format handling is enabled.
//
func (dec *VideoDecoder) NeedsFormat() bool {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_video_decoder_get_needs_format(_arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NeedsSyncPoint queries if the decoder requires a sync point before it starts
// outputting data in the beginning.
//
// The function returns the following values:
//
//    - ok: TRUE if a sync point is required in the beginning.
//
func (dec *VideoDecoder) NeedsSyncPoint() bool {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_video_decoder_get_needs_sync_point(_arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OldestFrame: get the oldest pending unfinished VideoCodecFrame.
//
// The function returns the following values:
//
//    - videoCodecFrame: oldest pending unfinished VideoCodecFrame.
//
func (decoder *VideoDecoder) OldestFrame() *VideoCodecFrame {
	var _arg0 *C.GstVideoDecoder    // out
	var _cret *C.GstVideoCodecFrame // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_oldest_frame(_arg0)
	runtime.KeepAlive(decoder)

	var _videoCodecFrame *VideoCodecFrame // out

	_videoCodecFrame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecFrame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	return _videoCodecFrame
}

// OutputState: get the VideoCodecState currently describing the output stream.
//
// The function returns the following values:
//
//    - videoCodecState describing format of video data.
//
func (decoder *VideoDecoder) OutputState() *VideoCodecState {
	var _arg0 *C.GstVideoDecoder    // out
	var _cret *C.GstVideoCodecState // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_output_state(_arg0)
	runtime.KeepAlive(decoder)

	var _videoCodecState *VideoCodecState // out

	_videoCodecState = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecState)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	return _videoCodecState
}

// Packetized queries whether input data is considered packetized or not by the
// base class.
//
// The function returns the following values:
//
//    - ok: TRUE if input data is considered packetized.
//
func (decoder *VideoDecoder) Packetized() bool {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_packetized(_arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PendingFrameSize returns the number of bytes previously added to the current
// frame by calling gst_video_decoder_add_to_frame().
//
// The function returns the following values:
//
//    - gsize: number of bytes pending for the current frame.
//
func (decoder *VideoDecoder) PendingFrameSize() uint {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gsize            // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_pending_frame_size(_arg0)
	runtime.KeepAlive(decoder)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// ProcessedSubframeIndex queries the number of subframes in the frame processed
// by the decoder baseclass.
//
// The function takes the following parameters:
//
//    - frame to update.
//
// The function returns the following values:
//
//    - guint: current subframe processed received in subframe mode.
//
func (decoder *VideoDecoder) ProcessedSubframeIndex(frame *VideoCodecFrame) uint {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.guint               // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_get_processed_subframe_index(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//    - gdouble: current QoS proportion.
//
func (decoder *VideoDecoder) QosProportion() float64 {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gdouble          // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_qos_proportion(_arg0)
	runtime.KeepAlive(decoder)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SubframeMode queries whether input data is considered as subframes or not by
// the base class. If FALSE, each input buffer will be considered as a full
// frame.
//
// The function returns the following values:
//
//    - ok: TRUE if input data is considered as sub frames.
//
func (decoder *VideoDecoder) SubframeMode() bool {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_get_subframe_mode(_arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HaveFrame gathers all data collected for currently parsed frame, gathers
// corresponding metadata and passes it along for further processing, i.e.
// handle_frame.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (decoder *VideoDecoder) HaveFrame() gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_have_frame(_arg0)
	runtime.KeepAlive(decoder)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// HaveLastSubframe indicates that the last subframe has been processed by the
// decoder in frame. This will release the current frame in video decoder
// allowing to receive new frames from upstream elements. This method must be
// called in the subclass handle_frame callback.
//
// The function takes the following parameters:
//
//    - frame to update.
//
// The function returns the following values:
//
//    - flowReturn usually GST_FLOW_OK.
//
func (decoder *VideoDecoder) HaveLastSubframe(frame *VideoCodecFrame) gst.FlowReturn {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C.gst_video_decoder_have_last_subframe(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Negotiate with downstream elements to currently configured VideoCodecState.
// Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
// negotiate fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (decoder *VideoDecoder) Negotiate() bool {
	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C.gst_video_decoder_negotiate(_arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyGetcaps returns caps that express caps (or sink template caps if caps ==
// NULL) restricted to resolution/format/... combinations supported by
// downstream elements.
//
// The function takes the following parameters:
//
//    - caps (optional): initial caps.
//    - filter (optional) caps.
//
// The function returns the following values:
//
//    - ret owned by caller.
//
func (decoder *VideoDecoder) ProxyGetcaps(caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstCaps         // out
	var _arg2 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	if filter != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_video_decoder_proxy_getcaps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// ReleaseFrame: similar to gst_video_decoder_drop_frame(), but simply releases
// frame without any processing other than removing it from list of pending
// frames, after which it is considered finished and released.
//
// The function takes the following parameters:
//
//    - frame to release.
//
func (dec *VideoDecoder) ReleaseFrame(frame *VideoCodecFrame) {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	C.gst_video_decoder_release_frame(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(frame)
}

// RequestSyncPoint allows the VideoDecoder subclass to request from the base
// class that a new sync should be requested from upstream, and that frame was
// the frame when the subclass noticed that a new sync point is required. A
// reason for the subclass to do this could be missing reference frames, for
// example.
//
// The base class will then request a new sync point from upstream as long as
// the time that passed since the last one is exceeding
// VideoDecoder:min-force-key-unit-interval.
//
// The subclass can signal via flags how the frames until the next sync point
// should be handled:
//
//    * If GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT is selected then
//      all following input frames until the next sync point are discarded.
//      This can be useful if the lack of a sync point will prevent all further
//      decoding and the decoder implementation is not very robust in handling
//      missing references frames.
//    * If GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT is selected
//      then all output frames following frame are marked as corrupted via
//      GST_BUFFER_FLAG_CORRUPTED. Corrupted frames can be automatically
//      dropped by the base class, see VideoDecoder:discard-corrupted-frames.
//      Subclasses can manually mark frames as corrupted via GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED
//      before calling gst_video_decoder_finish_frame().
//
// The function takes the following parameters:
//
//    - frame: VideoCodecFrame.
//    - flags: VideoDecoderRequestSyncPointFlags.
//
func (dec *VideoDecoder) RequestSyncPoint(frame *VideoCodecFrame, flags VideoDecoderRequestSyncPointFlags) {
	var _arg0 *C.GstVideoDecoder                     // out
	var _arg1 *C.GstVideoCodecFrame                  // out
	var _arg2 C.GstVideoDecoderRequestSyncPointFlags // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = C.GstVideoDecoderRequestSyncPointFlags(flags)

	C.gst_video_decoder_request_sync_point(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(flags)
}

// SetEstimateRate allows baseclass to perform byte to time estimated
// conversion.
//
// The function takes the following parameters:
//
//    - enabled: whether to enable byte to time conversion.
//
func (dec *VideoDecoder) SetEstimateRate(enabled bool) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_video_decoder_set_estimate_rate(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetInterlacedOutputState: same as #gst_video_decoder_set_output_state() but
// also allows you to also set the interlacing mode.
//
// The function takes the following parameters:
//
//    - fmt: VideoFormat.
//    - interlaceMode: VideoInterlaceMode.
//    - width in pixels.
//    - height in pixels.
//    - reference (optional): optional reference VideoCodecState.
//
// The function returns the following values:
//
//    - videoCodecState: newly configured output state.
//
func (decoder *VideoDecoder) SetInterlacedOutputState(fmt VideoFormat, interlaceMode VideoInterlaceMode, width, height uint, reference *VideoCodecState) *VideoCodecState {
	var _arg0 *C.GstVideoDecoder      // out
	var _arg1 C.GstVideoFormat        // out
	var _arg2 C.GstVideoInterlaceMode // out
	var _arg3 C.guint                 // out
	var _arg4 C.guint                 // out
	var _arg5 *C.GstVideoCodecState   // out
	var _cret *C.GstVideoCodecState   // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = C.GstVideoFormat(fmt)
	_arg2 = C.GstVideoInterlaceMode(interlaceMode)
	_arg3 = C.guint(width)
	_arg4 = C.guint(height)
	if reference != nil {
		_arg5 = (*C.GstVideoCodecState)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gst_video_decoder_set_interlaced_output_state(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(interlaceMode)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(reference)

	var _videoCodecState *VideoCodecState // out

	_videoCodecState = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecState)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	return _videoCodecState
}

// SetLatency lets VideoDecoder sub-classes tell the baseclass what the decoder
// latency is. Will also post a LATENCY message on the bus so the pipeline can
// reconfigure its global latency.
//
// The function takes the following parameters:
//
//    - minLatency: minimum latency.
//    - maxLatency: maximum latency.
//
func (decoder *VideoDecoder) SetLatency(minLatency, maxLatency gst.ClockTime) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTime     // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = C.guint64(minLatency)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(maxLatency)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_video_decoder_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(minLatency)
	runtime.KeepAlive(maxLatency)
}

// SetMaxErrors sets numbers of tolerated decoder errors, where a tolerated one
// is then only warned about, but more than tolerated will lead to fatal error.
// You can set -1 for never returning fatal errors. Default is set to
// GST_VIDEO_DECODER_MAX_ERRORS.
//
// The '-1' option was added in 1.4.
//
// The function takes the following parameters:
//
//    - num: max tolerated errors.
//
func (dec *VideoDecoder) SetMaxErrors(num int) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = C.gint(num)

	C.gst_video_decoder_set_max_errors(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(num)
}

// SetNeedsFormat configures decoder format needs. If enabled, subclass needs to
// be negotiated with format caps before it can process any data. It will then
// never be handed any data before it has been configured. Otherwise, it might
// be handed data without having been configured and is then expected being able
// to do so either by default or based on the input data.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (dec *VideoDecoder) SetNeedsFormat(enabled bool) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_video_decoder_set_needs_format(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetNeedsSyncPoint configures whether the decoder requires a sync point before
// it starts outputting data in the beginning. If enabled, the base class will
// discard all non-sync point frames in the beginning and after a flush and does
// not pass it to the subclass.
//
// If the first frame is not a sync point, the base class will request a sync
// point via the force-key-unit event.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (dec *VideoDecoder) SetNeedsSyncPoint(enabled bool) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_video_decoder_set_needs_sync_point(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetOutputState creates a new VideoCodecState with the specified fmt, width
// and height as the output state for the decoder. Any previously set output
// state on decoder will be replaced by the newly created one.
//
// If the subclass wishes to copy over existing fields (like pixel aspec ratio,
// or framerate) from an existing VideoCodecState, it can be provided as a
// reference.
//
// If the subclass wishes to override some fields from the output state (like
// pixel-aspect-ratio or framerate) it can do so on the returned
// VideoCodecState.
//
// The new output state will only take effect (set on pads and buffers) starting
// from the next call to #gst_video_decoder_finish_frame().
//
// The function takes the following parameters:
//
//    - fmt: VideoFormat.
//    - width in pixels.
//    - height in pixels.
//    - reference (optional): optional reference VideoCodecState.
//
// The function returns the following values:
//
//    - videoCodecState: newly configured output state.
//
func (decoder *VideoDecoder) SetOutputState(fmt VideoFormat, width, height uint, reference *VideoCodecState) *VideoCodecState {
	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 C.GstVideoFormat      // out
	var _arg2 C.guint               // out
	var _arg3 C.guint               // out
	var _arg4 *C.GstVideoCodecState // out
	var _cret *C.GstVideoCodecState // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = C.GstVideoFormat(fmt)
	_arg2 = C.guint(width)
	_arg3 = C.guint(height)
	if reference != nil {
		_arg4 = (*C.GstVideoCodecState)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gst_video_decoder_set_output_state(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(reference)

	var _videoCodecState *VideoCodecState // out

	_videoCodecState = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_videoCodecState)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	return _videoCodecState
}

// SetPacketized allows baseclass to consider input data as packetized or not.
// If the input is packetized, then the parse method will not be called.
//
// The function takes the following parameters:
//
//    - packetized: whether the input data should be considered as packetized.
//
func (decoder *VideoDecoder) SetPacketized(packetized bool) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if packetized {
		_arg1 = C.TRUE
	}

	C.gst_video_decoder_set_packetized(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(packetized)
}

// SetSubframeMode: if this is set to TRUE, it informs the base class that the
// subclass can receive the data at a granularity lower than one frame.
//
// Note that in this mode, the subclass has two options. It can either require
// the presence of a GST_VIDEO_BUFFER_FLAG_MARKER to mark the end of a frame. Or
// it can operate in such a way that it will decode a single frame at a time. In
// this second case, every buffer that arrives to the element is considered part
// of the same frame until gst_video_decoder_finish_frame() is called.
//
// In either case, the same VideoCodecFrame will be passed to the
// GstVideoDecoderClass:handle_frame vmethod repeatedly with a different
// GstVideoCodecFrame:input_buffer every time until the end of the frame has
// been signaled using either method. This method must be called during the
// decoder subclass set_format call.
//
// The function takes the following parameters:
//
//    - subframeMode: whether the input data should be considered as subframes.
//
func (decoder *VideoDecoder) SetSubframeMode(subframeMode bool) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if subframeMode {
		_arg1 = C.TRUE
	}

	C.gst_video_decoder_set_subframe_mode(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(subframeMode)
}

// SetUseDefaultPadAcceptcaps lets VideoDecoder sub-classes decide if they want
// the sink pad to use the default pad query handler to reply to accept-caps
// queries.
//
// By setting this to true it is possible to further customize the default
// handler with GST_PAD_SET_ACCEPT_INTERSECT and GST_PAD_SET_ACCEPT_TEMPLATE.
//
// The function takes the following parameters:
//
//    - use: if the default pad accept-caps query handling should be used.
//
func (decoder *VideoDecoder) SetUseDefaultPadAcceptcaps(use bool) {
	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if use {
		_arg1 = C.TRUE
	}

	C.gst_video_decoder_set_use_default_pad_acceptcaps(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(use)
}

// The function returns the following values:
//
func (decoder *VideoDecoder) close() bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.close

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (decoder *VideoDecoder) drain() gst.FlowReturn {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.drain

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_drain(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function returns the following values:
//
func (decoder *VideoDecoder) finish() gst.FlowReturn {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.finish

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_finish(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function returns the following values:
//
func (decoder *VideoDecoder) flush() bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.flush

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_flush(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) caps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.getcaps

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_getcaps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function takes the following parameters:
//
//    - frame to handle.
//
// The function returns the following values:
//
func (decoder *VideoDecoder) handleFrame(frame *VideoCodecFrame) gst.FlowReturn {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.handle_frame

	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_handle_frame(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
//    - timestamp: timestamp of the missing data.
//    - duration: duration of the missing data.
//
// The function returns the following values:
//
//    - ok: TRUE if the decoder should be drained afterwards.
//
func (decoder *VideoDecoder) handleMissingData(timestamp, duration gst.ClockTime) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.handle_missing_data

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTime     // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = C.guint64(timestamp)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(duration)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_handle_missing_data(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Negotiate: negotiate with downstream elements to currently configured
// VideoCodecState. Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark
// it again if negotiate fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (decoder *VideoDecoder) negotiate() bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.negotiate

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_negotiate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (decoder *VideoDecoder) open() bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.open

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - frame
//    - adapter
//    - atEos
//
// The function returns the following values:
//
func (decoder *VideoDecoder) parse(frame *VideoCodecFrame, adapter *gstbase.Adapter, atEos bool) gst.FlowReturn {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.parse

	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _arg2 *C.GstAdapter         // out
	var _arg3 C.gboolean            // out
	var _cret C.GstFlowReturn       // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	if atEos {
		_arg3 = C.TRUE
	}

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_parse(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(atEos)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) proposeAllocation(query *gst.Query) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.propose_allocation

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_propose_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) reset(hard bool) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.reset

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 C.gboolean         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if hard {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_reset(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(hard)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) setFormat(state *VideoCodecState) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.set_format

	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecState // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecState)(gextras.StructNative(unsafe.Pointer(state)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_set_format(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.sink_event

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) sinkQuery(query *gst.Query) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.sink_query

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_sink_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.src_event

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (decoder *VideoDecoder) srcQuery(query *gst.Query) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.src_query

	var _arg0 *C.GstVideoDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_src_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (decoder *VideoDecoder) start() bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.start

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (decoder *VideoDecoder) stop() bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.stop

	var _arg0 *C.GstVideoDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(decoder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - frame
//    - meta
//
// The function returns the following values:
//
func (decoder *VideoDecoder) transformMeta(frame *VideoCodecFrame, meta *gst.Meta) bool {
	gclass := (*C.GstVideoDecoderClass)(coreglib.PeekParentClass(decoder))
	fnarg := gclass.transform_meta

	var _arg0 *C.GstVideoDecoder    // out
	var _arg1 *C.GstVideoCodecFrame // out
	var _arg2 *C.GstMeta            // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstVideoDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	_arg1 = (*C.GstVideoCodecFrame)(gextras.StructNative(unsafe.Pointer(frame)))
	_arg2 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C._gotk4_gstvideo1_VideoDecoder_virtual_transform_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(meta)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VideoDecoderClass subclasses can override any of the available virtual
// methods or not, as needed. At minimum handle_frame needs to be overridden,
// and set_format and likely as well. If non-packetized input is supported or
// expected, parse needs to be overridden as well.
//
// An instance of this type is always passed by reference.
type VideoDecoderClass struct {
	*videoDecoderClass
}

// videoDecoderClass is the struct that's finalized.
type videoDecoderClass struct {
	native *C.GstVideoDecoderClass
}
