// Code generated by girgen. DO NOT EDIT.

package gstpbutils

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/pbutils/pbutils.h>
import "C"

// GType values.
var (
	GTypeEncodingAudioProfile     = coreglib.Type(C.gst_encoding_audio_profile_get_type())
	GTypeEncodingContainerProfile = coreglib.Type(C.gst_encoding_container_profile_get_type())
	GTypeEncodingProfile          = coreglib.Type(C.gst_encoding_profile_get_type())
	GTypeEncodingVideoProfile     = coreglib.Type(C.gst_encoding_video_profile_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeEncodingAudioProfile, F: marshalEncodingAudioProfile},
		coreglib.TypeMarshaler{T: GTypeEncodingContainerProfile, F: marshalEncodingContainerProfile},
		coreglib.TypeMarshaler{T: GTypeEncodingProfile, F: marshalEncodingProfile},
		coreglib.TypeMarshaler{T: GTypeEncodingVideoProfile, F: marshalEncodingVideoProfile},
	})
}

// EncodingAudioProfile: variant of EncodingProfile for audio streams.
type EncodingAudioProfile struct {
	_ [0]func() // equal guard
	EncodingProfile
}

var (
	_ coreglib.Objector = (*EncodingAudioProfile)(nil)
)

func wrapEncodingAudioProfile(obj *coreglib.Object) *EncodingAudioProfile {
	return &EncodingAudioProfile{
		EncodingProfile: EncodingProfile{
			Object: obj,
		},
	}
}

func marshalEncodingAudioProfile(p uintptr) (interface{}, error) {
	return wrapEncodingAudioProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingAudioProfile creates a new EncodingAudioProfile
//
// All provided allocatable arguments will be internally copied, so can be
// safely freed/unreferenced after calling this method.
//
// The function takes the following parameters:
//
//    - format: Caps.
//    - preset (optional): preset(s) to use on the encoder, can be NULL.
//    - restriction (optional) used to restrict the input to the encoder, can be
//      NULL. See gst_encoding_profile_get_restriction() for more details.
//    - presence: number of time this stream must be used. 0 means any number of
//      times (including never).
//
// The function returns the following values:
//
//    - encodingAudioProfile: newly created EncodingAudioProfile.
//
func NewEncodingAudioProfile(format *gst.Caps, preset string, restriction *gst.Caps, presence uint) *EncodingAudioProfile {
	var _arg1 *C.GstCaps                 // out
	var _arg2 *C.gchar                   // out
	var _arg3 *C.GstCaps                 // out
	var _arg4 C.guint                    // out
	var _cret *C.GstEncodingAudioProfile // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))
	if preset != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if restriction != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(restriction)))
	}
	_arg4 = C.guint(presence)

	_cret = C.gst_encoding_audio_profile_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(format)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(restriction)
	runtime.KeepAlive(presence)

	var _encodingAudioProfile *EncodingAudioProfile // out

	_encodingAudioProfile = wrapEncodingAudioProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingAudioProfile
}

// EncodingContainerProfile: encoding profiles for containers. Keeps track of a
// list of EncodingProfile.
type EncodingContainerProfile struct {
	_ [0]func() // equal guard
	EncodingProfile
}

var (
	_ coreglib.Objector = (*EncodingContainerProfile)(nil)
)

func wrapEncodingContainerProfile(obj *coreglib.Object) *EncodingContainerProfile {
	return &EncodingContainerProfile{
		EncodingProfile: EncodingProfile{
			Object: obj,
		},
	}
}

func marshalEncodingContainerProfile(p uintptr) (interface{}, error) {
	return wrapEncodingContainerProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingContainerProfile creates a new EncodingContainerProfile.
//
// The function takes the following parameters:
//
//    - name (optional) of the container profile, can be NULL.
//    - description (optional) of the container profile, can be NULL.
//    - format to use for this profile.
//    - preset (optional) to use for this profile.
//
// The function returns the following values:
//
//    - encodingContainerProfile: newly created EncodingContainerProfile.
//
func NewEncodingContainerProfile(name, description string, format *gst.Caps, preset string) *EncodingContainerProfile {
	var _arg1 *C.gchar                       // out
	var _arg2 *C.gchar                       // out
	var _arg3 *C.GstCaps                     // out
	var _arg4 *C.gchar                       // out
	var _cret *C.GstEncodingContainerProfile // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if description != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))
	if preset != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	_cret = C.gst_encoding_container_profile_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(description)
	runtime.KeepAlive(format)
	runtime.KeepAlive(preset)

	var _encodingContainerProfile *EncodingContainerProfile // out

	_encodingContainerProfile = wrapEncodingContainerProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingContainerProfile
}

// AddProfile: add a EncodingProfile to the list of profiles handled by
// container.
//
// No copy of profile will be made, if you wish to use it elsewhere after this
// method you should increment its reference count.
//
// The function takes the following parameters:
//
//    - profile to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the stream was properly added, else FALSE.
//
func (container *EncodingContainerProfile) AddProfile(profile *EncodingProfile) bool {
	var _arg0 *C.GstEncodingContainerProfile // out
	var _arg1 *C.GstEncodingProfile          // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.GstEncodingContainerProfile)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_container_profile_add_profile(_arg0, _arg1)
	runtime.KeepAlive(container)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsProfile checks if container contains a EncodingProfile identical to
// profile.
//
// The function takes the following parameters:
//
//    - profile: EncodingProfile.
//
// The function returns the following values:
//
//    - ok: TRUE if container contains a EncodingProfile identical to profile,
//      else FALSE.
//
func (container *EncodingContainerProfile) ContainsProfile(profile *EncodingProfile) bool {
	var _arg0 *C.GstEncodingContainerProfile // out
	var _arg1 *C.GstEncodingProfile          // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.GstEncodingContainerProfile)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_container_profile_contains_profile(_arg0, _arg1)
	runtime.KeepAlive(container)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - list: the list of contained EncodingProfile.
//
func (profile *EncodingContainerProfile) Profiles() []*EncodingProfile {
	var _arg0 *C.GstEncodingContainerProfile // out
	var _cret *C.GList                       // in

	_arg0 = (*C.GstEncodingContainerProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_container_profile_get_profiles(_arg0)
	runtime.KeepAlive(profile)

	var _list []*EncodingProfile // out

	_list = make([]*EncodingProfile, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstEncodingProfile)(v)
		var dst *EncodingProfile // out
		dst = wrapEncodingProfile(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// EncodingProfile: opaque base class object for all encoding profiles. This
// contains generic information like name, description, format and preset.
type EncodingProfile struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*EncodingProfile)(nil)
)

func wrapEncodingProfile(obj *coreglib.Object) *EncodingProfile {
	return &EncodingProfile{
		Object: obj,
	}
}

func marshalEncodingProfile(p uintptr) (interface{}, error) {
	return wrapEncodingProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Copy makes a deep copy of self.
//
// The function returns the following values:
//
//    - encodingProfile: copy of self.
//
func (self *EncodingProfile) Copy() *EncodingProfile {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstEncodingProfile // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gst_encoding_profile_copy(_arg0)
	runtime.KeepAlive(self)

	var _encodingProfile *EncodingProfile // out

	_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingProfile
}

// AllowDynamicOutput: get whether the format that has been negotiated in at
// some point can be renegotiated later during the encoding.
//
// The function returns the following values:
//
func (profile *EncodingProfile) AllowDynamicOutput() bool {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_allow_dynamic_output(_arg0)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - utf8: description of the profile, can be NULL.
//
func (profile *EncodingProfile) Description() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_description(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - structure (optional) properties that are going to be set on the
//      underlying element.
//
func (self *EncodingProfile) ElementProperties() *gst.Structure {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstStructure       // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gst_encoding_profile_get_element_properties(_arg0)
	runtime.KeepAlive(self)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// The function returns the following values:
//
//    - utf8: suitable file extension for profile, or NULL.
//
func (profile *EncodingProfile) FileExtension() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_file_extension(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - caps corresponding to the media format used in the profile. Unref after
//      usage.
//
func (profile *EncodingProfile) Format() *gst.Caps {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_format(_arg0)
	runtime.KeepAlive(profile)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// InputCaps computes the full output caps that this profile will be able to
// consume.
//
// The function returns the following values:
//
//    - caps: full caps the given profile can consume. Call gst_caps_unref() when
//      you are done with the caps.
//
func (profile *EncodingProfile) InputCaps() *gst.Caps {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_input_caps(_arg0)
	runtime.KeepAlive(profile)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function returns the following values:
//
//    - utf8: name of the profile, can be NULL.
//
func (profile *EncodingProfile) Name() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_name(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - guint: number of times the profile is used in its parent container
//      profile. If 0, it is not a mandatory stream.
//
func (profile *EncodingProfile) Presence() uint {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.guint               // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_presence(_arg0)
	runtime.KeepAlive(profile)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//    - utf8: name of the Preset to be used in the profile. This is the name that
//      has been set when saving the preset.
//
func (profile *EncodingProfile) Preset() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_preset(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - utf8: name of the Preset factory to be used in the profile.
//
func (profile *EncodingProfile) PresetName() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_preset_name(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - caps: restriction Caps to apply before the encoder that will be used in
//      the profile. The fields present in restriction caps are properties of the
//      raw stream (that is before encoding), such as height and width for video
//      and depth and sampling rate for audio. Does not apply to
//      EncodingContainerProfile (since there is no corresponding raw stream).
//      Can be NULL. Unref after usage.
//
func (profile *EncodingProfile) Restriction() *gst.Caps {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_restriction(_arg0)
	runtime.KeepAlive(profile)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function returns the following values:
//
//    - ok if the stream represented by profile should use a single segment
//      before the encoder, LSE otherwise. This means that buffers will be
//      retimestamped and segments will be eat so as to appear as one segment.
//
func (profile *EncodingProfile) SingleSegment() bool {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_single_segment(_arg0)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - utf8: human-readable name of the type of profile.
//
func (profile *EncodingProfile) TypeNick() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_type_nick(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
func (profile *EncodingProfile) IsEnabled() bool {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_profile_is_enabled(_arg0)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks whether the two EncodingProfile are equal.
//
// The function takes the following parameters:
//
//    - b: EncodingProfile.
//
// The function returns the following values:
//
//    - ok: TRUE if a and b are equal, else FALSE.
//
func (a *EncodingProfile) IsEqual(b *EncodingProfile) bool {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(a).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(b).Native()))

	_cret = C.gst_encoding_profile_is_equal(_arg0, _arg1)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAllowDynamicOutput sets whether the format that has been negotiated in at
// some point can be renegotiated later during the encoding.
//
// The function takes the following parameters:
//
//    - allowDynamicOutput: whether the format that has been negotiated first can
//      be renegotiated during the encoding.
//
func (profile *EncodingProfile) SetAllowDynamicOutput(allowDynamicOutput bool) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if allowDynamicOutput {
		_arg1 = C.TRUE
	}

	C.gst_encoding_profile_set_allow_dynamic_output(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(allowDynamicOutput)
}

// SetDescription: set description as the given description for the profile. A
// copy of description will be made internally.
//
// The function takes the following parameters:
//
//    - description (optional) to set on the profile.
//
func (profile *EncodingProfile) SetDescription(description string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if description != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_description(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(description)
}

// SetElementProperties: this allows setting the muxing/encoding element
// properties.
//
// **Set properties generically**
//
// ` properties [element-properties, boolean-prop=true, string-prop="hi"]
//
//
//      **Mapping properties with well known element factories**
//
//
//
//    properties
//
// element-properties-map, map = {
//
//        [openh264enc, gop-size=32, ],
//        [x264enc, key-int-max=32, tune=zerolatency],
//    }
//
// `.
//
// The function takes the following parameters:
//
//    - elementProperties defining the properties to be set to the element the
//      profile represents.
//
func (self *EncodingProfile) SetElementProperties(elementProperties *gst.Structure) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstStructure       // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(elementProperties)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(elementProperties)), nil)

	C.gst_encoding_profile_set_element_properties(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(elementProperties)
}

// SetEnabled: set whether the profile should be used or not.
//
// The function takes the following parameters:
//
//    - enabled: FALSE to disable profile, TRUE to enable it.
//
func (profile *EncodingProfile) SetEnabled(enabled bool) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_encoding_profile_set_enabled(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(enabled)
}

// SetFormat sets the media format used in the profile.
//
// The function takes the following parameters:
//
//    - format: media format to use in the profile.
//
func (profile *EncodingProfile) SetFormat(format *gst.Caps) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstCaps            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))

	C.gst_encoding_profile_set_format(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(format)
}

// SetName: set name as the given name for the profile. A copy of name will be
// made internally.
//
// The function takes the following parameters:
//
//    - name (optional) to set on the profile.
//
func (profile *EncodingProfile) SetName(name string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_name(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(name)
}

// SetPresence: set the number of time the profile is used in its parent
// container profile. If 0, it is not a mandatory stream.
//
// The function takes the following parameters:
//
//    - presence: number of time the profile can be used.
//
func (profile *EncodingProfile) SetPresence(presence uint) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.guint               // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	_arg1 = C.guint(presence)

	C.gst_encoding_profile_set_presence(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(presence)
}

// SetPreset sets the name of the Element that implements the Preset interface
// to use for the profile. This is the name that has been set when saving the
// preset.
//
// The function takes the following parameters:
//
//    - preset (optional): element preset to use.
//
func (profile *EncodingProfile) SetPreset(preset string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if preset != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_preset(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(preset)
}

// SetPresetName sets the name of the Preset's factory to be used in the
// profile.
//
// The function takes the following parameters:
//
//    - presetName (optional): name of the preset to use in this profile.
//
func (profile *EncodingProfile) SetPresetName(presetName string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if presetName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(presetName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_preset_name(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(presetName)
}

// SetRestriction: set the restriction Caps to apply before the encoder that
// will be used in the profile. See gst_encoding_profile_get_restriction() for
// more about restrictions. Does not apply to EncodingContainerProfile.
//
// The function takes the following parameters:
//
//    - restriction (optional) to apply.
//
func (profile *EncodingProfile) SetRestriction(restriction *gst.Caps) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstCaps            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if restriction != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(restriction)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(restriction)), nil)
	}

	C.gst_encoding_profile_set_restriction(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(restriction)
}

// SetSingleSegment: if using a single segment, buffers will be retimestamped
// and segments will be eat so as to appear as one segment.
//
// > *NOTE*: Single segment is not property supported when using >
// #encodebin:avoid-reencoding.
//
// The function takes the following parameters:
//
//    - singleSegment if the stream represented by profile should use a single
//      segment before the encoder, LSE otherwise.
//
func (profile *EncodingProfile) SetSingleSegment(singleSegment bool) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	if singleSegment {
		_arg1 = C.TRUE
	}

	C.gst_encoding_profile_set_single_segment(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(singleSegment)
}

// EncodingProfileFind: find the EncodingProfile with the specified name and
// category.
//
// The function takes the following parameters:
//
//    - targetname: name of the target.
//    - profilename (optional): name of the profile, if NULL provided, it will
//      default to the encoding profile called default.
//    - category (optional): target category. Can be NULL.
//
// The function returns the following values:
//
//    - encodingProfile: matching EncodingProfile or NULL.
//
func EncodingProfileFind(targetname, profilename, category string) *EncodingProfile {
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret *C.GstEncodingProfile // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(targetname)))
	defer C.free(unsafe.Pointer(_arg1))
	if profilename != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(profilename)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if category != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_encoding_profile_find(_arg1, _arg2, _arg3)
	runtime.KeepAlive(targetname)
	runtime.KeepAlive(profilename)
	runtime.KeepAlive(category)

	var _encodingProfile *EncodingProfile // out

	_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingProfile
}

// EncodingProfileFromDiscoverer creates a EncodingProfile matching the formats
// from the given DiscovererInfo. Streams other than audio or video (eg,
// subtitles), are currently ignored.
//
// The function takes the following parameters:
//
//    - info to read from.
//
// The function returns the following values:
//
//    - encodingProfile: new EncodingProfile or NULL.
//
func EncodingProfileFromDiscoverer(info *DiscovererInfo) *EncodingProfile {
	var _arg1 *C.GstDiscovererInfo  // out
	var _cret *C.GstEncodingProfile // in

	_arg1 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_encoding_profile_from_discoverer(_arg1)
	runtime.KeepAlive(info)

	var _encodingProfile *EncodingProfile // out

	_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingProfile
}

// EncodingVideoProfile: variant of EncodingProfile for video streams, allows
// specifying the pass.
type EncodingVideoProfile struct {
	_ [0]func() // equal guard
	EncodingProfile
}

var (
	_ coreglib.Objector = (*EncodingVideoProfile)(nil)
)

func wrapEncodingVideoProfile(obj *coreglib.Object) *EncodingVideoProfile {
	return &EncodingVideoProfile{
		EncodingProfile: EncodingProfile{
			Object: obj,
		},
	}
}

func marshalEncodingVideoProfile(p uintptr) (interface{}, error) {
	return wrapEncodingVideoProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingVideoProfile creates a new EncodingVideoProfile
//
// All provided allocatable arguments will be internally copied, so can be
// safely freed/unreferenced after calling this method.
//
// If you wish to control the pass number (in case of multi-pass scenarios),
// please refer to the gst_encoding_video_profile_set_pass() documentation.
//
// If you wish to use/force a constant framerate please refer to the
// gst_encoding_video_profile_set_variableframerate() documentation.
//
// The function takes the following parameters:
//
//    - format: Caps.
//    - preset (optional): preset(s) to use on the encoder, can be NULL.
//    - restriction (optional) used to restrict the input to the encoder, can be
//      NULL. See gst_encoding_profile_get_restriction() for more details.
//    - presence: number of time this stream must be used. 0 means any number of
//      times (including never).
//
// The function returns the following values:
//
//    - encodingVideoProfile: newly created EncodingVideoProfile.
//
func NewEncodingVideoProfile(format *gst.Caps, preset string, restriction *gst.Caps, presence uint) *EncodingVideoProfile {
	var _arg1 *C.GstCaps                 // out
	var _arg2 *C.gchar                   // out
	var _arg3 *C.GstCaps                 // out
	var _arg4 C.guint                    // out
	var _cret *C.GstEncodingVideoProfile // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))
	if preset != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if restriction != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(restriction)))
	}
	_arg4 = C.guint(presence)

	_cret = C.gst_encoding_video_profile_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(format)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(restriction)
	runtime.KeepAlive(presence)

	var _encodingVideoProfile *EncodingVideoProfile // out

	_encodingVideoProfile = wrapEncodingVideoProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingVideoProfile
}

// Pass: get the pass number if this is part of a multi-pass profile.
//
// The function returns the following values:
//
//    - guint pass number. Starts at 1 for multi-pass. 0 if this is not a
//      multi-pass profile.
//
func (prof *EncodingVideoProfile) Pass() uint {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _cret C.guint                    // in

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.InternObject(prof).Native()))

	_cret = C.gst_encoding_video_profile_get_pass(_arg0)
	runtime.KeepAlive(prof)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Variableframerate: > *NOTE*: Fixed framerate won't be enforced when
// #encodebin:avoid-reencoding > is set.
//
// The function returns the following values:
//
//    - ok: whether non-constant video framerate is allowed for encoding.
//
func (prof *EncodingVideoProfile) Variableframerate() bool {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.InternObject(prof).Native()))

	_cret = C.gst_encoding_video_profile_get_variableframerate(_arg0)
	runtime.KeepAlive(prof)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPass sets the pass number of this video profile. The first pass profile
// should have this value set to 1. If this video profile isn't part of a
// multi-pass profile, you may set it to 0 (the default value).
//
// The function takes the following parameters:
//
//    - pass number for this profile.
//
func (prof *EncodingVideoProfile) SetPass(pass uint) {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _arg1 C.guint                    // out

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.InternObject(prof).Native()))
	_arg1 = C.guint(pass)

	C.gst_encoding_video_profile_set_pass(_arg0, _arg1)
	runtime.KeepAlive(prof)
	runtime.KeepAlive(pass)
}

// SetVariableframerate: if set to TRUE, then the incoming stream will be
// allowed to have non-constant framerate. If set to FALSE (default value), then
// the incoming stream will be normalized by dropping/duplicating frames in
// order to produce a constance framerate.
//
// The function takes the following parameters:
//
//    - variableframerate: boolean.
//
func (prof *EncodingVideoProfile) SetVariableframerate(variableframerate bool) {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _arg1 C.gboolean                 // out

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.InternObject(prof).Native()))
	if variableframerate {
		_arg1 = C.TRUE
	}

	C.gst_encoding_video_profile_set_variableframerate(_arg0, _arg1)
	runtime.KeepAlive(prof)
	runtime.KeepAlive(variableframerate)
}
