// Code generated by girgen. DO NOT EDIT.

package gstpbutils

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/pbutils/pbutils.h>
import "C"

// GType values.
var (
	GTypeEncodingTarget = coreglib.Type(C.gst_encoding_target_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeEncodingTarget, F: marshalEncodingTarget},
	})
}

// ENCODING_CATEGORY_CAPTURE category for recording and capture. Targets within
// this category are optimized for low latency encoding.
const ENCODING_CATEGORY_CAPTURE = "capture"

// ENCODING_CATEGORY_DEVICE category for device-specific targets. The name of
// the target will usually be the constructor and model of the device, and that
// target will contain EncodingProfiles suitable for that device.
const ENCODING_CATEGORY_DEVICE = "device"

// ENCODING_CATEGORY_FILE_EXTENSION category for file extensions. The name of
// the target will be the name of the file extensions possible for a particular
// target. Those targets are defining like 'default' formats usually used for a
// particular file extension.
const ENCODING_CATEGORY_FILE_EXTENSION = "file-extension"

// ENCODING_CATEGORY_ONLINE_SERVICE category for online-services. The name of
// the target will usually be the name of the online service and that target
// will contain EncodingProfiles suitable for that online service.
const ENCODING_CATEGORY_ONLINE_SERVICE = "online-service"

// ENCODING_CATEGORY_STORAGE_EDITING category for storage, archiving and editing
// targets. Those targets can be lossless and/or provide very fast random access
// content. The name of the target will usually be the container type or editing
// target, and that target will contain EncodingProfiles suitable for editing or
// storage.
const ENCODING_CATEGORY_STORAGE_EDITING = "storage-editing"

// EncodingListAllTargets: list all available EncodingTarget for the specified
// category, or all categories if categoryname is NULL.
//
// The function takes the following parameters:
//
//    - categoryname (optional): category, for ex: T_ENCODING_CATEGORY_DEVICE.
//      Can be NULL.
//
// The function returns the following values:
//
//    - list of EncodingTarget.
//
func EncodingListAllTargets(categoryname string) []*EncodingTarget {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	if categoryname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(categoryname)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_encoding_list_all_targets(_arg1)
	runtime.KeepAlive(categoryname)

	var _list []*EncodingTarget // out

	_list = make([]*EncodingTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstEncodingTarget)(v)
		var dst *EncodingTarget // out
		dst = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// EncodingListAvailableCategories lists all EncodingTarget categories present
// on disk.
//
// The function returns the following values:
//
//    - list: list of EncodingTarget categories.
//
func EncodingListAvailableCategories() []string {
	var _cret *C.GList // in

	_cret = C.gst_encoding_list_available_categories()

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// EncodingTarget: collection of EncodingProfile for a specific target or
// use-case.
//
// When being stored/loaded, targets come from a specific category, like
// T_ENCODING_CATEGORY_DEVICE.
type EncodingTarget struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*EncodingTarget)(nil)
)

func wrapEncodingTarget(obj *coreglib.Object) *EncodingTarget {
	return &EncodingTarget{
		Object: obj,
	}
}

func marshalEncodingTarget(p uintptr) (interface{}, error) {
	return wrapEncodingTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingTarget creates a new EncodingTarget.
//
// The name and category can only consist of lowercase ASCII letters for the
// first character, followed by either lowercase ASCII letters, digits or
// hyphens ('-').
//
// The category *should* be one of the existing well-defined categories, like
// T_ENCODING_CATEGORY_DEVICE, but it *can* be a application or user specific
// category if needed.
//
// The function takes the following parameters:
//
//    - name of the target.
//    - category: name of the category to which this target belongs. For example:
//      T_ENCODING_CATEGORY_DEVICE.
//    - description of EncodingTarget in the current locale.
//    - profiles: #GList of EncodingProfile.
//
// The function returns the following values:
//
//    - encodingTarget: newly created EncodingTarget or NULL if there was an
//      error.
//
func NewEncodingTarget(name, category, description string, profiles []*EncodingProfile) *EncodingTarget {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GList             // out
	var _cret *C.GstEncodingTarget // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	for i := len(profiles) - 1; i >= 0; i-- {
		src := profiles[i]
		var dst *C.GstEncodingProfile // out
		dst = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg4 = C.g_list_prepend(_arg4, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg4)

	_cret = C.gst_encoding_target_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(category)
	runtime.KeepAlive(description)
	runtime.KeepAlive(profiles)

	var _encodingTarget *EncodingTarget // out

	_encodingTarget = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingTarget
}

// AddProfile adds the given profile to the target. Each added profile must have
// a unique name within the profile.
//
// The target will steal a reference to the profile. If you wish to use the
// profile after calling this method, you should increase its reference count.
//
// The function takes the following parameters:
//
//    - profile to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the profile was added, else FALSE.
//
func (target *EncodingTarget) AddProfile(profile *EncodingProfile) bool {
	var _arg0 *C.GstEncodingTarget  // out
	var _arg1 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.InternObject(profile).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(profile).Native()))

	_cret = C.gst_encoding_target_add_profile(_arg0, _arg1)
	runtime.KeepAlive(target)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - utf8: category of the target. For example: T_ENCODING_CATEGORY_DEVICE.
//
func (target *EncodingTarget) Category() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_encoding_target_get_category(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - utf8: description of the target.
//
func (target *EncodingTarget) Description() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_encoding_target_get_description(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - utf8: name of the target.
//
func (target *EncodingTarget) Name() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_encoding_target_get_name(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - utf8: path to the target file.
//
func (target *EncodingTarget) Path() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_encoding_target_get_path(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function takes the following parameters:
//
//    - name of the profile to retrieve.
//
// The function returns the following values:
//
//    - encodingProfile: matching EncodingProfile, or NULL.
//
func (target *EncodingTarget) Profile(name string) *EncodingProfile {
	var _arg0 *C.GstEncodingTarget  // out
	var _arg1 *C.gchar              // out
	var _cret *C.GstEncodingProfile // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_encoding_target_get_profile(_arg0, _arg1)
	runtime.KeepAlive(target)
	runtime.KeepAlive(name)

	var _encodingProfile *EncodingProfile // out

	_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingProfile
}

// The function returns the following values:
//
//    - list of EncodingProfile(s) this target handles.
//
func (target *EncodingTarget) Profiles() []*EncodingProfile {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_encoding_target_get_profiles(_arg0)
	runtime.KeepAlive(target)

	var _list []*EncodingProfile // out

	_list = make([]*EncodingProfile, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstEncodingProfile)(v)
		var dst *EncodingProfile // out
		dst = wrapEncodingProfile(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Save saves the target to a default user-local directory.
func (target *EncodingTarget) Save() error {
	var _arg0 *C.GstEncodingTarget // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	C.gst_encoding_target_save(_arg0, &_cerr)
	runtime.KeepAlive(target)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SaveToFile saves the target to the provided file location.
//
// The function takes the following parameters:
//
//    - filepath: location to store the target at.
//
func (target *EncodingTarget) SaveToFile(filepath string) error {
	var _arg0 *C.GstEncodingTarget // out
	var _arg1 *C.gchar             // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filepath)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_encoding_target_save_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(target)
	runtime.KeepAlive(filepath)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EncodingTargetLoad searches for the EncodingTarget with the given name, loads
// it and returns it.
//
// If the category name is specified only targets from that category will be
// searched for.
//
// The function takes the following parameters:
//
//    - name of the EncodingTarget to load (automatically converted to lower case
//      internally as capital letters are not valid for target names).
//    - category (optional): name of the target category, like
//      T_ENCODING_CATEGORY_DEVICE. Can be NULL.
//
// The function returns the following values:
//
//    - encodingTarget if available, else NULL.
//
func EncodingTargetLoad(name, category string) (*EncodingTarget, error) {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _cret *C.GstEncodingTarget // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if category != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_encoding_target_load(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(name)
	runtime.KeepAlive(category)

	var _encodingTarget *EncodingTarget // out
	var _goerr error                    // out

	_encodingTarget = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _encodingTarget, _goerr
}

// EncodingTargetLoadFromFile opens the provided file and returns the contained
// EncodingTarget.
//
// The function takes the following parameters:
//
//    - filepath: file location to load the EncodingTarget from.
//
// The function returns the following values:
//
//    - encodingTarget contained in the file, else NULL.
//
func EncodingTargetLoadFromFile(filepath string) (*EncodingTarget, error) {
	var _arg1 *C.gchar             // out
	var _cret *C.GstEncodingTarget // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filepath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_encoding_target_load_from_file(_arg1, &_cerr)
	runtime.KeepAlive(filepath)

	var _encodingTarget *EncodingTarget // out
	var _goerr error                    // out

	_encodingTarget = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _encodingTarget, _goerr
}
