// Code generated by girgen. DO NOT EDIT.

package gstpbutils

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstvideo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/pbutils/pbutils.h>
// extern gboolean _gotk4_gstpbutils1_AudioVisualizerClass_setup(GstAudioVisualizer*);
// extern gboolean _gotk4_gstpbutils1_AudioVisualizerClass_render(GstAudioVisualizer*, GstBuffer*, GstVideoFrame*);
// extern gboolean _gotk4_gstpbutils1_AudioVisualizerClass_decide_allocation(GstAudioVisualizer*, GstQuery*);
// gboolean _gotk4_gstpbutils1_AudioVisualizer_virtual_decide_allocation(void* fnptr, GstAudioVisualizer* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioVisualizer*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstpbutils1_AudioVisualizer_virtual_render(void* fnptr, GstAudioVisualizer* arg0, GstBuffer* arg1, GstVideoFrame* arg2) {
//   return ((gboolean (*)(GstAudioVisualizer*, GstBuffer*, GstVideoFrame*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstpbutils1_AudioVisualizer_virtual_setup(void* fnptr, GstAudioVisualizer* arg0) {
//   return ((gboolean (*)(GstAudioVisualizer*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioVisualizerShader = coreglib.Type(C.gst_audio_visualizer_shader_get_type())
	GTypeAudioVisualizer       = coreglib.Type(C.gst_audio_visualizer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioVisualizerShader, F: marshalAudioVisualizerShader},
		coreglib.TypeMarshaler{T: GTypeAudioVisualizer, F: marshalAudioVisualizer},
	})
}

// AudioVisualizerShader: different types of supported background shading
// functions.
type AudioVisualizerShader C.gint

const (
	// AudioVisualizerShaderNone: no shading.
	AudioVisualizerShaderNone AudioVisualizerShader = iota
	// AudioVisualizerShaderFade: plain fading.
	AudioVisualizerShaderFade
	// AudioVisualizerShaderFadeAndMoveUp: fade and move up.
	AudioVisualizerShaderFadeAndMoveUp
	// AudioVisualizerShaderFadeAndMoveDown: fade and move down.
	AudioVisualizerShaderFadeAndMoveDown
	// AudioVisualizerShaderFadeAndMoveLeft: fade and move left.
	AudioVisualizerShaderFadeAndMoveLeft
	// AudioVisualizerShaderFadeAndMoveRight: fade and move right.
	AudioVisualizerShaderFadeAndMoveRight
	// AudioVisualizerShaderFadeAndMoveHorizOut: fade and move horizontally out.
	AudioVisualizerShaderFadeAndMoveHorizOut
	// AudioVisualizerShaderFadeAndMoveHorizIn: fade and move horizontally in.
	AudioVisualizerShaderFadeAndMoveHorizIn
	// AudioVisualizerShaderFadeAndMoveVertOut: fade and move vertically out.
	AudioVisualizerShaderFadeAndMoveVertOut
	// AudioVisualizerShaderFadeAndMoveVertIn: fade and move vertically in.
	AudioVisualizerShaderFadeAndMoveVertIn
)

func marshalAudioVisualizerShader(p uintptr) (interface{}, error) {
	return AudioVisualizerShader(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioVisualizerShader.
func (a AudioVisualizerShader) String() string {
	switch a {
	case AudioVisualizerShaderNone:
		return "None"
	case AudioVisualizerShaderFade:
		return "Fade"
	case AudioVisualizerShaderFadeAndMoveUp:
		return "FadeAndMoveUp"
	case AudioVisualizerShaderFadeAndMoveDown:
		return "FadeAndMoveDown"
	case AudioVisualizerShaderFadeAndMoveLeft:
		return "FadeAndMoveLeft"
	case AudioVisualizerShaderFadeAndMoveRight:
		return "FadeAndMoveRight"
	case AudioVisualizerShaderFadeAndMoveHorizOut:
		return "FadeAndMoveHorizOut"
	case AudioVisualizerShaderFadeAndMoveHorizIn:
		return "FadeAndMoveHorizIn"
	case AudioVisualizerShaderFadeAndMoveVertOut:
		return "FadeAndMoveVertOut"
	case AudioVisualizerShaderFadeAndMoveVertIn:
		return "FadeAndMoveVertIn"
	default:
		return fmt.Sprintf("AudioVisualizerShader(%d)", a)
	}
}

// AudioVisualizerOverrides contains methods that are overridable.
type AudioVisualizerOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	//    - audio
	//    - video
	//
	// The function returns the following values:
	//
	Render func(audio *gst.Buffer, video *gstvideo.VideoFrame) bool
	// The function returns the following values:
	//
	Setup func() bool
}

func defaultAudioVisualizerOverrides(v *AudioVisualizer) AudioVisualizerOverrides {
	return AudioVisualizerOverrides{
		DecideAllocation: v.decideAllocation,
		Render:           v.render,
		Setup:            v.setup,
	}
}

// AudioVisualizer baseclass for scopes (visualizers). It takes care of
// re-fitting the audio-rate to video-rate and handles renegotiation (downstream
// video size changes).
//
// It also provides several background shading effects. These effects are
// applied to a previous picture before the render() implementation can draw a
// new frame.
type AudioVisualizer struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*AudioVisualizer)(nil)
)

// AudioVisualizerer describes types inherited from class AudioVisualizer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioVisualizerer interface {
	coreglib.Objector
	baseAudioVisualizer() *AudioVisualizer
}

var _ AudioVisualizerer = (*AudioVisualizer)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioVisualizer, *AudioVisualizerClass, AudioVisualizerOverrides](
		GTypeAudioVisualizer,
		initAudioVisualizerClass,
		wrapAudioVisualizer,
		defaultAudioVisualizerOverrides,
	)
}

func initAudioVisualizerClass(gclass unsafe.Pointer, overrides AudioVisualizerOverrides, classInitFunc func(*AudioVisualizerClass)) {
	pclass := (*C.GstAudioVisualizerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioVisualizer))))

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstpbutils1_AudioVisualizerClass_decide_allocation)
	}

	if overrides.Render != nil {
		pclass.render = (*[0]byte)(C._gotk4_gstpbutils1_AudioVisualizerClass_render)
	}

	if overrides.Setup != nil {
		pclass.setup = (*[0]byte)(C._gotk4_gstpbutils1_AudioVisualizerClass_setup)
	}

	if classInitFunc != nil {
		class := (*AudioVisualizerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioVisualizer(obj *coreglib.Object) *AudioVisualizer {
	return &AudioVisualizer{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalAudioVisualizer(p uintptr) (interface{}, error) {
	return wrapAudioVisualizer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *AudioVisualizer) baseAudioVisualizer() *AudioVisualizer {
	return v
}

// BaseAudioVisualizer returns the underlying base object.
func BaseAudioVisualizer(obj AudioVisualizerer) *AudioVisualizer {
	return obj.baseAudioVisualizer()
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (scope *AudioVisualizer) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstAudioVisualizerClass)(coreglib.PeekParentClass(scope))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstAudioVisualizer // out
	var _arg1 *C.GstQuery           // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioVisualizer)(unsafe.Pointer(coreglib.InternObject(scope).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstpbutils1_AudioVisualizer_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - audio
//    - video
//
// The function returns the following values:
//
func (scope *AudioVisualizer) render(audio *gst.Buffer, video *gstvideo.VideoFrame) bool {
	gclass := (*C.GstAudioVisualizerClass)(coreglib.PeekParentClass(scope))
	fnarg := gclass.render

	var _arg0 *C.GstAudioVisualizer // out
	var _arg1 *C.GstBuffer          // out
	var _arg2 *C.GstVideoFrame      // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioVisualizer)(unsafe.Pointer(coreglib.InternObject(scope).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(audio)))
	_arg2 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(video)))

	_cret = C._gotk4_gstpbutils1_AudioVisualizer_virtual_render(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(audio)
	runtime.KeepAlive(video)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (scope *AudioVisualizer) setup() bool {
	gclass := (*C.GstAudioVisualizerClass)(coreglib.PeekParentClass(scope))
	fnarg := gclass.setup

	var _arg0 *C.GstAudioVisualizer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioVisualizer)(unsafe.Pointer(coreglib.InternObject(scope).Native()))

	_cret = C._gotk4_gstpbutils1_AudioVisualizer_virtual_setup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(scope)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioVisualizerClass: instance of this type is always passed by reference.
type AudioVisualizerClass struct {
	*audioVisualizerClass
}

// audioVisualizerClass is the struct that's finalized.
type audioVisualizerClass struct {
	native *C.GstAudioVisualizerClass
}
