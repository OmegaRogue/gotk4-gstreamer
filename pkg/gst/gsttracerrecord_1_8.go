// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeTracerValueScope = coreglib.Type(C.gst_tracer_value_scope_get_type())
	GTypeTracerRecord     = coreglib.Type(C.gst_tracer_record_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTracerValueScope, F: marshalTracerValueScope},
		coreglib.TypeMarshaler{T: GTypeTracerRecord, F: marshalTracerRecord},
	})
}

// TracerValueScope: tracing record will contain fields that contain a measured
// value or extra meta-data. One such meta data are values that tell where a
// measurement was taken. This enumerating declares to which scope such a meta
// data field relates to. If it is e.g. GST_TRACER_VALUE_SCOPE_PAD, then each of
// the log events may contain values for different Pads.
type TracerValueScope C.gint

const (
	// TracerValueScopeProcess: value is related to the process.
	TracerValueScopeProcess TracerValueScope = iota
	// TracerValueScopeThread: value is related to a thread.
	TracerValueScopeThread
	// TracerValueScopeElement: value is related to an Element.
	TracerValueScopeElement
	// TracerValueScopePad: value is related to a Pad.
	TracerValueScopePad
)

func marshalTracerValueScope(p uintptr) (interface{}, error) {
	return TracerValueScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TracerValueScope.
func (t TracerValueScope) String() string {
	switch t {
	case TracerValueScopeProcess:
		return "Process"
	case TracerValueScopeThread:
		return "Thread"
	case TracerValueScopeElement:
		return "Element"
	case TracerValueScopePad:
		return "Pad"
	default:
		return fmt.Sprintf("TracerValueScope(%d)", t)
	}
}

// TracerRecord: tracing modules will create instances of this class to announce
// the data they will log and create a log formatter.
type TracerRecord struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*TracerRecord)(nil)
)

func wrapTracerRecord(obj *coreglib.Object) *TracerRecord {
	return &TracerRecord{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalTracerRecord(p uintptr) (interface{}, error) {
	return wrapTracerRecord(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}
