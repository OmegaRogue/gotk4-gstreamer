// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_Registry_ConnectPluginAdded(gpointer, GstPlugin*, guintptr);
// extern void _gotk4_gst1_Registry_ConnectFeatureAdded(gpointer, GstPluginFeature*, guintptr);
// extern gboolean _gotk4_gst1_PluginFilter(GstPlugin*, gpointer);
// extern gboolean _gotk4_gst1_PluginFeatureFilter(GstPluginFeature*, gpointer);
import "C"

// GType values.
var (
	GTypeRegistry = coreglib.Type(C.gst_registry_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRegistry, F: marshalRegistry},
	})
}

// RegistryOverrides contains methods that are overridable.
type RegistryOverrides struct {
}

func defaultRegistryOverrides(v *Registry) RegistryOverrides {
	return RegistryOverrides{}
}

// Registry: one registry holds the metadata of a set of plugins.
//
// <emphasis role="bold">Design:</emphasis>
//
// The Registry object is a list of plugins and some functions for dealing with
// them. Each Plugin is matched 1-1 with a file on disk, and may or may not be
// loaded at a given time.
//
// The primary source, at all times, of plugin information is each plugin file
// itself. Thus, if an application wants information about a particular plugin,
// or wants to search for a feature that satisfies given criteria, the primary
// means of doing so is to load every plugin and look at the resulting
// information that is gathered in the default registry. Clearly, this is a time
// consuming process, so we cache information in the registry file. The format
// and location of the cache file is internal to gstreamer.
//
// On startup, plugins are searched for in the plugin search path. The following
// locations are checked in this order:
//
// * location from --gst-plugin-path commandline option. * the GST_PLUGIN_PATH
// environment variable. * the GST_PLUGIN_SYSTEM_PATH environment variable. *
// default locations (if GST_PLUGIN_SYSTEM_PATH is not set). Those default
// locations are: $XDG_DATA_HOME/gstreamer-$GST_API_VERSION/plugins/ and
// $prefix/libs/gstreamer-$GST_API_VERSION/. $XDG_DATA_HOME
// (http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html)
// defaults to $HOME/.local/share.
//
// The registry cache file is loaded from
// $XDG_CACHE_HOME/gstreamer-$GST_API_VERSION/registry-$ARCH.bin (where
// $XDG_CACHE_HOME defaults to $HOME/.cache) or the file listed in the
// GST_REGISTRY env var. One reason to change the registry location is for
// testing.
//
// For each plugin that is found in the plugin search path, there could be 3
// possibilities for cached information:
//
//    * the cache may not contain information about a given file.
//    * the cache may have stale information.
//    * the cache may have current information.
//
// In the first two cases, the plugin is loaded and the cache updated. In
// addition to these cases, the cache may have entries for plugins that are not
// relevant to the current process. These are marked as not available to the
// current process. If the cache is updated for whatever reason, it is marked
// dirty.
//
// A dirty cache is written out at the end of initialization. Each entry is
// checked to make sure the information is minimally valid. If not, the entry is
// simply dropped.
//
// Implementation notes:
//
// The "cache" and "registry" are different concepts and can represent different
// sets of plugins. For various reasons, at init time, the cache is stored in
// the default registry, and plugins not relevant to the current process are
// marked with the GST_PLUGIN_FLAG_CACHED bit. These plugins are removed at the
// end of initialization.
type Registry struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Registry)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Registry, *RegistryClass, RegistryOverrides](
		GTypeRegistry,
		initRegistryClass,
		wrapRegistry,
		defaultRegistryOverrides,
	)
}

func initRegistryClass(gclass unsafe.Pointer, overrides RegistryOverrides, classInitFunc func(*RegistryClass)) {
	if classInitFunc != nil {
		class := (*RegistryClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRegistry(obj *coreglib.Object) *Registry {
	return &Registry{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalRegistry(p uintptr) (interface{}, error) {
	return wrapRegistry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectFeatureAdded signals that a feature has been added to the registry
// (possibly replacing a previously-added one by the same name).
func (registry *Registry) ConnectFeatureAdded(f func(feature PluginFeaturer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(registry, "feature-added", false, unsafe.Pointer(C._gotk4_gst1_Registry_ConnectFeatureAdded), f)
}

// ConnectPluginAdded signals that a plugin has been added to the registry
// (possibly replacing a previously-added one by the same name).
func (registry *Registry) ConnectPluginAdded(f func(plugin *Plugin)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(registry, "plugin-added", false, unsafe.Pointer(C._gotk4_gst1_Registry_ConnectPluginAdded), f)
}

// AddFeature: add the feature to the registry. The feature-added signal will be
// emitted.
//
// feature's reference count will be incremented, and any floating reference
// will be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//    - feature to add.
//
// The function returns the following values:
//
//    - ok: TRUE on success.
//
//      MT safe.
//
func (registry *Registry) AddFeature(feature PluginFeaturer) bool {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.GstPluginFeature // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_registry_add_feature(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddPlugin: add the plugin to the registry. The plugin-added signal will be
// emitted.
//
// plugin's reference count will be incremented, and any floating reference will
// be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//    - plugin to add.
//
// The function returns the following values:
//
//    - ok: TRUE on success.
//
//      MT safe.
//
func (registry *Registry) AddPlugin(plugin *Plugin) bool {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.GstPlugin   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_registry_add_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(plugin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckFeatureVersion checks whether a plugin feature by the given name exists
// in registry and whether its version is at least the version required.
//
// The function takes the following parameters:
//
//    - featureName: name of the feature (e.g. "oggdemux").
//    - minMajor: minimum major version number.
//    - minMinor: minimum minor version number.
//    - minMicro: minimum micro version number.
//
// The function returns the following values:
//
//    - ok: TRUE if the feature could be found and the version is the same as the
//      required version or newer, and FALSE otherwise.
//
func (registry *Registry) CheckFeatureVersion(featureName string, minMajor, minMinor, minMicro uint) bool {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _arg2 C.guint        // out
	var _arg3 C.guint        // out
	var _arg4 C.guint        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(featureName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(minMajor)
	_arg3 = C.guint(minMinor)
	_arg4 = C.guint(minMicro)

	_cret = C.gst_registry_check_feature_version(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(featureName)
	runtime.KeepAlive(minMajor)
	runtime.KeepAlive(minMinor)
	runtime.KeepAlive(minMicro)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FeatureFilter runs a filter against all features of the plugins in the
// registry and returns a GList with the results. If the first flag is set, only
// the first match is returned (as a list with a single object).
//
// The function takes the following parameters:
//
//    - filter to use.
//    - first: only return first match.
//
// The function returns the following values:
//
//    - list of PluginFeature. Use gst_plugin_feature_list_free() after usage.
//
//      MT safe.
//
func (registry *Registry) FeatureFilter(filter PluginFeatureFilter, first bool) []PluginFeaturer {
	var _arg0 *C.GstRegistry           // out
	var _arg1 C.GstPluginFeatureFilter // out
	var _arg3 C.gpointer
	var _arg2 C.gboolean // out
	var _cret *C.GList   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PluginFeatureFilter)
	_arg3 = C.gpointer(gbox.Assign(filter))
	defer gbox.Delete(uintptr(_arg3))
	if first {
		_arg2 = C.TRUE
	}

	_cret = C.gst_registry_feature_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(first)

	var _list []PluginFeaturer // out

	_list = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FindFeature: find the pluginfeature with the given name and type in the
// registry.
//
// The function takes the following parameters:
//
//    - name: pluginfeature name to find.
//    - typ: pluginfeature type to find.
//
// The function returns the following values:
//
//    - pluginFeature (optional): pluginfeature with the given name and type or
//      NULL if the plugin was not found. gst_object_unref() after usage.
//
//      MT safe.
//
func (registry *Registry) FindFeature(name string, typ coreglib.Type) PluginFeaturer {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.gchar            // out
	var _arg2 C.GType             // out
	var _cret *C.GstPluginFeature // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(typ)

	_cret = C.gst_registry_find_feature(_arg0, _arg1, _arg2)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)
	runtime.KeepAlive(typ)

	var _pluginFeature PluginFeaturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			_pluginFeature = rv
		}
	}

	return _pluginFeature
}

// FindPlugin: find the plugin with the given name in the registry. The plugin
// will be reffed; caller is responsible for unreffing.
//
// The function takes the following parameters:
//
//    - name: plugin name to find.
//
// The function returns the following values:
//
//    - plugin (optional) with the given name or NULL if the plugin was not
//      found. gst_object_unref() after usage.
//
//      MT safe.
//
func (registry *Registry) FindPlugin(name string) *Plugin {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _cret *C.GstPlugin   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_find_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// FeatureList retrieves a #GList of PluginFeature of type.
//
// The function takes the following parameters:
//
//    - typ: #GType.
//
// The function returns the following values:
//
//    - list of PluginFeature of type. Use gst_plugin_feature_list_free() after
//      use
//
//      MT safe.
//
func (registry *Registry) FeatureList(typ coreglib.Type) []PluginFeaturer {
	var _arg0 *C.GstRegistry // out
	var _arg1 C.GType        // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = C.GType(typ)

	_cret = C.gst_registry_get_feature_list(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(typ)

	var _list []PluginFeaturer // out

	_list = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FeatureListByPlugin retrieves a #GList of features of the plugin with name
// name.
//
// The function takes the following parameters:
//
//    - name: plugin name.
//
// The function returns the following values:
//
//    - list of PluginFeature. Use gst_plugin_feature_list_free() after usage.
//
func (registry *Registry) FeatureListByPlugin(name string) []PluginFeaturer {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_get_feature_list_by_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)

	var _list []PluginFeaturer // out

	_list = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FeatureListCookie returns the registry's feature list cookie. This changes
// every time a feature is added or removed from the registry.
//
// The function returns the following values:
//
//    - guint32: feature list cookie.
//
func (registry *Registry) FeatureListCookie() uint32 {
	var _arg0 *C.GstRegistry // out
	var _cret C.guint32      // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))

	_cret = C.gst_registry_get_feature_list_cookie(_arg0)
	runtime.KeepAlive(registry)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// PluginList: get a copy of all plugins registered in the given registry. The
// refcount of each element in the list in incremented.
//
// The function returns the following values:
//
//    - list of Plugin. Use gst_plugin_list_free() after usage.
//
//      MT safe.
//
func (registry *Registry) PluginList() []*Plugin {
	var _arg0 *C.GstRegistry // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))

	_cret = C.gst_registry_get_plugin_list(_arg0)
	runtime.KeepAlive(registry)

	var _list []*Plugin // out

	_list = make([]*Plugin, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPlugin)(v)
		var dst *Plugin // out
		dst = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Lookup: look up a plugin in the given registry with the given filename. If
// found, plugin is reffed.
//
// The function takes the following parameters:
//
//    - filename: name of the file to look up.
//
// The function returns the following values:
//
//    - plugin (optional) if found, or NULL if not. gst_object_unref() after
//      usage.
//
func (registry *Registry) Lookup(filename string) *Plugin {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.char        // out
	var _cret *C.GstPlugin   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_lookup(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(filename)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// LookupFeature: find a PluginFeature with name in registry.
//
// The function takes the following parameters:
//
//    - name: PluginFeature name.
//
// The function returns the following values:
//
//    - pluginFeature (optional) with its refcount incremented, use
//      gst_object_unref() after usage.
//
//      MT safe.
//
func (registry *Registry) LookupFeature(name string) PluginFeaturer {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.char             // out
	var _cret *C.GstPluginFeature // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_lookup_feature(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)

	var _pluginFeature PluginFeaturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			_pluginFeature = rv
		}
	}

	return _pluginFeature
}

// PluginFilter runs a filter against all plugins in the registry and returns a
// #GList with the results. If the first flag is set, only the first match is
// returned (as a list with a single object). Every plugin is reffed; use
// gst_plugin_list_free() after use, which will unref again.
//
// The function takes the following parameters:
//
//    - filter to use.
//    - first: only return first match.
//
// The function returns the following values:
//
//    - list of Plugin. Use gst_plugin_list_free() after usage.
//
//      MT safe.
//
func (registry *Registry) PluginFilter(filter PluginFilter, first bool) []*Plugin {
	var _arg0 *C.GstRegistry    // out
	var _arg1 C.GstPluginFilter // out
	var _arg3 C.gpointer
	var _arg2 C.gboolean // out
	var _cret *C.GList   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PluginFilter)
	_arg3 = C.gpointer(gbox.Assign(filter))
	defer gbox.Delete(uintptr(_arg3))
	if first {
		_arg2 = C.TRUE
	}

	_cret = C.gst_registry_plugin_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(first)

	var _list []*Plugin // out

	_list = make([]*Plugin, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPlugin)(v)
		var dst *Plugin // out
		dst = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// RemoveFeature: remove the feature from the registry.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - feature to remove.
//
func (registry *Registry) RemoveFeature(feature PluginFeaturer) {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.GstPluginFeature // out

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.gst_registry_remove_feature(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(feature)
}

// RemovePlugin: remove the plugin from the registry.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - plugin to remove.
//
func (registry *Registry) RemovePlugin(plugin *Plugin) {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.GstPlugin   // out

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	C.gst_registry_remove_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(plugin)
}

// ScanPath: scan the given path for plugins to add to the registry. The syntax
// of the path is specific to the registry.
//
// The function takes the following parameters:
//
//    - path to scan.
//
// The function returns the following values:
//
//    - ok: TRUE if registry changed.
//
func (registry *Registry) ScanPath(path string) bool {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_scan_path(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegistryGet retrieves the singleton plugin registry. The caller does not own
// a reference on the registry, as it is alive as long as GStreamer is
// initialized.
//
// The function returns the following values:
//
//    - registry: Registry.
//
func RegistryGet() *Registry {
	var _cret *C.GstRegistry // in

	_cret = C.gst_registry_get()

	var _registry *Registry // out

	_registry = wrapRegistry(coreglib.Take(unsafe.Pointer(_cret)))

	return _registry
}

// RegistryClass: instance of this type is always passed by reference.
type RegistryClass struct {
	*registryClass
}

// registryClass is the struct that's finalized.
type registryClass struct {
	native *C.GstRegistryClass
}

func (r *RegistryClass) ParentClass() *ObjectClass {
	valptr := &r.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
