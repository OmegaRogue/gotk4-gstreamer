// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeSeekType     = coreglib.Type(C.gst_seek_type_get_type())
	GTypeSeekFlags    = coreglib.Type(C.gst_seek_flags_get_type())
	GTypeSegmentFlags = coreglib.Type(C.gst_segment_flags_get_type())
	GTypeSegment      = coreglib.Type(C.gst_segment_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSeekType, F: marshalSeekType},
		coreglib.TypeMarshaler{T: GTypeSeekFlags, F: marshalSeekFlags},
		coreglib.TypeMarshaler{T: GTypeSegmentFlags, F: marshalSegmentFlags},
		coreglib.TypeMarshaler{T: GTypeSegment, F: marshalSegment},
	})
}

const SEGMENT_INSTANT_FLAGS = 912

// SeekType: different types of seek events. When constructing a seek event with
// gst_event_new_seek() or when doing gst_segment_do_seek ().
type SeekType C.gint

const (
	// SeekTypeNone: no change in position is required.
	SeekTypeNone SeekType = iota
	// SeekTypeSet: absolute position is requested.
	SeekTypeSet
	// SeekTypeEnd: relative position to duration is requested.
	SeekTypeEnd
)

func marshalSeekType(p uintptr) (interface{}, error) {
	return SeekType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SeekType.
func (s SeekType) String() string {
	switch s {
	case SeekTypeNone:
		return "None"
	case SeekTypeSet:
		return "Set"
	case SeekTypeEnd:
		return "End"
	default:
		return fmt.Sprintf("SeekType(%d)", s)
	}
}

// SeekFlags flags to be used with gst_element_seek() or gst_event_new_seek().
// All flags can be used together.
//
// A non flushing seek might take some time to perform as the currently playing
// data in the pipeline will not be cleared.
//
// An accurate seek might be slower for formats that don't have any indexes or
// timestamp markers in the stream. Specifying this flag might require a
// complete scan of the file in those cases.
//
// When performing a segment seek: after the playback of the segment completes,
// no EOS will be emitted by the element that performed the seek, but a
// GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
// When this message is posted, it is possible to send a new seek event to
// continue playback. With this seek method it is possible to perform seamless
// looping or simple linear editing.
//
// When only changing the playback rate and not the direction, the
// GST_SEEK_FLAG_INSTANT_RATE_CHANGE flag can be used for a non-flushing seek to
// signal that the rate change should be applied immediately. This requires
// special support in the seek handlers (e.g. demuxers) and any elements
// synchronizing to the clock, and in general can't work in all cases (for
// example UDP streaming where the delivery rate is controlled by a remote
// server). The instant-rate-change mode supports changing the trickmode-related
// GST_SEEK_ flags, but can't be used in conjunction with other seek flags that
// affect the new playback position - as the playback position will not be
// changing.
//
// When doing fast forward (rate > 1.0) or fast reverse (rate < -1.0) trickmode
// playback, the GST_SEEK_FLAG_TRICKMODE flag can be used to instruct decoders
// and demuxers to adjust the playback rate by skipping frames. This can improve
// performance and decrease CPU usage because not all frames need to be decoded.
//
// Beyond that, the GST_SEEK_FLAG_TRICKMODE_KEY_UNITS flag can be used to
// request that decoders skip all frames except key units, and
// GST_SEEK_FLAG_TRICKMODE_NO_AUDIO flags can be used to request that audio
// decoders do no decoding at all, and simple output silence.
//
// The GST_SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous
// relevant location, and the GST_SEEK_FLAG_SNAP_AFTER flag can be used to
// select the next relevant location. If GST_SEEK_FLAG_KEY_UNIT is specified,
// the relevant location is a keyframe. If both flags are specified, the nearest
// of these locations will be selected. If none are specified, the
// implementation is free to select whichever it wants.
//
// The before and after here are in running time, so when playing backwards, the
// next location refers to the one that will played in next, and not the one
// that is located after in the actual source stream.
//
// Also see part-seeking.txt in the GStreamer design documentation for more
// details on the meaning of these flags and the behaviour expected of elements
// that handle them.
type SeekFlags C.guint

const (
	// SeekFlagNone: no flag.
	SeekFlagNone SeekFlags = 0b0
	// SeekFlagFlush: flush pipeline.
	SeekFlagFlush SeekFlags = 0b1
	// SeekFlagAccurate: accurate position is requested, this might be
	// considerably slower for some formats.
	SeekFlagAccurate SeekFlags = 0b10
	// SeekFlagKeyUnit: seek to the nearest keyframe. This might be faster but
	// less accurate.
	SeekFlagKeyUnit SeekFlags = 0b100
	// SeekFlagSegment: perform a segment seek.
	SeekFlagSegment SeekFlags = 0b1000
	// SeekFlagTrickmode: when doing fast forward or fast reverse playback,
	// allow elements to skip frames instead of generating all frames. (Since:
	// 1.6).
	SeekFlagTrickmode SeekFlags = 0b10000
	// SeekFlagSkip: deprecated backward compatibility flag, replaced by
	// GST_SEEK_FLAG_TRICKMODE.
	SeekFlagSkip SeekFlags = 0b10000
	// SeekFlagSnapBefore: go to a location before the requested position, if
	// GST_SEEK_FLAG_KEY_UNIT this means the keyframe at or before the requested
	// position the one at or before the seek target.
	SeekFlagSnapBefore SeekFlags = 0b100000
	// SeekFlagSnapAfter: go to a location after the requested position, if
	// GST_SEEK_FLAG_KEY_UNIT this means the keyframe at of after the requested
	// position.
	SeekFlagSnapAfter SeekFlags = 0b1000000
	// SeekFlagSnapNearest: go to a position near the requested position, if
	// GST_SEEK_FLAG_KEY_UNIT this means the keyframe closest to the requested
	// position, if both keyframes are at an equal distance, behaves like
	// GST_SEEK_FLAG_SNAP_BEFORE.
	SeekFlagSnapNearest SeekFlags = 0b1100000
	// SeekFlagTrickmodeKeyUnits: when doing fast forward or fast reverse
	// playback, request that elements only decode keyframes and skip all other
	// content, for formats that have keyframes. (Since: 1.6).
	SeekFlagTrickmodeKeyUnits SeekFlags = 0b10000000
	// SeekFlagTrickmodeNoAudio: when doing fast forward or fast reverse
	// playback, request that audio decoder elements skip decoding and output
	// only gap events or silence. (Since: 1.6).
	SeekFlagTrickmodeNoAudio SeekFlags = 0b100000000
	// SeekFlagTrickmodeForwardPredicted: when doing fast forward or fast
	// reverse playback, request that elements only decode keyframes and forward
	// predicted frames and skip all other content (for example B-Frames), for
	// formats that have keyframes and forward predicted frames. (Since: 1.18).
	SeekFlagTrickmodeForwardPredicted SeekFlags = 0b1000000000
	// SeekFlagInstantRateChange signals that a rate change should be applied
	// immediately. Only valid if start/stop position are GST_CLOCK_TIME_NONE,
	// the playback direction does not change and the seek is not flushing.
	// (Since: 1.18).
	SeekFlagInstantRateChange SeekFlags = 0b10000000000
)

func marshalSeekFlags(p uintptr) (interface{}, error) {
	return SeekFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SeekFlags.
func (s SeekFlags) String() string {
	if s == 0 {
		return "SeekFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SeekFlagNone:
			builder.WriteString("None|")
		case SeekFlagFlush:
			builder.WriteString("Flush|")
		case SeekFlagAccurate:
			builder.WriteString("Accurate|")
		case SeekFlagKeyUnit:
			builder.WriteString("KeyUnit|")
		case SeekFlagSegment:
			builder.WriteString("Segment|")
		case SeekFlagTrickmode:
			builder.WriteString("Trickmode|")
		case SeekFlagSnapBefore:
			builder.WriteString("SnapBefore|")
		case SeekFlagSnapAfter:
			builder.WriteString("SnapAfter|")
		case SeekFlagSnapNearest:
			builder.WriteString("SnapNearest|")
		case SeekFlagTrickmodeKeyUnits:
			builder.WriteString("TrickmodeKeyUnits|")
		case SeekFlagTrickmodeNoAudio:
			builder.WriteString("TrickmodeNoAudio|")
		case SeekFlagTrickmodeForwardPredicted:
			builder.WriteString("TrickmodeForwardPredicted|")
		case SeekFlagInstantRateChange:
			builder.WriteString("InstantRateChange|")
		default:
			builder.WriteString(fmt.Sprintf("SeekFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SeekFlags) Has(other SeekFlags) bool {
	return (s & other) == other
}

// SegmentFlags flags for the GstSegment structure. Currently mapped to the
// corresponding values of the seek flags.
type SegmentFlags C.guint

const (
	// SegmentFlagNone: no flags.
	SegmentFlagNone SegmentFlags = 0b0
	// SegmentFlagReset: reset the pipeline running_time to the segment
	// running_time.
	SegmentFlagReset SegmentFlags = 0b1
	// SegmentFlagTrickmode: perform skip playback (Since: 1.6).
	SegmentFlagTrickmode SegmentFlags = 0b10000
	// SegmentFlagSkip: deprecated backward compatibility flag, replaced by
	// GST_SEGMENT_FLAG_TRICKMODE.
	SegmentFlagSkip SegmentFlags = 0b10000
	// SegmentFlagSegment: send SEGMENT_DONE instead of EOS.
	SegmentFlagSegment SegmentFlags = 0b1000
	// SegmentFlagTrickmodeKeyUnits: decode only keyframes, where possible
	// (Since: 1.6).
	SegmentFlagTrickmodeKeyUnits SegmentFlags = 0b10000000
	// SegmentFlagTrickmodeForwardPredicted: decode only keyframes or forward
	// predicted frames, where possible (Since: 1.18).
	SegmentFlagTrickmodeForwardPredicted SegmentFlags = 0b1000000000
	// SegmentFlagTrickmodeNoAudio: do not decode any audio, where possible
	// (Since: 1.6).
	SegmentFlagTrickmodeNoAudio SegmentFlags = 0b100000000
)

func marshalSegmentFlags(p uintptr) (interface{}, error) {
	return SegmentFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SegmentFlags.
func (s SegmentFlags) String() string {
	if s == 0 {
		return "SegmentFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(182)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SegmentFlagNone:
			builder.WriteString("None|")
		case SegmentFlagReset:
			builder.WriteString("Reset|")
		case SegmentFlagTrickmode:
			builder.WriteString("Trickmode|")
		case SegmentFlagSegment:
			builder.WriteString("Segment|")
		case SegmentFlagTrickmodeKeyUnits:
			builder.WriteString("TrickmodeKeyUnits|")
		case SegmentFlagTrickmodeForwardPredicted:
			builder.WriteString("TrickmodeForwardPredicted|")
		case SegmentFlagTrickmodeNoAudio:
			builder.WriteString("TrickmodeNoAudio|")
		default:
			builder.WriteString(fmt.Sprintf("SegmentFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SegmentFlags) Has(other SegmentFlags) bool {
	return (s & other) == other
}

// Segment: this helper structure holds the relevant values for tracking the
// region of interest in a media file, called a segment.
//
// The structure can be used for two purposes:
//
//    * performing seeks (handling seek events)
//    * tracking playback regions (handling newsegment events)
//
// The segment is usually configured by the application with a seek event which
// is propagated upstream and eventually handled by an element that performs the
// seek.
//
// The configured segment is then propagated back downstream with a newsegment
// event. This information is then used to clip media to the segment boundaries.
//
// A segment structure is initialized with gst_segment_init(), which takes a
// Format that will be used as the format of the segment values. The segment
// will be configured with a start value of 0 and a stop/duration of -1, which
// is undefined. The default rate and applied_rate is 1.0.
//
// The public duration field contains the duration of the segment. When using
// the segment for seeking, the start and time members should normally be left
// to their default 0 value. The stop position is left to -1 unless explicitly
// configured to a different value after a seek event.
//
// The current position in the segment should be set by changing the position
// member in the structure.
//
// For elements that perform seeks, the current segment should be updated with
// the gst_segment_do_seek() and the values from the seek event. This method
// will update all the segment fields. The position field will contain the new
// playback position. If the start_type was different from GST_SEEK_TYPE_NONE,
// playback continues from the position position, possibly with updated flags or
// rate.
//
// For elements that want to use Segment to track the playback region, update
// the segment fields with the information from the newsegment event. The
// gst_segment_clip() method can be used to check and clip the media data to the
// segment boundaries.
//
// For elements that want to synchronize to the pipeline clock,
// gst_segment_to_running_time() can be used to convert a timestamp to a value
// that can be used to synchronize to the clock. This function takes into
// account the base as well as any rate or applied_rate conversions.
//
// For elements that need to perform operations on media data in stream_time,
// gst_segment_to_stream_time() can be used to convert a timestamp and the
// segment info to stream time (which is always between 0 and the duration of
// the stream).
//
// An instance of this type is always passed by reference.
type Segment struct {
	*segment
}

// segment is the struct that's finalized.
type segment struct {
	native *C.GstSegment
}

func marshalSegment(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Segment{&segment{(*C.GstSegment)(b)}}, nil
}

// NewSegment constructs a struct Segment.
func NewSegment() *Segment {
	var _cret *C.GstSegment // in

	_cret = C.gst_segment_new()

	var _segment *Segment // out

	_segment = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_segment)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_segment_free((*C.GstSegment)(intern.C))
		},
	)

	return _segment
}

// Flags flags for this segment.
func (s *Segment) Flags() SegmentFlags {
	valptr := &s.native.flags
	var _v SegmentFlags // out
	_v = SegmentFlags(*valptr)
	return _v
}

// Rate: playback rate of the segment is set in response to a seek event and,
// without any seek, the value should be 1.0. This value is used by elements
// that synchronize buffer [running
// times](additional/design/synchronisation.md#running-time) on the clock
// (usually the sink elements), leading to consuming buffers faster (for a value
// > 1.0) or slower (for 0.0 < value < 1.0) than normal playback speed. The rate
// also defines the playback direction, meaning that when the value is lower
// than 0.0, the playback happens in reverse, and the stream-time
// (additional/design/synchronisation.md#stream-time) is going backward. The
// rate value should never be 0.0.
func (s *Segment) Rate() float64 {
	valptr := &s.native.rate
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// AppliedRate: applied rate is the rate that has been applied to the stream.
// The effective/resulting playback rate of a stream is rate * applied_rate. The
// applied rate can be set by source elements when a server is sending the
// stream with an already modified playback speed rate. Filter elements that
// modify the stream in a way that modifies the playback speed should also
// modify the applied rate. For example the #videorate element when its
// #videorate:rate property is set will set the applied rate of the segment it
// pushed downstream. Also #scaletempo applies the input segment rate to the
// stream and outputs a segment with rate=1.0 and
// applied_rate=<inputsegment.rate>.
func (s *Segment) AppliedRate() float64 {
	valptr := &s.native.applied_rate
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// Format: unit used for all of the segment's values.
func (s *Segment) Format() Format {
	valptr := &s.native.format
	var _v Format // out
	_v = Format(*valptr)
	return _v
}

// Base: running time (plus elapsed time, see offset) of the segment start
// (GstSegment.start) (stop (GstSegment.stop) if rate < 0.0).
func (s *Segment) Base() uint64 {
	valptr := &s.native.base
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Offset: offset expresses the elapsed time (in buffer timestamps) before a
// seek with its start (stop if rate < 0.0) seek type set to T_SEEK_TYPE_NONE,
// the value is set to the position of the segment at the time of the seek.
func (s *Segment) Offset() uint64 {
	valptr := &s.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Start: start time of the segment (in buffer timestamps) (PTS)
// (GstBuffer.pts), that is the timestamp of the first buffer to output inside
// the segment (last one during reverse playback). For example decoders will
// clip (gst_segment_clip) out the buffers before the start time.
func (s *Segment) Start() uint64 {
	valptr := &s.native.start
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Stop: stop time of the segment (in buffer timestamps) (PTS) (GstBuffer.pts),
// that is the timestamp of the last buffer to output inside the segment (first
// one during reverse playback). For example decoders will clip
// (gst_segment_clip) out buffers after the stop time.
func (s *Segment) Stop() uint64 {
	valptr := &s.native.stop
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Time: stream time of the segment start (GstSegment.start) (stop
// (GstSegment.stop) if rate < 0.0).
func (s *Segment) Time() uint64 {
	valptr := &s.native.time
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Position: buffer timestamp position in the segment is supposed to be updated
// by elements such as sources, demuxers or parsers to track progress by setting
// it to the last pushed buffer' end time (timestamp (GstBuffer.pts) +
// Buffer.duration) for that specific segment. The position is used when
// reconfiguring the segment with #gst_segment_do_seek when the seek is only
// updating the segment (see offset (GstSegment.offset)).
func (s *Segment) Position() uint64 {
	valptr := &s.native.position
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Duration: duration of the segment is the maximum absolute difference between
// Segment.start and Segment.stop if stop is not set, otherwise it should be the
// difference between those two values. This should be set by elements that know
// the overall stream duration (like demuxers) and will be used when seeking
// with T_SEEK_TYPE_END.
func (s *Segment) Duration() uint64 {
	valptr := &s.native.duration
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Rate: playback rate of the segment is set in response to a seek event and,
// without any seek, the value should be 1.0. This value is used by elements
// that synchronize buffer [running
// times](additional/design/synchronisation.md#running-time) on the clock
// (usually the sink elements), leading to consuming buffers faster (for a value
// > 1.0) or slower (for 0.0 < value < 1.0) than normal playback speed. The rate
// also defines the playback direction, meaning that when the value is lower
// than 0.0, the playback happens in reverse, and the stream-time
// (additional/design/synchronisation.md#stream-time) is going backward. The
// rate value should never be 0.0.
func (s *Segment) SetRate(rate float64) {
	valptr := &s.native.rate
	*valptr = C.gdouble(rate)
}

// AppliedRate: applied rate is the rate that has been applied to the stream.
// The effective/resulting playback rate of a stream is rate * applied_rate. The
// applied rate can be set by source elements when a server is sending the
// stream with an already modified playback speed rate. Filter elements that
// modify the stream in a way that modifies the playback speed should also
// modify the applied rate. For example the #videorate element when its
// #videorate:rate property is set will set the applied rate of the segment it
// pushed downstream. Also #scaletempo applies the input segment rate to the
// stream and outputs a segment with rate=1.0 and
// applied_rate=<inputsegment.rate>.
func (s *Segment) SetAppliedRate(appliedRate float64) {
	valptr := &s.native.applied_rate
	*valptr = C.gdouble(appliedRate)
}

// Base: running time (plus elapsed time, see offset) of the segment start
// (GstSegment.start) (stop (GstSegment.stop) if rate < 0.0).
func (s *Segment) SetBase(base uint64) {
	valptr := &s.native.base
	*valptr = C.guint64(base)
}

// Offset: offset expresses the elapsed time (in buffer timestamps) before a
// seek with its start (stop if rate < 0.0) seek type set to T_SEEK_TYPE_NONE,
// the value is set to the position of the segment at the time of the seek.
func (s *Segment) SetOffset(offset uint64) {
	valptr := &s.native.offset
	*valptr = C.guint64(offset)
}

// Start: start time of the segment (in buffer timestamps) (PTS)
// (GstBuffer.pts), that is the timestamp of the first buffer to output inside
// the segment (last one during reverse playback). For example decoders will
// clip (gst_segment_clip) out the buffers before the start time.
func (s *Segment) SetStart(start uint64) {
	valptr := &s.native.start
	*valptr = C.guint64(start)
}

// Stop: stop time of the segment (in buffer timestamps) (PTS) (GstBuffer.pts),
// that is the timestamp of the last buffer to output inside the segment (first
// one during reverse playback). For example decoders will clip
// (gst_segment_clip) out buffers after the stop time.
func (s *Segment) SetStop(stop uint64) {
	valptr := &s.native.stop
	*valptr = C.guint64(stop)
}

// Time: stream time of the segment start (GstSegment.start) (stop
// (GstSegment.stop) if rate < 0.0).
func (s *Segment) SetTime(time uint64) {
	valptr := &s.native.time
	*valptr = C.guint64(time)
}

// Position: buffer timestamp position in the segment is supposed to be updated
// by elements such as sources, demuxers or parsers to track progress by setting
// it to the last pushed buffer' end time (timestamp (GstBuffer.pts) +
// Buffer.duration) for that specific segment. The position is used when
// reconfiguring the segment with #gst_segment_do_seek when the seek is only
// updating the segment (see offset (GstSegment.offset)).
func (s *Segment) SetPosition(position uint64) {
	valptr := &s.native.position
	*valptr = C.guint64(position)
}

// Duration: duration of the segment is the maximum absolute difference between
// Segment.start and Segment.stop if stop is not set, otherwise it should be the
// difference between those two values. This should be set by elements that know
// the overall stream duration (like demuxers) and will be used when seeking
// with T_SEEK_TYPE_END.
func (s *Segment) SetDuration(duration uint64) {
	valptr := &s.native.duration
	*valptr = C.guint64(duration)
}

// Clip the given start and stop values to the segment boundaries given in
// segment. start and stop are compared and clipped to segment start and stop
// values.
//
// If the function returns FALSE, start and stop are known to fall outside of
// segment and clip_start and clip_stop are not updated.
//
// When the function returns TRUE, clip_start and clip_stop will be updated. If
// clip_start or clip_stop are different from start or stop respectively, the
// region fell partially in the segment.
//
// Note that when stop is -1, clip_stop will be set to the end of the segment.
// Depending on the use case, this may or may not be what you want.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - start position in the segment.
//    - stop position in the segment.
//
// The function returns the following values:
//
//    - clipStart (optional): clipped start position in the segment.
//    - clipStop (optional): clipped stop position in the segment.
//    - ok: TRUE if the given start and stop times fall partially or completely
//      in segment, FALSE if the values are completely outside of the segment.
//
func (segment *Segment) Clip(format Format, start uint64, stop uint64) (clipStart uint64, clipStop uint64, ok bool) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // out
	var _arg4 C.guint64     // in
	var _arg5 C.guint64     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(start)
	_arg3 = C.guint64(stop)

	_cret = C.gst_segment_clip(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)

	var _clipStart uint64 // out
	var _clipStop uint64  // out
	var _ok bool          // out

	_clipStart = uint64(_arg4)
	_clipStop = uint64(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _clipStart, _clipStop, _ok
}

// Copy: create a copy of given segment.
//
// Free-function: gst_segment_free.
//
// The function returns the following values:
//
//    - ret: new Segment, free with gst_segment_free().
//
func (segment *Segment) Copy() *Segment {
	var _arg0 *C.GstSegment // out
	var _cret *C.GstSegment // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C.gst_segment_copy(_arg0)
	runtime.KeepAlive(segment)

	var _ret *Segment // out

	_ret = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_segment_free((*C.GstSegment)(intern.C))
		},
	)

	return _ret
}

// CopyInto: copy the contents of src into dest.
//
// The function takes the following parameters:
//
//    - dest: Segment.
//
func (src *Segment) CopyInto(dest *Segment) {
	var _arg0 *C.GstSegment // out
	var _arg1 *C.GstSegment // out

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(dest)))

	C.gst_segment_copy_into(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// DoSeek: update the segment structure with the field values of a seek event
// (see gst_event_new_seek()).
//
// After calling this method, the segment field position and time will contain
// the requested new position in the segment. The new requested position in the
// segment depends on rate and start_type and stop_type.
//
// For positive rate, the new position in the segment is the new segment start
// field when it was updated with a start_type different from T_SEEK_TYPE_NONE.
// If no update was performed on segment start position (T_SEEK_TYPE_NONE),
// start is ignored and segment position is unmodified.
//
// For negative rate, the new position in the segment is the new segment stop
// field when it was updated with a stop_type different from T_SEEK_TYPE_NONE.
// If no stop was previously configured in the segment, the duration of the
// segment will be used to update the stop position. If no update was performed
// on segment stop position (T_SEEK_TYPE_NONE), stop is ignored and segment
// position is unmodified.
//
// The applied rate of the segment will be set to 1.0 by default. If the caller
// can apply a rate change, it should update segment rate and applied_rate after
// calling this function.
//
// update will be set to TRUE if a seek should be performed to the segment
// position field. This field can be FALSE if, for example, only the rate has
// been changed but not the playback position.
//
// The function takes the following parameters:
//
//    - rate of the segment.
//    - format of the segment.
//    - flags: segment flags for the segment.
//    - startType: seek method.
//    - start: seek start value.
//    - stopType: seek method.
//    - stop: seek stop value.
//
// The function returns the following values:
//
//    - update (optional): boolean holding whether position was updated.
//    - ok: TRUE if the seek could be performed.
//
func (segment *Segment) DoSeek(rate float64, format Format, flags SeekFlags, startType SeekType, start uint64, stopType SeekType, stop uint64) (update bool, ok bool) {
	var _arg0 *C.GstSegment  // out
	var _arg1 C.gdouble      // out
	var _arg2 C.GstFormat    // out
	var _arg3 C.GstSeekFlags // out
	var _arg4 C.GstSeekType  // out
	var _arg5 C.guint64      // out
	var _arg6 C.GstSeekType  // out
	var _arg7 C.guint64      // out
	var _arg8 C.gboolean     // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.GstSeekFlags(flags)
	_arg4 = C.GstSeekType(startType)
	_arg5 = C.guint64(start)
	_arg6 = C.GstSeekType(stopType)
	_arg7 = C.guint64(stop)

	_cret = C.gst_segment_do_seek(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_arg8)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stopType)
	runtime.KeepAlive(stop)

	var _update bool // out
	var _ok bool     // out

	if _arg8 != 0 {
		_update = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _update, _ok
}

// Init: start/position fields are set to 0 and the stop/duration fields are set
// to -1 (unknown). The default rate of 1.0 and no flags are set.
//
// Initialize segment to its default values.
//
// The function takes the following parameters:
//
//    - format of the segment.
//
func (segment *Segment) Init(format Format) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)

	C.gst_segment_init(_arg0, _arg1)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
}

// IsEqual checks for two segments being equal. Equality here is defined as
// perfect equality, including floating point values.
//
// The function takes the following parameters:
//
//    - s1: Segment structure.
//
// The function returns the following values:
//
//    - ok: TRUE if the segments are equal, FALSE otherwise.
//
func (s0 *Segment) IsEqual(s1 *Segment) bool {
	var _arg0 *C.GstSegment // out
	var _arg1 *C.GstSegment // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(s0)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(s1)))

	_cret = C.gst_segment_is_equal(_arg0, _arg1)
	runtime.KeepAlive(s0)
	runtime.KeepAlive(s1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OffsetRunningTime: adjust the values in segment so that offset is applied to
// all future running-time calculations.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - offset to apply in the segment.
//
// The function returns the following values:
//
//    - ok: TRUE if the segment could be updated successfully. If FALSE is
//      returned, offset is not in segment.
//
func (segment *Segment) OffsetRunningTime(format Format, offset int64) bool {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(offset)

	_cret = C.gst_segment_offset_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(offset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PositionFromRunningTime: convert running_time into a position in the segment
// so that gst_segment_to_running_time() with that position returns
// running_time.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - runningTime: running_time in the segment.
//
// The function returns the following values:
//
//    - guint64: position in the segment for running_time. This function returns
//      -1 when running_time is -1 or when it is not inside segment.
//
func (segment *Segment) PositionFromRunningTime(format Format, runningTime uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_position_from_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// PositionFromRunningTimeFull: translate running_time to the segment position
// using the currently configured segment. Compared to
// gst_segment_position_from_running_time() this function can return negative
// segment position.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// running_time can be any value and the result of this function for values
// outside of the segment is extrapolated.
//
// When 1 is returned, running_time resulted in a positive position returned in
// position.
//
// When this function returns -1, the returned position was < 0, and the value
// in the position variable should be negated to get the real negative segment
// position.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - runningTime: running-time.
//
// The function returns the following values:
//
//    - position: resulting position in the segment.
//    - gint: 1 or -1 on success, 0 on failure.
//
func (segment *Segment) PositionFromRunningTimeFull(format Format, runningTime uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_position_from_running_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _position uint64 // out
	var _gint int        // out

	_position = uint64(_arg3)
	_gint = int(_cret)

	return _position, _gint
}

// PositionFromStreamTime: convert stream_time into a position in the segment so
// that gst_segment_to_stream_time() with that position returns stream_time.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - streamTime: stream_time in the segment.
//
// The function returns the following values:
//
//    - guint64: position in the segment for stream_time. This function returns
//      -1 when stream_time is -1 or when it is not inside segment.
//
func (segment *Segment) PositionFromStreamTime(format Format, streamTime uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(streamTime)

	_cret = C.gst_segment_position_from_stream_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(streamTime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// PositionFromStreamTimeFull: translate stream_time to the segment position
// using the currently configured segment. Compared to
// gst_segment_position_from_stream_time() this function can return negative
// segment position.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// stream_time can be any value and the result of this function for values
// outside of the segment is extrapolated.
//
// When 1 is returned, stream_time resulted in a positive position returned in
// position.
//
// When this function returns -1, the returned position should be negated to get
// the real negative segment position.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - streamTime: stream-time.
//
// The function returns the following values:
//
//    - position: resulting position in the segment.
//    - gint: 1 or -1 on success, 0 on failure.
//
func (segment *Segment) PositionFromStreamTimeFull(format Format, streamTime uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(streamTime)

	_cret = C.gst_segment_position_from_stream_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(streamTime)

	var _position uint64 // out
	var _gint int        // out

	_position = uint64(_arg3)
	_gint = int(_cret)

	return _position, _gint
}

// SetRunningTime: adjust the start/stop and base values of segment such that
// the next valid buffer will be one with running_time.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - runningTime: running_time in the segment.
//
// The function returns the following values:
//
//    - ok: TRUE if the segment could be updated successfully. If FALSE is
//      returned, running_time is -1 or not in segment.
//
func (segment *Segment) SetRunningTime(format Format, runningTime uint64) bool {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_set_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToPosition: convert running_time into a position in the segment so that
// gst_segment_to_running_time() with that position returns running_time.
//
// Deprecated: Use gst_segment_position_from_running_time() instead.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - runningTime: running_time in the segment.
//
// The function returns the following values:
//
//    - guint64: position in the segment for running_time. This function returns
//      -1 when running_time is -1 or when it is not inside segment.
//
func (segment *Segment) ToPosition(format Format, runningTime uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_to_position(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToRunningTime: translate position to the total running time using the
// currently configured segment. Position is a value between segment start and
// stop time.
//
// This function is typically used by elements that need to synchronize to the
// global clock in a pipeline. The running time is a constantly increasing value
// starting from 0. When gst_segment_init() is called, this value will reset to
// 0.
//
// This function returns -1 if the position is outside of segment start and
// stop.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - position in the segment.
//
// The function returns the following values:
//
//    - guint64: position as the total running time or -1 when an invalid
//      position was given.
//
func (segment *Segment) ToRunningTime(format Format, position uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToRunningTimeFull: translate position to the total running time using the
// currently configured segment. Compared to gst_segment_to_running_time() this
// function can return negative running-time.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// position can be any value and the result of this function for values outside
// of the segment is extrapolated.
//
// When 1 is returned, position resulted in a positive running-time returned in
// running_time.
//
// When this function returns -1, the returned running_time should be negated to
// get the real negative running time.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - position in the segment.
//
// The function returns the following values:
//
//    - runningTime (optional): result running-time.
//    - gint: 1 or -1 on success, 0 on failure.
//
func (segment *Segment) ToRunningTimeFull(format Format, position uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_running_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _runningTime uint64 // out
	var _gint int           // out

	_runningTime = uint64(_arg3)
	_gint = int(_cret)

	return _runningTime, _gint
}

// ToStreamTime: translate position to stream time using the currently
// configured segment. The position value must be between segment start and stop
// value.
//
// This function is typically used by elements that need to operate on the
// stream time of the buffers it receives, such as effect plugins. In those use
// cases, position is typically the buffer timestamp or clock time that one
// wants to convert to the stream time. The stream time is always between 0 and
// the total duration of the media stream.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - position in the segment.
//
// The function returns the following values:
//
//    - guint64: position in stream_time or -1 when an invalid position was
//      given.
//
func (segment *Segment) ToStreamTime(format Format, position uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_stream_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToStreamTimeFull: translate position to the total stream time using the
// currently configured segment. Compared to gst_segment_to_stream_time() this
// function can return negative stream-time.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// position can be any value and the result of this function for values outside
// of the segment is extrapolated.
//
// When 1 is returned, position resulted in a positive stream-time returned in
// stream_time.
//
// When this function returns -1, the returned stream_time should be negated to
// get the real negative stream time.
//
// The function takes the following parameters:
//
//    - format of the segment.
//    - position in the segment.
//
// The function returns the following values:
//
//    - streamTime: result stream-time.
//    - gint: 1 or -1 on success, 0 on failure.
//
func (segment *Segment) ToStreamTimeFull(format Format, position uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_stream_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _streamTime uint64 // out
	var _gint int          // out

	_streamTime = uint64(_arg3)
	_gint = int(_cret)

	return _streamTime, _gint
}
