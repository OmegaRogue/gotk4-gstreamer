// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_PadTemplate_ConnectPadCreated(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_PadTemplateClass_pad_created(GstPadTemplate*, GstPad*);
// void _gotk4_gst1_PadTemplate_virtual_pad_created(void* fnptr, GstPadTemplate* arg0, GstPad* arg1) {
//   ((void (*)(GstPadTemplate*, GstPad*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypePadPresence      = coreglib.Type(C.gst_pad_presence_get_type())
	GTypePadTemplateFlags = coreglib.Type(C.gst_pad_template_flags_get_type())
	GTypePadTemplate      = coreglib.Type(C.gst_pad_template_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePadPresence, F: marshalPadPresence},
		coreglib.TypeMarshaler{T: GTypePadTemplateFlags, F: marshalPadTemplateFlags},
		coreglib.TypeMarshaler{T: GTypePadTemplate, F: marshalPadTemplate},
	})
}

// PadPresence indicates when this pad will become available.
type PadPresence C.gint

const (
	// PadAlways: pad is always available.
	PadAlways PadPresence = iota
	// PadSometimes: pad will become available depending on the media stream.
	PadSometimes
	// PadRequest: pad is only available on request with
	// gst_element_request_pad().
	PadRequest
)

func marshalPadPresence(p uintptr) (interface{}, error) {
	return PadPresence(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadPresence.
func (p PadPresence) String() string {
	switch p {
	case PadAlways:
		return "Always"
	case PadSometimes:
		return "Sometimes"
	case PadRequest:
		return "Request"
	default:
		return fmt.Sprintf("PadPresence(%d)", p)
	}
}

// PadTemplateFlags flags for the padtemplate.
type PadTemplateFlags C.guint

const (
	// PadTemplateFlagLast: first flag that can be used by subclasses.
	PadTemplateFlagLast PadTemplateFlags = 0b100000000
)

func marshalPadTemplateFlags(p uintptr) (interface{}, error) {
	return PadTemplateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadTemplateFlags.
func (p PadTemplateFlags) String() string {
	if p == 0 {
		return "PadTemplateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(19)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadTemplateFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("PadTemplateFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadTemplateFlags) Has(other PadTemplateFlags) bool {
	return (p & other) == other
}

// The function returns the following values:
//
func StaticPadTemplateGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_static_pad_template_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// PadTemplateOverrides contains methods that are overridable.
type PadTemplateOverrides struct {
	// PadCreated: emit the pad-created signal for this template when created by
	// this pad.
	//
	// The function takes the following parameters:
	//
	//    - pad that created it.
	//
	PadCreated func(pad *Pad)
}

func defaultPadTemplateOverrides(v *PadTemplate) PadTemplateOverrides {
	return PadTemplateOverrides{
		PadCreated: v.padCreated,
	}
}

// PadTemplate padtemplates describe the possible media types a pad or an
// elementfactory can handle. This allows for both inspection of handled types
// before loading the element plugin as well as identifying pads on elements
// that are not yet created (request or sometimes pads).
//
// Pad and PadTemplates have Caps attached to it to describe the media type they
// are capable of dealing with. gst_pad_template_get_caps() or
// GST_PAD_TEMPLATE_CAPS() are used to get the caps of a padtemplate. It's not
// possible to modify the caps of a padtemplate after creation.
//
// PadTemplates have a PadPresence property which identifies the lifetime of the
// pad and that can be retrieved with GST_PAD_TEMPLATE_PRESENCE(). Also the
// direction of the pad can be retrieved from the PadTemplate with
// GST_PAD_TEMPLATE_DIRECTION().
//
// The GST_PAD_TEMPLATE_NAME_TEMPLATE () is important for GST_PAD_REQUEST pads
// because it has to be used as the name in the gst_element_request_pad_simple()
// call to instantiate a pad from this template.
//
// Padtemplates can be created with gst_pad_template_new() or with
// gst_static_pad_template_get (), which creates a PadTemplate from a
// StaticPadTemplate that can be filled with the convenient
// GST_STATIC_PAD_TEMPLATE() macro.
//
// A padtemplate can be used to create a pad (see gst_pad_new_from_template() or
// gst_pad_new_from_static_template ()) or to add to an element class (see
// gst_element_class_add_static_pad_template ()).
//
// The following code example shows the code to create a pad from a padtemplate.
//
//      static void
//      my_element_class_init (GstMyElementClass *klass)
//      {
//        GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
//
//        gst_element_class_add_static_pad_template (gstelement_class, &my_template);
//      }.
type PadTemplate struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*PadTemplate)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*PadTemplate, *PadTemplateClass, PadTemplateOverrides](
		GTypePadTemplate,
		initPadTemplateClass,
		wrapPadTemplate,
		defaultPadTemplateOverrides,
	)
}

func initPadTemplateClass(gclass unsafe.Pointer, overrides PadTemplateOverrides, classInitFunc func(*PadTemplateClass)) {
	pclass := (*C.GstPadTemplateClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePadTemplate))))

	if overrides.PadCreated != nil {
		pclass.pad_created = (*[0]byte)(C._gotk4_gst1_PadTemplateClass_pad_created)
	}

	if classInitFunc != nil {
		class := (*PadTemplateClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPadTemplate(obj *coreglib.Object) *PadTemplate {
	return &PadTemplate{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPadTemplate(p uintptr) (interface{}, error) {
	return wrapPadTemplate(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPadCreated: this signal is fired when an element creates a pad from
// this template.
func (templ *PadTemplate) ConnectPadCreated(f func(pad *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(templ, "pad-created", false, unsafe.Pointer(C._gotk4_gst1_PadTemplate_ConnectPadCreated), f)
}

// NewPadTemplate creates a new pad template with a name according to the given
// template and with the given arguments.
//
// The function takes the following parameters:
//
//    - nameTemplate: name template.
//    - direction of the template.
//    - presence of the pad.
//    - caps set for the template.
//
// The function returns the following values:
//
//    - padTemplate (optional): new PadTemplate.
//
func NewPadTemplate(nameTemplate string, direction PadDirection, presence PadPresence, caps *Caps) *PadTemplate {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _arg3 C.GstPadPresence  // out
	var _arg4 *C.GstCaps        // out
	var _cret *C.GstPadTemplate // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nameTemplate)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = C.GstPadPresence(presence)
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pad_template_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(nameTemplate)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(presence)
	runtime.KeepAlive(caps)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// NewPadTemplateFromStaticPadTemplateWithGType converts a StaticPadTemplate
// into a PadTemplate with a type.
//
// The function takes the following parameters:
//
//    - padTemplate: static pad template.
//    - padType of the pad to create.
//
// The function returns the following values:
//
//    - padTemplate (optional): new PadTemplate.
//
func NewPadTemplateFromStaticPadTemplateWithGType(padTemplate *StaticPadTemplate, padType coreglib.Type) *PadTemplate {
	var _arg1 *C.GstStaticPadTemplate // out
	var _arg2 C.GType                 // out
	var _cret *C.GstPadTemplate       // in

	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(padTemplate)))
	_arg2 = C.GType(padType)

	_cret = C.gst_pad_template_new_from_static_pad_template_with_gtype(_arg1, _arg2)
	runtime.KeepAlive(padTemplate)
	runtime.KeepAlive(padType)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// NewPadTemplateWithGType creates a new pad template with a name according to
// the given template and with the given arguments.
//
// The function takes the following parameters:
//
//    - nameTemplate: name template.
//    - direction of the template.
//    - presence of the pad.
//    - caps set for the template.
//    - padType of the pad to create.
//
// The function returns the following values:
//
//    - padTemplate (optional): new PadTemplate.
//
func NewPadTemplateWithGType(nameTemplate string, direction PadDirection, presence PadPresence, caps *Caps, padType coreglib.Type) *PadTemplate {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _arg3 C.GstPadPresence  // out
	var _arg4 *C.GstCaps        // out
	var _arg5 C.GType           // out
	var _cret *C.GstPadTemplate // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nameTemplate)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = C.GstPadPresence(presence)
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg5 = C.GType(padType)

	_cret = C.gst_pad_template_new_with_gtype(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(nameTemplate)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(presence)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(padType)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// Caps gets the capabilities of the pad template.
//
// The function returns the following values:
//
//    - caps of the pad template. Unref after usage.
//
func (templ *PadTemplate) Caps() *Caps {
	var _arg0 *C.GstPadTemplate // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_pad_template_get_caps(_arg0)
	runtime.KeepAlive(templ)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// DocumentationCaps: see gst_pad_template_set_documentation_caps().
//
// The function returns the following values:
//
//    - caps to document. For convenience, this will return
//      gst_pad_template_get_caps() when no documentation caps were set.
//
func (templ *PadTemplate) DocumentationCaps() *Caps {
	var _arg0 *C.GstPadTemplate // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_pad_template_get_documentation_caps(_arg0)
	runtime.KeepAlive(templ)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// PadCreated: emit the pad-created signal for this template when created by
// this pad.
//
// The function takes the following parameters:
//
//    - pad that created it.
//
func (templ *PadTemplate) PadCreated(pad *Pad) {
	var _arg0 *C.GstPadTemplate // out
	var _arg1 *C.GstPad         // out

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_pad_template_pad_created(_arg0, _arg1)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(pad)
}

// SetDocumentationCaps: certain elements will dynamically construct the caps of
// their pad templates. In order not to let environment-specific information
// into the documentation, element authors should use this method to expose
// "stable" caps to the reader.
//
// The function takes the following parameters:
//
//    - caps: documented capabilities.
//
func (templ *PadTemplate) SetDocumentationCaps(caps *Caps) {
	var _arg0 *C.GstPadTemplate // out
	var _arg1 *C.GstCaps        // out

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	C.gst_pad_template_set_documentation_caps(_arg0, _arg1)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(caps)
}

// padCreated: emit the pad-created signal for this template when created by
// this pad.
//
// The function takes the following parameters:
//
//    - pad that created it.
//
func (templ *PadTemplate) padCreated(pad *Pad) {
	gclass := (*C.GstPadTemplateClass)(coreglib.PeekParentClass(templ))
	fnarg := gclass.pad_created

	var _arg0 *C.GstPadTemplate // out
	var _arg1 *C.GstPad         // out

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_PadTemplate_virtual_pad_created(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(pad)
}

// PadTemplateClass: instance of this type is always passed by reference.
type PadTemplateClass struct {
	*padTemplateClass
}

// padTemplateClass is the struct that's finalized.
type padTemplateClass struct {
	native *C.GstPadTemplateClass
}

func (p *PadTemplateClass) ParentClass() *ObjectClass {
	valptr := &p.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// StaticPadTemplate: structure describing the StaticPadTemplate.
//
// An instance of this type is always passed by reference.
type StaticPadTemplate struct {
	*staticPadTemplate
}

// staticPadTemplate is the struct that's finalized.
type staticPadTemplate struct {
	native *C.GstStaticPadTemplate
}

// NameTemplate: name of the template.
func (s *StaticPadTemplate) NameTemplate() string {
	valptr := &s.native.name_template
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Direction: direction of the template.
func (s *StaticPadTemplate) Direction() PadDirection {
	valptr := &s.native.direction
	var _v PadDirection // out
	_v = PadDirection(*valptr)
	return _v
}

// Presence: presence of the template.
func (s *StaticPadTemplate) Presence() PadPresence {
	valptr := &s.native.presence
	var _v PadPresence // out
	_v = PadPresence(*valptr)
	return _v
}

// StaticCaps caps of the template.
func (s *StaticPadTemplate) StaticCaps() *StaticCaps {
	valptr := &s.native.static_caps
	var _v *StaticCaps // out
	_v = (*StaticCaps)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Get converts a StaticPadTemplate into a PadTemplate.
//
// The function returns the following values:
//
//    - padTemplate (optional): new PadTemplate.
//
func (padTemplate *StaticPadTemplate) Get() *PadTemplate {
	var _arg0 *C.GstStaticPadTemplate // out
	var _cret *C.GstPadTemplate       // in

	_arg0 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(padTemplate)))

	_cret = C.gst_static_pad_template_get(_arg0)
	runtime.KeepAlive(padTemplate)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// Caps gets the capabilities of the static pad template.
//
// The function returns the following values:
//
//    - caps of the static pad template. Unref after usage. Since the core holds
//      an additional ref to the returned caps, use gst_caps_make_writable() on
//      the returned caps to modify it.
//
func (templ *StaticPadTemplate) Caps() *Caps {
	var _arg0 *C.GstStaticPadTemplate // out
	var _cret *C.GstCaps              // in

	_arg0 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(templ)))

	_cret = C.gst_static_pad_template_get_caps(_arg0)
	runtime.KeepAlive(templ)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}
