// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gboolean _gotk4_gst1_ControlBindingClass_sync_values(GstControlBinding*, GstObject*, GstClockTime, GstClockTime);
// extern gboolean _gotk4_gst1_ControlBindingClass_get_g_value_array(GstControlBinding*, GstClockTime, GstClockTime, guint, GValue*);
// extern GValue* _gotk4_gst1_ControlBindingClass_get_value(GstControlBinding*, GstClockTime);
// GValue* _gotk4_gst1_ControlBinding_virtual_get_value(void* fnptr, GstControlBinding* arg0, GstClockTime arg1) {
//   return ((GValue* (*)(GstControlBinding*, GstClockTime))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_ControlBinding_virtual_get_g_value_array(void* fnptr, GstControlBinding* arg0, GstClockTime arg1, GstClockTime arg2, guint arg3, GValue* arg4) {
//   return ((gboolean (*)(GstControlBinding*, GstClockTime, GstClockTime, guint, GValue*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gst1_ControlBinding_virtual_sync_values(void* fnptr, GstControlBinding* arg0, GstObject* arg1, GstClockTime arg2, GstClockTime arg3) {
//   return ((gboolean (*)(GstControlBinding*, GstObject*, GstClockTime, GstClockTime))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeControlBinding = coreglib.Type(C.gst_control_binding_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeControlBinding, F: marshalControlBinding},
	})
}

// ControlBindingOverrides contains methods that are overridable.
type ControlBindingOverrides struct {
	// GValueArray gets a number of #GValues for the given controlled property
	// starting at the requested time. The array values need to hold enough
	// space for n_values of #GValue.
	//
	// This function is useful if one wants to e.g. draw a graph of the control
	// curve or apply a control curve sample by sample.
	//
	// The function takes the following parameters:
	//
	//    - timestamp: time that should be processed.
	//    - interval: time spacing between subsequent values.
	//    - values: array to put control-values in.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the given array could be filled, FALSE otherwise.
	//
	GValueArray func(timestamp, interval ClockTime, values []coreglib.Value) bool
	// Value gets the value for the given controlled property at the requested
	// time.
	//
	// The function takes the following parameters:
	//
	//    - timestamp: time the control-change should be read from.
	//
	// The function returns the following values:
	//
	//    - value (optional): GValue of the property at the given time, or NULL
	//      if the property isn't controlled.
	//
	Value func(timestamp ClockTime) *coreglib.Value
	// SyncValues sets the property of the object, according to the
	// ControlSources that handles it and for the given timestamp.
	//
	// If this function fails, it is most likely the application developers
	// fault. Most probably the control sources are not setup correctly.
	//
	// The function takes the following parameters:
	//
	//    - object that has controlled properties.
	//    - timestamp: time that should be processed.
	//    - lastSync: last time this was called.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the controller value could be applied to the object
	//      property, FALSE otherwise.
	//
	SyncValues func(object GstObjector, timestamp, lastSync ClockTime) bool
}

func defaultControlBindingOverrides(v *ControlBinding) ControlBindingOverrides {
	return ControlBindingOverrides{
		GValueArray: v.gValueArray,
		Value:       v.value,
		SyncValues:  v.syncValues,
	}
}

// ControlBinding: base class for value mapping objects that attaches control
// sources to #GObject properties. Such an object is taking one or more
// ControlSource instances, combines them and maps the resulting value to the
// type and value range of the bound property.
type ControlBinding struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*ControlBinding)(nil)
)

// ControlBindinger describes types inherited from class ControlBinding.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ControlBindinger interface {
	coreglib.Objector
	baseControlBinding() *ControlBinding
}

var _ ControlBindinger = (*ControlBinding)(nil)

func init() {
	coreglib.RegisterClassInfo[*ControlBinding, *ControlBindingClass, ControlBindingOverrides](
		GTypeControlBinding,
		initControlBindingClass,
		wrapControlBinding,
		defaultControlBindingOverrides,
	)
}

func initControlBindingClass(gclass unsafe.Pointer, overrides ControlBindingOverrides, classInitFunc func(*ControlBindingClass)) {
	pclass := (*C.GstControlBindingClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeControlBinding))))

	if overrides.GValueArray != nil {
		pclass.get_g_value_array = (*[0]byte)(C._gotk4_gst1_ControlBindingClass_get_g_value_array)
	}

	if overrides.Value != nil {
		pclass.get_value = (*[0]byte)(C._gotk4_gst1_ControlBindingClass_get_value)
	}

	if overrides.SyncValues != nil {
		pclass.sync_values = (*[0]byte)(C._gotk4_gst1_ControlBindingClass_sync_values)
	}

	if classInitFunc != nil {
		class := (*ControlBindingClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapControlBinding(obj *coreglib.Object) *ControlBinding {
	return &ControlBinding{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalControlBinding(p uintptr) (interface{}, error) {
	return wrapControlBinding(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (binding *ControlBinding) baseControlBinding() *ControlBinding {
	return binding
}

// BaseControlBinding returns the underlying base object.
func BaseControlBinding(obj ControlBindinger) *ControlBinding {
	return obj.baseControlBinding()
}

// GValueArray gets a number of #GValues for the given controlled property
// starting at the requested time. The array values need to hold enough space
// for n_values of #GValue.
//
// This function is useful if one wants to e.g. draw a graph of the control
// curve or apply a control curve sample by sample.
//
// The function takes the following parameters:
//
//    - timestamp: time that should be processed.
//    - interval: time spacing between subsequent values.
//    - values: array to put control-values in.
//
// The function returns the following values:
//
//    - ok: TRUE if the given array could be filled, FALSE otherwise.
//
func (binding *ControlBinding) GValueArray(timestamp, interval ClockTime, values []coreglib.Value) bool {
	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _arg2 C.GstClockTime       // out
	var _arg4 *C.GValue            // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(interval)
	type _ = ClockTime
	type _ = uint64
	_arg3 = (C.guint)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_control_binding_get_g_value_array(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the value for the given controlled property at the requested time.
//
// The function takes the following parameters:
//
//    - timestamp: time the control-change should be read from.
//
// The function returns the following values:
//
//    - value (optional): GValue of the property at the given time, or NULL if
//      the property isn't controlled.
//
func (binding *ControlBinding) Value(timestamp ClockTime) *coreglib.Value {
	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _cret *C.GValue            // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_control_binding_get_value(_arg0, _arg1)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
		runtime.SetFinalizer(_value, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
	}

	return _value
}

// IsDisabled checks if the control binding is disabled.
//
// The function returns the following values:
//
//    - ok: TRUE if the binding is inactive.
//
func (binding *ControlBinding) IsDisabled() bool {
	var _arg0 *C.GstControlBinding // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))

	_cret = C.gst_control_binding_is_disabled(_arg0)
	runtime.KeepAlive(binding)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDisabled: this function is used to disable a control binding for some
// time, i.e. gst_object_sync_values() will do nothing.
//
// The function takes the following parameters:
//
//    - disabled: boolean that specifies whether to disable the controller or
//      not.
//
func (binding *ControlBinding) SetDisabled(disabled bool) {
	var _arg0 *C.GstControlBinding // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	if disabled {
		_arg1 = C.TRUE
	}

	C.gst_control_binding_set_disabled(_arg0, _arg1)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(disabled)
}

// SyncValues sets the property of the object, according to the ControlSources
// that handles it and for the given timestamp.
//
// If this function fails, it is most likely the application developers fault.
// Most probably the control sources are not setup correctly.
//
// The function takes the following parameters:
//
//    - object that has controlled properties.
//    - timestamp: time that should be processed.
//    - lastSync: last time this was called.
//
// The function returns the following values:
//
//    - ok: TRUE if the controller value could be applied to the object property,
//      FALSE otherwise.
//
func (binding *ControlBinding) SyncValues(object GstObjector, timestamp, lastSync ClockTime) bool {
	var _arg0 *C.GstControlBinding // out
	var _arg1 *C.GstObject         // out
	var _arg2 C.GstClockTime       // out
	var _arg3 C.GstClockTime       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg2 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(lastSync)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_control_binding_sync_values(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(object)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(lastSync)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// gValueArray gets a number of #GValues for the given controlled property
// starting at the requested time. The array values need to hold enough space
// for n_values of #GValue.
//
// This function is useful if one wants to e.g. draw a graph of the control
// curve or apply a control curve sample by sample.
//
// The function takes the following parameters:
//
//    - timestamp: time that should be processed.
//    - interval: time spacing between subsequent values.
//    - values: array to put control-values in.
//
// The function returns the following values:
//
//    - ok: TRUE if the given array could be filled, FALSE otherwise.
//
func (binding *ControlBinding) gValueArray(timestamp, interval ClockTime, values []coreglib.Value) bool {
	gclass := (*C.GstControlBindingClass)(coreglib.PeekParentClass(binding))
	fnarg := gclass.get_g_value_array

	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _arg2 C.GstClockTime       // out
	var _arg4 *C.GValue            // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(interval)
	type _ = ClockTime
	type _ = uint64
	_arg3 = (C.guint)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C._gotk4_gst1_ControlBinding_virtual_get_g_value_array(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the value for the given controlled property at the requested time.
//
// The function takes the following parameters:
//
//    - timestamp: time the control-change should be read from.
//
// The function returns the following values:
//
//    - value (optional): GValue of the property at the given time, or NULL if
//      the property isn't controlled.
//
func (binding *ControlBinding) value(timestamp ClockTime) *coreglib.Value {
	gclass := (*C.GstControlBindingClass)(coreglib.PeekParentClass(binding))
	fnarg := gclass.get_value

	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _cret *C.GValue            // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64

	_cret = C._gotk4_gst1_ControlBinding_virtual_get_value(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
		runtime.SetFinalizer(_value, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
	}

	return _value
}

// syncValues sets the property of the object, according to the ControlSources
// that handles it and for the given timestamp.
//
// If this function fails, it is most likely the application developers fault.
// Most probably the control sources are not setup correctly.
//
// The function takes the following parameters:
//
//    - object that has controlled properties.
//    - timestamp: time that should be processed.
//    - lastSync: last time this was called.
//
// The function returns the following values:
//
//    - ok: TRUE if the controller value could be applied to the object property,
//      FALSE otherwise.
//
func (binding *ControlBinding) syncValues(object GstObjector, timestamp, lastSync ClockTime) bool {
	gclass := (*C.GstControlBindingClass)(coreglib.PeekParentClass(binding))
	fnarg := gclass.sync_values

	var _arg0 *C.GstControlBinding // out
	var _arg1 *C.GstObject         // out
	var _arg2 C.GstClockTime       // out
	var _arg3 C.GstClockTime       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg2 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(lastSync)
	type _ = ClockTime
	type _ = uint64

	_cret = C._gotk4_gst1_ControlBinding_virtual_sync_values(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(object)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(lastSync)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ControlBindingClass class structure of ControlBinding.
//
// An instance of this type is always passed by reference.
type ControlBindingClass struct {
	*controlBindingClass
}

// controlBindingClass is the struct that's finalized.
type controlBindingClass struct {
	native *C.GstControlBindingClass
}

// ParentClass: parent class.
func (c *ControlBindingClass) ParentClass() *ObjectClass {
	valptr := &c.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
