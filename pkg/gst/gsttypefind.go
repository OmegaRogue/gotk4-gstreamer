// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_TypeFindFunction(GstTypeFind*, gpointer);
import "C"

// GType values.
var (
	GTypeTypeFindProbability = coreglib.Type(C.gst_type_find_probability_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTypeFindProbability, F: marshalTypeFindProbability},
	})
}

// TypeFindProbability: probability of the typefind function. Higher values have
// more certainty in doing a reliable typefind.
type TypeFindProbability C.gint

const (
	// TypeFindNone: type undetected.
	TypeFindNone TypeFindProbability = 0
	// TypeFindMinimum: unlikely typefind.
	TypeFindMinimum TypeFindProbability = 1
	// TypeFindPossible: possible type detected.
	TypeFindPossible TypeFindProbability = 50
	// TypeFindLikely: likely a type was detected.
	TypeFindLikely TypeFindProbability = 80
	// TypeFindNearlyCertain: nearly certain that a type was detected.
	TypeFindNearlyCertain TypeFindProbability = 99
	// TypeFindMaximum: very certain a type was detected.
	TypeFindMaximum TypeFindProbability = 100
)

func marshalTypeFindProbability(p uintptr) (interface{}, error) {
	return TypeFindProbability(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TypeFindProbability.
func (t TypeFindProbability) String() string {
	switch t {
	case TypeFindNone:
		return "None"
	case TypeFindMinimum:
		return "Minimum"
	case TypeFindPossible:
		return "Possible"
	case TypeFindLikely:
		return "Likely"
	case TypeFindNearlyCertain:
		return "NearlyCertain"
	case TypeFindMaximum:
		return "Maximum"
	default:
		return fmt.Sprintf("TypeFindProbability(%d)", t)
	}
}

// TypeFindFunction: function that will be called by typefinding.
type TypeFindFunction func(find *TypeFind)

// The function returns the following values:
//
func TypeFindGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_type_find_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// TypeFind: following functions allow you to detect the media type of an
// unknown stream.
//
// An instance of this type is always passed by reference.
type TypeFind struct {
	*typeFind
}

// typeFind is the struct that's finalized.
type typeFind struct {
	native *C.GstTypeFind
}

// Data: data used by the caller of the typefinding function.
func (t *TypeFind) Data() unsafe.Pointer {
	valptr := &t.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Length: get the length of the data stream.
//
// The function returns the following values:
//
//    - guint64: length of the data stream, or 0 if it is not available.
//
func (find *TypeFind) Length() uint64 {
	var _arg0 *C.GstTypeFind // out
	var _cret C.guint64      // in

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))

	_cret = C.gst_type_find_get_length(_arg0)
	runtime.KeepAlive(find)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Suggest: if a TypeFindFunction calls this function it suggests the caps with
// the given probability. A TypeFindFunction may supply different suggestions in
// one call. It is up to the caller of the TypeFindFunction to interpret these
// values.
//
// The function takes the following parameters:
//
//    - probability in percent that the suggestion is right.
//    - caps: fixed Caps to suggest.
//
func (find *TypeFind) Suggest(probability uint, caps *Caps) {
	var _arg0 *C.GstTypeFind // out
	var _arg1 C.guint        // out
	var _arg2 *C.GstCaps     // out

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))
	_arg1 = C.guint(probability)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_type_find_suggest(_arg0, _arg1, _arg2)
	runtime.KeepAlive(find)
	runtime.KeepAlive(probability)
	runtime.KeepAlive(caps)
}

// SuggestEmptySimple: if a TypeFindFunction calls this function it suggests
// caps of the given media_type with the given probability.
//
// This function is similar to gst_type_find_suggest_simple(), but uses a Caps
// with no fields.
//
// The function takes the following parameters:
//
//    - probability in percent that the suggestion is right.
//    - mediaType: media type of the suggested caps.
//
func (find *TypeFind) SuggestEmptySimple(probability uint, mediaType string) {
	var _arg0 *C.GstTypeFind // out
	var _arg1 C.guint        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))
	_arg1 = C.guint(probability)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(mediaType)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_type_find_suggest_empty_simple(_arg0, _arg1, _arg2)
	runtime.KeepAlive(find)
	runtime.KeepAlive(probability)
	runtime.KeepAlive(mediaType)
}

// TypeFindRegister registers a new typefind function to be used for
// typefinding. After registering this function will be available for
// typefinding. This function is typically called during an element's plugin
// initialization.
//
// The function takes the following parameters:
//
//    - plugin (optional) or NULL for a static typefind function.
//    - name for registering.
//    - rank (or importance) of this typefind function.
//    - fn to use.
//    - extensions (optional): optional comma-separated list of extensions that
//      could belong to this type.
//    - possibleCaps (optional): optionally the caps that could be returned when
//      typefinding succeeds.
//
// The function returns the following values:
//
//    - ok: TRUE on success, FALSE otherwise.
//
func TypeFindRegister(plugin *Plugin, name string, rank uint, fn TypeFindFunction, extensions string, possibleCaps *Caps) bool {
	var _arg1 *C.GstPlugin          // out
	var _arg2 *C.gchar              // out
	var _arg3 C.guint               // out
	var _arg4 C.GstTypeFindFunction // out
	var _arg7 C.gpointer
	var _arg8 C.GDestroyNotify
	var _arg5 *C.gchar   // out
	var _arg6 *C.GstCaps // out
	var _cret C.gboolean // in

	if plugin != nil {
		_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(rank)
	_arg4 = (*[0]byte)(C._gotk4_gst1_TypeFindFunction)
	_arg7 = C.gpointer(gbox.Assign(fn))
	_arg8 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	if extensions != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(extensions)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if possibleCaps != nil {
		_arg6 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(possibleCaps)))
	}

	_cret = C.gst_type_find_register(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(name)
	runtime.KeepAlive(rank)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(extensions)
	runtime.KeepAlive(possibleCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
