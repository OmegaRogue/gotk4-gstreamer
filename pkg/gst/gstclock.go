// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_Clock_ConnectSynced(gpointer, gboolean, guintptr);
// extern void _gotk4_gst1_ClockClass_unschedule(GstClock*, GstClockEntry*);
// extern gboolean _gotk4_gst1_ClockCallback(GstClock*, GstClockTime, GstClockID, gpointer);
// extern GstClockTime _gotk4_gst1_ClockClass_get_resolution(GstClock*);
// extern GstClockTime _gotk4_gst1_ClockClass_get_internal_time(GstClock*);
// extern GstClockTime _gotk4_gst1_ClockClass_change_resolution(GstClock*, GstClockTime, GstClockTime);
// extern GstClockReturn _gotk4_gst1_ClockClass_wait_async(GstClock*, GstClockEntry*);
// extern GstClockReturn _gotk4_gst1_ClockClass_wait(GstClock*, GstClockEntry*, GstClockTimeDiff*);
// GstClockReturn _gotk4_gst1_Clock_virtual_wait(void* fnptr, GstClock* arg0, GstClockEntry* arg1, GstClockTimeDiff* arg2) {
//   return ((GstClockReturn (*)(GstClock*, GstClockEntry*, GstClockTimeDiff*))(fnptr))(arg0, arg1, arg2);
// };
// GstClockReturn _gotk4_gst1_Clock_virtual_wait_async(void* fnptr, GstClock* arg0, GstClockEntry* arg1) {
//   return ((GstClockReturn (*)(GstClock*, GstClockEntry*))(fnptr))(arg0, arg1);
// };
// GstClockTime _gotk4_gst1_Clock_virtual_change_resolution(void* fnptr, GstClock* arg0, GstClockTime arg1, GstClockTime arg2) {
//   return ((GstClockTime (*)(GstClock*, GstClockTime, GstClockTime))(fnptr))(arg0, arg1, arg2);
// };
// GstClockTime _gotk4_gst1_Clock_virtual_get_internal_time(void* fnptr, GstClock* arg0) {
//   return ((GstClockTime (*)(GstClock*))(fnptr))(arg0);
// };
// GstClockTime _gotk4_gst1_Clock_virtual_get_resolution(void* fnptr, GstClock* arg0) {
//   return ((GstClockTime (*)(GstClock*))(fnptr))(arg0);
// };
// void _gotk4_gst1_Clock_virtual_unschedule(void* fnptr, GstClock* arg0, GstClockEntry* arg1) {
//   ((void (*)(GstClock*, GstClockEntry*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeClockEntryType = coreglib.Type(C.gst_clock_entry_type_get_type())
	GTypeClockReturn    = coreglib.Type(C.gst_clock_return_get_type())
	GTypeClockFlags     = coreglib.Type(C.gst_clock_flags_get_type())
	GTypeClock          = coreglib.Type(C.gst_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeClockEntryType, F: marshalClockEntryType},
		coreglib.TypeMarshaler{T: GTypeClockReturn, F: marshalClockReturn},
		coreglib.TypeMarshaler{T: GTypeClockFlags, F: marshalClockFlags},
		coreglib.TypeMarshaler{T: GTypeClock, F: marshalClock},
	})
}

// TIME_FORMAT: string that can be used in printf-like format strings to display
// a ClockTime value in h:m:s format. Use GST_TIME_ARGS() to construct the
// matching arguments.
//
// Example:
//
//    C printf("%" GST_TIME_FORMAT "\n", GST_TIME_ARGS(ts));.
const TIME_FORMAT = "u:%02u:%02u.%09u"

// ClockID: datatype to hold the handle to an outstanding sync or async clock
// callback.
type ClockID = unsafe.Pointer

// ClockTime: datatype to hold a time, measured in nanoseconds.
type ClockTime = uint64

// ClockTimeDiff: datatype to hold a time difference, measured in nanoseconds.
type ClockTimeDiff = int64

// ClockEntryType: type of the clock entry.
type ClockEntryType C.gint

const (
	// ClockEntrySingle: single shot timeout.
	ClockEntrySingle ClockEntryType = iota
	// ClockEntryPeriodic: periodic timeout request.
	ClockEntryPeriodic
)

func marshalClockEntryType(p uintptr) (interface{}, error) {
	return ClockEntryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ClockEntryType.
func (c ClockEntryType) String() string {
	switch c {
	case ClockEntrySingle:
		return "Single"
	case ClockEntryPeriodic:
		return "Periodic"
	default:
		return fmt.Sprintf("ClockEntryType(%d)", c)
	}
}

// ClockReturn: return value of a clock operation.
type ClockReturn C.gint

const (
	// ClockOK: operation succeeded.
	ClockOK ClockReturn = iota
	// ClockEarly: operation was scheduled too late.
	ClockEarly
	// ClockUnscheduled: clockID was unscheduled.
	ClockUnscheduled
	// ClockBusy: clockID is busy.
	ClockBusy
	// ClockBadtime: bad time was provided to a function.
	ClockBadtime
	// ClockError: error occurred.
	ClockError
	// ClockUnsupported: operation is not supported.
	ClockUnsupported
	// ClockDone: clockID is done waiting.
	ClockDone
)

func marshalClockReturn(p uintptr) (interface{}, error) {
	return ClockReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ClockReturn.
func (c ClockReturn) String() string {
	switch c {
	case ClockOK:
		return "OK"
	case ClockEarly:
		return "Early"
	case ClockUnscheduled:
		return "Unscheduled"
	case ClockBusy:
		return "Busy"
	case ClockBadtime:
		return "Badtime"
	case ClockError:
		return "Error"
	case ClockUnsupported:
		return "Unsupported"
	case ClockDone:
		return "Done"
	default:
		return fmt.Sprintf("ClockReturn(%d)", c)
	}
}

// ClockFlags capabilities of this clock.
type ClockFlags C.guint

const (
	// ClockFlagCanDoSingleSync: clock can do a single sync timeout request.
	ClockFlagCanDoSingleSync ClockFlags = 0b10000
	// ClockFlagCanDoSingleAsync: clock can do a single async timeout request.
	ClockFlagCanDoSingleAsync ClockFlags = 0b100000
	// ClockFlagCanDoPeriodicSync: clock can do sync periodic timeout requests.
	ClockFlagCanDoPeriodicSync ClockFlags = 0b1000000
	// ClockFlagCanDoPeriodicAsync: clock can do async periodic timeout
	// callbacks.
	ClockFlagCanDoPeriodicAsync ClockFlags = 0b10000000
	// ClockFlagCanSetResolution clock's resolution can be changed.
	ClockFlagCanSetResolution ClockFlags = 0b100000000
	// ClockFlagCanSetMaster: clock can be slaved to a master clock.
	ClockFlagCanSetMaster ClockFlags = 0b1000000000
	// ClockFlagNeedsStartupSync: clock needs to be synced before it can be
	// used.
	ClockFlagNeedsStartupSync ClockFlags = 0b10000000000
	// ClockFlagLast subclasses can add additional flags starting from this
	// flag.
	ClockFlagLast ClockFlags = 0b1000000000000
)

func marshalClockFlags(p uintptr) (interface{}, error) {
	return ClockFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ClockFlags.
func (c ClockFlags) String() string {
	if c == 0 {
		return "ClockFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(193)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case ClockFlagCanDoSingleSync:
			builder.WriteString("CanDoSingleSync|")
		case ClockFlagCanDoSingleAsync:
			builder.WriteString("CanDoSingleAsync|")
		case ClockFlagCanDoPeriodicSync:
			builder.WriteString("CanDoPeriodicSync|")
		case ClockFlagCanDoPeriodicAsync:
			builder.WriteString("CanDoPeriodicAsync|")
		case ClockFlagCanSetResolution:
			builder.WriteString("CanSetResolution|")
		case ClockFlagCanSetMaster:
			builder.WriteString("CanSetMaster|")
		case ClockFlagNeedsStartupSync:
			builder.WriteString("NeedsStartupSync|")
		case ClockFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("ClockFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c ClockFlags) Has(other ClockFlags) bool {
	return (c & other) == other
}

// ClockCallback: function prototype of the callback.
type ClockCallback func(clock Clocker, time ClockTime, id ClockID) (ok bool)

// ClockOverrides contains methods that are overridable.
type ClockOverrides struct {
	// ChangeResolution: change the resolution of the clock. Not all values
	// might be acceptable.
	//
	// The function takes the following parameters:
	//
	//    - oldResolution previous resolution.
	//    - newResolution: new resolution.
	//
	// The function returns the following values:
	//
	//    - clockTime: new resolution.
	//
	ChangeResolution func(oldResolution, newResolution ClockTime) ClockTime
	// InternalTime gets the current internal time of the given clock. The time
	// is returned unadjusted for the offset and the rate.
	//
	// The function returns the following values:
	//
	//    - clockTime: internal time of the clock. Or GST_CLOCK_TIME_NONE when
	//      given invalid input.
	//
	InternalTime func() ClockTime
	// Resolution gets the accuracy of the clock. The accuracy of the clock is
	// the granularity of the values returned by gst_clock_get_time().
	//
	// The function returns the following values:
	//
	//    - clockTime: resolution of the clock in units of ClockTime.
	//
	Resolution func() ClockTime
	// Unschedule: unblock a blocking or async wait operation.
	//
	// The function takes the following parameters:
	//
	//    - entry to unschedule.
	//
	Unschedule func(entry *ClockEntry)
	// Wait: perform a blocking wait on the given ClockEntry and return the
	// jitter.
	//
	// The function takes the following parameters:
	//
	//    - entry to wait on.
	//
	// The function returns the following values:
	//
	//    - jitter (optional): pointer that will contain the jitter.
	//    - clockReturn: result of the blocking wait. T_CLOCK_EARLY will be
	//      returned if the current clock time is past the time of id, T_CLOCK_OK
	//      if id was scheduled in time. T_CLOCK_UNSCHEDULED if id was
	//      unscheduled with gst_clock_id_unschedule().
	//
	Wait func(entry *ClockEntry) (ClockTimeDiff, ClockReturn)
	// WaitAsync: perform an asynchronous wait on the given ClockEntry.
	//
	// The function takes the following parameters:
	//
	//    - entry to wait on.
	//
	// The function returns the following values:
	//
	//    - clockReturn: result of the non blocking wait.
	//
	WaitAsync func(entry *ClockEntry) ClockReturn
}

func defaultClockOverrides(v *Clock) ClockOverrides {
	return ClockOverrides{
		ChangeResolution: v.changeResolution,
		InternalTime:     v.internalTime,
		Resolution:       v.resolution,
		Unschedule:       v.unschedule,
		Wait:             v.wait,
		WaitAsync:        v.waitAsync,
	}
}

// Clock: GStreamer uses a global clock to synchronize the plugins in a
// pipeline. Different clock implementations are possible by implementing this
// abstract base class or, more conveniently, by subclassing SystemClock.
//
// The Clock returns a monotonically increasing time with the method
// gst_clock_get_time(). Its accuracy and base time depend on the specific clock
// implementation but time is always expressed in nanoseconds. Since the
// baseline of the clock is undefined, the clock time returned is not meaningful
// in itself, what matters are the deltas between two clock times. The time
// returned by a clock is called the absolute time.
//
// The pipeline uses the clock to calculate the running time. Usually all
// renderers synchronize to the global clock using the buffer timestamps, the
// T_EVENT_SEGMENT events and the element's base time, see Pipeline.
//
// A clock implementation can support periodic and single shot clock
// notifications both synchronous and asynchronous.
//
// One first needs to create a ClockID for the periodic or single shot
// notification using gst_clock_new_single_shot_id() or
// gst_clock_new_periodic_id().
//
// To perform a blocking wait for the specific time of the ClockID use
// gst_clock_id_wait(). To receive a callback when the specific time is reached
// in the clock use gst_clock_id_wait_async(). Both these calls can be
// interrupted with the gst_clock_id_unschedule() call. If the blocking wait is
// unscheduled a return value of T_CLOCK_UNSCHEDULED is returned.
//
// Periodic callbacks scheduled async will be repeatedly called automatically
// until they are unscheduled. To schedule a sync periodic callback,
// gst_clock_id_wait() should be called repeatedly.
//
// The async callbacks can happen from any thread, either provided by the core
// or from a streaming thread. The application should be prepared for this.
//
// A ClockID that has been unscheduled cannot be used again for any wait
// operation, a new ClockID should be created and the old unscheduled one should
// be destroyed with gst_clock_id_unref().
//
// It is possible to perform a blocking wait on the same ClockID from multiple
// threads. However, registering the same ClockID for multiple async
// notifications is not possible, the callback will only be called for the
// thread registering the entry last.
//
// None of the wait operations unref the ClockID, the owner is responsible for
// unreffing the ids itself. This holds for both periodic and single shot
// notifications. The reason being that the owner of the ClockID has to keep a
// handle to the ClockID to unblock the wait on FLUSHING events or state changes
// and if the entry would be unreffed automatically, the handle might become
// invalid without any notification.
//
// These clock operations do not operate on the running time, so the callbacks
// will also occur when not in PLAYING state as if the clock just keeps on
// running. Some clocks however do not progress when the element that provided
// the clock is not PLAYING.
//
// When a clock has the T_CLOCK_FLAG_CAN_SET_MASTER flag set, it can be slaved
// to another Clock with gst_clock_set_master(). The clock will then
// automatically be synchronized to this master clock by repeatedly sampling the
// master clock and the slave clock and recalibrating the slave clock with
// gst_clock_set_calibration(). This feature is mostly useful for plugins that
// have an internal clock but must operate with another clock selected by the
// Pipeline. They can track the offset and rate difference of their internal
// clock relative to the master clock by using the gst_clock_get_calibration()
// function.
//
// The master/slave synchronisation can be tuned with the Clock:timeout,
// Clock:window-size and Clock:window-threshold properties. The Clock:timeout
// property defines the interval to sample the master clock and run the
// calibration functions. Clock:window-size defines the number of samples to use
// when calibrating and Clock:window-threshold defines the minimum number of
// samples before the calibration is performed.
type Clock struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Clock)(nil)
)

// Clocker describes types inherited from class Clock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Clocker interface {
	coreglib.Objector
	baseClock() *Clock
}

var _ Clocker = (*Clock)(nil)

func init() {
	coreglib.RegisterClassInfo[*Clock, *ClockClass, ClockOverrides](
		GTypeClock,
		initClockClass,
		wrapClock,
		defaultClockOverrides,
	)
}

func initClockClass(gclass unsafe.Pointer, overrides ClockOverrides, classInitFunc func(*ClockClass)) {
	pclass := (*C.GstClockClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeClock))))

	if overrides.ChangeResolution != nil {
		pclass.change_resolution = (*[0]byte)(C._gotk4_gst1_ClockClass_change_resolution)
	}

	if overrides.InternalTime != nil {
		pclass.get_internal_time = (*[0]byte)(C._gotk4_gst1_ClockClass_get_internal_time)
	}

	if overrides.Resolution != nil {
		pclass.get_resolution = (*[0]byte)(C._gotk4_gst1_ClockClass_get_resolution)
	}

	if overrides.Unschedule != nil {
		pclass.unschedule = (*[0]byte)(C._gotk4_gst1_ClockClass_unschedule)
	}

	if overrides.Wait != nil {
		pclass.wait = (*[0]byte)(C._gotk4_gst1_ClockClass_wait)
	}

	if overrides.WaitAsync != nil {
		pclass.wait_async = (*[0]byte)(C._gotk4_gst1_ClockClass_wait_async)
	}

	if classInitFunc != nil {
		class := (*ClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapClock(obj *coreglib.Object) *Clock {
	return &Clock{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalClock(p uintptr) (interface{}, error) {
	return wrapClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (clock *Clock) baseClock() *Clock {
	return clock
}

// BaseClock returns the underlying base object.
func BaseClock(obj Clocker) *Clock {
	return obj.baseClock()
}

// ConnectSynced: signaled on clocks with GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC set
// once the clock is synchronized, or when it completely lost synchronization.
// This signal will not be emitted on clocks without the flag.
//
// This signal will be emitted from an arbitrary thread, most likely not the
// application's main thread.
func (clock *Clock) ConnectSynced(f func(synced bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(clock, "synced", false, unsafe.Pointer(C._gotk4_gst1_Clock_ConnectSynced), f)
}

// AddObservation: time master of the master clock and the time slave of the
// slave clock are added to the list of observations. If enough observations are
// available, a linear regression algorithm is run on the observations and clock
// is recalibrated.
//
// If this functions returns TRUE, r_squared will contain the correlation
// coefficient of the interpolation. A value of 1.0 means a perfect regression
// was performed. This value can be used to control the sampling frequency of
// the master and slave clocks.
//
// The function takes the following parameters:
//
//    - slave: time on the slave.
//    - master: time on the master.
//
// The function returns the following values:
//
//    - rSquared: pointer to hold the result.
//    - ok: TRUE if enough observations were added to run the regression
//      algorithm.
//
func (clock *Clock) AddObservation(slave, master ClockTime) (float64, bool) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.gdouble      // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(slave)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(master)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_add_observation(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(slave)
	runtime.KeepAlive(master)

	var _rSquared float64 // out
	var _ok bool          // out

	_rSquared = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _rSquared, _ok
}

// AddObservationUnapplied: add a clock observation to the internal slaving
// algorithm the same as gst_clock_add_observation(), and return the result of
// the master clock estimation, without updating the internal calibration.
//
// The caller can then take the results and call gst_clock_set_calibration()
// with the values, or some modified version of them.
//
// The function takes the following parameters:
//
//    - slave: time on the slave.
//    - master: time on the master.
//
// The function returns the following values:
//
//    - rSquared: pointer to hold the result.
//    - internal (optional): location to store the internal time.
//    - external (optional): location to store the external time.
//    - rateNum (optional): location to store the rate numerator.
//    - rateDenom (optional): location to store the rate denominator.
//    - ok: TRUE if enough observations were added to run the regression
//      algorithm.
//
func (clock *Clock) AddObservationUnapplied(slave, master ClockTime) (rSquared float64, internal, external, rateNum, rateDenom ClockTime, ok bool) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.gdouble      // in
	var _arg4 C.GstClockTime // in
	var _arg5 C.GstClockTime // in
	var _arg6 C.GstClockTime // in
	var _arg7 C.GstClockTime // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(slave)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(master)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_add_observation_unapplied(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(slave)
	runtime.KeepAlive(master)

	var _rSquared float64    // out
	var _internal ClockTime  // out
	var _external ClockTime  // out
	var _rateNum ClockTime   // out
	var _rateDenom ClockTime // out
	var _ok bool             // out

	_rSquared = float64(_arg3)
	_internal = uint64(_arg4)
	type _ = ClockTime
	type _ = uint64
	_external = uint64(_arg5)
	type _ = ClockTime
	type _ = uint64
	_rateNum = uint64(_arg6)
	type _ = ClockTime
	type _ = uint64
	_rateDenom = uint64(_arg7)
	type _ = ClockTime
	type _ = uint64
	if _cret != 0 {
		_ok = true
	}

	return _rSquared, _internal, _external, _rateNum, _rateDenom, _ok
}

// AdjustUnlocked converts the given internal clock time to the external time,
// adjusting for the rate and reference time set with
// gst_clock_set_calibration() and making sure that the returned time is
// increasing. This function should be called with the clock's OBJECT_LOCK held
// and is mainly used by clock subclasses.
//
// This function is the reverse of gst_clock_unadjust_unlocked().
//
// The function takes the following parameters:
//
//    - internal: clock time.
//
// The function returns the following values:
//
//    - clockTime: converted time of the clock.
//
func (clock *Clock) AdjustUnlocked(internal ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(internal)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_adjust_unlocked(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(internal)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// AdjustWithCalibration converts the given internal_target clock time to the
// external time, using the passed calibration parameters. This function
// performs the same calculation as gst_clock_adjust_unlocked() when called
// using the current calibration parameters, but doesn't ensure a monotonically
// increasing result as gst_clock_adjust_unlocked() does.
//
// Note: The clock parameter is unused and can be NULL.
//
// The function takes the following parameters:
//
//    - internalTarget: clock time.
//    - cinternal: reference internal time.
//    - cexternal: reference external time.
//    - cnum: numerator of the rate of the clock relative to its internal time.
//    - cdenom: denominator of the rate of the clock.
//
// The function returns the following values:
//
//    - clockTime: converted time of the clock.
//
func (clock *Clock) AdjustWithCalibration(internalTarget, cinternal, cexternal, cnum, cdenom ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.GstClockTime // out
	var _arg5 C.GstClockTime // out
	var _cret C.GstClockTime // in

	if clock != nil {
		_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}
	_arg1 = C.guint64(internalTarget)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(cinternal)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(cexternal)
	type _ = ClockTime
	type _ = uint64
	_arg4 = C.guint64(cnum)
	type _ = ClockTime
	type _ = uint64
	_arg5 = C.guint64(cdenom)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_adjust_with_calibration(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(internalTarget)
	runtime.KeepAlive(cinternal)
	runtime.KeepAlive(cexternal)
	runtime.KeepAlive(cnum)
	runtime.KeepAlive(cdenom)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Calibration gets the internal rate and reference time of clock. See
// gst_clock_set_calibration() for more information.
//
// internal, external, rate_num, and rate_denom can be left NULL if the caller
// is not interested in the values.
//
// The function returns the following values:
//
//    - internal (optional): location to store the internal time.
//    - external (optional): location to store the external time.
//    - rateNum (optional): location to store the rate numerator.
//    - rateDenom (optional): location to store the rate denominator.
//
func (clock *Clock) Calibration() (internal, external, rateNum, rateDenom ClockTime) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in
	var _arg4 C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	C.gst_clock_get_calibration(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(clock)

	var _internal ClockTime  // out
	var _external ClockTime  // out
	var _rateNum ClockTime   // out
	var _rateDenom ClockTime // out

	_internal = uint64(_arg1)
	type _ = ClockTime
	type _ = uint64
	_external = uint64(_arg2)
	type _ = ClockTime
	type _ = uint64
	_rateNum = uint64(_arg3)
	type _ = ClockTime
	type _ = uint64
	_rateDenom = uint64(_arg4)
	type _ = ClockTime
	type _ = uint64

	return _internal, _external, _rateNum, _rateDenom
}

// InternalTime gets the current internal time of the given clock. The time is
// returned unadjusted for the offset and the rate.
//
// The function returns the following values:
//
//    - clockTime: internal time of the clock. Or GST_CLOCK_TIME_NONE when given
//      invalid input.
//
func (clock *Clock) InternalTime() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_internal_time(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Master gets the master clock that clock is slaved to or NULL when the clock
// is not slaved to any master clock.
//
// The function returns the following values:
//
//    - ret (optional): master Clock or NULL when this clock is not slaved to a
//      master clock.
//
func (clock *Clock) Master() Clocker {
	var _arg0 *C.GstClock // out
	var _cret *C.GstClock // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_master(_arg0)
	runtime.KeepAlive(clock)

	var _ret Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_ret = rv
		}
	}

	return _ret
}

// Resolution gets the accuracy of the clock. The accuracy of the clock is the
// granularity of the values returned by gst_clock_get_time().
//
// The function returns the following values:
//
//    - clockTime: resolution of the clock in units of ClockTime.
//
func (clock *Clock) Resolution() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_resolution(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Time gets the current time of the given clock. The time is always
// monotonically increasing and adjusted according to the current offset and
// rate.
//
// The function returns the following values:
//
//    - clockTime: time of the clock. Or GST_CLOCK_TIME_NONE when given invalid
//      input.
//
func (clock *Clock) Time() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_time(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Timeout gets the amount of time that master and slave clocks are sampled.
//
// The function returns the following values:
//
//    - clockTime: interval between samples.
//
func (clock *Clock) Timeout() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_timeout(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// IsSynced checks if the clock is currently synced, by looking at whether
// GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set.
//
// The function returns the following values:
//
//    - ok: TRUE if the clock is currently synced.
//
func (clock *Clock) IsSynced() bool {
	var _arg0 *C.GstClock // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_is_synced(_arg0)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewPeriodicID gets an ID from clock to trigger a periodic notification. The
// periodic notifications will start at time start_time and will then be fired
// with the given interval.
//
// The function takes the following parameters:
//
//    - startTime: requested start time.
//    - interval: requested interval.
//
// The function returns the following values:
//
//    - clockID that can be used to request the time notification.
//
func (clock *Clock) NewPeriodicID(startTime, interval ClockTime) ClockID {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _cret C.GstClockID   // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(startTime)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(interval)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_new_periodic_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(startTime)
	runtime.KeepAlive(interval)

	var _clockID ClockID // out

	_clockID = (unsafe.Pointer)(unsafe.Pointer(_cret))
	type _ = ClockID
	type _ = unsafe.Pointer

	return _clockID
}

// NewSingleShotID gets a ClockID from clock to trigger a single shot
// notification at the requested time.
//
// The function takes the following parameters:
//
//    - time: requested time.
//
// The function returns the following values:
//
//    - clockID that can be used to request the time notification.
//
func (clock *Clock) NewSingleShotID(time ClockTime) ClockID {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockID   // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(time)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_new_single_shot_id(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(time)

	var _clockID ClockID // out

	_clockID = (unsafe.Pointer)(unsafe.Pointer(_cret))
	type _ = ClockID
	type _ = unsafe.Pointer

	return _clockID
}

// PeriodicIDReinit reinitializes the provided periodic id to the provided start
// time and interval. Does not modify the reference count.
//
// The function takes the following parameters:
//
//    - id: ClockID.
//    - startTime: requested start time.
//    - interval: requested interval.
//
// The function returns the following values:
//
//    - ok: TRUE if the GstClockID could be reinitialized to the provided time,
//      else FALSE.
//
func (clock *Clock) PeriodicIDReinit(id ClockID, startTime, interval ClockTime) bool {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockID   // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = ClockID
	type _ = unsafe.Pointer
	_arg2 = C.guint64(startTime)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(interval)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_periodic_id_reinit(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(id)
	runtime.KeepAlive(startTime)
	runtime.KeepAlive(interval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCalibration adjusts the rate and time of clock. A rate of 1/1 is the
// normal speed of the clock. Values bigger than 1/1 make the clock go faster.
//
// internal and external are calibration parameters that arrange that
// gst_clock_get_time() should have been external at internal time internal.
// This internal time should not be in the future; that is, it should be less
// than the value of gst_clock_get_internal_time() when this function is called.
//
// Subsequent calls to gst_clock_get_time() will return clock times computed as
// follows:
//
//    C   time = (internal_time - internal) * rate_num / rate_denom + external
//
// This formula is implemented in gst_clock_adjust_unlocked(). Of course, it
// tries to do the integer arithmetic as precisely as possible.
//
// Note that gst_clock_get_time() always returns increasing values so when you
// move the clock backwards, gst_clock_get_time() will report the previous value
// until the clock catches up.
//
// The function takes the following parameters:
//
//    - internal: reference internal time.
//    - external: reference external time.
//    - rateNum: numerator of the rate of the clock relative to its internal
//      time.
//    - rateDenom: denominator of the rate of the clock.
//
func (clock *Clock) SetCalibration(internal, external, rateNum, rateDenom ClockTime) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.GstClockTime // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(internal)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(external)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(rateNum)
	type _ = ClockTime
	type _ = uint64
	_arg4 = C.guint64(rateDenom)
	type _ = ClockTime
	type _ = uint64

	C.gst_clock_set_calibration(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(internal)
	runtime.KeepAlive(external)
	runtime.KeepAlive(rateNum)
	runtime.KeepAlive(rateDenom)
}

// SetMaster sets master as the master clock for clock. clock will be
// automatically calibrated so that gst_clock_get_time() reports the same time
// as the master clock.
//
// A clock provider that slaves its clock to a master can get the current
// calibration values with gst_clock_get_calibration().
//
// master can be NULL in which case clock will not be slaved anymore. It will
// however keep reporting its time adjusted with the last configured rate and
// time offsets.
//
// The function takes the following parameters:
//
//    - master (optional) Clock.
//
// The function returns the following values:
//
//    - ok: TRUE if the clock is capable of being slaved to a master clock.
//      Trying to set a master on a clock without the T_CLOCK_FLAG_CAN_SET_MASTER
//      flag will make this function return FALSE.
//
func (clock *Clock) SetMaster(master Clocker) bool {
	var _arg0 *C.GstClock // out
	var _arg1 *C.GstClock // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if master != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(master).Native()))
	}

	_cret = C.gst_clock_set_master(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(master)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetResolution sets the accuracy of the clock. Some clocks have the
// possibility to operate with different accuracy at the expense of more
// resource usage. There is normally no need to change the default resolution of
// a clock. The resolution of a clock can only be changed if the clock has the
// T_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.
//
// The function takes the following parameters:
//
//    - resolution to set.
//
// The function returns the following values:
//
//    - clockTime: new resolution of the clock.
//
func (clock *Clock) SetResolution(resolution ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(resolution)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_set_resolution(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(resolution)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// SetSynced sets clock to synced and emits the Clock::synced signal, and wakes
// up any thread waiting in gst_clock_wait_for_sync().
//
// This function must only be called if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set
// on the clock, and is intended to be called by subclasses only.
//
// The function takes the following parameters:
//
//    - synced: if the clock is synced.
//
func (clock *Clock) SetSynced(synced bool) {
	var _arg0 *C.GstClock // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if synced {
		_arg1 = C.TRUE
	}

	C.gst_clock_set_synced(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(synced)
}

// SetTimeout sets the amount of time, in nanoseconds, to sample master and
// slave clocks.
//
// The function takes the following parameters:
//
//    - timeout: timeout.
//
func (clock *Clock) SetTimeout(timeout ClockTime) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64

	C.gst_clock_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(timeout)
}

// SingleShotIDReinit reinitializes the provided single shot id to the provided
// time. Does not modify the reference count.
//
// The function takes the following parameters:
//
//    - id: ClockID.
//    - time: requested time.
//
// The function returns the following values:
//
//    - ok: TRUE if the GstClockID could be reinitialized to the provided time,
//      else FALSE.
//
func (clock *Clock) SingleShotIDReinit(id ClockID, time ClockTime) bool {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockID   // out
	var _arg2 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = ClockID
	type _ = unsafe.Pointer
	_arg2 = C.guint64(time)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_single_shot_id_reinit(_arg0, _arg1, _arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(id)
	runtime.KeepAlive(time)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnadjustUnlocked converts the given external clock time to the internal time
// of clock, using the rate and reference time set with
// gst_clock_set_calibration(). This function should be called with the clock's
// OBJECT_LOCK held and is mainly used by clock subclasses.
//
// This function is the reverse of gst_clock_adjust_unlocked().
//
// The function takes the following parameters:
//
//    - external clock time.
//
// The function returns the following values:
//
//    - clockTime: internal time of the clock corresponding to external.
//
func (clock *Clock) UnadjustUnlocked(external ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(external)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_unadjust_unlocked(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(external)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// UnadjustWithCalibration converts the given external_target clock time to the
// internal time, using the passed calibration parameters. This function
// performs the same calculation as gst_clock_unadjust_unlocked() when called
// using the current calibration parameters.
//
// Note: The clock parameter is unused and can be NULL.
//
// The function takes the following parameters:
//
//    - externalTarget: clock time.
//    - cinternal: reference internal time.
//    - cexternal: reference external time.
//    - cnum: numerator of the rate of the clock relative to its internal time.
//    - cdenom: denominator of the rate of the clock.
//
// The function returns the following values:
//
//    - clockTime: converted time of the clock.
//
func (clock *Clock) UnadjustWithCalibration(externalTarget, cinternal, cexternal, cnum, cdenom ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.GstClockTime // out
	var _arg5 C.GstClockTime // out
	var _cret C.GstClockTime // in

	if clock != nil {
		_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}
	_arg1 = C.guint64(externalTarget)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(cinternal)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(cexternal)
	type _ = ClockTime
	type _ = uint64
	_arg4 = C.guint64(cnum)
	type _ = ClockTime
	type _ = uint64
	_arg5 = C.guint64(cdenom)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_unadjust_with_calibration(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(externalTarget)
	runtime.KeepAlive(cinternal)
	runtime.KeepAlive(cexternal)
	runtime.KeepAlive(cnum)
	runtime.KeepAlive(cdenom)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// WaitForSync waits until clock is synced for reporting the current time. If
// timeout is GST_CLOCK_TIME_NONE it will wait forever, otherwise it will time
// out after timeout nanoseconds.
//
// For asynchronous waiting, the Clock::synced signal can be used.
//
// This returns immediately with TRUE if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is
// not set on the clock, or if the clock is already synced.
//
// The function takes the following parameters:
//
//    - timeout for waiting or GST_CLOCK_TIME_NONE.
//
// The function returns the following values:
//
//    - ok: TRUE if waiting was successful, or FALSE on timeout.
//
func (clock *Clock) WaitForSync(timeout ClockTime) bool {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_clock_wait_for_sync(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(timeout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// changeResolution: change the resolution of the clock. Not all values might be
// acceptable.
//
// The function takes the following parameters:
//
//    - oldResolution previous resolution.
//    - newResolution: new resolution.
//
// The function returns the following values:
//
//    - clockTime: new resolution.
//
func (clock *Clock) changeResolution(oldResolution, newResolution ClockTime) ClockTime {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.change_resolution

	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(oldResolution)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(newResolution)
	type _ = ClockTime
	type _ = uint64

	_cret = C._gotk4_gst1_Clock_virtual_change_resolution(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(oldResolution)
	runtime.KeepAlive(newResolution)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// internalTime gets the current internal time of the given clock. The time is
// returned unadjusted for the offset and the rate.
//
// The function returns the following values:
//
//    - clockTime: internal time of the clock. Or GST_CLOCK_TIME_NONE when given
//      invalid input.
//
func (clock *Clock) internalTime() ClockTime {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.get_internal_time

	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C._gotk4_gst1_Clock_virtual_get_internal_time(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Resolution gets the accuracy of the clock. The accuracy of the clock is the
// granularity of the values returned by gst_clock_get_time().
//
// The function returns the following values:
//
//    - clockTime: resolution of the clock in units of ClockTime.
//
func (clock *Clock) resolution() ClockTime {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.get_resolution

	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C._gotk4_gst1_Clock_virtual_get_resolution(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Unschedule: unblock a blocking or async wait operation.
//
// The function takes the following parameters:
//
//    - entry to unschedule.
//
func (clock *Clock) unschedule(entry *ClockEntry) {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.unschedule

	var _arg0 *C.GstClock      // out
	var _arg1 *C.GstClockEntry // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (*C.GstClockEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	C._gotk4_gst1_Clock_virtual_unschedule(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(entry)
}

// Wait: perform a blocking wait on the given ClockEntry and return the jitter.
//
// The function takes the following parameters:
//
//    - entry to wait on.
//
// The function returns the following values:
//
//    - jitter (optional): pointer that will contain the jitter.
//    - clockReturn: result of the blocking wait. T_CLOCK_EARLY will be returned
//      if the current clock time is past the time of id, T_CLOCK_OK if id was
//      scheduled in time. T_CLOCK_UNSCHEDULED if id was unscheduled with
//      gst_clock_id_unschedule().
//
func (clock *Clock) wait(entry *ClockEntry) (ClockTimeDiff, ClockReturn) {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.wait

	var _arg0 *C.GstClock        // out
	var _arg1 *C.GstClockEntry   // out
	var _arg2 C.GstClockTimeDiff // in
	var _cret C.GstClockReturn   // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (*C.GstClockEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C._gotk4_gst1_Clock_virtual_wait(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(entry)

	var _jitter ClockTimeDiff    // out
	var _clockReturn ClockReturn // out

	_jitter = int64(_arg2)
	type _ = ClockTimeDiff
	type _ = int64
	_clockReturn = ClockReturn(_cret)

	return _jitter, _clockReturn
}

// waitAsync: perform an asynchronous wait on the given ClockEntry.
//
// The function takes the following parameters:
//
//    - entry to wait on.
//
// The function returns the following values:
//
//    - clockReturn: result of the non blocking wait.
//
func (clock *Clock) waitAsync(entry *ClockEntry) ClockReturn {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.wait_async

	var _arg0 *C.GstClock      // out
	var _arg1 *C.GstClockEntry // out
	var _cret C.GstClockReturn // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (*C.GstClockEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C._gotk4_gst1_Clock_virtual_wait_async(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(entry)

	var _clockReturn ClockReturn // out

	_clockReturn = ClockReturn(_cret)

	return _clockReturn
}

// ClockIDCompareFunc compares the two ClockID instances. This function can be
// used as a GCompareFunc when sorting ids.
//
// The function takes the following parameters:
//
//    - id1 (optional): ClockID.
//    - id2 (optional) to compare with.
//
// The function returns the following values:
//
//    - gint: negative value if a < b; zero if a = b; positive value if a > b.
//
func ClockIDCompareFunc(id1, id2 unsafe.Pointer) int {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gint          // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(id1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(id2))

	_cret = C.gst_clock_id_compare_func(_arg1, _arg2)
	runtime.KeepAlive(id1)
	runtime.KeepAlive(id2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ClockIDGetTime gets the time of the clock ID.
//
// The function takes the following parameters:
//
//    - id to query.
//
// The function returns the following values:
//
//    - clockTime: time of the given clock id.
//
func ClockIDGetTime(id ClockID) ClockTime {
	var _arg1 C.GstClockID   // out
	var _cret C.GstClockTime // in

	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = ClockID
	type _ = unsafe.Pointer

	_cret = C.gst_clock_id_get_time(_arg1)
	runtime.KeepAlive(id)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// ClockIDUnschedule cancels an outstanding request with id. This can either be
// an outstanding async notification or a pending sync notification. After this
// call, id cannot be used anymore to receive sync or async notifications, you
// need to create a new ClockID.
//
// The function takes the following parameters:
//
//    - id to unschedule.
//
func ClockIDUnschedule(id ClockID) {
	var _arg1 C.GstClockID // out

	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = ClockID
	type _ = unsafe.Pointer

	C.gst_clock_id_unschedule(_arg1)
	runtime.KeepAlive(id)
}

// ClockIDWait performs a blocking wait on id. id should have been created with
// gst_clock_new_single_shot_id() or gst_clock_new_periodic_id() and should not
// have been unscheduled with a call to gst_clock_id_unschedule().
//
// If the jitter argument is not NULL and this function returns T_CLOCK_OK or
// T_CLOCK_EARLY, it will contain the difference against the clock and the time
// of id when this method was called. Positive values indicate how late id was
// relative to the clock (in which case this function will return
// T_CLOCK_EARLY). Negative values indicate how much time was spent waiting on
// the clock before this function returned.
//
// The function takes the following parameters:
//
//    - id to wait on.
//
// The function returns the following values:
//
//    - jitter (optional): pointer that will contain the jitter, can be NULL.
//    - clockReturn: result of the blocking wait. T_CLOCK_EARLY will be returned
//      if the current clock time is past the time of id, T_CLOCK_OK if id was
//      scheduled in time. T_CLOCK_UNSCHEDULED if id was unscheduled with
//      gst_clock_id_unschedule().
//
func ClockIDWait(id ClockID) (ClockTimeDiff, ClockReturn) {
	var _arg1 C.GstClockID       // out
	var _arg2 C.GstClockTimeDiff // in
	var _cret C.GstClockReturn   // in

	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = ClockID
	type _ = unsafe.Pointer

	_cret = C.gst_clock_id_wait(_arg1, &_arg2)
	runtime.KeepAlive(id)

	var _jitter ClockTimeDiff    // out
	var _clockReturn ClockReturn // out

	_jitter = int64(_arg2)
	type _ = ClockTimeDiff
	type _ = int64
	_clockReturn = ClockReturn(_cret)

	return _jitter, _clockReturn
}

// ClockIDWaitAsync registers a callback on the given ClockID id with the given
// function and user_data. When passing a ClockID with an invalid time to this
// function, the callback will be called immediately with a time set to
// GST_CLOCK_TIME_NONE. The callback will be called when the time of id has been
// reached.
//
// The callback func can be invoked from any thread, either provided by the core
// or from a streaming thread. The application should be prepared for this.
//
// The function takes the following parameters:
//
//    - id to wait on.
//    - fn: callback function.
//
// The function returns the following values:
//
//    - clockReturn: result of the non blocking wait.
//
func ClockIDWaitAsync(id ClockID, fn ClockCallback) ClockReturn {
	var _arg1 C.GstClockID       // out
	var _arg2 C.GstClockCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.GstClockReturn // in

	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = ClockID
	type _ = unsafe.Pointer
	_arg2 = (*[0]byte)(C._gotk4_gst1_ClockCallback)
	_arg3 = C.gpointer(gbox.Assign(fn))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_clock_id_wait_async(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(id)
	runtime.KeepAlive(fn)

	var _clockReturn ClockReturn // out

	_clockReturn = ClockReturn(_cret)

	return _clockReturn
}

// ClockClass: GStreamer clock class. Override the vmethods to implement the
// clock functionality.
//
// An instance of this type is always passed by reference.
type ClockClass struct {
	*clockClass
}

// clockClass is the struct that's finalized.
type clockClass struct {
	native *C.GstClockClass
}

// ParentClass: parent class structure.
func (c *ClockClass) ParentClass() *ObjectClass {
	valptr := &c.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ClockEntry: all pending timeouts or periodic notifies are converted into an
// entry. Note that GstClockEntry should be treated as an opaque structure. It
// must not be extended or allocated using a custom allocator.
//
// An instance of this type is always passed by reference.
type ClockEntry struct {
	*clockEntry
}

// clockEntry is the struct that's finalized.
type clockEntry struct {
	native *C.GstClockEntry
}

// Refcount: reference counter (read-only).
func (c *ClockEntry) Refcount() int {
	valptr := &c.native.refcount
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Refcount: reference counter (read-only).
func (c *ClockEntry) SetRefcount(refcount int) {
	valptr := &c.native.refcount
	*valptr = C.gint(refcount)
}
