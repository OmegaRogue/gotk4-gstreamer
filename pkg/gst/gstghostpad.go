// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeGhostPad = coreglib.Type(C.gst_ghost_pad_get_type())
	GTypeProxyPad = coreglib.Type(C.gst_proxy_pad_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGhostPad, F: marshalGhostPad},
		coreglib.TypeMarshaler{T: GTypeProxyPad, F: marshalProxyPad},
	})
}

// GhostPadOverrides contains methods that are overridable.
type GhostPadOverrides struct {
}

func defaultGhostPadOverrides(v *GhostPad) GhostPadOverrides {
	return GhostPadOverrides{}
}

// GhostPad ghostPads are useful when organizing pipelines with Bin like
// elements. The idea here is to create hierarchical element graphs. The bin
// element contains a sub-graph. Now one would like to treat the bin-element
// like any other Element. This is where GhostPads come into play. A GhostPad
// acts as a proxy for another pad. Thus the bin can have sink and source
// ghost-pads that are associated with sink and source pads of the child
// elements.
//
// If the target pad is known at creation time, gst_ghost_pad_new() is the
// function to use to get a ghost-pad. Otherwise one can use
// gst_ghost_pad_new_no_target() to create the ghost-pad and use
// gst_ghost_pad_set_target() to establish the association later on.
//
// Note that GhostPads add overhead to the data processing of a pipeline.
type GhostPad struct {
	_ [0]func() // equal guard
	ProxyPad
}

var (
	_ GstObjector = (*GhostPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GhostPad, *GhostPadClass, GhostPadOverrides](
		GTypeGhostPad,
		initGhostPadClass,
		wrapGhostPad,
		defaultGhostPadOverrides,
	)
}

func initGhostPadClass(gclass unsafe.Pointer, overrides GhostPadOverrides, classInitFunc func(*GhostPadClass)) {
	if classInitFunc != nil {
		class := (*GhostPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGhostPad(obj *coreglib.Object) *GhostPad {
	return &GhostPad{
		ProxyPad: ProxyPad{
			Pad: Pad{
				GstObject: GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGhostPad(p uintptr) (interface{}, error) {
	return wrapGhostPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGhostPad: create a new ghostpad with target as the target. The direction
// will be taken from the target pad. target must be unlinked.
//
// Will ref the target.
//
// The function takes the following parameters:
//
//    - name (optional) of the new pad, or NULL to assign a default name.
//    - target: pad to ghost.
//
// The function returns the following values:
//
//    - ghostPad (optional): new Pad, or NULL in case of an error.
//
func NewGhostPad(name string, target *Pad) *GhostPad {
	var _arg1 *C.gchar  // out
	var _arg2 *C.GstPad // out
	var _cret *C.GstPad // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_ghost_pad_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(target)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// NewGhostPadFromTemplate: create a new ghostpad with target as the target. The
// direction will be taken from the target pad. The template used on the
// ghostpad will be template.
//
// Will ref the target.
//
// The function takes the following parameters:
//
//    - name (optional) of the new pad, or NULL to assign a default name.
//    - target: pad to ghost.
//    - templ to use on the ghostpad.
//
// The function returns the following values:
//
//    - ghostPad (optional): new Pad, or NULL in case of an error.
//
func NewGhostPadFromTemplate(name string, target *Pad, templ *PadTemplate) *GhostPad {
	var _arg1 *C.gchar          // out
	var _arg2 *C.GstPad         // out
	var _arg3 *C.GstPadTemplate // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg3 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_ghost_pad_new_from_template(_arg1, _arg2, _arg3)
	runtime.KeepAlive(name)
	runtime.KeepAlive(target)
	runtime.KeepAlive(templ)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// NewGhostPadNoTarget: create a new ghostpad without a target with the given
// direction. A target can be set on the ghostpad later with the
// gst_ghost_pad_set_target() function.
//
// The created ghostpad will not have a padtemplate.
//
// The function takes the following parameters:
//
//    - name (optional) of the new pad, or NULL to assign a default name.
//    - dir: direction of the ghostpad.
//
// The function returns the following values:
//
//    - ghostPad (optional): new Pad, or NULL in case of an error.
//
func NewGhostPadNoTarget(name string, dir PadDirection) *GhostPad {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GstPadDirection(dir)

	_cret = C.gst_ghost_pad_new_no_target(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(dir)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// NewGhostPadNoTargetFromTemplate: create a new ghostpad based on templ,
// without setting a target. The direction will be taken from the templ.
//
// The function takes the following parameters:
//
//    - name (optional) of the new pad, or NULL to assign a default name.
//    - templ to create the ghostpad from.
//
// The function returns the following values:
//
//    - ghostPad (optional): new Pad, or NULL in case of an error.
//
func NewGhostPadNoTargetFromTemplate(name string, templ *PadTemplate) *GhostPad {
	var _arg1 *C.gchar          // out
	var _arg2 *C.GstPadTemplate // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_ghost_pad_new_no_target_from_template(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(templ)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// Construct: finish initialization of a newly allocated ghost pad.
//
// This function is most useful in language bindings and when subclassing
// GhostPad; plugin and application developers normally will not call this
// function. Call this function directly after a call to g_object_new
// (GST_TYPE_GHOST_PAD, "direction", dir, ..., NULL).
//
// Deprecated: This function is deprecated since 1.18 and does nothing anymore.
//
// The function returns the following values:
//
//    - ok: TRUE if the construction succeeds, FALSE otherwise.
//
func (gpad *GhostPad) Construct() bool {
	var _arg0 *C.GstGhostPad // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGhostPad)(unsafe.Pointer(coreglib.InternObject(gpad).Native()))

	_cret = C.gst_ghost_pad_construct(_arg0)
	runtime.KeepAlive(gpad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Target: get the target pad of gpad. Unref target pad after usage.
//
// The function returns the following values:
//
//    - pad (optional): target Pad, can be NULL if the ghostpad has no target
//      set. Unref target pad after usage.
//
func (gpad *GhostPad) Target() *Pad {
	var _arg0 *C.GstGhostPad // out
	var _cret *C.GstPad      // in

	_arg0 = (*C.GstGhostPad)(unsafe.Pointer(coreglib.InternObject(gpad).Native()))

	_cret = C.gst_ghost_pad_get_target(_arg0)
	runtime.KeepAlive(gpad)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// SetTarget: set the new target of the ghostpad gpad. Any existing target is
// unlinked and links to the new target are established. if newtarget is NULL
// the target will be cleared.
//
// The function takes the following parameters:
//
//    - newtarget (optional): new pad target.
//
// The function returns the following values:
//
//    - ok: TRUE if the new target could be set. This function can return FALSE
//      when the internal pads could not be linked.
//
func (gpad *GhostPad) SetTarget(newtarget *Pad) bool {
	var _arg0 *C.GstGhostPad // out
	var _arg1 *C.GstPad      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGhostPad)(unsafe.Pointer(coreglib.InternObject(gpad).Native()))
	if newtarget != nil {
		_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(newtarget).Native()))
	}

	_cret = C.gst_ghost_pad_set_target(_arg0, _arg1)
	runtime.KeepAlive(gpad)
	runtime.KeepAlive(newtarget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GhostPadActivateModeDefault: invoke the default activate mode function of a
// ghost pad.
//
// The function takes the following parameters:
//
//    - pad to activate or deactivate.
//    - parent (optional) of pad or NULL.
//    - mode: requested activation mode.
//    - active: whether the pad should be active or not.
//
// The function returns the following values:
//
//    - ok: TRUE if the operation was successful.
//
func GhostPadActivateModeDefault(pad *Pad, parent GstObjector, mode PadMode, active bool) bool {
	var _arg1 *C.GstPad    // out
	var _arg2 *C.GstObject // out
	var _arg3 C.GstPadMode // out
	var _arg4 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = C.GstPadMode(mode)
	if active {
		_arg4 = C.TRUE
	}

	_cret = C.gst_ghost_pad_activate_mode_default(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GhostPadInternalActivateModeDefault: invoke the default activate mode
// function of a proxy pad that is owned by a ghost pad.
//
// The function takes the following parameters:
//
//    - pad to activate or deactivate.
//    - parent (optional) of pad or NULL.
//    - mode: requested activation mode.
//    - active: whether the pad should be active or not.
//
// The function returns the following values:
//
//    - ok: TRUE if the operation was successful.
//
func GhostPadInternalActivateModeDefault(pad *Pad, parent GstObjector, mode PadMode, active bool) bool {
	var _arg1 *C.GstPad    // out
	var _arg2 *C.GstObject // out
	var _arg3 C.GstPadMode // out
	var _arg4 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = C.GstPadMode(mode)
	if active {
		_arg4 = C.TRUE
	}

	_cret = C.gst_ghost_pad_internal_activate_mode_default(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyPadOverrides contains methods that are overridable.
type ProxyPadOverrides struct {
}

func defaultProxyPadOverrides(v *ProxyPad) ProxyPadOverrides {
	return ProxyPadOverrides{}
}

type ProxyPad struct {
	_ [0]func() // equal guard
	Pad
}

var (
	_ GstObjector = (*ProxyPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ProxyPad, *ProxyPadClass, ProxyPadOverrides](
		GTypeProxyPad,
		initProxyPadClass,
		wrapProxyPad,
		defaultProxyPadOverrides,
	)
}

func initProxyPadClass(gclass unsafe.Pointer, overrides ProxyPadOverrides, classInitFunc func(*ProxyPadClass)) {
	if classInitFunc != nil {
		class := (*ProxyPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapProxyPad(obj *coreglib.Object) *ProxyPad {
	return &ProxyPad{
		Pad: Pad{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalProxyPad(p uintptr) (interface{}, error) {
	return wrapProxyPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Internal: get the internal pad of pad. Unref target pad after usage.
//
// The internal pad of a GhostPad is the internally used pad of opposite
// direction, which is used to link to the target.
//
// The function returns the following values:
//
//    - proxyPad (optional): target ProxyPad, can be NULL. Unref target pad after
//      usage.
//
func (pad *ProxyPad) Internal() *ProxyPad {
	var _arg0 *C.GstProxyPad // out
	var _cret *C.GstProxyPad // in

	_arg0 = (*C.GstProxyPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_proxy_pad_get_internal(_arg0)
	runtime.KeepAlive(pad)

	var _proxyPad *ProxyPad // out

	if _cret != nil {
		_proxyPad = wrapProxyPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _proxyPad
}

// ProxyPadChainDefault: invoke the default chain function of the proxy pad.
//
// The function takes the following parameters:
//
//    - pad: sink Pad, returns GST_FLOW_ERROR if not.
//    - parent (optional) of pad or NULL.
//    - buffer to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//    - flowReturn from the pad.
//
func ProxyPadChainDefault(pad *Pad, parent GstObjector, buffer *Buffer) FlowReturn {
	var _arg1 *C.GstPad       // out
	var _arg2 *C.GstObject    // out
	var _arg3 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_proxy_pad_chain_default(_arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(buffer)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// ProxyPadChainListDefault: invoke the default chain list function of the proxy
// pad.
//
// The function takes the following parameters:
//
//    - pad: sink Pad, returns GST_FLOW_ERROR if not.
//    - parent (optional) of pad or NULL.
//    - list to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//    - flowReturn from the pad.
//
func ProxyPadChainListDefault(pad *Pad, parent GstObjector, list *BufferList) FlowReturn {
	var _arg1 *C.GstPad        // out
	var _arg2 *C.GstObject     // out
	var _arg3 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_proxy_pad_chain_list_default(_arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(list)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// ProxyPadGetrangeDefault: invoke the default getrange function of the proxy
// pad.
//
// The function takes the following parameters:
//
//    - pad: src Pad, returns T_FLOW_ERROR if not.
//    - parent of pad.
//    - offset: start offset of the buffer.
//    - size: length of the buffer.
//
// The function returns the following values:
//
//    - buffer: pointer to hold the Buffer, returns T_FLOW_ERROR if NULL.
//    - flowReturn from the pad.
//
func ProxyPadGetrangeDefault(pad *Pad, parent GstObjector, offset uint64, size uint) (*Buffer, FlowReturn) {
	var _arg1 *C.GstPad       // out
	var _arg2 *C.GstObject    // out
	var _arg3 C.guint64       // out
	var _arg4 C.guint         // out
	var _arg5 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg3 = C.guint64(offset)
	_arg4 = C.guint(size)

	_cret = C.gst_proxy_pad_getrange_default(_arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// ProxyPadIterateInternalLinksDefault: invoke the default iterate internal
// links function of the proxy pad.
//
// The function takes the following parameters:
//
//    - pad to get the internal links of.
//    - parent (optional) of pad or NULL.
//
// The function returns the following values:
//
//    - iterator (optional) of Pad, or NULL if pad has no parent. Unref each
//      returned pad with gst_object_unref().
//
func ProxyPadIterateInternalLinksDefault(pad *Pad, parent GstObjector) *Iterator {
	var _arg1 *C.GstPad      // out
	var _arg2 *C.GstObject   // out
	var _cret *C.GstIterator // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gst_proxy_pad_iterate_internal_links_default(_arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// GhostPadClass: instance of this type is always passed by reference.
type GhostPadClass struct {
	*ghostPadClass
}

// ghostPadClass is the struct that's finalized.
type ghostPadClass struct {
	native *C.GstGhostPadClass
}

func (g *GhostPadClass) ParentClass() *ProxyPadClass {
	valptr := &g.native.parent_class
	var _v *ProxyPadClass // out
	_v = (*ProxyPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ProxyPadClass: instance of this type is always passed by reference.
type ProxyPadClass struct {
	*proxyPadClass
}

// proxyPadClass is the struct that's finalized.
type proxyPadClass struct {
	native *C.GstProxyPadClass
}

func (p *ProxyPadClass) ParentClass() *PadClass {
	valptr := &p.native.parent_class
	var _v *PadClass // out
	_v = (*PadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
