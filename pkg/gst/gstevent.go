// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeEventType      = coreglib.Type(C.gst_event_type_get_type())
	GTypeQOSType        = coreglib.Type(C.gst_qos_type_get_type())
	GTypeEventTypeFlags = coreglib.Type(C.gst_event_type_flags_get_type())
	GTypeEvent          = coreglib.Type(C.gst_event_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeEventType, F: marshalEventType},
		coreglib.TypeMarshaler{T: GTypeQOSType, F: marshalQOSType},
		coreglib.TypeMarshaler{T: GTypeEventTypeFlags, F: marshalEventTypeFlags},
		coreglib.TypeMarshaler{T: GTypeEvent, F: marshalEvent},
	})
}

const EVENT_NUM_SHIFT = 8

// EventType lists the standard event types that can be sent in a pipeline.
//
// The custom event types can be used for private messages between elements that
// can't be expressed using normal GStreamer buffer passing semantics. Custom
// events carry an arbitrary Structure. Specific custom events are distinguished
// by the name of the structure.
type EventType C.gint

const (
	// EventUnknown: unknown event.
	EventUnknown EventType = 0
	// EventFlushStart: start a flush operation. This event clears all data from
	// the pipeline and unblock all streaming threads.
	EventFlushStart EventType = 2563
	// EventFlushStop: stop a flush operation. This event resets the
	// running-time of the pipeline.
	EventFlushStop EventType = 5127
	// EventStreamStart: event to mark the start of a new stream. Sent before
	// any other serialized event and only sent at the start of a new stream,
	// not after flushing seeks.
	EventStreamStart EventType = 10254
	// EventCaps event. Notify the pad of a new media type.
	EventCaps EventType = 12814
	// EventSegment: new media segment follows in the dataflow. The segment
	// events contains information for clipping buffers and converting buffer
	// timestamps to running-time and stream-time.
	EventSegment EventType = 17934
	// EventStreamCollection: new StreamCollection is available (Since: 1.10).
	EventStreamCollection EventType = 19230
	// EventTag: new set of metadata tags has been found in the stream.
	EventTag EventType = 20510
	// EventBuffersize: notification of buffering requirements. Currently not
	// used yet.
	EventBuffersize EventType = 23054
	// EventSinkMessage: event that sinks turn into a message. Used to send
	// messages that should be emitted in sync with rendering.
	EventSinkMessage EventType = 25630
	// EventStreamGroupDone indicates that there is no more data for the stream
	// group ID in the message. Sent before EOS in some instances and should be
	// handled mostly the same. (Since: 1.10).
	EventStreamGroupDone EventType = 26894
	// EventEos: end-Of-Stream. No more data is to be expected to follow without
	// either a STREAM_START event, or a FLUSH_STOP and a SEGMENT event.
	EventEos EventType = 28174
	// EventToc: event which indicates that a new table of contents (TOC) was
	// found or updated.
	EventToc EventType = 30750
	// EventProtection: event which indicates that new or updated encryption
	// information has been found in the stream.
	EventProtection EventType = 33310
	// EventSegmentDone marks the end of a segment playback.
	EventSegmentDone EventType = 38406
	// EventGap marks a gap in the datastream.
	EventGap EventType = 40966
	// EventInstantRateChange: notify downstream that a playback rate override
	// should be applied as soon as possible. (Since: 1.18).
	EventInstantRateChange EventType = 46090
	// EventQos: quality message. Used to indicate to upstream elements that the
	// downstream elements should adjust their processing rate.
	EventQos EventType = 48641
	// EventSeek: request for a new playback position and rate.
	EventSeek EventType = 51201
	// EventNavigation: navigation events are usually used for communicating
	// user requests, such as mouse or keyboard movements, to upstream elements.
	EventNavigation EventType = 53761
	// EventLatency: notification of new latency adjustment. Sinks will use the
	// latency information to adjust their synchronisation.
	EventLatency EventType = 56321
	// EventStep: request for stepping through the media. Sinks will usually
	// execute the step operation.
	EventStep EventType = 58881
	// EventReconfigure: request for upstream renegotiating caps and
	// reconfiguring.
	EventReconfigure EventType = 61441
	// EventTocSelect: request for a new playback position based on TOC entry's
	// UID.
	EventTocSelect EventType = 64001
	// EventSelectStreams: request to select one or more streams (Since: 1.10).
	EventSelectStreams EventType = 66561
	// EventInstantRateSyncTime: sent by the pipeline to notify elements that
	// handle the instant-rate-change event about the running-time when the rate
	// multiplier should be applied (or was applied). (Since: 1.18).
	EventInstantRateSyncTime EventType = 66817
	// EventCustomUpstream: upstream custom event.
	EventCustomUpstream EventType = 69121
	// EventCustomDownstream: downstream custom event that travels in the data
	// flow.
	EventCustomDownstream EventType = 71686
	// EventCustomDownstreamOob: custom out-of-band downstream event.
	EventCustomDownstreamOob EventType = 74242
	// EventCustomDownstreamSticky: custom sticky downstream event.
	EventCustomDownstreamSticky EventType = 76830
	// EventCustomBoth: custom upstream or downstream event. In-band when
	// travelling downstream.
	EventCustomBoth EventType = 79367
	// EventCustomBothOob: custom upstream or downstream out-of-band event.
	EventCustomBothOob EventType = 81923
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventType.
func (e EventType) String() string {
	switch e {
	case EventUnknown:
		return "Unknown"
	case EventFlushStart:
		return "FlushStart"
	case EventFlushStop:
		return "FlushStop"
	case EventStreamStart:
		return "StreamStart"
	case EventCaps:
		return "Caps"
	case EventSegment:
		return "Segment"
	case EventStreamCollection:
		return "StreamCollection"
	case EventTag:
		return "Tag"
	case EventBuffersize:
		return "Buffersize"
	case EventSinkMessage:
		return "SinkMessage"
	case EventStreamGroupDone:
		return "StreamGroupDone"
	case EventEos:
		return "Eos"
	case EventToc:
		return "Toc"
	case EventProtection:
		return "Protection"
	case EventSegmentDone:
		return "SegmentDone"
	case EventGap:
		return "Gap"
	case EventInstantRateChange:
		return "InstantRateChange"
	case EventQos:
		return "Qos"
	case EventSeek:
		return "Seek"
	case EventNavigation:
		return "Navigation"
	case EventLatency:
		return "Latency"
	case EventStep:
		return "Step"
	case EventReconfigure:
		return "Reconfigure"
	case EventTocSelect:
		return "TocSelect"
	case EventSelectStreams:
		return "SelectStreams"
	case EventInstantRateSyncTime:
		return "InstantRateSyncTime"
	case EventCustomUpstream:
		return "CustomUpstream"
	case EventCustomDownstream:
		return "CustomDownstream"
	case EventCustomDownstreamOob:
		return "CustomDownstreamOob"
	case EventCustomDownstreamSticky:
		return "CustomDownstreamSticky"
	case EventCustomBoth:
		return "CustomBoth"
	case EventCustomBothOob:
		return "CustomBothOob"
	default:
		return fmt.Sprintf("EventType(%d)", e)
	}
}

// EventTypeGetFlags gets the EventTypeFlags associated with type.
//
// The function takes the following parameters:
//
//    - typ: EventType.
//
// The function returns the following values:
//
//    - eventTypeFlags: EventTypeFlags.
//
func EventTypeGetFlags(typ EventType) EventTypeFlags {
	var _arg1 C.GstEventType      // out
	var _cret C.GstEventTypeFlags // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_get_flags(_arg1)
	runtime.KeepAlive(typ)

	var _eventTypeFlags EventTypeFlags // out

	_eventTypeFlags = EventTypeFlags(_cret)

	return _eventTypeFlags
}

// EventTypeGetName: get a printable name for the given event type. Do not
// modify or free.
//
// The function takes the following parameters:
//
//    - typ: event type.
//
// The function returns the following values:
//
//    - utf8: reference to the static name of the event.
//
func EventTypeGetName(typ EventType) string {
	var _arg1 C.GstEventType // out
	var _cret *C.gchar       // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EventTypeToQuark: get the unique quark for the given event type.
//
// The function takes the following parameters:
//
//    - typ: event type.
//
// The function returns the following values:
//
//    - quark associated with the event type.
//
func EventTypeToQuark(typ EventType) glib.Quark {
	var _arg1 C.GstEventType // out
	var _cret C.GQuark       // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_to_quark(_arg1)
	runtime.KeepAlive(typ)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// QOSType: different types of QoS events that can be given to the
// gst_event_new_qos() method.
type QOSType C.gint

const (
	// QosTypeOverflow: qoS event type that is produced when upstream elements
	// are producing data too quickly and the element can't keep up processing
	// the data. Upstream should reduce their production rate. This type is also
	// used when buffers arrive early or in time.
	QosTypeOverflow QOSType = iota
	// QosTypeUnderflow: qoS event type that is produced when upstream elements
	// are producing data too slowly and need to speed up their production rate.
	QosTypeUnderflow
	// QosTypeThrottle: qoS event type that is produced when the application
	// enabled throttling to limit the data rate.
	QosTypeThrottle
)

func marshalQOSType(p uintptr) (interface{}, error) {
	return QOSType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for QOSType.
func (q QOSType) String() string {
	switch q {
	case QosTypeOverflow:
		return "Overflow"
	case QosTypeUnderflow:
		return "Underflow"
	case QosTypeThrottle:
		return "Throttle"
	default:
		return fmt.Sprintf("QOSType(%d)", q)
	}
}

// EventTypeFlags indicate the aspects of the different EventType values. You
// can get the type flags of a EventType with the gst_event_type_get_flags()
// function.
type EventTypeFlags C.guint

const (
	// EventTypeUpstream: set if the event can travel upstream.
	EventTypeUpstream EventTypeFlags = 0b1
	// EventTypeDownstream: set if the event can travel downstream.
	EventTypeDownstream EventTypeFlags = 0b10
	// EventTypeSerialized: set if the event should be serialized with data
	// flow.
	EventTypeSerialized EventTypeFlags = 0b100
	// EventTypeSticky: set if the event is sticky on the pads.
	EventTypeSticky EventTypeFlags = 0b1000
	// EventTypeStickyMulti: multiple sticky events can be on a pad, each
	// identified by the event name.
	EventTypeStickyMulti EventTypeFlags = 0b10000
)

func marshalEventTypeFlags(p uintptr) (interface{}, error) {
	return EventTypeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for EventTypeFlags.
func (e EventTypeFlags) String() string {
	if e == 0 {
		return "EventTypeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case EventTypeUpstream:
			builder.WriteString("Upstream|")
		case EventTypeDownstream:
			builder.WriteString("Downstream|")
		case EventTypeSerialized:
			builder.WriteString("Serialized|")
		case EventTypeSticky:
			builder.WriteString("Sticky|")
		case EventTypeStickyMulti:
			builder.WriteString("StickyMulti|")
		default:
			builder.WriteString(fmt.Sprintf("EventTypeFlags(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e EventTypeFlags) Has(other EventTypeFlags) bool {
	return (e & other) == other
}

// Event: event class provides factory methods to construct events for sending
// and functions to query (parse) received events.
//
// Events are usually created with gst_event_new_*() which takes event-type
// specific parameters as arguments. To send an event application will usually
// use gst_element_send_event() and elements will use gst_pad_send_event() or
// gst_pad_push_event(). The event should be unreffed with gst_event_unref() if
// it has not been sent.
//
// Events that have been received can be parsed with their respective
// gst_event_parse_*() functions. It is valid to pass NULL for unwanted details.
//
// Events are passed between elements in parallel to the data stream. Some
// events are serialized with buffers, others are not. Some events only travel
// downstream, others only upstream. Some events can travel both upstream and
// downstream.
//
// The events are used to signal special conditions in the datastream such as
// EOS (end of stream) or the start of a new stream-segment. Events are also
// used to flush the pipeline of any pending data.
//
// Most of the event API is used inside plugins. Applications usually only
// construct and use seek events. To do that gst_event_new_seek() is used to
// create a seek event. It takes the needed parameters to specify seeking time
// and mode.
//
//    GstEvent *event;
//    gboolean result;
//    ...
//    // construct a seek event to play the media from second 2 to 5, flush
//    // the pipeline to decrease latency.
//    event = gst_event_new_seek (1.0,
//       GST_FORMAT_TIME,
//       GST_SEEK_FLAG_FLUSH,
//       GST_SEEK_TYPE_SET, 2 * GST_SECOND,
//       GST_SEEK_TYPE_SET, 5 * GST_SECOND);
//    ...
//    result = gst_element_send_event (pipeline, event);
//    if (!result)
//      g_warning ("seek failed");
//    ...
//
// An instance of this type is always passed by reference.
type Event struct {
	*event
}

// event is the struct that's finalized.
type event struct {
	native *C.GstEvent
}

func marshalEvent(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Event{&event{(*C.GstEvent)(b)}}, nil
}

// NewEventBufferSize constructs a struct Event.
func NewEventBufferSize(format Format, minsize int64, maxsize int64, async bool) *Event {
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.gint64    // out
	var _arg4 C.gboolean  // out
	var _cret *C.GstEvent // in

	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(minsize)
	_arg3 = C.gint64(maxsize)
	if async {
		_arg4 = C.TRUE
	}

	_cret = C.gst_event_new_buffer_size(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(format)
	runtime.KeepAlive(minsize)
	runtime.KeepAlive(maxsize)
	runtime.KeepAlive(async)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventCaps constructs a struct Event.
func NewEventCaps(caps *Caps) *Event {
	var _arg1 *C.GstCaps  // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_event_new_caps(_arg1)
	runtime.KeepAlive(caps)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// NewEventCustom constructs a struct Event.
func NewEventCustom(typ EventType, structure *Structure) *Event {
	var _arg1 C.GstEventType  // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstEvent     // in

	_arg1 = C.GstEventType(typ)
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_event_new_custom(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(structure)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// NewEventEos constructs a struct Event.
func NewEventEos() *Event {
	var _cret *C.GstEvent // in

	_cret = C.gst_event_new_eos()

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventFlushStart constructs a struct Event.
func NewEventFlushStart() *Event {
	var _cret *C.GstEvent // in

	_cret = C.gst_event_new_flush_start()

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventFlushStop constructs a struct Event.
func NewEventFlushStop(resetTime bool) *Event {
	var _arg1 C.gboolean  // out
	var _cret *C.GstEvent // in

	if resetTime {
		_arg1 = C.TRUE
	}

	_cret = C.gst_event_new_flush_stop(_arg1)
	runtime.KeepAlive(resetTime)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventGap constructs a struct Event.
func NewEventGap(timestamp ClockTime, duration ClockTime) *Event {
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GstEvent    // in

	_arg1 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.guint64(duration)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_event_new_gap(_arg1, _arg2)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventInstantRateChange constructs a struct Event.
func NewEventInstantRateChange(rateMultiplier float64, newFlags SegmentFlags) *Event {
	var _arg1 C.gdouble         // out
	var _arg2 C.GstSegmentFlags // out
	var _cret *C.GstEvent       // in

	_arg1 = C.gdouble(rateMultiplier)
	_arg2 = C.GstSegmentFlags(newFlags)

	_cret = C.gst_event_new_instant_rate_change(_arg1, _arg2)
	runtime.KeepAlive(rateMultiplier)
	runtime.KeepAlive(newFlags)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventInstantRateSyncTime constructs a struct Event.
func NewEventInstantRateSyncTime(rateMultiplier float64, runningTime ClockTime, upstreamRunningTime ClockTime) *Event {
	var _arg1 C.gdouble      // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _cret *C.GstEvent    // in

	_arg1 = C.gdouble(rateMultiplier)
	_arg2 = C.guint64(runningTime)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(upstreamRunningTime)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_event_new_instant_rate_sync_time(_arg1, _arg2, _arg3)
	runtime.KeepAlive(rateMultiplier)
	runtime.KeepAlive(runningTime)
	runtime.KeepAlive(upstreamRunningTime)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventLatency constructs a struct Event.
func NewEventLatency(latency ClockTime) *Event {
	var _arg1 C.GstClockTime // out
	var _cret *C.GstEvent    // in

	_arg1 = C.guint64(latency)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_event_new_latency(_arg1)
	runtime.KeepAlive(latency)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventNavigation constructs a struct Event.
func NewEventNavigation(structure *Structure) *Event {
	var _arg1 *C.GstStructure // out
	var _cret *C.GstEvent     // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_event_new_navigation(_arg1)
	runtime.KeepAlive(structure)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventProtection constructs a struct Event.
func NewEventProtection(systemId string, data *Buffer, origin string) *Event {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GstBuffer // out
	var _arg3 *C.gchar     // out
	var _cret *C.GstEvent  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(systemId)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(data)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(origin)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_event_new_protection(_arg1, _arg2, _arg3)
	runtime.KeepAlive(systemId)
	runtime.KeepAlive(data)
	runtime.KeepAlive(origin)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventQos constructs a struct Event.
func NewEventQos(typ QOSType, proportion float64, diff ClockTimeDiff, timestamp ClockTime) *Event {
	var _arg1 C.GstQOSType       // out
	var _arg2 C.gdouble          // out
	var _arg3 C.GstClockTimeDiff // out
	var _arg4 C.GstClockTime     // out
	var _cret *C.GstEvent        // in

	_arg1 = C.GstQOSType(typ)
	_arg2 = C.gdouble(proportion)
	_arg3 = C.gint64(diff)
	type _ = ClockTimeDiff
	type _ = int64
	_arg4 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_event_new_qos(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(proportion)
	runtime.KeepAlive(diff)
	runtime.KeepAlive(timestamp)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// NewEventReconfigure constructs a struct Event.
func NewEventReconfigure() *Event {
	var _cret *C.GstEvent // in

	_cret = C.gst_event_new_reconfigure()

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSeek constructs a struct Event.
func NewEventSeek(rate float64, format Format, flags SeekFlags, startType SeekType, start int64, stopType SeekType, stop int64) *Event {
	var _arg1 C.gdouble      // out
	var _arg2 C.GstFormat    // out
	var _arg3 C.GstSeekFlags // out
	var _arg4 C.GstSeekType  // out
	var _arg5 C.gint64       // out
	var _arg6 C.GstSeekType  // out
	var _arg7 C.gint64       // out
	var _cret *C.GstEvent    // in

	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.GstSeekFlags(flags)
	_arg4 = C.GstSeekType(startType)
	_arg5 = C.gint64(start)
	_arg6 = C.GstSeekType(stopType)
	_arg7 = C.gint64(stop)

	_cret = C.gst_event_new_seek(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stopType)
	runtime.KeepAlive(stop)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// NewEventSegment constructs a struct Event.
func NewEventSegment(segment *Segment) *Event {
	var _arg1 *C.GstSegment // out
	var _cret *C.GstEvent   // in

	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C.gst_event_new_segment(_arg1)
	runtime.KeepAlive(segment)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// NewEventSegmentDone constructs a struct Event.
func NewEventSegmentDone(format Format, position int64) *Event {
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _cret *C.GstEvent // in

	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(position)

	_cret = C.gst_event_new_segment_done(_arg1, _arg2)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSelectStreams constructs a struct Event.
func NewEventSelectStreams(streams []string) *Event {
	var _arg1 *C.GList    // out
	var _cret *C.GstEvent // in

	for i := len(streams) - 1; i >= 0; i-- {
		src := streams[i]
		var dst *C.gchar // out
		dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
		defer C.free(unsafe.Pointer(dst))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.gst_event_new_select_streams(_arg1)
	runtime.KeepAlive(streams)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSinkMessage constructs a struct Event.
func NewEventSinkMessage(name string, msg *Message) *Event {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstMessage // out
	var _cret *C.GstEvent   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	_cret = C.gst_event_new_sink_message(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(msg)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStep constructs a struct Event.
func NewEventStep(format Format, amount uint64, rate float64, flush bool, intermediate bool) *Event {
	var _arg1 C.GstFormat // out
	var _arg2 C.guint64   // out
	var _arg3 C.gdouble   // out
	var _arg4 C.gboolean  // out
	var _arg5 C.gboolean  // out
	var _cret *C.GstEvent // in

	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(amount)
	_arg3 = C.gdouble(rate)
	if flush {
		_arg4 = C.TRUE
	}
	if intermediate {
		_arg5 = C.TRUE
	}

	_cret = C.gst_event_new_step(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(format)
	runtime.KeepAlive(amount)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(flush)
	runtime.KeepAlive(intermediate)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// NewEventStreamCollection constructs a struct Event.
func NewEventStreamCollection(collection *StreamCollection) *Event {
	var _arg1 *C.GstStreamCollection // out
	var _cret *C.GstEvent            // in

	_arg1 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_event_new_stream_collection(_arg1)
	runtime.KeepAlive(collection)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStreamGroupDone constructs a struct Event.
func NewEventStreamGroupDone(groupId uint) *Event {
	var _arg1 C.guint     // out
	var _cret *C.GstEvent // in

	_arg1 = C.guint(groupId)

	_cret = C.gst_event_new_stream_group_done(_arg1)
	runtime.KeepAlive(groupId)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStreamStart constructs a struct Event.
func NewEventStreamStart(streamId string) *Event {
	var _arg1 *C.gchar    // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_event_new_stream_start(_arg1)
	runtime.KeepAlive(streamId)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventToc constructs a struct Event.
func NewEventToc(toc *Toc, updated bool) *Event {
	var _arg1 *C.GstToc   // out
	var _arg2 C.gboolean  // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	if updated {
		_arg2 = C.TRUE
	}

	_cret = C.gst_event_new_toc(_arg1, _arg2)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(updated)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventTocSelect constructs a struct Event.
func NewEventTocSelect(uid string) *Event {
	var _arg1 *C.gchar    // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_event_new_toc_select(_arg1)
	runtime.KeepAlive(uid)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// MiniObject: parent structure.
func (e *Event) MiniObject() *MiniObject {
	valptr := &e.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Type of the event.
func (e *Event) Type() EventType {
	valptr := &e.native._type
	var _v EventType // out
	_v = EventType(*valptr)
	return _v
}

// Timestamp: timestamp of the event.
func (e *Event) Timestamp() uint64 {
	valptr := &e.native.timestamp
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Timestamp: timestamp of the event.
func (e *Event) SetTimestamp(timestamp uint64) {
	valptr := &e.native.timestamp
	*valptr = C.guint64(timestamp)
}

// CopySegment parses a segment event and copies the Segment into the location
// given by segment.
//
// The function takes the following parameters:
//
//    - segment: pointer to a Segment.
//
func (event *Event) CopySegment(segment *Segment) {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstSegment // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	C.gst_event_copy_segment(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(segment)
}

// RunningTimeOffset: retrieve the accumulated running time offset of the event.
//
// Events passing through Pads that have a running time offset set via
// gst_pad_set_offset() will get their offset adjusted according to the pad's
// offset.
//
// If the event contains any information that related to the running time, this
// information will need to be updated before usage with this offset.
//
// The function returns the following values:
//
//    - gint64 event's running time offset
//
//      MT safe.
//
func (event *Event) RunningTimeOffset() int64 {
	var _arg0 *C.GstEvent // out
	var _cret C.gint64    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_get_running_time_offset(_arg0)
	runtime.KeepAlive(event)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Seqnum: retrieve the sequence number of a event.
//
// Events have ever-incrementing sequence numbers, which may also be set
// explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
// indicate that a event corresponds to some other set of events or messages,
// for example an EOS event corresponding to a SEEK event. It is considered good
// practice to make this correspondence when possible, though it is not
// required.
//
// Note that events and messages share the same sequence number incrementor; two
// events or messages will never have the same sequence number unless that
// correspondence was made explicitly.
//
// The function returns the following values:
//
//    - guint32 event's sequence number.
//
//      MT safe.
//
func (event *Event) Seqnum() uint32 {
	var _arg0 *C.GstEvent // out
	var _cret C.guint32   // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_get_seqnum(_arg0)
	runtime.KeepAlive(event)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Structure access the structure of the event.
//
// The function returns the following values:
//
//    - structure (optional) of the event. The structure is still owned by the
//      event, which means that you should not free it and that the pointer
//      becomes invalid when you free the event.
//
//      MT safe.
//
func (event *Event) Structure() *Structure {
	var _arg0 *C.GstEvent     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_get_structure(_arg0)
	runtime.KeepAlive(event)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// HasName checks if event has the given name. This function is usually used to
// check the name of a custom event.
//
// The function takes the following parameters:
//
//    - name to check.
//
// The function returns the following values:
//
//    - ok: TRUE if name matches the name of the event structure.
//
func (event *Event) HasName(name string) bool {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.gchar    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_event_has_name(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasNameID checks if event has the given name. This function is usually used
// to check the name of a custom event.
//
// The function takes the following parameters:
//
//    - name to check as a GQuark.
//
// The function returns the following values:
//
//    - ok: TRUE if name matches the name of the event structure.
//
func (event *Event) HasNameID(name glib.Quark) bool {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GQuark    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.guint32(name)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_event_has_name_id(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseBufferSize: get the format, minsize, maxsize and async-flag in the
// buffersize event.
//
// The function returns the following values:
//
//    - format: pointer to store the format in.
//    - minsize: pointer to store the minsize in.
//    - maxsize: pointer to store the maxsize in.
//    - async: pointer to store the async-flag in.
//
func (event *Event) ParseBufferSize() (format Format, minsize int64, maxsize int64, async bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in
	var _arg3 C.gint64    // in
	var _arg4 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_buffer_size(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _format Format // out
	var _minsize int64 // out
	var _maxsize int64 // out
	var _async bool    // out

	_format = Format(_arg1)
	_minsize = int64(_arg2)
	_maxsize = int64(_arg3)
	if _arg4 != 0 {
		_async = true
	}

	return _format, _minsize, _maxsize, _async
}

// ParseCaps: get the caps from event. The caps remains valid as long as event
// remains valid.
//
// The function returns the following values:
//
//    - caps: pointer to the caps.
//
func (event *Event) ParseCaps() *Caps {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_caps(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _caps
}

// ParseFlushStop: parse the FLUSH_STOP event and retrieve the reset_time
// member.
//
// The function returns the following values:
//
//    - resetTime: if time should be reset.
//
func (event *Event) ParseFlushStop() bool {
	var _arg0 *C.GstEvent // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_flush_stop(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _resetTime bool // out

	if _arg1 != 0 {
		_resetTime = true
	}

	return _resetTime
}

// ParseGap: extract timestamp and duration from a new GAP event.
//
// The function returns the following values:
//
//    - timestamp (optional): location where to store the start time (pts) of the
//      gap, or NULL.
//    - duration (optional): location where to store the duration of the gap, or
//      NULL.
//
func (event *Event) ParseGap() (timestamp ClockTime, duration ClockTime) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // in
	var _arg2 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_gap(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _timestamp ClockTime // out
	var _duration ClockTime  // out

	_timestamp = uint64(_arg1)
	type _ = ClockTime
	type _ = uint64
	_duration = uint64(_arg2)
	type _ = ClockTime
	type _ = uint64

	return _timestamp, _duration
}

// ParseGapFlags: retrieve the gap flags that may have been set on a gap event
// with gst_event_set_gap_flags().
//
// The function returns the following values:
//
//    - flags or NULL.
//
func (event *Event) ParseGapFlags() GapFlags {
	var _arg0 *C.GstEvent   // out
	var _arg1 C.GstGapFlags // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_gap_flags(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _flags GapFlags // out

	_flags = GapFlags(_arg1)

	return _flags
}

// The function returns the following values:
//
//    - groupId address of variable where to store the group id.
//    - ok: TRUE if a group id was set on the event and could be parsed, FALSE
//      otherwise.
//
func (event *Event) ParseGroupID() (uint, bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint     // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_parse_group_id(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _groupId uint // out
	var _ok bool      // out

	_groupId = uint(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _groupId, _ok
}

// ParseInstantRateChange: extract rate and flags from an instant-rate-change
// event.
//
// The function returns the following values:
//
//    - rateMultiplier (optional): location in which to store the rate multiplier
//      of the instant-rate-change event, or NULL.
//    - newFlags (optional): location in which to store the new segment flags of
//      the instant-rate-change event, or NULL.
//
func (event *Event) ParseInstantRateChange() (float64, SegmentFlags) {
	var _arg0 *C.GstEvent       // out
	var _arg1 C.gdouble         // in
	var _arg2 C.GstSegmentFlags // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_instant_rate_change(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _rateMultiplier float64 // out
	var _newFlags SegmentFlags  // out

	_rateMultiplier = float64(_arg1)
	_newFlags = SegmentFlags(_arg2)

	return _rateMultiplier, _newFlags
}

// ParseInstantRateSyncTime: extract the rate multiplier and running times from
// an instant-rate-sync-time event.
//
// The function returns the following values:
//
//    - rateMultiplier (optional): location where to store the rate of the
//      instant-rate-sync-time event, or NULL.
//    - runningTime (optional): location in which to store the running time of
//      the instant-rate-sync-time event, or NULL.
//    - upstreamRunningTime (optional): location in which to store the upstream
//      running time of the instant-rate-sync-time event, or NULL.
//
func (event *Event) ParseInstantRateSyncTime() (rateMultiplier float64, runningTime ClockTime, upstreamRunningTime ClockTime) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.gdouble      // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_instant_rate_sync_time(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(event)

	var _rateMultiplier float64        // out
	var _runningTime ClockTime         // out
	var _upstreamRunningTime ClockTime // out

	_rateMultiplier = float64(_arg1)
	_runningTime = uint64(_arg2)
	type _ = ClockTime
	type _ = uint64
	_upstreamRunningTime = uint64(_arg3)
	type _ = ClockTime
	type _ = uint64

	return _rateMultiplier, _runningTime, _upstreamRunningTime
}

// ParseLatency: get the latency in the latency event.
//
// The function returns the following values:
//
//    - latency: pointer to store the latency in.
//
func (event *Event) ParseLatency() ClockTime {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_latency(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _latency ClockTime // out

	_latency = uint64(_arg1)
	type _ = ClockTime
	type _ = uint64

	return _latency
}

// ParseProtection parses an event containing protection system specific
// information and stores the results in system_id, data and origin. The data
// stored in system_id, origin and data are valid until event is released.
//
// The function returns the following values:
//
//    - systemId (optional): pointer to store the UUID string uniquely
//      identifying a content protection system.
//    - data (optional): pointer to store a Buffer holding protection system
//      specific information.
//    - origin (optional): pointer to store a value that indicates where the
//      protection information carried by event was extracted from.
//
func (event *Event) ParseProtection() (systemId string, data *Buffer, origin string) {
	var _arg0 *C.GstEvent  // out
	var _arg1 *C.gchar     // in
	var _arg2 *C.GstBuffer // in
	var _arg3 *C.gchar     // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_protection(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(event)

	var _systemId string // out
	var _data *Buffer    // out
	var _origin string   // out

	if _arg1 != nil {
		_systemId = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		_data = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	}
	if _arg3 != nil {
		_origin = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	}

	return _systemId, _data, _origin
}

// ParseQos: get the type, proportion, diff and timestamp in the qos event. See
// gst_event_new_qos() for more information about the different QoS values.
//
// timestamp will be adjusted for any pad offsets of pads it was passing
// through.
//
// The function returns the following values:
//
//    - typ: pointer to store the QoS type in.
//    - proportion: pointer to store the proportion in.
//    - diff: pointer to store the diff in.
//    - timestamp: pointer to store the timestamp in.
//
func (event *Event) ParseQos() (QOSType, float64, ClockTimeDiff, ClockTime) {
	var _arg0 *C.GstEvent        // out
	var _arg1 C.GstQOSType       // in
	var _arg2 C.gdouble          // in
	var _arg3 C.GstClockTimeDiff // in
	var _arg4 C.GstClockTime     // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_qos(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _typ QOSType         // out
	var _proportion float64  // out
	var _diff ClockTimeDiff  // out
	var _timestamp ClockTime // out

	_typ = QOSType(_arg1)
	_proportion = float64(_arg2)
	_diff = int64(_arg3)
	type _ = ClockTimeDiff
	type _ = int64
	_timestamp = uint64(_arg4)
	type _ = ClockTime
	type _ = uint64

	return _typ, _proportion, _diff, _timestamp
}

// ParseSeek parses a seek event and stores the results in the given result
// locations.
//
// The function returns the following values:
//
//    - rate: result location for the rate.
//    - format: result location for the stream format.
//    - flags: result location for the SeekFlags.
//    - startType: result location for the SeekType of the start position.
//    - start: result location for the start position expressed in format.
//    - stopType: result location for the SeekType of the stop position.
//    - stop: result location for the stop position expressed in format.
//
func (event *Event) ParseSeek() (rate float64, format Format, flags SeekFlags, startType SeekType, start int64, stopType SeekType, stop int64) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.gdouble      // in
	var _arg2 C.GstFormat    // in
	var _arg3 C.GstSeekFlags // in
	var _arg4 C.GstSeekType  // in
	var _arg5 C.gint64       // in
	var _arg6 C.GstSeekType  // in
	var _arg7 C.gint64       // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_seek(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(event)

	var _rate float64       // out
	var _format Format      // out
	var _flags SeekFlags    // out
	var _startType SeekType // out
	var _start int64        // out
	var _stopType SeekType  // out
	var _stop int64         // out

	_rate = float64(_arg1)
	_format = Format(_arg2)
	_flags = SeekFlags(_arg3)
	_startType = SeekType(_arg4)
	_start = int64(_arg5)
	_stopType = SeekType(_arg6)
	_stop = int64(_arg7)

	return _rate, _format, _flags, _startType, _start, _stopType, _stop
}

// ParseSeekTrickmodeInterval: retrieve the trickmode interval that may have
// been set on a seek event with gst_event_set_seek_trickmode_interval().
//
// The function returns the following values:
//
func (event *Event) ParseSeekTrickmodeInterval() ClockTime {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_seek_trickmode_interval(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _interval ClockTime // out

	_interval = uint64(_arg1)
	type _ = ClockTime
	type _ = uint64

	return _interval
}

// ParseSegment parses a segment event and stores the result in the given
// segment location. segment remains valid only until the event is freed. Don't
// modify the segment and make a copy if you want to modify it or store it for
// later use.
//
// The function returns the following values:
//
//    - segment: pointer to a Segment.
//
func (event *Event) ParseSegment() *Segment {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstSegment // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_segment(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _segment *Segment // out

	_segment = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _segment
}

// ParseSegmentDone extracts the position and format from the segment done
// message.
//
// The function returns the following values:
//
//    - format (optional): result location for the format, or NULL.
//    - position (optional): result location for the position, or NULL.
//
func (event *Event) ParseSegmentDone() (Format, int64) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_segment_done(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _format Format  // out
	var _position int64 // out

	_format = Format(_arg1)
	_position = int64(_arg2)

	return _format, _position
}

// ParseSelectStreams: parse the SELECT_STREAMS event and retrieve the contained
// streams.
//
// The function returns the following values:
//
//    - streams: streams.
//
func (event *Event) ParseSelectStreams() []string {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.GList    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_select_streams(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _streams []string // out

	_streams = make([]string, 0, gextras.ListSize(unsafe.Pointer(_arg1)))
	gextras.MoveList(unsafe.Pointer(_arg1), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_streams = append(_streams, dst)
	})

	return _streams
}

// ParseSinkMessage: parse the sink-message event. Unref msg after usage.
//
// The function returns the following values:
//
//    - msg: pointer to store the Message in.
//
func (event *Event) ParseSinkMessage() *Message {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstMessage // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_sink_message(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _msg *Message // out

	_msg = (*Message)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_msg)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _msg
}

// ParseStep: parse the step event.
//
// The function returns the following values:
//
//    - format (optional): pointer to store the format in.
//    - amount (optional): pointer to store the amount in.
//    - rate (optional): pointer to store the rate in.
//    - flush (optional): pointer to store the flush boolean in.
//    - intermediate (optional): pointer to store the intermediate boolean in.
//
func (event *Event) ParseStep() (format Format, amount uint64, rate float64, flush bool, intermediate bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GstFormat // in
	var _arg2 C.guint64   // in
	var _arg3 C.gdouble   // in
	var _arg4 C.gboolean  // in
	var _arg5 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_step(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(event)

	var _format Format     // out
	var _amount uint64     // out
	var _rate float64      // out
	var _flush bool        // out
	var _intermediate bool // out

	_format = Format(_arg1)
	_amount = uint64(_arg2)
	_rate = float64(_arg3)
	if _arg4 != 0 {
		_flush = true
	}
	if _arg5 != 0 {
		_intermediate = true
	}

	return _format, _amount, _rate, _flush, _intermediate
}

// ParseStream: parse a stream-start event and extract the Stream from it.
//
// The function returns the following values:
//
//    - stream address of variable to store the stream.
//
func (event *Event) ParseStream() *Stream {
	var _arg0 *C.GstEvent  // out
	var _arg1 *C.GstStream // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _stream *Stream // out

	_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))

	return _stream
}

// ParseStreamCollection: retrieve new StreamCollection from STREAM_COLLECTION
// event event.
//
// The function returns the following values:
//
//    - collection: pointer to store the collection.
//
func (event *Event) ParseStreamCollection() *StreamCollection {
	var _arg0 *C.GstEvent            // out
	var _arg1 *C.GstStreamCollection // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_collection(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _collection *StreamCollection // out

	_collection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))

	return _collection
}

// The function returns the following values:
//
//    - flags address of variable where to store the stream flags.
//
func (event *Event) ParseStreamFlags() StreamFlags {
	var _arg0 *C.GstEvent      // out
	var _arg1 C.GstStreamFlags // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_flags(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _flags StreamFlags // out

	_flags = StreamFlags(_arg1)

	return _flags
}

// ParseStreamGroupDone: parse a stream-group-done event and store the result in
// the given group_id location.
//
// The function returns the following values:
//
//    - groupId address of variable to store the group id into.
//
func (event *Event) ParseStreamGroupDone() uint {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint     // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_group_done(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _groupId uint // out

	_groupId = uint(_arg1)

	return _groupId
}

// ParseStreamStart: parse a stream-id event and store the result in the given
// stream_id location. The string stored in stream_id must not be modified and
// will remain valid only until event gets freed. Make a copy if you want to
// modify it or store it for later use.
//
// The function returns the following values:
//
//    - streamId: pointer to store the stream-id.
//
func (event *Event) ParseStreamStart() string {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_start(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _streamId string // out

	_streamId = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))

	return _streamId
}

// ParseToc: parse a TOC event and store the results in the given toc and
// updated locations.
//
// The function returns the following values:
//
//    - toc: pointer to Toc structure.
//    - updated: pointer to store TOC updated flag.
//
func (event *Event) ParseToc() (*Toc, bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.GstToc   // in
	var _arg2 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_toc(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _toc *Toc     // out
	var _updated bool // out

	_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toc)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _arg2 != 0 {
		_updated = true
	}

	return _toc, _updated
}

// ParseTocSelect: parse a TOC select event and store the results in the given
// uid location.
//
// The function returns the following values:
//
//    - uid (optional): storage for the selection UID.
//
func (event *Event) ParseTocSelect() string {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_toc_select(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _uid string // out

	if _arg1 != nil {
		_uid = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	return _uid
}

// SetGapFlags sets flags on event to give additional information about the
// reason for the T_EVENT_GAP.
//
// The function takes the following parameters:
//
//    - flags: GapFlags.
//
func (event *Event) SetGapFlags(flags GapFlags) {
	var _arg0 *C.GstEvent   // out
	var _arg1 C.GstGapFlags // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.GstGapFlags(flags)

	C.gst_event_set_gap_flags(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(flags)
}

// SetGroupID: all streams that have the same group id are supposed to be played
// together, i.e. all streams inside a container file should have the same group
// id but different stream ids. The group id should change each time the stream
// is started, resulting in different group ids each time a file is played for
// example.
//
// Use gst_util_group_id_next() to get a new group id.
//
// The function takes the following parameters:
//
//    - groupId: group id to set.
//
func (event *Event) SetGroupID(groupId uint) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.guint(groupId)

	C.gst_event_set_group_id(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(groupId)
}

// SetRunningTimeOffset: set the running time offset of a event. See
// gst_event_get_running_time_offset() for more information.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - offset: the new running time offset.
//
func (event *Event) SetRunningTimeOffset(offset int64) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.gint64    // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.gint64(offset)

	C.gst_event_set_running_time_offset(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(offset)
}

// SetSeekTrickmodeInterval sets a trickmode interval on a (writable) seek
// event. Elements that support TRICKMODE_KEY_UNITS seeks SHOULD use this as the
// minimal interval between each frame they may output.
//
// The function takes the following parameters:
//
func (event *Event) SetSeekTrickmodeInterval(interval ClockTime) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.guint64(interval)
	type _ = ClockTime
	type _ = uint64

	C.gst_event_set_seek_trickmode_interval(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(interval)
}

// SetSeqnum: set the sequence number of a event.
//
// This function might be called by the creator of a event to indicate that the
// event relates to other events or messages. See gst_event_get_seqnum() for
// more information.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - seqnum: sequence number.
//
func (event *Event) SetSeqnum(seqnum uint32) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint32   // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.guint32(seqnum)

	C.gst_event_set_seqnum(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(seqnum)
}

// SetStream: set the stream on the stream-start event.
//
// The function takes the following parameters:
//
//    - stream object to set.
//
func (event *Event) SetStream(stream *Stream) {
	var _arg0 *C.GstEvent  // out
	var _arg1 *C.GstStream // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.gst_event_set_stream(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(stream)
}

// The function takes the following parameters:
//
//    - flags: stream flags to set.
//
func (event *Event) SetStreamFlags(flags StreamFlags) {
	var _arg0 *C.GstEvent      // out
	var _arg1 C.GstStreamFlags // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.GstStreamFlags(flags)

	C.gst_event_set_stream_flags(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(flags)
}

// WritableStructure: get a writable version of the structure.
//
// The function returns the following values:
//
//    - structure of the event. The structure is still owned by the event, which
//      means that you should not free it and that the pointer becomes invalid
//      when you free the event. This function checks if event is writable and
//      will never return NULL.
//
//      MT safe.
//
func (event *Event) WritableStructure() *Structure {
	var _arg0 *C.GstEvent     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_writable_structure(_arg0)
	runtime.KeepAlive(event)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}
