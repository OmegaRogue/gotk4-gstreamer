// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeFormat = coreglib.Type(C.gst_format_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFormat, F: marshalFormat},
	})
}

// FORMAT_PERCENT_MAX: PERCENT format is between 0 and this value.
const FORMAT_PERCENT_MAX = 1000000

// FORMAT_PERCENT_SCALE: value used to scale down the reported PERCENT format
// value to its real value.
const FORMAT_PERCENT_SCALE = 10000

// Format: standard predefined formats.
type Format C.gint

const (
	// FormatUndefined: undefined format.
	FormatUndefined Format = iota
	// FormatDefault: default format of the pad/element. This can be samples for
	// raw audio, frames/fields for raw video (some, but not all, elements
	// support this; use GST_FORMAT_TIME if you don't have a good reason to
	// query for samples/frames).
	FormatDefault
	// FormatBytes: bytes.
	FormatBytes
	// FormatTime: time in nanoseconds.
	FormatTime
	// FormatBuffers buffers (few, if any, elements implement this as of May
	// 2009).
	FormatBuffers
	// FormatPercent: percentage of stream (few, if any, elements implement this
	// as of May 2009).
	FormatPercent
)

func marshalFormat(p uintptr) (interface{}, error) {
	return Format(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Format.
func (f Format) String() string {
	switch f {
	case FormatUndefined:
		return "Undefined"
	case FormatDefault:
		return "Default"
	case FormatBytes:
		return "Bytes"
	case FormatTime:
		return "Time"
	case FormatBuffers:
		return "Buffers"
	case FormatPercent:
		return "Percent"
	default:
		return fmt.Sprintf("Format(%d)", f)
	}
}

// FormatGetByNick: return the format registered with the given nick.
//
// The function takes the following parameters:
//
//    - nick of the format.
//
// The function returns the following values:
//
//    - format with nick or GST_FORMAT_UNDEFINED if the format was not
//      registered.
//
func FormatGetByNick(nick string) Format {
	var _arg1 *C.gchar    // out
	var _cret C.GstFormat // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_format_get_by_nick(_arg1)
	runtime.KeepAlive(nick)

	var _format Format // out

	_format = Format(_cret)

	return _format
}

// FormatGetDetails: get details about the given format.
//
// The function takes the following parameters:
//
//    - format to get details of.
//
// The function returns the following values:
//
//    - formatDefinition (optional) for format or NULL on failure.
//
//      MT safe.
//
func FormatGetDetails(format Format) *FormatDefinition {
	var _arg1 C.GstFormat            // out
	var _cret *C.GstFormatDefinition // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_format_get_details(_arg1)
	runtime.KeepAlive(format)

	var _formatDefinition *FormatDefinition // out

	if _cret != nil {
		_formatDefinition = (*FormatDefinition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _formatDefinition
}

// FormatGetName: get a printable name for the given format. Do not modify or
// free.
//
// The function takes the following parameters:
//
//    - format: Format.
//
// The function returns the following values:
//
//    - utf8 (optional): reference to the static name of the format or NULL if
//      the format is unknown.
//
func FormatGetName(format Format) string {
	var _arg1 C.GstFormat // out
	var _cret *C.gchar    // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_format_get_name(_arg1)
	runtime.KeepAlive(format)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// FormatIterateDefinitions: iterate all the registered formats. The format
// definition is read only.
//
// The function returns the following values:
//
//    - iterator: gstIterator of FormatDefinition.
//
func FormatIterateDefinitions() *Iterator {
	var _cret *C.GstIterator // in

	_cret = C.gst_format_iterate_definitions()

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// FormatRegister: create a new GstFormat based on the nick or return an already
// registered format with that nick.
//
// The function takes the following parameters:
//
//    - nick of the new format.
//    - description of the new format.
//
// The function returns the following values:
//
//    - format: new GstFormat or an already registered format with the same nick.
//
//      MT safe.
//
func FormatRegister(nick, description string) Format {
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.GstFormat // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_format_register(_arg1, _arg2)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(description)

	var _format Format // out

	_format = Format(_cret)

	return _format
}

// FormatToQuark: get the unique quark for the given format.
//
// The function takes the following parameters:
//
//    - format: Format.
//
// The function returns the following values:
//
//    - quark associated with the format or 0 if the format is unknown.
//
func FormatToQuark(format Format) glib.Quark {
	var _arg1 C.GstFormat // out
	var _cret C.GQuark    // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_format_to_quark(_arg1)
	runtime.KeepAlive(format)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// FormatsContains: see if the given format is inside the format array.
//
// The function takes the following parameters:
//
//    - formats: format array to search.
//    - format to find.
//
// The function returns the following values:
//
//    - ok: TRUE if the format is found inside the array.
//
func FormatsContains(formats []Format, format Format) bool {
	var _arg1 *C.GstFormat // out
	var _arg2 C.GstFormat  // out
	var _cret C.gboolean   // in

	{
		var zero Format
		formats = append(formats, zero)
		_arg1 = (*C.GstFormat)(unsafe.Pointer(&formats[0]))
	}
	_arg2 = C.GstFormat(format)

	_cret = C.gst_formats_contains(_arg1, _arg2)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(format)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FormatDefinition: format definition
//
// An instance of this type is always passed by reference.
type FormatDefinition struct {
	*formatDefinition
}

// formatDefinition is the struct that's finalized.
type formatDefinition struct {
	native *C.GstFormatDefinition
}

// Value: unique id of this format.
func (f *FormatDefinition) Value() Format {
	valptr := &f.native.value
	var _v Format // out
	_v = Format(*valptr)
	return _v
}

// Nick: short nick of the format.
func (f *FormatDefinition) Nick() string {
	valptr := &f.native.nick
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Description: longer description of the format.
func (f *FormatDefinition) Description() string {
	valptr := &f.native.description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Quark: quark for the nick.
func (f *FormatDefinition) Quark() glib.Quark {
	valptr := &f.native.quark
	var _v glib.Quark // out
	_v = uint32(*valptr)
	type _ = glib.Quark
	type _ = uint32
	return _v
}
