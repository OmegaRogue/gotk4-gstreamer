// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_TaskFunction(gpointer);
import "C"

// GType values.
var (
	GTypeTaskState = coreglib.Type(C.gst_task_state_get_type())
	GTypeTask      = coreglib.Type(C.gst_task_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTaskState, F: marshalTaskState},
		coreglib.TypeMarshaler{T: GTypeTask, F: marshalTask},
	})
}

// TaskState: different states a task can be in.
type TaskState C.gint

const (
	// TaskStarted: task is started and running.
	TaskStarted TaskState = iota
	// TaskStopped: task is stopped.
	TaskStopped
	// TaskPaused: task is paused.
	TaskPaused
)

func marshalTaskState(p uintptr) (interface{}, error) {
	return TaskState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TaskState.
func (t TaskState) String() string {
	switch t {
	case TaskStarted:
		return "Started"
	case TaskStopped:
		return "Stopped"
	case TaskPaused:
		return "Paused"
	default:
		return fmt.Sprintf("TaskState(%d)", t)
	}
}

// TaskFunction: function that will repeatedly be called in the thread created
// by a Task.
type TaskFunction func()

// TaskOverrides contains methods that are overridable.
type TaskOverrides struct {
}

func defaultTaskOverrides(v *Task) TaskOverrides {
	return TaskOverrides{}
}

// Task is used by Element and Pad to provide the data passing threads in a
// Pipeline.
//
// A Pad will typically start a Task to push or pull data to/from the peer pads.
// Most source elements start a Task to push data. In some cases a demuxer
// element can start a Task to pull data from a peer element. This is typically
// done when the demuxer can perform random access on the upstream peer element
// for improved performance.
//
// Although convenience functions exist on Pad to start/pause/stop tasks, it
// might sometimes be needed to create a Task manually if it is not related to a
// Pad.
//
// Before the Task can be run, it needs a Mutex that can be set with
// gst_task_set_lock().
//
// The task can be started, paused and stopped with gst_task_start(),
// gst_task_pause() and gst_task_stop() respectively or with the
// gst_task_set_state() function.
//
// A Task will repeatedly call the TaskFunction with the user data that was
// provided when creating the task with gst_task_new(). While calling the
// function it will acquire the provided lock. The provided lock is released
// when the task pauses or stops.
//
// Stopping a task with gst_task_stop() will not immediately make sure the task
// is not running anymore. Use gst_task_join() to make sure the task is
// completely stopped and the thread is stopped.
//
// After creating a Task, use gst_object_unref() to free its resources. This can
// only be done when the task is not running anymore.
//
// Task functions can send a Message to send out-of-band data to the
// application. The application can receive messages from the Bus in its
// mainloop.
//
// For debugging purposes, the task will configure its object name as the thread
// name on Linux. Please note that the object name should be configured before
// the task is started; changing the object name after the task has been
// started, has no effect on the thread name.
type Task struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Task)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Task, *TaskClass, TaskOverrides](
		GTypeTask,
		initTaskClass,
		wrapTask,
		defaultTaskOverrides,
	)
}

func initTaskClass(gclass unsafe.Pointer, overrides TaskOverrides, classInitFunc func(*TaskClass)) {
	if classInitFunc != nil {
		class := (*TaskClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTask(obj *coreglib.Object) *Task {
	return &Task{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	return wrapTask(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTask: create a new Task that will repeatedly call the provided func with
// user_data as a parameter. Typically the task will run in a new thread.
//
// The function cannot be changed after the task has been created. You must
// create a new Task to change the function.
//
// This function will not yet create and start a thread. Use gst_task_start() or
// gst_task_pause() to create and start the GThread.
//
// Before the task can be used, a Mutex must be configured using the
// gst_task_set_lock() function. This lock will always be acquired while func is
// called.
//
// The function takes the following parameters:
//
//    - fn to use.
//
// The function returns the following values:
//
//    - task: new Task.
//
//      MT safe.
//
func NewTask(fn TaskFunction) *Task {
	var _arg1 C.GstTaskFunction // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GstTask // in

	_arg1 = (*[0]byte)(C._gotk4_gst1_TaskFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_task_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(fn)

	var _task *Task // out

	_task = wrapTask(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _task
}

// Pool: get the TaskPool that this task will use for its streaming threads.
//
// MT safe.
//
// The function returns the following values:
//
//    - taskPool used by task. gst_object_unref() after usage.
//
func (task *Task) Pool() *TaskPool {
	var _arg0 *C.GstTask     // out
	var _cret *C.GstTaskPool // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_get_pool(_arg0)
	runtime.KeepAlive(task)

	var _taskPool *TaskPool // out

	_taskPool = wrapTaskPool(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _taskPool
}

// State: get the current state of the task.
//
// The function returns the following values:
//
//    - taskState of the task
//
//      MT safe.
//
func (task *Task) State() TaskState {
	var _arg0 *C.GstTask     // out
	var _cret C.GstTaskState // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_get_state(_arg0)
	runtime.KeepAlive(task)

	var _taskState TaskState // out

	_taskState = TaskState(_cret)

	return _taskState
}

// Join joins task. After this call, it is safe to unref the task and clean up
// the lock set with gst_task_set_lock().
//
// The task will automatically be stopped with this call.
//
// This function cannot be called from within a task function as this would
// cause a deadlock. The function will detect this and print a g_warning.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be joined.
//
//      MT safe.
//
func (task *Task) Join() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_join(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause pauses task. This method can also be called on a task in the stopped
// state, in which case a thread will be started and will remain in the paused
// state. This function does not wait for the task to complete the paused state.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be paused.
//
//      MT safe.
//
func (task *Task) Pause() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_pause(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Resume task in case it was paused. If the task was stopped, it will remain in
// that state and this function will return FALSE.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be resumed.
//
//      MT safe.
//
func (task *Task) Resume() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_resume(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPool: set pool as the new GstTaskPool for task. Any new streaming threads
// that will be created by task will now use pool.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - pool: TaskPool.
//
func (task *Task) SetPool(pool *TaskPool) {
	var _arg0 *C.GstTask     // out
	var _arg1 *C.GstTaskPool // out

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C.gst_task_set_pool(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(pool)
}

// SetState sets the state of task to state.
//
// The task must have a lock associated with it using gst_task_set_lock() when
// going to GST_TASK_STARTED or GST_TASK_PAUSED or this function will return
// FALSE.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - state: new task state.
//
// The function returns the following values:
//
//    - ok: TRUE if the state could be changed.
//
func (task *Task) SetState(state TaskState) bool {
	var _arg0 *C.GstTask     // out
	var _arg1 C.GstTaskState // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = C.GstTaskState(state)

	_cret = C.gst_task_set_state(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts task. The task must have a lock associated with it using
// gst_task_set_lock() or this function will return FALSE.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be started.
//
//      MT safe.
//
func (task *Task) Start() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_start(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop stops task. This method merely schedules the task to stop and will not
// wait for the task to have completely stopped. Use gst_task_join() to stop and
// wait for completion.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be stopped.
//
//      MT safe.
//
func (task *Task) Stop() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_stop(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TaskCleanupAll: wait for all tasks to be stopped. This is mainly used
// internally to ensure proper cleanup of internal data structures in test
// suites.
//
// MT safe.
func TaskCleanupAll() {
	C.gst_task_cleanup_all()
}

// TaskClass: instance of this type is always passed by reference.
type TaskClass struct {
	*taskClass
}

// taskClass is the struct that's finalized.
type taskClass struct {
	native *C.GstTaskClass
}

func (t *TaskClass) ParentClass() *ObjectClass {
	valptr := &t.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
