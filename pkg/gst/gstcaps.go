// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gboolean _gotk4_gst1_CapsMapFunc(GstCapsFeatures*, GstStructure*, gpointer);
// extern gboolean _gotk4_gst1_CapsForEachFunc(GstCapsFeatures*, GstStructure*, gpointer);
// extern gboolean _gotk4_gst1_CapsFilterMapFunc(GstCapsFeatures*, GstStructure*, gpointer);
import "C"

// GType values.
var (
	GTypeCapsIntersectMode = coreglib.Type(C.gst_caps_intersect_mode_get_type())
	GTypeCapsFlags         = coreglib.Type(C.gst_caps_flags_get_type())
	GTypeCaps              = coreglib.Type(C.gst_caps_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCapsIntersectMode, F: marshalCapsIntersectMode},
		coreglib.TypeMarshaler{T: GTypeCapsFlags, F: marshalCapsFlags},
		coreglib.TypeMarshaler{T: GTypeCaps, F: marshalCaps},
	})
}

// CapsIntersectMode modes of caps intersection
//
// GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps by
// iterating on the caps' structures as the following matrix shows:
//
//             caps1
//          +-------------
//          | 1  2  4  7
//    caps2 | 3  5  8 10
//          | 6  9 11 12
//
//
// Used when there is no explicit precedence of one caps over the other. e.g.
// tee's sink pad getcaps function, it will probe its src pad peers' for their
// caps and intersect them with this mode.
//
// GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve another
// element's caps priority order when intersecting with its own caps. Example:
// If caps1 is [A, B, C] and caps2 is [E, B, D, A], the result would be [A, B],
// maintaining the first caps priority on the intersection.
type CapsIntersectMode C.gint

const (
	// CapsIntersectZigZag zig-zags over both caps.
	CapsIntersectZigZag CapsIntersectMode = iota
	// CapsIntersectFirst keeps the first caps order.
	CapsIntersectFirst
)

func marshalCapsIntersectMode(p uintptr) (interface{}, error) {
	return CapsIntersectMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CapsIntersectMode.
func (c CapsIntersectMode) String() string {
	switch c {
	case CapsIntersectZigZag:
		return "ZigZag"
	case CapsIntersectFirst:
		return "First"
	default:
		return fmt.Sprintf("CapsIntersectMode(%d)", c)
	}
}

// CapsFlags: extra flags for a caps.
type CapsFlags C.guint

const (
	// CapsFlagAny caps has no specific content, but can contain anything.
	CapsFlagAny CapsFlags = 0b10000
)

func marshalCapsFlags(p uintptr) (interface{}, error) {
	return CapsFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CapsFlags.
func (c CapsFlags) String() string {
	if c == 0 {
		return "CapsFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(11)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CapsFlagAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("CapsFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CapsFlags) Has(other CapsFlags) bool {
	return (c & other) == other
}

// CapsFilterMapFunc: function that will be called in
// gst_caps_filter_and_map_in_place(). The function may modify features and
// structure, and both will be removed from the caps if FALSE is returned.
type CapsFilterMapFunc func(features *CapsFeatures, structure *Structure) (ok bool)

// CapsMapFunc: function that will be called in gst_caps_map_in_place(). The
// function may modify features and structure.
type CapsMapFunc func(features *CapsFeatures, structure *Structure) (ok bool)

// The function returns the following values:
//
func StaticCapsGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_static_caps_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Caps (capabilities) are lightweight refcounted objects describing media
// types. They are composed of an array of Structure.
//
// Caps are exposed on PadTemplate to describe all possible types a given pad
// can handle. They are also stored in the Registry along with a description of
// the Element.
//
// Caps are exposed on the element pads using the gst_pad_query_caps() pad
// function. This function describes the possible types that the pad can handle
// or produce at runtime.
//
// A Caps can be constructed with the following code fragment:
//
//    C   GstCaps *caps = gst_caps_new_simple ("video/x-raw",      "format", G_TYPE_STRING, "I420",      "framerate", GST_TYPE_FRACTION, 25, 1,      "pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,      "width", G_TYPE_INT, 320,      "height", G_TYPE_INT, 240,      NULL);
//
// A Caps is fixed when it has no fields with ranges or lists. Use
// gst_caps_is_fixed() to test for fixed caps. Fixed caps can be used in a caps
// event to notify downstream elements of the current media type.
//
// Various methods exist to work with the media types such as subtracting or
// intersecting.
//
// Be aware that until 1.20 the Caps / Structure serialization into string had
// limited support for nested Caps / Structure fields. It could only support one
// level of nesting. Using more levels would lead to unexpected behavior when
// using serialization features, such as gst_caps_to_string() or
// gst_value_serialize() and their counterparts.
//
// An instance of this type is always passed by reference.
type Caps struct {
	*caps
}

// caps is the struct that's finalized.
type caps struct {
	native *C.GstCaps
}

func marshalCaps(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Caps{&caps{(*C.GstCaps)(b)}}, nil
}

// NewCapsAny constructs a struct Caps.
func NewCapsAny() *Caps {
	var _cret *C.GstCaps // in

	_cret = C.gst_caps_new_any()

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// NewCapsEmpty constructs a struct Caps.
func NewCapsEmpty() *Caps {
	var _cret *C.GstCaps // in

	_cret = C.gst_caps_new_empty()

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// NewCapsEmptySimple constructs a struct Caps.
func NewCapsEmptySimple(mediaType string) *Caps {
	var _arg1 *C.char    // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mediaType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_new_empty_simple(_arg1)
	runtime.KeepAlive(mediaType)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// MiniObject: parent type.
func (c *Caps) MiniObject() *MiniObject {
	valptr := &c.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Append appends the structures contained in caps2 to caps1. The structures in
// caps2 are not copied -- they are transferred to caps1, and then caps2 is
// freed. If either caps is ANY, the resulting caps will be ANY.
//
// The function takes the following parameters:
//
//    - caps2 to append.
//
func (caps1 *Caps) Append(caps2 *Caps) {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps2)), nil)

	C.gst_caps_append(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)
}

// AppendStructure appends structure to caps. The structure is not copied; caps
// becomes the owner of structure.
//
// The function takes the following parameters:
//
//    - structure to append.
//
func (caps *Caps) AppendStructure(structure *Structure) {
	var _arg0 *C.GstCaps      // out
	var _arg1 *C.GstStructure // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	C.gst_caps_append_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
}

// AppendStructureFull appends structure with features to caps. The structure is
// not copied; caps becomes the owner of structure.
//
// The function takes the following parameters:
//
//    - structure to append.
//    - features (optional) to append.
//
func (caps *Caps) AppendStructureFull(structure *Structure, features *CapsFeatures) {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstStructure    // out
	var _arg2 *C.GstCapsFeatures // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	C.gst_caps_append_structure_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(features)
}

// CanIntersect tries intersecting caps1 and caps2 and reports whether the
// result would not be empty.
//
// The function takes the following parameters:
//
//    - caps2 to intersect.
//
// The function returns the following values:
//
//    - ok: TRUE if intersection would be not empty.
//
func (caps1 *Caps) CanIntersect(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_can_intersect(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy creates a new Caps as a copy of the old caps. The new caps will have a
// refcount of 1, owned by the caller. The structures are copied as well.
//
// Note that this function is the semantic equivalent of a gst_caps_ref()
// followed by a gst_caps_make_writable(). If you only want to hold on to a
// reference to the data, you should use gst_caps_ref().
//
// The function returns the following values:
//
//    - ret: new Caps.
//
func (caps *Caps) Copy() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_copy(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// CopyNth creates a new Caps and appends a copy of the nth structure contained
// in caps.
//
// The function takes the following parameters:
//
//    - nth structure to copy.
//
// The function returns the following values:
//
//    - ret: new Caps.
//
func (caps *Caps) CopyNth(nth uint) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 C.guint    // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(nth)

	_cret = C.gst_caps_copy_nth(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(nth)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// FilterAndMapInPlace calls the provided function once for each structure and
// caps feature in the Caps. In contrast to gst_caps_foreach(), the function may
// modify the structure and features. In contrast to
// gst_caps_filter_and_map_in_place(), the structure and features are removed
// from the caps if FALSE is returned from the function. The caps must be
// mutable.
//
// The function takes the following parameters:
//
//    - fn: function to call for each field.
//
func (caps *Caps) FilterAndMapInPlace(fn CapsFilterMapFunc) {
	var _arg0 *C.GstCaps             // out
	var _arg1 C.GstCapsFilterMapFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_CapsFilterMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_caps_filter_and_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(fn)
}

// Fixate modifies the given caps into a representation with only fixed values.
// First the caps will be truncated and then the first structure will be fixated
// with gst_structure_fixate().
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it so you must not use caps afterwards unless you keep an additional
// reference to it with gst_caps_ref().
//
// Note that it is not guaranteed that the returned caps have exactly one
// structure. If caps are empty caps then the returned caps will be the empty
// too and contain no structure at all.
//
// Calling this function with ANY caps is not allowed.
//
// The function returns the following values:
//
//    - ret: fixated caps.
//
func (caps *Caps) Fixate() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_fixate(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// ForEach calls the provided function once for each structure and caps feature
// in the Caps. The function must not modify the fields. Also see
// gst_caps_map_in_place() and gst_caps_filter_and_map_in_place().
//
// The function takes the following parameters:
//
//    - fn: function to call for each field.
//
// The function returns the following values:
//
//    - ok: TRUE if the supplied function returns TRUE for each call, FALSE
//      otherwise.
//
func (caps *Caps) ForEach(fn CapsForEachFunc) bool {
	var _arg0 *C.GstCaps           // out
	var _arg1 C.GstCapsForeachFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_CapsForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_caps_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Features finds the features in caps at index, and returns it.
//
// WARNING: This function takes a const GstCaps *, but returns a non-const
// GstCapsFeatures *. This is for programming convenience -- the caller should
// be aware that features inside a constant Caps should not be modified.
// However, if you know the caps are writable, either because you have just
// copied them or made them writable with gst_caps_make_writable(), you may
// modify the features returned in the usual way, e.g. with functions like
// gst_caps_features_add().
//
// The function takes the following parameters:
//
//    - index of the structure.
//
// The function returns the following values:
//
//    - capsFeatures (optional): pointer to the CapsFeatures corresponding to
//      index.
//
func (caps *Caps) Features(index uint) *CapsFeatures {
	var _arg0 *C.GstCaps         // out
	var _arg1 C.guint            // out
	var _cret *C.GstCapsFeatures // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)

	_cret = C.gst_caps_get_features(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)

	var _capsFeatures *CapsFeatures // out

	if _cret != nil {
		_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _capsFeatures
}

// Size gets the number of structures contained in caps.
//
// The function returns the following values:
//
//    - guint: number of structures that caps contains.
//
func (caps *Caps) Size() uint {
	var _arg0 *C.GstCaps // out
	var _cret C.guint    // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_get_size(_arg0)
	runtime.KeepAlive(caps)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Structure finds the structure in caps at index, and returns it.
//
// WARNING: This function takes a const GstCaps *, but returns a non-const
// GstStructure *. This is for programming convenience -- the caller should be
// aware that structures inside a constant Caps should not be modified. However,
// if you know the caps are writable, either because you have just copied them
// or made them writable with gst_caps_make_writable(), you may modify the
// structure returned in the usual way, e.g. with functions like
// gst_structure_set().
//
// The function takes the following parameters:
//
//    - index of the structure.
//
// The function returns the following values:
//
//    - structure: pointer to the Structure corresponding to index.
//
func (caps *Caps) Structure(index uint) *Structure {
	var _arg0 *C.GstCaps      // out
	var _arg1 C.guint         // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)

	_cret = C.gst_caps_get_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// Intersect creates a new Caps that contains all the formats that are common to
// both caps1 and caps2. Defaults to GST_CAPS_INTERSECT_ZIG_ZAG mode.
//
// The function takes the following parameters:
//
//    - caps2 to intersect.
//
// The function returns the following values:
//
//    - caps: new Caps.
//
func (caps1 *Caps) Intersect(caps2 *Caps) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_intersect(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// IntersectFull creates a new Caps that contains all the formats that are
// common to both caps1 and caps2, the order is defined by the CapsIntersectMode
// used.
//
// The function takes the following parameters:
//
//    - caps2 to intersect.
//    - mode: intersection algorithm/mode to use.
//
// The function returns the following values:
//
//    - caps: new Caps.
//
func (caps1 *Caps) IntersectFull(caps2 *Caps, mode CapsIntersectMode) *Caps {
	var _arg0 *C.GstCaps             // out
	var _arg1 *C.GstCaps             // out
	var _arg2 C.GstCapsIntersectMode // out
	var _cret *C.GstCaps             // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))
	_arg2 = C.GstCapsIntersectMode(mode)

	_cret = C.gst_caps_intersect_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)
	runtime.KeepAlive(mode)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// IsAlwaysCompatible: given Caps structure is always compatible with another if
// every media format that is in the first is also contained in the second. That
// is, caps1 is a subset of caps2.
//
// The function takes the following parameters:
//
//    - caps2 to test.
//
// The function returns the following values:
//
//    - ok: TRUE if caps1 is a subset of caps2.
//
func (caps1 *Caps) IsAlwaysCompatible(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_always_compatible(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsAny determines if caps represents any media format.
//
// The function returns the following values:
//
//    - ok: TRUE if caps represents any format.
//
func (caps *Caps) IsAny() bool {
	var _arg0 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_is_any(_arg0)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEmpty determines if caps represents no media formats.
//
// The function returns the following values:
//
//    - ok: TRUE if caps represents no formats.
//
func (caps *Caps) IsEmpty() bool {
	var _arg0 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_is_empty(_arg0)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks if the given caps represent the same set of caps.
//
// The function takes the following parameters:
//
//    - caps2: another Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if both caps are equal.
//
func (caps1 *Caps) IsEqual(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_equal(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqualFixed tests if two Caps are equal. This function only works on fixed
// Caps.
//
// The function takes the following parameters:
//
//    - caps2 to test.
//
// The function returns the following values:
//
//    - ok: TRUE if the arguments represent the same format.
//
func (caps1 *Caps) IsEqualFixed(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_equal_fixed(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFixed: fixed Caps describe exactly one format, that is, they have exactly
// one structure, and each field in the structure describes a fixed type.
// Examples of non-fixed types are GST_TYPE_INT_RANGE and GST_TYPE_LIST.
//
// The function returns the following values:
//
//    - ok: TRUE if caps is fixed.
//
func (caps *Caps) IsFixed() bool {
	var _arg0 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_is_fixed(_arg0)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsStrictlyEqual checks if the given caps are exactly the same set of caps.
//
// The function takes the following parameters:
//
//    - caps2: another Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if both caps are strictly equal.
//
func (caps1 *Caps) IsStrictlyEqual(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_strictly_equal(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubset checks if all caps represented by subset are also represented by
// superset.
//
// The function takes the following parameters:
//
//    - superset: potentially greater Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if subset is a subset of superset.
//
func (subset *Caps) IsSubset(superset *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(subset)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(superset)))

	_cret = C.gst_caps_is_subset(_arg0, _arg1)
	runtime.KeepAlive(subset)
	runtime.KeepAlive(superset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubsetStructure checks if structure is a subset of caps. See
// gst_caps_is_subset() for more information.
//
// The function takes the following parameters:
//
//    - structure: potential Structure subset of caps.
//
// The function returns the following values:
//
//    - ok: TRUE if structure is a subset of caps.
//
func (caps *Caps) IsSubsetStructure(structure *Structure) bool {
	var _arg0 *C.GstCaps      // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_caps_is_subset_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubsetStructureFull checks if structure is a subset of caps. See
// gst_caps_is_subset() for more information.
//
// The function takes the following parameters:
//
//    - structure: potential Structure subset of caps.
//    - features (optional) for structure.
//
// The function returns the following values:
//
//    - ok: TRUE if structure is a subset of caps.
//
func (caps *Caps) IsSubsetStructureFull(structure *Structure, features *CapsFeatures) bool {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstStructure    // out
	var _arg2 *C.GstCapsFeatures // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	}

	_cret = C.gst_caps_is_subset_structure_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(features)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MapInPlace calls the provided function once for each structure and caps
// feature in the Caps. In contrast to gst_caps_foreach(), the function may
// modify but not delete the structures and features. The caps must be mutable.
//
// The function takes the following parameters:
//
//    - fn: function to call for each field.
//
// The function returns the following values:
//
//    - ok: TRUE if the supplied function returns TRUE for each call, FALSE
//      otherwise.
//
func (caps *Caps) MapInPlace(fn CapsMapFunc) bool {
	var _arg0 *C.GstCaps       // out
	var _arg1 C.GstCapsMapFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_CapsMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_caps_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Merge appends the structures contained in caps2 to caps1 if they are not yet
// expressed by caps1. The structures in caps2 are not copied -- they are
// transferred to a writable copy of caps1, and then caps2 is freed. If either
// caps is ANY, the resulting caps will be ANY.
//
// The function takes the following parameters:
//
//    - caps2 to merge in.
//
// The function returns the following values:
//
//    - caps: merged caps.
//
func (caps1 *Caps) Merge(caps2 *Caps) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps1)), nil)
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps2)), nil)

	_cret = C.gst_caps_merge(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// MergeStructure appends structure to caps if it is not already expressed by
// caps.
//
// The function takes the following parameters:
//
//    - structure to merge.
//
// The function returns the following values:
//
//    - ret: merged caps.
//
func (caps *Caps) MergeStructure(structure *Structure) *Caps {
	var _arg0 *C.GstCaps      // out
	var _arg1 *C.GstStructure // out
	var _cret *C.GstCaps      // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_caps_merge_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// MergeStructureFull appends structure with features to caps if its not already
// expressed by caps.
//
// The function takes the following parameters:
//
//    - structure to merge.
//    - features (optional) to merge.
//
// The function returns the following values:
//
//    - ret: merged caps.
//
func (caps *Caps) MergeStructureFull(structure *Structure, features *CapsFeatures) *Caps {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstStructure    // out
	var _arg2 *C.GstCapsFeatures // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	_cret = C.gst_caps_merge_structure_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(features)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// Normalize returns a Caps that represents the same set of formats as caps, but
// contains no lists. Each list is expanded into separate Structure.
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it so you must not use caps afterwards unless you keep an additional
// reference to it with gst_caps_ref().
//
// The function returns the following values:
//
//    - ret: normalized Caps.
//
func (caps *Caps) Normalize() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_normalize(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// RemoveStructure removes the structure with the given index from the list of
// structures contained in caps.
//
// The function takes the following parameters:
//
//    - idx: index of the structure to remove.
//
func (caps *Caps) RemoveStructure(idx uint) {
	var _arg0 *C.GstCaps // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(idx)

	C.gst_caps_remove_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(idx)
}

// Serialize converts caps to a string representation. This string
// representation can be converted back to a Caps by gst_caps_from_string().
//
// This prints the caps in human readable form.
//
// This version of the caps serialization function introduces support for nested
// structures and caps but the resulting strings won't be parsable with
// GStreamer prior to 1.20 unless T_SERIALIZE_FLAG_BACKWARD_COMPAT is passed as
// flag.
//
// The function takes the following parameters:
//
//    - flags: SerializeFlags.
//
// The function returns the following values:
//
//    - utf8: newly allocated string representing caps.
//
func (caps *Caps) Serialize(flags SerializeFlags) string {
	var _arg0 *C.GstCaps          // out
	var _arg1 C.GstSerializeFlags // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.GstSerializeFlags(flags)

	_cret = C.gst_caps_serialize(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetFeatures sets the features for the structure at index.
//
// The function takes the following parameters:
//
//    - index of the structure.
//    - features (optional) to set.
//
func (caps *Caps) SetFeatures(index uint, features *CapsFeatures) {
	var _arg0 *C.GstCaps         // out
	var _arg1 C.guint            // out
	var _arg2 *C.GstCapsFeatures // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	C.gst_caps_set_features(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)
	runtime.KeepAlive(features)
}

// SetFeaturesSimple sets the features for all the structures of caps.
//
// The function takes the following parameters:
//
//    - features (optional) to set.
//
func (caps *Caps) SetFeaturesSimple(features *CapsFeatures) {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstCapsFeatures // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	if features != nil {
		_arg1 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	C.gst_caps_set_features_simple(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(features)
}

// SetValue sets the given field on all structures of caps to the given value.
// This is a convenience function for calling gst_structure_set_value() on all
// structures of caps.
//
// The function takes the following parameters:
//
//    - field: name of the field to set.
//    - value to set the field to.
//
func (caps *Caps) SetValue(field string, value *coreglib.Value) {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.char    // out
	var _arg2 *C.GValue  // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(field)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_caps_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(field)
	runtime.KeepAlive(value)
}

// Simplify converts the given caps into a representation that represents the
// same set of formats, but in a simpler form. Component structures that are
// identical are merged. Component structures that have values that can be
// merged are also merged.
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it if necessary, so you must not use caps afterwards unless you keep an
// additional reference to it with gst_caps_ref().
//
// This method does not preserve the original order of caps.
//
// The function returns the following values:
//
//    - ret: simplified caps.
//
func (caps *Caps) Simplify() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_simplify(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// StealStructure retrieves the structure with the given index from the list of
// structures contained in caps. The caller becomes the owner of the returned
// structure.
//
// The function takes the following parameters:
//
//    - index: index of the structure to retrieve.
//
// The function returns the following values:
//
//    - structure (optional): pointer to the Structure corresponding to index.
//
func (caps *Caps) StealStructure(index uint) *Structure {
	var _arg0 *C.GstCaps      // out
	var _arg1 C.guint         // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)

	_cret = C.gst_caps_steal_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// Subtract subtracts the subtrahend from the minuend. > This function does not
// work reliably if optional properties for caps > are included on one caps and
// omitted on the other.
//
// The function takes the following parameters:
//
//    - subtrahend to subtract.
//
// The function returns the following values:
//
//    - caps: resulting caps.
//
func (minuend *Caps) Subtract(subtrahend *Caps) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(minuend)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(subtrahend)))

	_cret = C.gst_caps_subtract(_arg0, _arg1)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// String converts caps to a string representation. This string representation
// can be converted back to a Caps by gst_caps_from_string().
//
// For debugging purposes its easier to do something like this:
//
//    C GST_LOG ("caps are %" GST_PTR_FORMAT, caps);
//
// This prints the caps in human readable form.
//
// The implementation of serialization up to 1.20 would lead to unexpected
// results when there were nested Caps / Structure deeper than one level.
//
// The function returns the following values:
//
//    - utf8: newly allocated string representing caps.
//
func (caps *Caps) String() string {
	var _arg0 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_to_string(_arg0)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Truncate discards all but the first structure from caps. Useful when
// fixating.
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it if necessary, so you must not use caps afterwards unless you keep an
// additional reference to it with gst_caps_ref().
//
// Note that it is not guaranteed that the returned caps have exactly one
// structure. If caps is any or empty caps then the returned caps will be the
// same and contain no structure at all.
//
// The function returns the following values:
//
//    - ret: truncated caps.
//
func (caps *Caps) Truncate() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_truncate(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// CapsFromString converts caps from a string representation.
//
// The implementation of serialization up to 1.20 would lead to unexpected
// results when there were nested Caps / Structure deeper than one level.
//
// The function takes the following parameters:
//
//    - str: string to convert to Caps.
//
// The function returns the following values:
//
//    - caps (optional): newly allocated Caps.
//
func CapsFromString(str string) *Caps {
	var _arg1 *C.gchar   // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_from_string(_arg1)
	runtime.KeepAlive(str)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// StaticCaps: data structure to initialize Caps from a string description
// usually used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get()
// to instantiate a Caps.
//
// An instance of this type is always passed by reference.
type StaticCaps struct {
	*staticCaps
}

// staticCaps is the struct that's finalized.
type staticCaps struct {
	native *C.GstStaticCaps
}

// Caps: cached Caps.
func (s *StaticCaps) Caps() *Caps {
	valptr := &s.native.caps
	var _v *Caps // out
	_v = (*Caps)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// String: string describing a caps.
func (s *StaticCaps) String() string {
	valptr := &s.native.string
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Cleanup cleans up the cached caps contained in static_caps.
func (staticCaps *StaticCaps) Cleanup() {
	var _arg0 *C.GstStaticCaps // out

	_arg0 = (*C.GstStaticCaps)(gextras.StructNative(unsafe.Pointer(staticCaps)))

	C.gst_static_caps_cleanup(_arg0)
	runtime.KeepAlive(staticCaps)
}

// Get converts a StaticCaps to a Caps.
//
// The function returns the following values:
//
//    - caps (optional): pointer to the Caps. Since the core holds an additional
//      ref to the returned caps, use gst_caps_make_writable() on the returned
//      caps to modify it.
//
func (staticCaps *StaticCaps) Get() *Caps {
	var _arg0 *C.GstStaticCaps // out
	var _cret *C.GstCaps       // in

	_arg0 = (*C.GstStaticCaps)(gextras.StructNative(unsafe.Pointer(staticCaps)))

	_cret = C.gst_static_caps_get(_arg0)
	runtime.KeepAlive(staticCaps)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}
