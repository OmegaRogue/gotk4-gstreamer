// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeTocEntryType = coreglib.Type(C.gst_toc_entry_type_get_type())
	GTypeTocScope     = coreglib.Type(C.gst_toc_scope_get_type())
	GTypeToc          = coreglib.Type(C.gst_toc_get_type())
	GTypeTocEntry     = coreglib.Type(C.gst_toc_entry_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTocEntryType, F: marshalTocEntryType},
		coreglib.TypeMarshaler{T: GTypeTocScope, F: marshalTocScope},
		coreglib.TypeMarshaler{T: GTypeToc, F: marshalToc},
		coreglib.TypeMarshaler{T: GTypeTocEntry, F: marshalTocEntry},
	})
}

// TocEntryType: different types of TOC entries (see TocEntry).
//
// There are two types of TOC entries: alternatives or parts in a sequence.
type TocEntryType C.gint

const (
	// TocEntryTypeAngle: entry is an angle (i.e. an alternative).
	TocEntryTypeAngle TocEntryType = -3
	// TocEntryTypeVersion: entry is a version (i.e. alternative).
	TocEntryTypeVersion TocEntryType = -2
	// TocEntryTypeEdition: entry is an edition (i.e. alternative).
	TocEntryTypeEdition TocEntryType = -1
	// TocEntryTypeInvalid: invalid entry type value.
	TocEntryTypeInvalid TocEntryType = 0
	// TocEntryTypeTitle: entry is a title (i.e. a part of a sequence).
	TocEntryTypeTitle TocEntryType = 1
	// TocEntryTypeTrack: entry is a track (i.e. a part of a sequence).
	TocEntryTypeTrack TocEntryType = 2
	// TocEntryTypeChapter: entry is a chapter (i.e. a part of a sequence).
	TocEntryTypeChapter TocEntryType = 3
)

func marshalTocEntryType(p uintptr) (interface{}, error) {
	return TocEntryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TocEntryType.
func (t TocEntryType) String() string {
	switch t {
	case TocEntryTypeAngle:
		return "Angle"
	case TocEntryTypeVersion:
		return "Version"
	case TocEntryTypeEdition:
		return "Edition"
	case TocEntryTypeInvalid:
		return "Invalid"
	case TocEntryTypeTitle:
		return "Title"
	case TocEntryTypeTrack:
		return "Track"
	case TocEntryTypeChapter:
		return "Chapter"
	default:
		return fmt.Sprintf("TocEntryType(%d)", t)
	}
}

// TocEntryTypeGetNick converts type to a string representation.
//
// The function takes the following parameters:
//
//    - typ: TocEntryType.
//
// The function returns the following values:
//
//    - utf8 returns a human-readable string for type. This string is only for
//      debugging purpose and should not be displayed in a user interface.
//
func TocEntryTypeGetNick(typ TocEntryType) string {
	var _arg1 C.GstTocEntryType // out
	var _cret *C.gchar          // in

	_arg1 = C.GstTocEntryType(typ)

	_cret = C.gst_toc_entry_type_get_nick(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TocScope: scope of a TOC.
type TocScope C.gint

const (
	// TocScopeGlobal: global TOC representing all selectable options (this is
	// what applications are usually interested in).
	TocScopeGlobal TocScope = 1
	// TocScopeCurrent: TOC for the currently active/selected stream (this is a
	// TOC representing the current stream from start to EOS, and is what a TOC
	// writer / muxer is usually interested in; it will usually be a subset of
	// the global TOC, e.g. just the chapters of the current title, or the
	// chapters selected for playback from the current title).
	TocScopeCurrent TocScope = 2
)

func marshalTocScope(p uintptr) (interface{}, error) {
	return TocScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TocScope.
func (t TocScope) String() string {
	switch t {
	case TocScopeGlobal:
		return "Global"
	case TocScopeCurrent:
		return "Current"
	default:
		return fmt.Sprintf("TocScope(%d)", t)
	}
}

// Toc functions are used to create/free Toc and TocEntry structures. Also they
// are used to convert Toc into Structure and vice versa.
//
// Toc lets you to inform other elements in pipeline or application that playing
// source has some kind of table of contents (TOC). These may be chapters,
// editions, angles or other types. For example: DVD chapters, Matroska chapters
// or cue sheet TOC. Such TOC will be useful for applications to display instead
// of just a playlist.
//
// Using TOC is very easy. Firstly, create Toc structure which represents root
// contents of the source. You can also attach TOC-specific tags to it. Then
// fill it with TocEntry entries by appending them to the Toc using
// gst_toc_append_entry(), and appending subentries to a TocEntry using
// gst_toc_entry_append_sub_entry().
//
// Note that root level of the TOC can contain only either editions or chapters.
// You should not mix them together at the same level. Otherwise you will get
// serialization /deserialization errors. Make sure that no one of the entries
// has negative start and stop values.
//
// Use gst_event_new_toc() to create a new TOC Event, and gst_event_parse_toc()
// to parse received TOC event. Use gst_event_new_toc_select() to create a new
// TOC select Event, and gst_event_parse_toc_select() to parse received TOC
// select event. The same rule for the Message: gst_message_new_toc() to create
// new TOC Message, and gst_message_parse_toc() to parse received TOC message.
//
// TOCs can have global scope or current scope. Global scope TOCs contain all
// entries that can possibly be selected using a toc select event, and are what
// an application is usually interested in. TOCs with current scope only contain
// the parts of the TOC relevant to the currently selected/playing stream; the
// current scope TOC is used by downstream elements such as muxers to write
// correct TOC entries when transcoding files, for example. When playing a DVD,
// the global TOC would contain a hierarchy of all titles, chapters and angles,
// for example, while the current TOC would only contain the chapters for the
// currently playing title if playback of a specific title was requested.
//
// Applications and plugins should not rely on TOCs having a certain kind of
// structure, but should allow for different alternatives. For example, a simple
// CUE sheet embedded in a file may be presented as a flat list of track
// entries, or could have a top-level edition node (or some other alternative
// type entry) with track entries underneath that node; or even multiple
// top-level edition nodes (or some other alternative type entries) each with
// track entries underneath, in case the source file has extracted a track
// listing from different sources).
//
// An instance of this type is always passed by reference.
type Toc struct {
	*toc
}

// toc is the struct that's finalized.
type toc struct {
	native *C.GstToc
}

func marshalToc(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Toc{&toc{(*C.GstToc)(b)}}, nil
}

// NewToc constructs a struct Toc.
func NewToc(scope TocScope) *Toc {
	var _arg1 C.GstTocScope // out
	var _cret *C.GstToc     // in

	_arg1 = C.GstTocScope(scope)

	_cret = C.gst_toc_new(_arg1)
	runtime.KeepAlive(scope)

	var _toc *Toc // out

	_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toc)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _toc
}

// AppendEntry appends the TocEntry entry to toc.
//
// The function takes the following parameters:
//
//    - entry: TocEntry.
//
func (toc *Toc) AppendEntry(entry *TocEntry) {
	var _arg0 *C.GstToc      // out
	var _arg1 *C.GstTocEntry // out

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	_arg1 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(entry)), nil)

	C.gst_toc_append_entry(_arg0, _arg1)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(entry)
}

func (toc *Toc) Dump() {
	var _arg0 *C.GstToc // out

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	C.gst_toc_dump(_arg0)
	runtime.KeepAlive(toc)
}

// FindEntry: find TocEntry with given uid in the toc.
//
// The function takes the following parameters:
//
//    - uid: UID to find TocEntry with.
//
// The function returns the following values:
//
//    - tocEntry (optional) with specified uid from the toc, or NULL if not
//      found.
//
func (toc *Toc) FindEntry(uid string) *TocEntry {
	var _arg0 *C.GstToc      // out
	var _arg1 *C.gchar       // out
	var _cret *C.GstTocEntry // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_toc_find_entry(_arg0, _arg1)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(uid)

	var _tocEntry *TocEntry // out

	if _cret != nil {
		_tocEntry = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tocEntry
}

// Entries gets the list of TocEntry of toc.
//
// The function returns the following values:
//
//    - list of TocEntry for entry.
//
func (toc *Toc) Entries() []*TocEntry {
	var _arg0 *C.GstToc // out
	var _cret *C.GList  // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	_cret = C.gst_toc_get_entries(_arg0)
	runtime.KeepAlive(toc)

	var _list []*TocEntry // out

	_list = make([]*TocEntry, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstTocEntry)(v)
		var dst *TocEntry // out
		dst = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//    - tocScope: scope of toc.
//
func (toc *Toc) Scope() TocScope {
	var _arg0 *C.GstToc     // out
	var _cret C.GstTocScope // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	_cret = C.gst_toc_get_scope(_arg0)
	runtime.KeepAlive(toc)

	var _tocScope TocScope // out

	_tocScope = TocScope(_cret)

	return _tocScope
}

// TocEntry: instance of this type is always passed by reference.
type TocEntry struct {
	*tocEntry
}

// tocEntry is the struct that's finalized.
type tocEntry struct {
	native *C.GstTocEntry
}

func marshalTocEntry(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TocEntry{&tocEntry{(*C.GstTocEntry)(b)}}, nil
}

// NewTocEntry constructs a struct TocEntry.
func NewTocEntry(typ TocEntryType, uid string) *TocEntry {
	var _arg1 C.GstTocEntryType // out
	var _arg2 *C.gchar          // out
	var _cret *C.GstTocEntry    // in

	_arg1 = C.GstTocEntryType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(uid)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_toc_entry_new(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(uid)

	var _tocEntry *TocEntry // out

	_tocEntry = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tocEntry)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tocEntry
}

// AppendSubEntry appends the TocEntry subentry to entry.
//
// The function takes the following parameters:
//
//    - subentry: TocEntry.
//
func (entry *TocEntry) AppendSubEntry(subentry *TocEntry) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 *C.GstTocEntry // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	_arg1 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(subentry)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(subentry)), nil)

	C.gst_toc_entry_append_sub_entry(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(subentry)
}

// The function returns the following values:
//
//    - tocEntryType entry's entry type.
//
func (entry *TocEntry) EntryType() TocEntryType {
	var _arg0 *C.GstTocEntry    // out
	var _cret C.GstTocEntryType // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_entry_type(_arg0)
	runtime.KeepAlive(entry)

	var _tocEntryType TocEntryType // out

	_tocEntryType = TocEntryType(_cret)

	return _tocEntryType
}

// Loop: get loop_type and repeat_count values from the entry and write them
// into appropriate storages. Loops are e.g. used by sampled instruments.
// GStreamer is not automatically applying the loop. The application can process
// this meta data and use it e.g. to send a seek-event to loop a section.
//
// The function returns the following values:
//
//    - loopType (optional): storage for the loop_type value, leave NULL if not
//      need.
//    - repeatCount (optional): storage for the repeat_count value, leave NULL if
//      not need.
//    - ok: TRUE if all non-NULL storage pointers were filled with appropriate
//      values, FALSE otherwise.
//
func (entry *TocEntry) Loop() (TocLoopType, int, bool) {
	var _arg0 *C.GstTocEntry   // out
	var _arg1 C.GstTocLoopType // in
	var _arg2 C.gint           // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_loop(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(entry)

	var _loopType TocLoopType // out
	var _repeatCount int      // out
	var _ok bool              // out

	_loopType = TocLoopType(_arg1)
	_repeatCount = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _loopType, _repeatCount, _ok
}

// Parent gets the parent TocEntry of entry.
//
// The function returns the following values:
//
//    - tocEntry (optional): parent TocEntry of entry.
//
func (entry *TocEntry) Parent() *TocEntry {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GstTocEntry // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_parent(_arg0)
	runtime.KeepAlive(entry)

	var _tocEntry *TocEntry // out

	if _cret != nil {
		_tocEntry = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tocEntry
}

// StartStopTimes: get start and stop values from the entry and write them into
// appropriate storages.
//
// The function returns the following values:
//
//    - start (optional): storage for the start value, leave NULL if not need.
//    - stop (optional): storage for the stop value, leave NULL if not need.
//    - ok: TRUE if all non-NULL storage pointers were filled with appropriate
//      values, FALSE otherwise.
//
func (entry *TocEntry) StartStopTimes() (start int64, stop int64, ok bool) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 C.gint64       // in
	var _arg2 C.gint64       // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_start_stop_times(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(entry)

	var _start int64 // out
	var _stop int64  // out
	var _ok bool     // out

	_start = int64(_arg1)
	_stop = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _start, _stop, _ok
}

// SubEntries gets the sub-entries of entry.
//
// The function returns the following values:
//
//    - list of TocEntry of entry.
//
func (entry *TocEntry) SubEntries() []*TocEntry {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_sub_entries(_arg0)
	runtime.KeepAlive(entry)

	var _list []*TocEntry // out

	_list = make([]*TocEntry, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstTocEntry)(v)
		var dst *TocEntry // out
		dst = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Toc gets the parent Toc of entry.
//
// The function returns the following values:
//
//    - toc: parent Toc of entry.
//
func (entry *TocEntry) Toc() *Toc {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GstToc      // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_toc(_arg0)
	runtime.KeepAlive(entry)

	var _toc *Toc // out

	_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _toc
}

// Uid gets the UID of entry.
//
// The function returns the following values:
//
//    - utf8: UID of entry.
//
func (entry *TocEntry) Uid() string {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_uid(_arg0)
	runtime.KeepAlive(entry)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//    - ok: TRUE if entry's type is an alternative type, otherwise FALSE.
//
func (entry *TocEntry) IsAlternative() bool {
	var _arg0 *C.GstTocEntry // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_is_alternative(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: TRUE if entry's type is a sequence type, otherwise FALSE.
//
func (entry *TocEntry) IsSequence() bool {
	var _arg0 *C.GstTocEntry // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_is_sequence(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetLoop: set loop_type and repeat_count values for the entry.
//
// The function takes the following parameters:
//
//    - loopType: loop_type value to set.
//    - repeatCount: repeat_count value to set.
//
func (entry *TocEntry) SetLoop(loopType TocLoopType, repeatCount int) {
	var _arg0 *C.GstTocEntry   // out
	var _arg1 C.GstTocLoopType // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	_arg1 = C.GstTocLoopType(loopType)
	_arg2 = C.gint(repeatCount)

	C.gst_toc_entry_set_loop(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(loopType)
	runtime.KeepAlive(repeatCount)
}

// SetStartStopTimes: set start and stop values for the entry.
//
// The function takes the following parameters:
//
//    - start value to set.
//    - stop value to set.
//
func (entry *TocEntry) SetStartStopTimes(start int64, stop int64) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 C.gint64       // out
	var _arg2 C.gint64       // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	_arg1 = C.gint64(start)
	_arg2 = C.gint64(stop)

	C.gst_toc_entry_set_start_stop_times(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)
}
