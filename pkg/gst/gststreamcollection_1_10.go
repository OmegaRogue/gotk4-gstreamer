// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeStreamCollection = coreglib.Type(C.gst_stream_collection_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStreamCollection, F: marshalStreamCollection},
	})
}

// StreamCollectionOverrides contains methods that are overridable.
type StreamCollectionOverrides struct {
}

func defaultStreamCollectionOverrides(v *StreamCollection) StreamCollectionOverrides {
	return StreamCollectionOverrides{}
}

// StreamCollection: collection of Stream that are available.
//
// A StreamCollection will be provided by elements that can make those streams
// available. Applications can use the collection to show the user what streams
// are available by using gst_stream_collection_get_stream()
//
// Once posted, a StreamCollection is immutable. Updates are made by sending a
// new StreamCollection message, which may or may not share some of the Stream
// objects from the collection it replaces. The receiver can check the sender of
// a stream collection message to know which collection is obsoleted.
//
// Several elements in a pipeline can provide StreamCollection.
//
// Applications can activate streams from a collection by using the
// T_EVENT_SELECT_STREAMS event on a pipeline, bin or element.
type StreamCollection struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*StreamCollection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StreamCollection, *StreamCollectionClass, StreamCollectionOverrides](
		GTypeStreamCollection,
		initStreamCollectionClass,
		wrapStreamCollection,
		defaultStreamCollectionOverrides,
	)
}

func initStreamCollectionClass(gclass unsafe.Pointer, overrides StreamCollectionOverrides, classInitFunc func(*StreamCollectionClass)) {
	if classInitFunc != nil {
		class := (*StreamCollectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStreamCollection(obj *coreglib.Object) *StreamCollection {
	return &StreamCollection{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalStreamCollection(p uintptr) (interface{}, error) {
	return wrapStreamCollection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStreamCollection: create a new StreamCollection.
//
// The function takes the following parameters:
//
//    - upstreamId (optional): stream id of the parent stream.
//
// The function returns the following values:
//
//    - streamCollection: new StreamCollection.
//
func NewStreamCollection(upstreamId string) *StreamCollection {
	var _arg1 *C.gchar               // out
	var _cret *C.GstStreamCollection // in

	if upstreamId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(upstreamId)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_stream_collection_new(_arg1)
	runtime.KeepAlive(upstreamId)

	var _streamCollection *StreamCollection // out

	_streamCollection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _streamCollection
}

// AddStream: add the given stream to the collection.
//
// The function takes the following parameters:
//
//    - stream to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the stream was properly added, else FALSE.
//
func (collection *StreamCollection) AddStream(stream *Stream) bool {
	var _arg0 *C.GstStreamCollection // out
	var _arg1 *C.GstStream           // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))
	_arg1 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_collection_add_stream(_arg0, _arg1)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size: get the number of streams this collection contains.
//
// The function returns the following values:
//
//    - guint: number of streams that collection contains.
//
func (collection *StreamCollection) Size() uint {
	var _arg0 *C.GstStreamCollection // out
	var _cret C.guint                // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_stream_collection_get_size(_arg0)
	runtime.KeepAlive(collection)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Stream: retrieve the Stream with index index from the collection.
//
// The caller should not modify the returned Stream.
//
// The function takes the following parameters:
//
//    - index: index of the stream to retrieve.
//
// The function returns the following values:
//
//    - stream (optional): Stream.
//
func (collection *StreamCollection) Stream(index uint) *Stream {
	var _arg0 *C.GstStreamCollection // out
	var _arg1 C.guint                // out
	var _cret *C.GstStream           // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))
	_arg1 = C.guint(index)

	_cret = C.gst_stream_collection_get_stream(_arg0, _arg1)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(index)

	var _stream *Stream // out

	if _cret != nil {
		_stream = wrapStream(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _stream
}

// UpstreamID returns the upstream id of the collection.
//
// The function returns the following values:
//
//    - utf8 (optional): upstream id.
//
func (collection *StreamCollection) UpstreamID() string {
	var _arg0 *C.GstStreamCollection // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_stream_collection_get_upstream_id(_arg0)
	runtime.KeepAlive(collection)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}
