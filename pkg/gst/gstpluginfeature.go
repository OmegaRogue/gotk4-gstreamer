// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeRank          = coreglib.Type(C.gst_rank_get_type())
	GTypePluginFeature = coreglib.Type(C.gst_plugin_feature_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRank, F: marshalRank},
		coreglib.TypeMarshaler{T: GTypePluginFeature, F: marshalPluginFeature},
	})
}

// Rank: element priority ranks. Defines the order in which the autoplugger (or
// similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())
// will choose this element over an alternative one with the same function.
//
// These constants serve as a rough guidance for defining the rank of a
// PluginFeature. Any value is valid, including values bigger than
// GST_RANK_PRIMARY.
type Rank C.gint

const (
	// RankNone will be chosen last or not at all.
	RankNone Rank = 0
	// RankMarginal: unlikely to be chosen.
	RankMarginal Rank = 64
	// RankSecondary: likely to be chosen.
	RankSecondary Rank = 128
	// RankPrimary will be chosen first.
	RankPrimary Rank = 256
)

func marshalRank(p uintptr) (interface{}, error) {
	return Rank(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Rank.
func (r Rank) String() string {
	switch r {
	case RankNone:
		return "None"
	case RankMarginal:
		return "Marginal"
	case RankSecondary:
		return "Secondary"
	case RankPrimary:
		return "Primary"
	default:
		return fmt.Sprintf("Rank(%d)", r)
	}
}

// PluginFeatureFilter: function that can be used with e.g.
// gst_registry_feature_filter() to get a list of pluginfeature that match
// certain criteria.
type PluginFeatureFilter func(feature PluginFeaturer) (ok bool)

// PluginFeature: this is a base class for anything that can be added to a
// Plugin.
type PluginFeature struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*PluginFeature)(nil)
)

// PluginFeaturer describes types inherited from class PluginFeature.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type PluginFeaturer interface {
	coreglib.Objector
	basePluginFeature() *PluginFeature
}

var _ PluginFeaturer = (*PluginFeature)(nil)

func wrapPluginFeature(obj *coreglib.Object) *PluginFeature {
	return &PluginFeature{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPluginFeature(p uintptr) (interface{}, error) {
	return wrapPluginFeature(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (feature *PluginFeature) basePluginFeature() *PluginFeature {
	return feature
}

// BasePluginFeature returns the underlying base object.
func BasePluginFeature(obj PluginFeaturer) *PluginFeature {
	return obj.basePluginFeature()
}

// CheckVersion checks whether the given plugin feature is at least the required
// version.
//
// The function takes the following parameters:
//
//    - minMajor: minimum required major version.
//    - minMinor: minimum required minor version.
//    - minMicro: minimum required micro version.
//
// The function returns the following values:
//
//    - ok: TRUE if the plugin feature has at least the required version,
//      otherwise FALSE.
//
func (feature *PluginFeature) CheckVersion(minMajor, minMinor, minMicro uint) bool {
	var _arg0 *C.GstPluginFeature // out
	var _arg1 C.guint             // out
	var _arg2 C.guint             // out
	var _arg3 C.guint             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))
	_arg1 = C.guint(minMajor)
	_arg2 = C.guint(minMinor)
	_arg3 = C.guint(minMicro)

	_cret = C.gst_plugin_feature_check_version(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(minMajor)
	runtime.KeepAlive(minMinor)
	runtime.KeepAlive(minMicro)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Plugin: get the plugin that provides this feature.
//
// The function returns the following values:
//
//    - plugin (optional) that provides this feature, or NULL. Unref with
//      gst_object_unref() when no longer needed.
//
func (feature *PluginFeature) Plugin() *Plugin {
	var _arg0 *C.GstPluginFeature // out
	var _cret *C.GstPlugin        // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_get_plugin(_arg0)
	runtime.KeepAlive(feature)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// PluginName: get the name of the plugin that provides this feature.
//
// The function returns the following values:
//
//    - utf8 (optional): name of the plugin that provides this feature, or NULL
//      if the feature is not associated with a plugin.
//
func (feature *PluginFeature) PluginName() string {
	var _arg0 *C.GstPluginFeature // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_get_plugin_name(_arg0)
	runtime.KeepAlive(feature)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Rank gets the rank of a plugin feature.
//
// The function returns the following values:
//
//    - guint: rank of the feature.
//
func (feature *PluginFeature) Rank() uint {
	var _arg0 *C.GstPluginFeature // out
	var _cret C.guint             // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_get_rank(_arg0)
	runtime.KeepAlive(feature)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Load loads the plugin containing feature if it's not already loaded. feature
// is unaffected; use the return value instead.
//
// Normally this function is used like this:
//
//    GstPluginFeature *loaded_feature;
//
//    loaded_feature = gst_plugin_feature_load (feature);
//    // presumably, we're no longer interested in the potentially-unloaded feature
//    gst_object_unref (feature);
//    feature = loaded_feature;.
//
// The function returns the following values:
//
//    - pluginFeature (optional): reference to the loaded feature, or NULL on
//      error.
//
func (feature *PluginFeature) Load() PluginFeaturer {
	var _arg0 *C.GstPluginFeature // out
	var _cret *C.GstPluginFeature // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_load(_arg0)
	runtime.KeepAlive(feature)

	var _pluginFeature PluginFeaturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			_pluginFeature = rv
		}
	}

	return _pluginFeature
}

// SetRank specifies a rank for a plugin feature, so that autoplugging uses the
// most appropriate feature.
//
// The function takes the following parameters:
//
//    - rank value - higher number means more priority rank.
//
func (feature *PluginFeature) SetRank(rank uint) {
	var _arg0 *C.GstPluginFeature // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))
	_arg1 = C.guint(rank)

	C.gst_plugin_feature_set_rank(_arg0, _arg1)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(rank)
}

// PluginFeatureListCopy copies the list of features. Caller should call
// gst_plugin_feature_list_free when done with the list.
//
// The function takes the following parameters:
//
//    - list: list of PluginFeature.
//
// The function returns the following values:
//
//    - ret: copy of list, with each feature's reference count incremented.
//
func PluginFeatureListCopy(list []PluginFeaturer) []PluginFeaturer {
	var _arg1 *C.GList // out
	var _cret *C.GList // in

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstPluginFeature // out
		dst = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.gst_plugin_feature_list_copy(_arg1)
	runtime.KeepAlive(list)

	var _ret []PluginFeaturer // out

	_ret = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_ret = append(_ret, dst)
	})

	return _ret
}

// PluginFeatureListDebug: debug the plugin feature names in list.
//
// The function takes the following parameters:
//
//    - list of plugin features.
//
func PluginFeatureListDebug(list []PluginFeaturer) {
	var _arg1 *C.GList // out

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstPluginFeature // out
		dst = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	C.gst_plugin_feature_list_debug(_arg1)
	runtime.KeepAlive(list)
}

// PluginFeatureRankCompareFunc compares the two given PluginFeature instances.
// This function can be used as a Func when sorting by rank and then by name.
//
// The function takes the following parameters:
//
//    - p1 (optional): PluginFeature.
//    - p2 (optional): PluginFeature.
//
// The function returns the following values:
//
//    - gint: negative value if the rank of p1 > the rank of p2 or the ranks are
//      equal but the name of p1 comes before the name of p2; zero if the rank
//      and names are equal; positive value if the rank of p1 < the rank of p2 or
//      the ranks are equal but the name of p2 comes before the name of p1.
//
func PluginFeatureRankCompareFunc(p1, p2 unsafe.Pointer) int {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gint          // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(p1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(p2))

	_cret = C.gst_plugin_feature_rank_compare_func(_arg1, _arg2)
	runtime.KeepAlive(p1)
	runtime.KeepAlive(p2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}
