// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypePipelineFlags = coreglib.Type(C.gst_pipeline_flags_get_type())
	GTypePipeline      = coreglib.Type(C.gst_pipeline_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePipelineFlags, F: marshalPipelineFlags},
		coreglib.TypeMarshaler{T: GTypePipeline, F: marshalPipeline},
	})
}

// PipelineFlags: pipeline flags.
type PipelineFlags C.guint

const (
	// PipelineFlagFixedClock: pipeline works with a fixed clock.
	PipelineFlagFixedClock PipelineFlags = 0b10000000000000000000
	// PipelineFlagLast: offset to define more flags.
	PipelineFlagLast PipelineFlags = 0b100000000000000000000000
)

func marshalPipelineFlags(p uintptr) (interface{}, error) {
	return PipelineFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PipelineFlags.
func (p PipelineFlags) String() string {
	if p == 0 {
		return "PipelineFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(39)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PipelineFlagFixedClock:
			builder.WriteString("FixedClock|")
		case PipelineFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("PipelineFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PipelineFlags) Has(other PipelineFlags) bool {
	return (p & other) == other
}

// PipelineOverrides contains methods that are overridable.
type PipelineOverrides struct {
}

func defaultPipelineOverrides(v *Pipeline) PipelineOverrides {
	return PipelineOverrides{}
}

// Pipeline is a special Bin used as the toplevel container for the filter
// graph. The Pipeline will manage the selection and distribution of a global
// Clock as well as provide a Bus to the application.
//
// gst_pipeline_new() is used to create a pipeline. when you are done with the
// pipeline, use gst_object_unref() to free its resources including all added
// Element objects (if not otherwise referenced).
//
// Elements are added and removed from the pipeline using the Bin methods like
// gst_bin_add() and gst_bin_remove() (see Bin).
//
// Before changing the state of the Pipeline (see Element) a Bus should be
// retrieved with gst_pipeline_get_bus(). This Bus should then be used to
// receive Message from the elements in the pipeline. Listening to the Bus is
// necessary for retrieving error messages from the Pipeline and otherwise the
// Pipeline might stop without any indication, why. Furthermore, the Pipeline
// posts messages even if nobody listens on the Bus, which will pile up and use
// up memory.
//
// By default, a Pipeline will automatically flush the pending Bus messages when
// going to the NULL state to ensure that no circular references exist when no
// messages are read from the Bus. This behaviour can be changed with
// gst_pipeline_set_auto_flush_bus().
//
// When the Pipeline performs the PAUSED to PLAYING state change it will select
// a clock for the elements. The clock selection algorithm will by default
// select a clock provided by an element that is most upstream (closest to the
// source). For live pipelines (ones that return T_STATE_CHANGE_NO_PREROLL from
// the gst_element_set_state() call) this will select the clock provided by the
// live source. For normal pipelines this will select a clock provided by the
// sinks (most likely the audio sink). If no element provides a clock, a default
// SystemClock is used.
//
// The clock selection can be controlled with the gst_pipeline_use_clock()
// method, which will enforce a given clock on the pipeline. With
// gst_pipeline_auto_clock() the default clock selection algorithm can be
// restored.
//
// A Pipeline maintains a running time for the elements. The running time is
// defined as the difference between the current clock time and the base time.
// When the pipeline goes to READY or a flushing seek is performed on it, the
// running time is reset to 0. When the pipeline is set from PLAYING to PAUSED,
// the current clock time is sampled and used to configure the base time for the
// elements when the pipeline is set to PLAYING again. The effect is that the
// running time (as the difference between the clock time and the base time)
// will count how much time was spent in the PLAYING state. This default
// behaviour can be changed with the gst_element_set_start_time() method.
type Pipeline struct {
	_ [0]func() // equal guard
	Bin
}

var (
	_ Elementer = (*Pipeline)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Pipeline, *PipelineClass, PipelineOverrides](
		GTypePipeline,
		initPipelineClass,
		wrapPipeline,
		defaultPipelineOverrides,
	)
}

func initPipelineClass(gclass unsafe.Pointer, overrides PipelineOverrides, classInitFunc func(*PipelineClass)) {
	if classInitFunc != nil {
		class := (*PipelineClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPipeline(obj *coreglib.Object) *Pipeline {
	return &Pipeline{
		Bin: Bin{
			Element: Element{
				GstObject: GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
			ChildProxy: ChildProxy{
				Object: obj,
			},
		},
	}
}

func marshalPipeline(p uintptr) (interface{}, error) {
	return wrapPipeline(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPipeline: create a new pipeline with the given name.
//
// The function takes the following parameters:
//
//    - name (optional) of new pipeline.
//
// The function returns the following values:
//
//    - pipeline: newly created GstPipeline
//
//      MT safe.
//
func NewPipeline(name string) *Pipeline {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_pipeline_new(_arg1)
	runtime.KeepAlive(name)

	var _pipeline *Pipeline // out

	_pipeline = wrapPipeline(coreglib.Take(unsafe.Pointer(_cret)))

	return _pipeline
}

// AutoClock: let pipeline select a clock automatically. This is the default
// behaviour.
//
// Use this function if you previous forced a fixed clock with
// gst_pipeline_use_clock() and want to restore the default pipeline clock
// selection algorithm.
//
// MT safe.
func (pipeline *Pipeline) AutoClock() {
	var _arg0 *C.GstPipeline // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	C.gst_pipeline_auto_clock(_arg0)
	runtime.KeepAlive(pipeline)
}

// AutoFlushBus: check if pipeline will automatically flush messages when going
// to the NULL state.
//
// The function returns the following values:
//
//    - ok: whether the pipeline will automatically flush its bus when going from
//      READY to NULL state or not.
//
//      MT safe.
//
func (pipeline *Pipeline) AutoFlushBus() bool {
	var _arg0 *C.GstPipeline // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_auto_flush_bus(_arg0)
	runtime.KeepAlive(pipeline)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Bus gets the Bus of pipeline. The bus allows applications to receive Message
// packets.
//
// The function returns the following values:
//
//    - bus unref after usage.
//
//      MT safe.
//
func (pipeline *Pipeline) Bus() *Bus {
	var _arg0 *C.GstPipeline // out
	var _cret *C.GstBus      // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_bus(_arg0)
	runtime.KeepAlive(pipeline)

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// Delay: get the configured delay (see gst_pipeline_set_delay()).
//
// The function returns the following values:
//
//    - clockTime: configured delay.
//
//      MT safe.
//
func (pipeline *Pipeline) Delay() ClockTime {
	var _arg0 *C.GstPipeline // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_delay(_arg0)
	runtime.KeepAlive(pipeline)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Latency gets the latency that should be configured on the pipeline. See
// gst_pipeline_set_latency().
//
// The function returns the following values:
//
//    - clockTime: latency to configure on the pipeline or GST_CLOCK_TIME_NONE.
//
func (pipeline *Pipeline) Latency() ClockTime {
	var _arg0 *C.GstPipeline // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_latency(_arg0)
	runtime.KeepAlive(pipeline)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// PipelineClock gets the current clock used by pipeline.
//
// Unlike gst_element_get_clock(), this function will always return a clock,
// even if the pipeline is not in the PLAYING state.
//
// The function returns the following values:
//
//    - clock unref after usage.
//
func (pipeline *Pipeline) PipelineClock() Clocker {
	var _arg0 *C.GstPipeline // out
	var _cret *C.GstClock    // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_pipeline_clock(_arg0)
	runtime.KeepAlive(pipeline)

	var _clock Clocker // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Clocker is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Clocker)
			return ok
		})
		rv, ok := casted.(Clocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
		}
		_clock = rv
	}

	return _clock
}

// SetAutoFlushBus: usually, when a pipeline goes from READY to NULL state, it
// automatically flushes all pending messages on the bus, which is done for
// refcounting purposes, to break circular references.
//
// This means that applications that update state using (async) bus messages
// (e.g. do certain things when a pipeline goes from PAUSED to READY) might not
// get to see messages when the pipeline is shut down, because they might be
// flushed before they can be dispatched in the main thread. This behaviour can
// be disabled using this function.
//
// It is important that all messages on the bus are handled when the automatic
// flushing is disabled else memory leaks will be introduced.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - autoFlush: whether or not to automatically flush the bus when the
//      pipeline goes from READY to NULL state.
//
func (pipeline *Pipeline) SetAutoFlushBus(autoFlush bool) {
	var _arg0 *C.GstPipeline // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	if autoFlush {
		_arg1 = C.TRUE
	}

	C.gst_pipeline_set_auto_flush_bus(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(autoFlush)
}

// SetDelay: set the expected delay needed for all elements to perform the
// PAUSED to PLAYING state change. delay will be added to the base time of the
// elements so that they wait an additional delay amount of time before starting
// to process buffers and cannot be T_CLOCK_TIME_NONE.
//
// This option is used for tuning purposes and should normally not be used.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - delay: delay.
//
func (pipeline *Pipeline) SetDelay(delay ClockTime) {
	var _arg0 *C.GstPipeline // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	_arg1 = C.guint64(delay)
	type _ = ClockTime
	type _ = uint64

	C.gst_pipeline_set_delay(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(delay)
}

// SetLatency sets the latency that should be configured on the pipeline.
// Setting GST_CLOCK_TIME_NONE will restore the default behaviour of using the
// minimum latency from the LATENCY query. Setting this is usually not required
// and the pipeline will figure out an appropriate latency automatically.
//
// Setting a too low latency, especially lower than the minimum latency from the
// LATENCY query, will most likely cause the pipeline to fail.
//
// The function takes the following parameters:
//
//    - latency to configure.
//
func (pipeline *Pipeline) SetLatency(latency ClockTime) {
	var _arg0 *C.GstPipeline // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	_arg1 = C.guint64(latency)
	type _ = ClockTime
	type _ = uint64

	C.gst_pipeline_set_latency(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(latency)
}

// UseClock: force pipeline to use the given clock. The pipeline will always use
// the given clock even if new clock providers are added to this pipeline.
//
// If clock is NULL all clocking will be disabled which will make the pipeline
// run as fast as possible.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - clock (optional) to use.
//
func (pipeline *Pipeline) UseClock(clock Clocker) {
	var _arg0 *C.GstPipeline // out
	var _arg1 *C.GstClock    // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	if clock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}

	C.gst_pipeline_use_clock(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(clock)
}

// PipelineClass: instance of this type is always passed by reference.
type PipelineClass struct {
	*pipelineClass
}

// pipelineClass is the struct that's finalized.
type pipelineClass struct {
	native *C.GstPipelineClass
}

func (p *PipelineClass) ParentClass() *BinClass {
	valptr := &p.native.parent_class
	var _v *BinClass // out
	_v = (*BinClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
