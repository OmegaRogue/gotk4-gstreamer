// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeCapsFeatures = coreglib.Type(C.gst_caps_features_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCapsFeatures, F: marshalCapsFeatures},
	})
}

// CapsFeatures can optionally be set on a Caps to add requirements for
// additional features for a specific Structure. Caps structures with the same
// name but with a non-equal set of caps features are not compatible. If a pad
// supports multiple sets of features it has to add multiple equal structures
// with different feature sets to the caps.
//
// Empty CapsFeatures are equivalent with the CapsFeatures that only contain
// T_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY. ANY CapsFeatures as created by
// gst_caps_features_new_any() are equal to any other CapsFeatures and can be
// used to specify that any CapsFeatures would be supported, e.g. for elements
// that don't touch buffer memory. Caps with ANY CapsFeatures are considered
// non-fixed and during negotiation some CapsFeatures have to be selected.
//
// Examples for caps features would be the requirement of a specific Memory
// types or the requirement of having a specific Meta on the buffer. Features
// are given as a string of the format memory:GstMemoryTypeName or
// meta:GstMetaAPIName.
//
// An instance of this type is always passed by reference.
type CapsFeatures struct {
	*capsFeatures
}

// capsFeatures is the struct that's finalized.
type capsFeatures struct {
	native *C.GstCapsFeatures
}

func marshalCapsFeatures(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &CapsFeatures{&capsFeatures{(*C.GstCapsFeatures)(b)}}, nil
}

// NewCapsFeaturesAny constructs a struct CapsFeatures.
func NewCapsFeaturesAny() *CapsFeatures {
	var _cret *C.GstCapsFeatures // in

	_cret = C.gst_caps_features_new_any()

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// NewCapsFeaturesEmpty constructs a struct CapsFeatures.
func NewCapsFeaturesEmpty() *CapsFeatures {
	var _cret *C.GstCapsFeatures // in

	_cret = C.gst_caps_features_new_empty()

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// NewCapsFeaturesSingle constructs a struct CapsFeatures.
func NewCapsFeaturesSingle(feature string) *CapsFeatures {
	var _arg1 *C.gchar           // out
	var _cret *C.GstCapsFeatures // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_features_new_single(_arg1)
	runtime.KeepAlive(feature)

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// Add adds feature to features.
//
// The function takes the following parameters:
//
//    - feature: feature.
//
func (features *CapsFeatures) Add(feature string) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_caps_features_add(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// AddID adds feature to features.
//
// The function takes the following parameters:
//
//    - feature: feature.
//
func (features *CapsFeatures) AddID(feature glib.Quark) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.GQuark           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint32(feature)
	type _ = glib.Quark
	type _ = uint32

	C.gst_caps_features_add_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// Contains checks if features contains feature.
//
// The function takes the following parameters:
//
//    - feature: feature.
//
// The function returns the following values:
//
//    - ok: TRUE if features contains feature.
//
func (features *CapsFeatures) Contains(feature string) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_features_contains(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsID checks if features contains feature.
//
// The function takes the following parameters:
//
//    - feature: feature.
//
// The function returns the following values:
//
//    - ok: TRUE if features contains feature.
//
func (features *CapsFeatures) ContainsID(feature glib.Quark) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.GQuark           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint32(feature)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_caps_features_contains_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy duplicates a CapsFeatures and all its values.
//
// The function returns the following values:
//
//    - capsFeatures: new CapsFeatures.
//
func (features *CapsFeatures) Copy() *CapsFeatures {
	var _arg0 *C.GstCapsFeatures // out
	var _cret *C.GstCapsFeatures // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_copy(_arg0)
	runtime.KeepAlive(features)

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// Nth returns the i-th feature of features.
//
// The function takes the following parameters:
//
//    - i: index of the feature.
//
// The function returns the following values:
//
//    - utf8 (optional): i-th feature of features.
//
func (features *CapsFeatures) Nth(i uint) string {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.guint            // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint(i)

	_cret = C.gst_caps_features_get_nth(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(i)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NthID returns the i-th feature of features.
//
// The function takes the following parameters:
//
//    - i: index of the feature.
//
// The function returns the following values:
//
//    - quark: i-th feature of features.
//
func (features *CapsFeatures) NthID(i uint) glib.Quark {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.guint            // out
	var _cret C.GQuark           // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint(i)

	_cret = C.gst_caps_features_get_nth_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(i)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// Size returns the number of features in features.
//
// The function returns the following values:
//
//    - guint: number of features in features.
//
func (features *CapsFeatures) Size() uint {
	var _arg0 *C.GstCapsFeatures // out
	var _cret C.guint            // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_get_size(_arg0)
	runtime.KeepAlive(features)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsAny checks if features is GST_CAPS_FEATURES_ANY.
//
// The function returns the following values:
//
//    - ok: TRUE if features is GST_CAPS_FEATURES_ANY.
//
func (features *CapsFeatures) IsAny() bool {
	var _arg0 *C.GstCapsFeatures // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_is_any(_arg0)
	runtime.KeepAlive(features)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks if features1 and features2 are equal.
//
// The function takes the following parameters:
//
//    - features2: CapsFeatures.
//
// The function returns the following values:
//
//    - ok: TRUE if features1 and features2 are equal.
//
func (features1 *CapsFeatures) IsEqual(features2 *CapsFeatures) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.GstCapsFeatures // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features1)))
	_arg1 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features2)))

	_cret = C.gst_caps_features_is_equal(_arg0, _arg1)
	runtime.KeepAlive(features1)
	runtime.KeepAlive(features2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes feature from features.
//
// The function takes the following parameters:
//
//    - feature: feature.
//
func (features *CapsFeatures) Remove(feature string) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_caps_features_remove(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// RemoveID removes feature from features.
//
// The function takes the following parameters:
//
//    - feature: feature.
//
func (features *CapsFeatures) RemoveID(feature glib.Quark) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.GQuark           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint32(feature)
	type _ = glib.Quark
	type _ = uint32

	C.gst_caps_features_remove_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// SetParentRefcount sets the parent_refcount field of CapsFeatures. This field
// is used to determine whether a caps features is mutable or not. This function
// should only be called by code implementing parent objects of CapsFeatures, as
// described in the MT refcounting design document
// (additional/design/MT-refcounting.md).
//
// The function takes the following parameters:
//
//    - refcount: pointer to the parent's refcount.
//
// The function returns the following values:
//
//    - ok: TRUE if the parent refcount could be set.
//
func (features *CapsFeatures) SetParentRefcount(refcount *int) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gint)(unsafe.Pointer(refcount))

	_cret = C.gst_caps_features_set_parent_refcount(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(refcount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String converts features to a human-readable string representation.
//
// For debugging purposes its easier to do something like this:
//
//    C GST_LOG ("features is %" GST_PTR_FORMAT, features);
//
// This prints the features in human readable form.
//
// The function returns the following values:
//
//    - utf8: pointer to string allocated by g_malloc().
//
func (features *CapsFeatures) String() string {
	var _arg0 *C.GstCapsFeatures // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_to_string(_arg0)
	runtime.KeepAlive(features)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CapsFeaturesFromString creates a CapsFeatures from a string representation.
//
// The function takes the following parameters:
//
//    - features: string representation of a CapsFeatures.
//
// The function returns the following values:
//
//    - capsFeatures (optional): new CapsFeatures or NULL when the string could
//      not be parsed.
//
func CapsFeaturesFromString(features string) *CapsFeatures {
	var _arg1 *C.gchar           // out
	var _cret *C.GstCapsFeatures // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(features)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_features_from_string(_arg1)
	runtime.KeepAlive(features)

	var _capsFeatures *CapsFeatures // out

	if _cret != nil {
		_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
			},
		)
	}

	return _capsFeatures
}
