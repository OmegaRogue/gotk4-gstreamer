// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// ElementTypeSetSkipDocumentation marks type as "documentation should be
// skipped". Can be useful for dynamically registered element to be excluded
// from plugin documentation system.
//
// Example:
//
//    GType my_type;
//    GTypeInfo my_type_info;
//
//    // Fill "my_type_info"
//    ...
//
//    my_type = g_type_register_static (GST_TYPE_MY_ELEMENT, "my-type-name",
//       &my_type_info, 0);
//    gst_element_type_set_skip_documentation (my_type);
//    gst_element_register (plugin, "my-plugin-feature-name", rank, my_type);.
//
// The function takes the following parameters:
//
//    - typ of element.
//
func ElementTypeSetSkipDocumentation(typ coreglib.Type) {
	var _arg1 C.GType // out

	_arg1 = C.GType(typ)

	C.gst_element_type_set_skip_documentation(_arg1)
	runtime.KeepAlive(typ)
}

// ElementFactoryMakeWithProperties: create a new element of the type defined by
// the given elementfactory. The supplied list of properties, will be passed at
// object construction.
//
// The function takes the following parameters:
//
//    - factoryname: named factory to instantiate.
//    - names (optional): array of properties names.
//    - values (optional): array of associated properties values.
//
// The function returns the following values:
//
//    - element (optional): new Element or NULL if the element couldn't be
//      created.
//
func ElementFactoryMakeWithProperties(factoryname string, names []string, values []coreglib.Value) Elementer {
	var _arg1 *C.gchar  // out
	var _arg3 **C.gchar // out
	var _arg2 C.guint
	var _arg4 *C.GValue     // out
	var _cret *C.GstElement // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(names))
	_arg3 = (**C.gchar)(C.calloc(C.size_t(len(names)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((**C.gchar)(_arg3), len(names))
		for i := range names {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(names[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (C.guint)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_element_factory_make_with_properties(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(factoryname)
	runtime.KeepAlive(names)
	runtime.KeepAlive(values)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}
