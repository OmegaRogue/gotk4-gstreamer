// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeCoreError     = coreglib.Type(C.gst_core_error_get_type())
	GTypeLibraryError  = coreglib.Type(C.gst_library_error_get_type())
	GTypeResourceError = coreglib.Type(C.gst_resource_error_get_type())
	GTypeStreamError   = coreglib.Type(C.gst_stream_error_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCoreError, F: marshalCoreError},
		coreglib.TypeMarshaler{T: GTypeLibraryError, F: marshalLibraryError},
		coreglib.TypeMarshaler{T: GTypeResourceError, F: marshalResourceError},
		coreglib.TypeMarshaler{T: GTypeStreamError, F: marshalStreamError},
	})
}

// ERROR_SYSTEM builds a string using errno describing the previously failed
// system call. To be used as the debug argument in T_ELEMENT_ERROR.
const ERROR_SYSTEM = "system error: %s"

// CoreError: core errors are errors inside the core GStreamer library.
type CoreError C.gint

const (
	// CoreErrorFailed: general error which doesn't fit in any other category.
	// Make sure you add a custom message to the error call.
	CoreErrorFailed CoreError = 1
	// CoreErrorTooLaZY: do not use this except as a placeholder for deciding
	// where to go while developing code.
	CoreErrorTooLaZY CoreError = 2
	// CoreErrorNotImplemented: use this when you do not want to implement this
	// functionality yet.
	CoreErrorNotImplemented CoreError = 3
	// CoreErrorStateChange: used for state change errors.
	CoreErrorStateChange CoreError = 4
	// CoreErrorPad: used for pad-related errors.
	CoreErrorPad CoreError = 5
	// CoreErrorThread: used for thread-related errors.
	CoreErrorThread CoreError = 6
	// CoreErrorNegotiation: used for negotiation-related errors.
	CoreErrorNegotiation CoreError = 7
	// CoreErrorEvent: used for event-related errors.
	CoreErrorEvent CoreError = 8
	// CoreErrorSeek: used for seek-related errors.
	CoreErrorSeek CoreError = 9
	// CoreErrorCaps: used for caps-related errors.
	CoreErrorCaps CoreError = 10
	// CoreErrorTag: used for negotiation-related errors.
	CoreErrorTag CoreError = 11
	// CoreErrorMissingPlugin: used if a plugin is missing.
	CoreErrorMissingPlugin CoreError = 12
	// CoreErrorClock: used for clock related errors.
	CoreErrorClock CoreError = 13
	// CoreErrorDisabled: used if functionality has been disabled at compile
	// time.
	CoreErrorDisabled CoreError = 14
	// CoreErrorNumErrors: number of core error types.
	CoreErrorNumErrors CoreError = 15
)

func marshalCoreError(p uintptr) (interface{}, error) {
	return CoreError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CoreError.
func (c CoreError) String() string {
	switch c {
	case CoreErrorFailed:
		return "Failed"
	case CoreErrorTooLaZY:
		return "TooLaZY"
	case CoreErrorNotImplemented:
		return "NotImplemented"
	case CoreErrorStateChange:
		return "StateChange"
	case CoreErrorPad:
		return "Pad"
	case CoreErrorThread:
		return "Thread"
	case CoreErrorNegotiation:
		return "Negotiation"
	case CoreErrorEvent:
		return "Event"
	case CoreErrorSeek:
		return "Seek"
	case CoreErrorCaps:
		return "Caps"
	case CoreErrorTag:
		return "Tag"
	case CoreErrorMissingPlugin:
		return "MissingPlugin"
	case CoreErrorClock:
		return "Clock"
	case CoreErrorDisabled:
		return "Disabled"
	case CoreErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("CoreError(%d)", c)
	}
}

// LibraryError: library errors are for errors from the library being used by
// elements (initializing, finalizing, settings, ...).
type LibraryError C.gint

const (
	// LibraryErrorFailed: general error which doesn't fit in any other
	// category. Make sure you add a custom message to the error call.
	LibraryErrorFailed LibraryError = 1
	// LibraryErrorTooLaZY: do not use this except as a placeholder for deciding
	// where to go while developing code.
	LibraryErrorTooLaZY LibraryError = 2
	// LibraryErrorInit: used when the library could not be opened.
	LibraryErrorInit LibraryError = 3
	// LibraryErrorShutdown: used when the library could not be closed.
	LibraryErrorShutdown LibraryError = 4
	// LibraryErrorSettings: used when the library doesn't accept settings.
	LibraryErrorSettings LibraryError = 5
	// LibraryErrorEncode: used when the library generated an encoding error.
	LibraryErrorEncode LibraryError = 6
	// LibraryErrorNumErrors: number of library error types.
	LibraryErrorNumErrors LibraryError = 7
)

func marshalLibraryError(p uintptr) (interface{}, error) {
	return LibraryError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LibraryError.
func (l LibraryError) String() string {
	switch l {
	case LibraryErrorFailed:
		return "Failed"
	case LibraryErrorTooLaZY:
		return "TooLaZY"
	case LibraryErrorInit:
		return "Init"
	case LibraryErrorShutdown:
		return "Shutdown"
	case LibraryErrorSettings:
		return "Settings"
	case LibraryErrorEncode:
		return "Encode"
	case LibraryErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("LibraryError(%d)", l)
	}
}

// ResourceError: resource errors are for any resource used by an element:
// memory, files, network connections, process space, ... They're typically used
// by source and sink elements.
type ResourceError C.gint

const (
	// ResourceErrorFailed: general error which doesn't fit in any other
	// category. Make sure you add a custom message to the error call.
	ResourceErrorFailed ResourceError = 1
	// ResourceErrorTooLaZY: do not use this except as a placeholder for
	// deciding where to go while developing code.
	ResourceErrorTooLaZY ResourceError = 2
	// ResourceErrorNotFound: used when the resource could not be found.
	ResourceErrorNotFound ResourceError = 3
	// ResourceErrorBusy: used when resource is busy.
	ResourceErrorBusy ResourceError = 4
	// ResourceErrorOpenRead: used when resource fails to open for reading.
	ResourceErrorOpenRead ResourceError = 5
	// ResourceErrorOpenWrite: used when resource fails to open for writing.
	ResourceErrorOpenWrite ResourceError = 6
	// ResourceErrorOpenReadWrite: used when resource cannot be opened for both
	// reading and writing, or either (but unspecified which).
	ResourceErrorOpenReadWrite ResourceError = 7
	// ResourceErrorClose: used when the resource can't be closed.
	ResourceErrorClose ResourceError = 8
	// ResourceErrorRead: used when the resource can't be read from.
	ResourceErrorRead ResourceError = 9
	// ResourceErrorWrite: used when the resource can't be written to.
	ResourceErrorWrite ResourceError = 10
	// ResourceErrorSeek: used when a seek on the resource fails.
	ResourceErrorSeek ResourceError = 11
	// ResourceErrorSync: used when a synchronize on the resource fails.
	ResourceErrorSync ResourceError = 12
	// ResourceErrorSettings: used when settings can't be manipulated on.
	ResourceErrorSettings ResourceError = 13
	// ResourceErrorNoSpaceLeft: used when the resource has no space left.
	ResourceErrorNoSpaceLeft ResourceError = 14
	// ResourceErrorNotAuthorized: used when the resource can't be opened due to
	// missing authorization. (Since: 1.2.4).
	ResourceErrorNotAuthorized ResourceError = 15
	// ResourceErrorNumErrors: number of resource error types.
	ResourceErrorNumErrors ResourceError = 16
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResourceError.
func (r ResourceError) String() string {
	switch r {
	case ResourceErrorFailed:
		return "Failed"
	case ResourceErrorTooLaZY:
		return "TooLaZY"
	case ResourceErrorNotFound:
		return "NotFound"
	case ResourceErrorBusy:
		return "Busy"
	case ResourceErrorOpenRead:
		return "OpenRead"
	case ResourceErrorOpenWrite:
		return "OpenWrite"
	case ResourceErrorOpenReadWrite:
		return "OpenReadWrite"
	case ResourceErrorClose:
		return "Close"
	case ResourceErrorRead:
		return "Read"
	case ResourceErrorWrite:
		return "Write"
	case ResourceErrorSeek:
		return "Seek"
	case ResourceErrorSync:
		return "Sync"
	case ResourceErrorSettings:
		return "Settings"
	case ResourceErrorNoSpaceLeft:
		return "NoSpaceLeft"
	case ResourceErrorNotAuthorized:
		return "NotAuthorized"
	case ResourceErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("ResourceError(%d)", r)
	}
}

// StreamError: stream errors are for anything related to the stream being
// processed: format errors, media type errors, ... They're typically used by
// decoders, demuxers, converters, ...
type StreamError C.gint

const (
	// StreamErrorFailed: general error which doesn't fit in any other category.
	// Make sure you add a custom message to the error call.
	StreamErrorFailed StreamError = 1
	// StreamErrorTooLaZY: do not use this except as a placeholder for deciding
	// where to go while developing code.
	StreamErrorTooLaZY StreamError = 2
	// StreamErrorNotImplemented: use this when you do not want to implement
	// this functionality yet.
	StreamErrorNotImplemented StreamError = 3
	// StreamErrorTypeNotFound: used when the element doesn't know the stream's
	// type.
	StreamErrorTypeNotFound StreamError = 4
	// StreamErrorWrongType: used when the element doesn't handle this type of
	// stream.
	StreamErrorWrongType StreamError = 5
	// StreamErrorCodecNotFound: used when there's no codec to handle the
	// stream's type.
	StreamErrorCodecNotFound StreamError = 6
	// StreamErrorDecode: used when decoding fails.
	StreamErrorDecode StreamError = 7
	// StreamErrorEncode: used when encoding fails.
	StreamErrorEncode StreamError = 8
	// StreamErrorDemux: used when demuxing fails.
	StreamErrorDemux StreamError = 9
	// StreamErrorMux: used when muxing fails.
	StreamErrorMux StreamError = 10
	// StreamErrorFormat: used when the stream is of the wrong format (for
	// example, wrong caps).
	StreamErrorFormat StreamError = 11
	// StreamErrorDecrypt: used when the stream is encrypted and can't be
	// decrypted because this is not supported by the element.
	StreamErrorDecrypt StreamError = 12
	// StreamErrorDecryptNokey: used when the stream is encrypted and can't be
	// decrypted because no suitable key is available.
	StreamErrorDecryptNokey StreamError = 13
	// StreamErrorNumErrors: number of stream error types.
	StreamErrorNumErrors StreamError = 14
)

func marshalStreamError(p uintptr) (interface{}, error) {
	return StreamError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StreamError.
func (s StreamError) String() string {
	switch s {
	case StreamErrorFailed:
		return "Failed"
	case StreamErrorTooLaZY:
		return "TooLaZY"
	case StreamErrorNotImplemented:
		return "NotImplemented"
	case StreamErrorTypeNotFound:
		return "TypeNotFound"
	case StreamErrorWrongType:
		return "WrongType"
	case StreamErrorCodecNotFound:
		return "CodecNotFound"
	case StreamErrorDecode:
		return "Decode"
	case StreamErrorEncode:
		return "Encode"
	case StreamErrorDemux:
		return "Demux"
	case StreamErrorMux:
		return "Mux"
	case StreamErrorFormat:
		return "Format"
	case StreamErrorDecrypt:
		return "Decrypt"
	case StreamErrorDecryptNokey:
		return "DecryptNokey"
	case StreamErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("StreamError(%d)", s)
	}
}

// ErrorGetMessage: get a string describing the error message in the current
// locale.
//
// The function takes the following parameters:
//
//    - domain: GStreamer error domain this error belongs to.
//    - code: error code belonging to the domain.
//
// The function returns the following values:
//
//    - utf8: newly allocated string describing the error message (in UTF-8
//      encoding).
//
func ErrorGetMessage(domain glib.Quark, code int) string {
	var _arg1 C.GQuark // out
	var _arg2 C.gint   // out
	var _cret *C.gchar // in

	_arg1 = C.guint32(domain)
	type _ = glib.Quark
	type _ = uint32
	_arg2 = C.gint(code)

	_cret = C.gst_error_get_message(_arg1, _arg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}
