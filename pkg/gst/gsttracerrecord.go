// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeTracerValueFlags = coreglib.Type(C.gst_tracer_value_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTracerValueFlags, F: marshalTracerValueFlags},
	})
}

// TracerValueFlags: flag that describe the value. These flags help applications
// processing the logs to understand the values.
type TracerValueFlags C.guint

const (
	// TracerValueFlagsNone: no flags.
	TracerValueFlagsNone TracerValueFlags = 0b0
	// TracerValueFlagsOptional: value is optional. When using this flag one
	// need to have an additional boolean arg before this value in the var-args
	// list passed to gst_tracer_record_log().
	TracerValueFlagsOptional TracerValueFlags = 0b1
	// TracerValueFlagsAggregated: value is a combined figure, since the start
	// of tracing. Examples are averages or timestamps.
	TracerValueFlagsAggregated TracerValueFlags = 0b10
)

func marshalTracerValueFlags(p uintptr) (interface{}, error) {
	return TracerValueFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TracerValueFlags.
func (t TracerValueFlags) String() string {
	if t == 0 {
		return "TracerValueFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(72)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TracerValueFlagsNone:
			builder.WriteString("None|")
		case TracerValueFlagsOptional:
			builder.WriteString("Optional|")
		case TracerValueFlagsAggregated:
			builder.WriteString("Aggregated|")
		default:
			builder.WriteString(fmt.Sprintf("TracerValueFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TracerValueFlags) Has(other TracerValueFlags) bool {
	return (t & other) == other
}
