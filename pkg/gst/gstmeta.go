// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeMetaFlags = coreglib.Type(C.gst_meta_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMetaFlags, F: marshalMetaFlags},
	})
}

// MetaFlags: extra metadata flags.
type MetaFlags C.guint

const (
	// MetaFlagNone: no flags.
	MetaFlagNone MetaFlags = 0b0
	// MetaFlagReadonly: metadata should not be modified.
	MetaFlagReadonly MetaFlags = 0b1
	// MetaFlagPooled: metadata is managed by a bufferpool.
	MetaFlagPooled MetaFlags = 0b10
	// MetaFlagLocked: metadata should not be removed.
	MetaFlagLocked MetaFlags = 0b100
	// MetaFlagLast: additional flags can be added starting from this flag.
	MetaFlagLast MetaFlags = 0b10000000000000000
)

func marshalMetaFlags(p uintptr) (interface{}, error) {
	return MetaFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MetaFlags.
func (m MetaFlags) String() string {
	if m == 0 {
		return "MetaFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(72)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MetaFlagNone:
			builder.WriteString("None|")
		case MetaFlagReadonly:
			builder.WriteString("Readonly|")
		case MetaFlagPooled:
			builder.WriteString("Pooled|")
		case MetaFlagLocked:
			builder.WriteString("Locked|")
		case MetaFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("MetaFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MetaFlags) Has(other MetaFlags) bool {
	return (m & other) == other
}

// Meta structure should be included as the first member of a Buffer metadata
// structure. The structure defines the API of the metadata and should be
// accessible to all elements using the metadata.
//
// A metadata API is registered with gst_meta_api_type_register() which takes a
// name for the metadata API and some tags associated with the metadata. With
// gst_meta_api_type_has_tag() one can check if a certain metadata API contains
// a given tag.
//
// Multiple implementations of a metadata API can be registered. To implement a
// metadata API, gst_meta_register() should be used. This function takes all
// parameters needed to create, free and transform metadata along with the size
// of the metadata. The function returns a MetaInfo structure that contains the
// information for the implementation of the API.
//
// A specific implementation can be retrieved by name with gst_meta_get_info().
//
// See Buffer for how the metadata can be added, retrieved and removed from
// buffers.
//
// An instance of this type is always passed by reference.
type Meta struct {
	*meta
}

// meta is the struct that's finalized.
type meta struct {
	native *C.GstMeta
}

// Flags: extra flags for the metadata.
func (m *Meta) Flags() MetaFlags {
	valptr := &m.native.flags
	var _v MetaFlags // out
	_v = MetaFlags(*valptr)
	return _v
}

// Info: pointer to the MetaInfo.
func (m *Meta) Info() *MetaInfo {
	valptr := &m.native.info
	var _v *MetaInfo // out
	_v = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// CompareSeqnum: meta sequence number compare function. Can be used as Func or
// a DataFunc.
//
// The function takes the following parameters:
//
//    - meta2: Meta.
//
// The function returns the following values:
//
//    - gint: negative number if meta1 comes before meta2, 0 if both metas have
//      an equal sequence number, or a positive integer if meta1 comes after
//      meta2.
//
func (meta1 *Meta) CompareSeqnum(meta2 *Meta) int {
	var _arg0 *C.GstMeta // out
	var _arg1 *C.GstMeta // out
	var _cret C.gint     // in

	_arg0 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta1)))
	_arg1 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta2)))

	_cret = C.gst_meta_compare_seqnum(_arg0, _arg1)
	runtime.KeepAlive(meta1)
	runtime.KeepAlive(meta2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Seqnum gets seqnum for this meta.
//
// The function returns the following values:
//
func (meta *Meta) Seqnum() uint64 {
	var _arg0 *C.GstMeta // out
	var _cret C.guint64  // in

	_arg0 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_meta_get_seqnum(_arg0)
	runtime.KeepAlive(meta)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MetaApiTypeHasTag: check if api was registered with tag.
//
// The function takes the following parameters:
//
//    - api: API.
//    - tag to check.
//
// The function returns the following values:
//
//    - ok: TRUE if api was registered with tag.
//
func MetaApiTypeHasTag(api coreglib.Type, tag glib.Quark) bool {
	var _arg1 C.GType    // out
	var _arg2 C.GQuark   // out
	var _cret C.gboolean // in

	_arg1 = C.GType(api)
	_arg2 = C.guint32(tag)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_meta_api_type_has_tag(_arg1, _arg2)
	runtime.KeepAlive(api)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MetaApiTypeRegister: register and return a GType for the api and associate it
// with tags.
//
// The function takes the following parameters:
//
//    - api: API to register.
//    - tags for api.
//
// The function returns the following values:
//
//    - gType: unique GType for api.
//
func MetaApiTypeRegister(api string, tags []string) coreglib.Type {
	var _arg1 *C.gchar  // out
	var _arg2 **C.gchar // out
	var _cret C.GType   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(api)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(tags) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(tags)+1)
			var zero *C.gchar
			out[len(tags)] = zero
			for i := range tags {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(tags[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_meta_api_type_register(_arg1, _arg2)
	runtime.KeepAlive(api)
	runtime.KeepAlive(tags)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// MetaGetInfo: lookup a previously registered meta info structure by its
// implementation name impl.
//
// The function takes the following parameters:
//
//    - impl: name.
//
// The function returns the following values:
//
//    - metaInfo (optional) with impl, or NULL when no such metainfo exists.
//
func MetaGetInfo(impl string) *MetaInfo {
	var _arg1 *C.gchar       // out
	var _cret *C.GstMetaInfo // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(impl)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_meta_get_info(_arg1)
	runtime.KeepAlive(impl)

	var _metaInfo *MetaInfo // out

	if _cret != nil {
		_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _metaInfo
}

// MetaInfo provides information about a specific metadata structure.
//
// An instance of this type is always passed by reference.
type MetaInfo struct {
	*metaInfo
}

// metaInfo is the struct that's finalized.
type metaInfo struct {
	native *C.GstMetaInfo
}

// The function returns the following values:
//
//    - ok: whether info was registered as a CustomMeta with
//      gst_meta_register_custom().
//
func (info *MetaInfo) IsCustom() bool {
	var _arg0 *C.GstMetaInfo // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstMetaInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_meta_info_is_custom(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MetaTransformCopy: extra data passed to a "gst-copy" transform
// MetaTransformFunction.
//
// An instance of this type is always passed by reference.
type MetaTransformCopy struct {
	*metaTransformCopy
}

// metaTransformCopy is the struct that's finalized.
type metaTransformCopy struct {
	native *C.GstMetaTransformCopy
}

// NewMetaTransformCopy creates a new MetaTransformCopy instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewMetaTransformCopy(region bool, offset, size uint) MetaTransformCopy {
	var f0 C.gboolean // out
	if region {
		f0 = C.TRUE
	}
	var f1 C.gsize // out
	f1 = C.gsize(offset)
	var f2 C.gsize // out
	f2 = C.gsize(size)

	v := C.GstMetaTransformCopy{
		region: f0,
		offset: f1,
		size:   f2,
	}

	return *(*MetaTransformCopy)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Region: TRUE if only region is copied.
func (m *MetaTransformCopy) Region() bool {
	valptr := &m.native.region
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Offset: offset to copy, 0 if region is FALSE, otherwise > 0.
func (m *MetaTransformCopy) Offset() uint {
	valptr := &m.native.offset
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Size: size to copy, -1 or the buffer size when region is FALSE.
func (m *MetaTransformCopy) Size() uint {
	valptr := &m.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Region: TRUE if only region is copied.
func (m *MetaTransformCopy) SetRegion(region bool) {
	valptr := &m.native.region
	if region {
		*valptr = C.TRUE
	}
}

// Offset: offset to copy, 0 if region is FALSE, otherwise > 0.
func (m *MetaTransformCopy) SetOffset(offset uint) {
	valptr := &m.native.offset
	*valptr = C.gsize(offset)
}

// Size: size to copy, -1 or the buffer size when region is FALSE.
func (m *MetaTransformCopy) SetSize(size uint) {
	valptr := &m.native.size
	*valptr = C.gsize(size)
}
