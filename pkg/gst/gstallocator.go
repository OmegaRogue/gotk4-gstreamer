// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern GstMemory* _gotk4_gst1_AllocatorClass_alloc(GstAllocator*, gsize, GstAllocationParams*);
// GstMemory* _gotk4_gst1_Allocator_virtual_alloc(void* fnptr, GstAllocator* arg0, gsize arg1, GstAllocationParams* arg2) {
//   return ((GstMemory* (*)(GstAllocator*, gsize, GstAllocationParams*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeAllocatorFlags   = coreglib.Type(C.gst_allocator_flags_get_type())
	GTypeAllocator        = coreglib.Type(C.gst_allocator_get_type())
	GTypeAllocationParams = coreglib.Type(C.gst_allocation_params_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAllocatorFlags, F: marshalAllocatorFlags},
		coreglib.TypeMarshaler{T: GTypeAllocator, F: marshalAllocator},
		coreglib.TypeMarshaler{T: GTypeAllocationParams, F: marshalAllocationParams},
	})
}

// ALLOCATOR_SYSMEM: allocator name for the default system memory allocator.
const ALLOCATOR_SYSMEM = "SystemMemory"

// AllocatorFlags flags for allocators.
type AllocatorFlags C.guint

const (
	// AllocatorFlagCustomAlloc: allocator has a custom alloc function.
	AllocatorFlagCustomAlloc AllocatorFlags = 0b10000
	// AllocatorFlagLast: first flag that can be used for custom purposes.
	AllocatorFlagLast AllocatorFlags = 0b100000000000000000000
)

func marshalAllocatorFlags(p uintptr) (interface{}, error) {
	return AllocatorFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AllocatorFlags.
func (a AllocatorFlags) String() string {
	if a == 0 {
		return "AllocatorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(42)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AllocatorFlagCustomAlloc:
			builder.WriteString("CustomAlloc|")
		case AllocatorFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("AllocatorFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AllocatorFlags) Has(other AllocatorFlags) bool {
	return (a & other) == other
}

// AllocatorOverrides contains methods that are overridable.
type AllocatorOverrides struct {
	// Alloc: use allocator to allocate a new memory block with memory that is
	// at least size big.
	//
	// The optional params can specify the prefix and padding for the memory. If
	// NULL is passed, no flags, no extra prefix/padding and a default alignment
	// is used.
	//
	// The prefix/padding will be filled with 0 if flags contains
	// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED respectively.
	//
	// When allocator is NULL, the default allocator will be used.
	//
	// The alignment in params is given as a bitmask so that align + 1 equals
	// the amount of bytes to align to. For example, to align to 8 bytes, use an
	// alignment of 7.
	//
	// The function takes the following parameters:
	//
	//    - size of the visible memory area.
	//    - params (optional): optional parameters.
	//
	// The function returns the following values:
	//
	//    - memory (optional): new Memory.
	//
	Alloc func(size uint, params *AllocationParams) *Memory
}

func defaultAllocatorOverrides(v *Allocator) AllocatorOverrides {
	return AllocatorOverrides{
		Alloc: v.alloc,
	}
}

// Allocator: memory is usually created by allocators with a
// gst_allocator_alloc() method call. When NULL is used as the allocator, the
// default allocator will be used.
//
// New allocators can be registered with gst_allocator_register(). Allocators
// are identified by name and can be retrieved with gst_allocator_find().
// gst_allocator_set_default() can be used to change the default allocator.
//
// New memory can be created with gst_memory_new_wrapped() that wraps the memory
// allocated elsewhere.
type Allocator struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Allocator)(nil)
)

// Allocatorrer describes types inherited from class Allocator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Allocatorrer interface {
	coreglib.Objector
	baseAllocator() *Allocator
}

var _ Allocatorrer = (*Allocator)(nil)

func init() {
	coreglib.RegisterClassInfo[*Allocator, *AllocatorClass, AllocatorOverrides](
		GTypeAllocator,
		initAllocatorClass,
		wrapAllocator,
		defaultAllocatorOverrides,
	)
}

func initAllocatorClass(gclass unsafe.Pointer, overrides AllocatorOverrides, classInitFunc func(*AllocatorClass)) {
	pclass := (*C.GstAllocatorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAllocator))))

	if overrides.Alloc != nil {
		pclass.alloc = (*[0]byte)(C._gotk4_gst1_AllocatorClass_alloc)
	}

	if classInitFunc != nil {
		class := (*AllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAllocator(obj *coreglib.Object) *Allocator {
	return &Allocator{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalAllocator(p uintptr) (interface{}, error) {
	return wrapAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (allocator *Allocator) baseAllocator() *Allocator {
	return allocator
}

// BaseAllocator returns the underlying base object.
func BaseAllocator(obj Allocatorrer) *Allocator {
	return obj.baseAllocator()
}

// Alloc: use allocator to allocate a new memory block with memory that is at
// least size big.
//
// The optional params can specify the prefix and padding for the memory. If
// NULL is passed, no flags, no extra prefix/padding and a default alignment is
// used.
//
// The prefix/padding will be filled with 0 if flags contains
// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED respectively.
//
// When allocator is NULL, the default allocator will be used.
//
// The alignment in params is given as a bitmask so that align + 1 equals the
// amount of bytes to align to. For example, to align to 8 bytes, use an
// alignment of 7.
//
// The function takes the following parameters:
//
//    - size of the visible memory area.
//    - params (optional): optional parameters.
//
// The function returns the following values:
//
//    - memory (optional): new Memory.
//
func (allocator *Allocator) Alloc(size uint, params *AllocationParams) *Memory {
	var _arg0 *C.GstAllocator        // out
	var _arg1 C.gsize                // out
	var _arg2 *C.GstAllocationParams // out
	var _cret *C.GstMemory           // in

	if allocator != nil {
		_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	_arg1 = C.gsize(size)
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_allocator_alloc(_arg0, _arg1, _arg2)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(size)
	runtime.KeepAlive(params)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// SetDefault: set the default allocator.
func (allocator *Allocator) SetDefault() {
	var _arg0 *C.GstAllocator // out

	_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(allocator).Native()))

	C.gst_allocator_set_default(_arg0)
	runtime.KeepAlive(allocator)
}

// Alloc: use allocator to allocate a new memory block with memory that is at
// least size big.
//
// The optional params can specify the prefix and padding for the memory. If
// NULL is passed, no flags, no extra prefix/padding and a default alignment is
// used.
//
// The prefix/padding will be filled with 0 if flags contains
// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED respectively.
//
// When allocator is NULL, the default allocator will be used.
//
// The alignment in params is given as a bitmask so that align + 1 equals the
// amount of bytes to align to. For example, to align to 8 bytes, use an
// alignment of 7.
//
// The function takes the following parameters:
//
//    - size of the visible memory area.
//    - params (optional): optional parameters.
//
// The function returns the following values:
//
//    - memory (optional): new Memory.
//
func (allocator *Allocator) alloc(size uint, params *AllocationParams) *Memory {
	gclass := (*C.GstAllocatorClass)(coreglib.PeekParentClass(allocator))
	fnarg := gclass.alloc

	var _arg0 *C.GstAllocator        // out
	var _arg1 C.gsize                // out
	var _arg2 *C.GstAllocationParams // out
	var _cret *C.GstMemory           // in

	if allocator != nil {
		_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	_arg1 = C.gsize(size)
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C._gotk4_gst1_Allocator_virtual_alloc(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(size)
	runtime.KeepAlive(params)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// AllocatorFind: find a previously registered allocator with name. When name is
// NULL, the default allocator will be returned.
//
// The function takes the following parameters:
//
//    - name (optional) of the allocator.
//
// The function returns the following values:
//
//    - allocator (optional) or NULL when the allocator with name was not
//      registered.
//
func AllocatorFind(name string) Allocatorrer {
	var _arg1 *C.gchar        // out
	var _cret *C.GstAllocator // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_allocator_find(_arg1)
	runtime.KeepAlive(name)

	var _allocator Allocatorrer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Allocatorrer)
				return ok
			})
			rv, ok := casted.(Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}

	return _allocator
}

// AllocatorRegister registers the memory allocator with name.
//
// The function takes the following parameters:
//
//    - name of the allocator.
//    - allocator: Allocator.
//
func AllocatorRegister(name string, allocator Allocatorrer) {
	var _arg1 *C.gchar        // out
	var _arg2 *C.GstAllocator // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(allocator).Native()))

	C.gst_allocator_register(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(allocator)
}

// AllocationParams parameters to control the allocation of memory
//
// An instance of this type is always passed by reference.
type AllocationParams struct {
	*allocationParams
}

// allocationParams is the struct that's finalized.
type allocationParams struct {
	native *C.GstAllocationParams
}

func marshalAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AllocationParams{&allocationParams{(*C.GstAllocationParams)(b)}}, nil
}

// NewAllocationParams constructs a struct AllocationParams.
func NewAllocationParams() *AllocationParams {
	var _cret *C.GstAllocationParams // in

	_cret = C.gst_allocation_params_new()

	var _allocationParams *AllocationParams // out

	_allocationParams = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_allocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocationParams
}

// Flags flags to control allocation.
func (a *AllocationParams) Flags() MemoryFlags {
	valptr := &a.native.flags
	var _v MemoryFlags // out
	_v = MemoryFlags(*valptr)
	return _v
}

// Align: desired alignment of the memory.
func (a *AllocationParams) Align() uint {
	valptr := &a.native.align
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Prefix: desired prefix.
func (a *AllocationParams) Prefix() uint {
	valptr := &a.native.prefix
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Padding: desired padding.
func (a *AllocationParams) Padding() uint {
	valptr := &a.native.padding
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Align: desired alignment of the memory.
func (a *AllocationParams) SetAlign(align uint) {
	valptr := &a.native.align
	*valptr = C.gsize(align)
}

// Prefix: desired prefix.
func (a *AllocationParams) SetPrefix(prefix uint) {
	valptr := &a.native.prefix
	*valptr = C.gsize(prefix)
}

// Padding: desired padding.
func (a *AllocationParams) SetPadding(padding uint) {
	valptr := &a.native.padding
	*valptr = C.gsize(padding)
}

// Copy: create a copy of params.
//
// The function returns the following values:
//
//    - allocationParams (optional): new AllocationParams.
//
func (params *AllocationParams) Copy() *AllocationParams {
	var _arg0 *C.GstAllocationParams // out
	var _cret *C.GstAllocationParams // in

	if params != nil {
		_arg0 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_allocation_params_copy(_arg0)
	runtime.KeepAlive(params)

	var _allocationParams *AllocationParams // out

	if _cret != nil {
		_allocationParams = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_allocationParams)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
			},
		)
	}

	return _allocationParams
}

// Init: initialize params to its default values.
func (params *AllocationParams) Init() {
	var _arg0 *C.GstAllocationParams // out

	_arg0 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	C.gst_allocation_params_init(_arg0)
	runtime.KeepAlive(params)
}

// AllocatorClass is used to create new memory.
//
// An instance of this type is always passed by reference.
type AllocatorClass struct {
	*allocatorClass
}

// allocatorClass is the struct that's finalized.
type allocatorClass struct {
	native *C.GstAllocatorClass
}

// ObjectClass: object parent class.
func (a *AllocatorClass) ObjectClass() *ObjectClass {
	valptr := &a.native.object_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
