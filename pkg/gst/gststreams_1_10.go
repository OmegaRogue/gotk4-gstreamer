// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeStreamType = coreglib.Type(C.gst_stream_type_get_type())
	GTypeStream     = coreglib.Type(C.gst_stream_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStreamType, F: marshalStreamType},
		coreglib.TypeMarshaler{T: GTypeStream, F: marshalStream},
	})
}

// StreamType describes a high level classification set for flows of data in
// Stream objects.
//
// Note that this is a flag, and therefore users should not assume it will be a
// single value. Do not use the equality operator for checking whether a stream
// is of a certain type.
type StreamType C.guint

const (
	// StreamTypeUnknown: stream is of unknown (unclassified) type.
	StreamTypeUnknown StreamType = 0b1
	// StreamTypeAudio: stream is of audio data.
	StreamTypeAudio StreamType = 0b10
	// StreamTypeVideo: stream carries video data.
	StreamTypeVideo StreamType = 0b100
	// StreamTypeContainer: stream is a muxed container type.
	StreamTypeContainer StreamType = 0b1000
	// StreamTypeText: stream contains subtitle / subpicture data.
	StreamTypeText StreamType = 0b10000
)

func marshalStreamType(p uintptr) (interface{}, error) {
	return StreamType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StreamType.
func (s StreamType) String() string {
	if s == 0 {
		return "StreamType(0)"
	}

	var builder strings.Builder
	builder.Grow(84)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StreamTypeUnknown:
			builder.WriteString("Unknown|")
		case StreamTypeAudio:
			builder.WriteString("Audio|")
		case StreamTypeVideo:
			builder.WriteString("Video|")
		case StreamTypeContainer:
			builder.WriteString("Container|")
		case StreamTypeText:
			builder.WriteString("Text|")
		default:
			builder.WriteString(fmt.Sprintf("StreamType(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StreamType) Has(other StreamType) bool {
	return (s & other) == other
}

// StreamTypeGetName: get a descriptive string for a given StreamType.
//
// The function takes the following parameters:
//
//    - stype: StreamType.
//
// The function returns the following values:
//
//    - utf8: string describing the stream type.
//
func StreamTypeGetName(stype StreamType) string {
	var _arg1 C.GstStreamType // out
	var _cret *C.gchar        // in

	_arg1 = C.GstStreamType(stype)

	_cret = C.gst_stream_type_get_name(_arg1)
	runtime.KeepAlive(stype)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// StreamOverrides contains methods that are overridable.
type StreamOverrides struct {
}

func defaultStreamOverrides(v *Stream) StreamOverrides {
	return StreamOverrides{}
}

// Stream: high-level object representing a single stream. It might be backed,
// or not, by an actual flow of data in a pipeline (Pad).
//
// A Stream does not care about data changes (such as decoding, encoding,
// parsing,...) as long as the underlying data flow corresponds to the same
// high-level flow (ex: a certain audio track).
//
// A Stream contains all the information pertinent to a stream, such as
// stream-id, tags, caps, type, ...
//
// Elements can subclass a Stream for internal usage (to contain information
// pertinent to streams of data).
type Stream struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Stream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Stream, *StreamClass, StreamOverrides](
		GTypeStream,
		initStreamClass,
		wrapStream,
		defaultStreamOverrides,
	)
}

func initStreamClass(gclass unsafe.Pointer, overrides StreamOverrides, classInitFunc func(*StreamClass)) {
	if classInitFunc != nil {
		class := (*StreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStream(obj *coreglib.Object) *Stream {
	return &Stream{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalStream(p uintptr) (interface{}, error) {
	return wrapStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStream: create a new Stream for the given stream_id, caps, type and flags.
//
// The function takes the following parameters:
//
//    - streamId (optional): id for the new stream. If NULL, a new one will be
//      automatically generated.
//    - caps (optional) of the stream.
//    - typ of the stream.
//    - flags of the stream.
//
// The function returns the following values:
//
//    - stream: new Stream.
//
func NewStream(streamId string, caps *Caps, typ StreamType, flags StreamFlags) *Stream {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GstCaps       // out
	var _arg3 C.GstStreamType  // out
	var _arg4 C.GstStreamFlags // out
	var _cret *C.GstStream     // in

	if streamId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg3 = C.GstStreamType(typ)
	_arg4 = C.GstStreamFlags(flags)

	_cret = C.gst_stream_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(streamId)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)

	var _stream *Stream // out

	_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stream
}

// Caps: retrieve the caps for stream, if any.
//
// The function returns the following values:
//
//    - caps (optional) for stream.
//
func (stream *Stream) Caps() *Caps {
	var _arg0 *C.GstStream // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_caps(_arg0)
	runtime.KeepAlive(stream)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// StreamFlags: retrieve the current stream flags for stream.
//
// The function returns the following values:
//
//    - streamFlags for stream.
//
func (stream *Stream) StreamFlags() StreamFlags {
	var _arg0 *C.GstStream     // out
	var _cret C.GstStreamFlags // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_stream_flags(_arg0)
	runtime.KeepAlive(stream)

	var _streamFlags StreamFlags // out

	_streamFlags = StreamFlags(_cret)

	return _streamFlags
}

// StreamID returns the stream ID of stream.
//
// The function returns the following values:
//
//    - utf8 (optional): stream ID of stream. Only valid during the lifetime of
//      stream.
//
func (stream *Stream) StreamID() string {
	var _arg0 *C.GstStream // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_stream_id(_arg0)
	runtime.KeepAlive(stream)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// StreamType: retrieve the stream type for stream.
//
// The function returns the following values:
//
//    - streamType for stream.
//
func (stream *Stream) StreamType() StreamType {
	var _arg0 *C.GstStream    // out
	var _cret C.GstStreamType // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_stream_type(_arg0)
	runtime.KeepAlive(stream)

	var _streamType StreamType // out

	_streamType = StreamType(_cret)

	return _streamType
}

// SetCaps: set the caps for the Stream.
//
// The function takes the following parameters:
//
//    - caps (optional): Caps.
//
func (stream *Stream) SetCaps(caps *Caps) {
	var _arg0 *C.GstStream // out
	var _arg1 *C.GstCaps   // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_stream_set_caps(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(caps)
}

// SetStreamFlags: set the flags for the stream.
//
// The function takes the following parameters:
//
//    - flags to set on stream.
//
func (stream *Stream) SetStreamFlags(flags StreamFlags) {
	var _arg0 *C.GstStream     // out
	var _arg1 C.GstStreamFlags // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GstStreamFlags(flags)

	C.gst_stream_set_stream_flags(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(flags)
}

// SetStreamType: set the stream type of stream.
//
// The function takes the following parameters:
//
//    - streamType: type to set on stream.
//
func (stream *Stream) SetStreamType(streamType StreamType) {
	var _arg0 *C.GstStream    // out
	var _arg1 C.GstStreamType // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GstStreamType(streamType)

	C.gst_stream_set_stream_type(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(streamType)
}
