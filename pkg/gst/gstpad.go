// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_TaskFunction(gpointer);
// extern void _gotk4_gst1_Pad_ConnectUnlinked(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_Pad_ConnectLinked(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_PadClass_unlinked(GstPad*, GstPad*);
// extern void _gotk4_gst1_PadClass_linked(GstPad*, GstPad*);
// extern gboolean _gotk4_gst1_PadStickyEventsForEachFunction(GstPad*, GstEvent**, gpointer);
// extern gboolean _gotk4_gst1_PadForwardFunction(GstPad*, gpointer);
// extern GstPadProbeReturn _gotk4_gst1_PadProbeCallback(GstPad*, GstPadProbeInfo*, gpointer);
// void _gotk4_gst1_Pad_virtual_linked(void* fnptr, GstPad* arg0, GstPad* arg1) {
//   ((void (*)(GstPad*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Pad_virtual_unlinked(void* fnptr, GstPad* arg0, GstPad* arg1) {
//   ((void (*)(GstPad*, GstPad*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeFlowReturn     = coreglib.Type(C.gst_flow_return_get_type())
	GTypePadDirection   = coreglib.Type(C.gst_pad_direction_get_type())
	GTypePadLinkReturn  = coreglib.Type(C.gst_pad_link_return_get_type())
	GTypePadMode        = coreglib.Type(C.gst_pad_mode_get_type())
	GTypePadProbeReturn = coreglib.Type(C.gst_pad_probe_return_get_type())
	GTypePadFlags       = coreglib.Type(C.gst_pad_flags_get_type())
	GTypePadLinkCheck   = coreglib.Type(C.gst_pad_link_check_get_type())
	GTypePadProbeType   = coreglib.Type(C.gst_pad_probe_type_get_type())
	GTypePad            = coreglib.Type(C.gst_pad_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFlowReturn, F: marshalFlowReturn},
		coreglib.TypeMarshaler{T: GTypePadDirection, F: marshalPadDirection},
		coreglib.TypeMarshaler{T: GTypePadLinkReturn, F: marshalPadLinkReturn},
		coreglib.TypeMarshaler{T: GTypePadMode, F: marshalPadMode},
		coreglib.TypeMarshaler{T: GTypePadProbeReturn, F: marshalPadProbeReturn},
		coreglib.TypeMarshaler{T: GTypePadFlags, F: marshalPadFlags},
		coreglib.TypeMarshaler{T: GTypePadLinkCheck, F: marshalPadLinkCheck},
		coreglib.TypeMarshaler{T: GTypePadProbeType, F: marshalPadProbeType},
		coreglib.TypeMarshaler{T: GTypePad, F: marshalPad},
	})
}

// FlowReturn: result of passing data to a pad.
//
// Note that the custom return values should not be exposed outside of the
// element scope.
type FlowReturn C.gint

const (
	// FlowCustomSuccess2: pre-defined custom success code.
	FlowCustomSuccess2 FlowReturn = 102
	// FlowCustomSuccess1: pre-defined custom success code (define your custom
	// success code to this to avoid compiler warnings).
	FlowCustomSuccess1 FlowReturn = 101
	// FlowCustomSuccess elements can use values starting from this (and higher)
	// to define custom success codes.
	FlowCustomSuccess FlowReturn = 100
	// FlowOK: data passing was ok.
	FlowOK FlowReturn = 0
	// FlowNotLinked: pad is not linked.
	FlowNotLinked FlowReturn = -1
	// FlowFlushing: pad is flushing.
	FlowFlushing FlowReturn = -2
	// FlowEos: pad is EOS.
	FlowEos FlowReturn = -3
	// FlowNotNegotiated: pad is not negotiated.
	FlowNotNegotiated FlowReturn = -4
	// FlowError: some (fatal) error occurred. Element generating this error
	// should post an error message using GST_ELEMENT_ERROR() with more details.
	FlowError FlowReturn = -5
	// FlowNotSupported: this operation is not supported.
	FlowNotSupported FlowReturn = -6
	// FlowCustomError elements can use values starting from this (and lower) to
	// define custom error codes.
	FlowCustomError FlowReturn = -100
	// FlowCustomError1: pre-defined custom error code (define your custom error
	// code to this to avoid compiler warnings).
	FlowCustomError1 FlowReturn = -101
	// FlowCustomError2: pre-defined custom error code.
	FlowCustomError2 FlowReturn = -102
)

func marshalFlowReturn(p uintptr) (interface{}, error) {
	return FlowReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FlowReturn.
func (f FlowReturn) String() string {
	switch f {
	case FlowCustomSuccess2:
		return "CustomSuccess2"
	case FlowCustomSuccess1:
		return "CustomSuccess1"
	case FlowCustomSuccess:
		return "CustomSuccess"
	case FlowOK:
		return "OK"
	case FlowNotLinked:
		return "NotLinked"
	case FlowFlushing:
		return "Flushing"
	case FlowEos:
		return "Eos"
	case FlowNotNegotiated:
		return "NotNegotiated"
	case FlowError:
		return "Error"
	case FlowNotSupported:
		return "NotSupported"
	case FlowCustomError:
		return "CustomError"
	case FlowCustomError1:
		return "CustomError1"
	case FlowCustomError2:
		return "CustomError2"
	default:
		return fmt.Sprintf("FlowReturn(%d)", f)
	}
}

// PadDirection: direction of a pad.
type PadDirection C.gint

const (
	// PadUnknown: direction is unknown.
	PadUnknown PadDirection = iota
	// PadSrc: pad is a source pad.
	PadSrc
	// PadSink: pad is a sink pad.
	PadSink
)

func marshalPadDirection(p uintptr) (interface{}, error) {
	return PadDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadDirection.
func (p PadDirection) String() string {
	switch p {
	case PadUnknown:
		return "Unknown"
	case PadSrc:
		return "Src"
	case PadSink:
		return "Sink"
	default:
		return fmt.Sprintf("PadDirection(%d)", p)
	}
}

// PadLinkReturn: result values from gst_pad_link and friends.
type PadLinkReturn C.gint

const (
	// PadLinkOK: link succeeded.
	PadLinkOK PadLinkReturn = 0
	// PadLinkWrongHierarchy pads have no common grandparent.
	PadLinkWrongHierarchy PadLinkReturn = -1
	// PadLinkWasLinked: pad was already linked.
	PadLinkWasLinked PadLinkReturn = -2
	// PadLinkWrongDirection pads have wrong direction.
	PadLinkWrongDirection PadLinkReturn = -3
	// PadLinkNoformat pads do not have common format.
	PadLinkNoformat PadLinkReturn = -4
	// PadLinkNosched pads cannot cooperate in scheduling.
	PadLinkNosched PadLinkReturn = -5
	// PadLinkRefused: refused for some reason.
	PadLinkRefused PadLinkReturn = -6
)

func marshalPadLinkReturn(p uintptr) (interface{}, error) {
	return PadLinkReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadLinkReturn.
func (p PadLinkReturn) String() string {
	switch p {
	case PadLinkOK:
		return "OK"
	case PadLinkWrongHierarchy:
		return "WrongHierarchy"
	case PadLinkWasLinked:
		return "WasLinked"
	case PadLinkWrongDirection:
		return "WrongDirection"
	case PadLinkNoformat:
		return "Noformat"
	case PadLinkNosched:
		return "Nosched"
	case PadLinkRefused:
		return "Refused"
	default:
		return fmt.Sprintf("PadLinkReturn(%d)", p)
	}
}

// PadMode status of a GstPad. After activating a pad, which usually happens
// when the parent element goes from READY to PAUSED, the GstPadMode defines if
// the pad operates in push or pull mode.
type PadMode C.gint

const (
	// PadModeNone: pad will not handle dataflow.
	PadModeNone PadMode = iota
	// PadModePush: pad handles dataflow in downstream push mode.
	PadModePush
	// PadModePull: pad handles dataflow in upstream pull mode.
	PadModePull
)

func marshalPadMode(p uintptr) (interface{}, error) {
	return PadMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadMode.
func (p PadMode) String() string {
	switch p {
	case PadModeNone:
		return "None"
	case PadModePush:
		return "Push"
	case PadModePull:
		return "Pull"
	default:
		return fmt.Sprintf("PadMode(%d)", p)
	}
}

// PadModeGetName: return the name of a pad mode, for use in debug messages
// mostly.
//
// The function takes the following parameters:
//
//    - mode: pad mode.
//
// The function returns the following values:
//
//    - utf8: short mnemonic for pad mode mode.
//
func PadModeGetName(mode PadMode) string {
	var _arg1 C.GstPadMode // out
	var _cret *C.gchar     // in

	_arg1 = C.GstPadMode(mode)

	_cret = C.gst_pad_mode_get_name(_arg1)
	runtime.KeepAlive(mode)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadProbeReturn: different return values for the PadProbeCallback.
type PadProbeReturn C.gint

const (
	// PadProbeDrop: drop data in data probes. For push mode this means that the
	// data item is not sent downstream. For pull mode, it means that the data
	// item is not passed upstream. In both cases, no other probes are called
	// for this item and GST_FLOW_OK or TRUE is returned to the caller.
	PadProbeDrop PadProbeReturn = iota
	// PadProbeOK: normal probe return value. This leaves the probe in place,
	// and defers decisions about dropping or passing data to other probes, if
	// any. If there are no other probes, the default behaviour for the probe
	// type applies ('block' for blocking probes, and 'pass' for non-blocking
	// probes).
	PadProbeOK
	// PadProbeRemove: remove this probe, passing the data. For blocking probes
	// this will cause data flow to unblock, unless there are also other
	// blocking probes installed.
	PadProbeRemove
	// PadProbePass pass the data item in the block probe and block on the next
	// item. Note, that if there are multiple pad probes installed and any probe
	// returns PASS, the data will be passed.
	PadProbePass
	// PadProbeHandled: data has been handled in the probe and will not be
	// forwarded further. For events and buffers this is the same behaviour as
	// GST_PAD_PROBE_DROP (except that in this case you need to unref the buffer
	// or event yourself). For queries it will also return TRUE to the caller.
	// The probe can also modify the FlowReturn value by using the
	// T_PAD_PROBE_INFO_FLOW_RETURN() accessor. Note that the resulting query
	// must contain valid entries. Since: 1.6.
	PadProbeHandled
)

func marshalPadProbeReturn(p uintptr) (interface{}, error) {
	return PadProbeReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadProbeReturn.
func (p PadProbeReturn) String() string {
	switch p {
	case PadProbeDrop:
		return "Drop"
	case PadProbeOK:
		return "OK"
	case PadProbeRemove:
		return "Remove"
	case PadProbePass:
		return "Pass"
	case PadProbeHandled:
		return "Handled"
	default:
		return fmt.Sprintf("PadProbeReturn(%d)", p)
	}
}

// PadFlags: pad state flags.
type PadFlags C.guint

const (
	// PadFlagBlocked is dataflow on a pad blocked.
	PadFlagBlocked PadFlags = 0b10000
	// PadFlagFlushing is pad flushing.
	PadFlagFlushing PadFlags = 0b100000
	// PadFlagEos is pad in EOS state.
	PadFlagEos PadFlags = 0b1000000
	// PadFlagBlocking is pad currently blocking on a buffer or event.
	PadFlagBlocking PadFlags = 0b10000000
	// PadFlagNeedParent: ensure that there is a parent object before calling
	// into the pad callbacks.
	PadFlagNeedParent PadFlags = 0b100000000
	// PadFlagNeedReconfigure: pad should be reconfigured/renegotiated. The flag
	// has to be unset manually after reconfiguration happened.
	PadFlagNeedReconfigure PadFlags = 0b1000000000
	// PadFlagPendingEvents: pad has pending events.
	PadFlagPendingEvents PadFlags = 0b10000000000
	// PadFlagFixedCaps: pad is using fixed caps. This means that once the caps
	// are set on the pad, the default caps query function will only return
	// those caps.
	PadFlagFixedCaps PadFlags = 0b100000000000
	// PadFlagProxyCaps: default event and query handler will forward all events
	// and queries to the internally linked pads instead of discarding them.
	PadFlagProxyCaps PadFlags = 0b1000000000000
	// PadFlagProxyAllocation: default query handler will forward allocation
	// queries to the internally linked pads instead of discarding them.
	PadFlagProxyAllocation PadFlags = 0b10000000000000
	// PadFlagProxyScheduling: default query handler will forward scheduling
	// queries to the internally linked pads instead of discarding them.
	PadFlagProxyScheduling PadFlags = 0b100000000000000
	// PadFlagAcceptIntersect: default accept-caps handler will check it the
	// caps intersect the query-caps result instead of checking for a subset.
	// This is interesting for parsers that can accept incompletely specified
	// caps.
	PadFlagAcceptIntersect PadFlags = 0b1000000000000000
	// PadFlagAcceptTemplate: default accept-caps handler will use the template
	// pad caps instead of query caps to compare with the accept caps. Use this
	// in combination with GST_PAD_FLAG_ACCEPT_INTERSECT. (Since: 1.6).
	PadFlagAcceptTemplate PadFlags = 0b10000000000000000
	// PadFlagLast: offset to define more flags.
	PadFlagLast PadFlags = 0b100000000000000000000
)

func marshalPadFlags(p uintptr) (interface{}, error) {
	return PadFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadFlags.
func (p PadFlags) String() string {
	if p == 0 {
		return "PadFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadFlagBlocked:
			builder.WriteString("Blocked|")
		case PadFlagFlushing:
			builder.WriteString("Flushing|")
		case PadFlagEos:
			builder.WriteString("Eos|")
		case PadFlagBlocking:
			builder.WriteString("Blocking|")
		case PadFlagNeedParent:
			builder.WriteString("NeedParent|")
		case PadFlagNeedReconfigure:
			builder.WriteString("NeedReconfigure|")
		case PadFlagPendingEvents:
			builder.WriteString("PendingEvents|")
		case PadFlagFixedCaps:
			builder.WriteString("FixedCaps|")
		case PadFlagProxyCaps:
			builder.WriteString("ProxyCaps|")
		case PadFlagProxyAllocation:
			builder.WriteString("ProxyAllocation|")
		case PadFlagProxyScheduling:
			builder.WriteString("ProxyScheduling|")
		case PadFlagAcceptIntersect:
			builder.WriteString("AcceptIntersect|")
		case PadFlagAcceptTemplate:
			builder.WriteString("AcceptTemplate|")
		case PadFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("PadFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadFlags) Has(other PadFlags) bool {
	return (p & other) == other
}

// PadLinkCheck: amount of checking to be done when linking pads.
// GST_PAD_LINK_CHECK_CAPS and GST_PAD_LINK_CHECK_TEMPLATE_CAPS are mutually
// exclusive. If both are specified, expensive but safe GST_PAD_LINK_CHECK_CAPS
// are performed.
//
// > Only disable some of the checks if you are 100% certain you know the link >
// will not fail because of hierarchy/caps compatibility failures. If uncertain,
// > use the default checks (GST_PAD_LINK_CHECK_DEFAULT) or the regular methods
// > for linking the pads.
type PadLinkCheck C.guint

const (
	// PadLinkCheckNothing: don't check hierarchy or caps compatibility.
	PadLinkCheckNothing PadLinkCheck = 0b0
	// PadLinkCheckHierarchy: check the pads have same parents/grandparents.
	// Could be omitted if it is already known that the two elements that own
	// the pads are in the same bin.
	PadLinkCheckHierarchy PadLinkCheck = 0b1
	// PadLinkCheckTemplateCaps: check if the pads are compatible by using their
	// template caps. This is much faster than GST_PAD_LINK_CHECK_CAPS, but
	// would be unsafe e.g. if one pad has GST_CAPS_ANY.
	PadLinkCheckTemplateCaps PadLinkCheck = 0b10
	// PadLinkCheckCaps: check if the pads are compatible by comparing the caps
	// returned by gst_pad_query_caps().
	PadLinkCheckCaps PadLinkCheck = 0b100
	// PadLinkCheckNoReconfigure disables pushing a reconfigure event when pads
	// are linked.
	PadLinkCheckNoReconfigure PadLinkCheck = 0b1000
	// PadLinkCheckDefault: default checks done when linking pads (i.e. the ones
	// used by gst_pad_link()).
	PadLinkCheckDefault PadLinkCheck = 0b101
)

func marshalPadLinkCheck(p uintptr) (interface{}, error) {
	return PadLinkCheck(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadLinkCheck.
func (p PadLinkCheck) String() string {
	if p == 0 {
		return "PadLinkCheck(0)"
	}

	var builder strings.Builder
	builder.Grow(129)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadLinkCheckNothing:
			builder.WriteString("Nothing|")
		case PadLinkCheckHierarchy:
			builder.WriteString("Hierarchy|")
		case PadLinkCheckTemplateCaps:
			builder.WriteString("TemplateCaps|")
		case PadLinkCheckCaps:
			builder.WriteString("Caps|")
		case PadLinkCheckNoReconfigure:
			builder.WriteString("NoReconfigure|")
		case PadLinkCheckDefault:
			builder.WriteString("Default|")
		default:
			builder.WriteString(fmt.Sprintf("PadLinkCheck(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadLinkCheck) Has(other PadLinkCheck) bool {
	return (p & other) == other
}

// PadProbeType: different probing types that can occur. When either one of
// GST_PAD_PROBE_TYPE_IDLE or GST_PAD_PROBE_TYPE_BLOCK is used, the probe will
// be a blocking probe.
type PadProbeType C.guint

const (
	// PadProbeTypeInvalid: invalid probe type.
	PadProbeTypeInvalid PadProbeType = 0b0
	// PadProbeTypeIdle: probe idle pads and block while the callback is called.
	PadProbeTypeIdle PadProbeType = 0b1
	// PadProbeTypeBlock: probe and block pads.
	PadProbeTypeBlock PadProbeType = 0b10
	// PadProbeTypeBuffer: probe buffers.
	PadProbeTypeBuffer PadProbeType = 0b10000
	// PadProbeTypeBufferList: probe buffer lists.
	PadProbeTypeBufferList PadProbeType = 0b100000
	// PadProbeTypeEventDownstream: probe downstream events.
	PadProbeTypeEventDownstream PadProbeType = 0b1000000
	// PadProbeTypeEventUpstream: probe upstream events.
	PadProbeTypeEventUpstream PadProbeType = 0b10000000
	// PadProbeTypeEventFlush: probe flush events. This probe has to be
	// explicitly enabled and is not included in the
	// @GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM or
	// @GST_PAD_PROBE_TYPE_EVENT_UPSTREAM probe types.
	PadProbeTypeEventFlush PadProbeType = 0b100000000
	// PadProbeTypeQueryDownstream: probe downstream queries.
	PadProbeTypeQueryDownstream PadProbeType = 0b1000000000
	// PadProbeTypeQueryUpstream: probe upstream queries.
	PadProbeTypeQueryUpstream PadProbeType = 0b10000000000
	// PadProbeTypePush: probe push.
	PadProbeTypePush PadProbeType = 0b1000000000000
	// PadProbeTypePull: probe pull.
	PadProbeTypePull PadProbeType = 0b10000000000000
	// PadProbeTypeBlocking: probe and block at the next opportunity, at data
	// flow or when idle.
	PadProbeTypeBlocking PadProbeType = 0b11
	// PadProbeTypeDataDownstream: probe downstream data (buffers, buffer lists,
	// and events).
	PadProbeTypeDataDownstream PadProbeType = 0b1110000
	// PadProbeTypeDataUpstream: probe upstream data (events).
	PadProbeTypeDataUpstream PadProbeType = 0b10000000
	// PadProbeTypeDataBoth: probe upstream and downstream data (buffers, buffer
	// lists, and events).
	PadProbeTypeDataBoth PadProbeType = 0b11110000
	// PadProbeTypeBlockDownstream: probe and block downstream data (buffers,
	// buffer lists, and events).
	PadProbeTypeBlockDownstream PadProbeType = 0b1110010
	// PadProbeTypeBlockUpstream: probe and block upstream data (events).
	PadProbeTypeBlockUpstream PadProbeType = 0b10000010
	// PadProbeTypeEventBoth: probe upstream and downstream events.
	PadProbeTypeEventBoth PadProbeType = 0b11000000
	// PadProbeTypeQueryBoth: probe upstream and downstream queries.
	PadProbeTypeQueryBoth PadProbeType = 0b11000000000
	// PadProbeTypeAllBoth: probe upstream events and queries and downstream
	// buffers, buffer lists, events and queries.
	PadProbeTypeAllBoth PadProbeType = 0b11011110000
	// PadProbeTypeScheduling: probe push and pull.
	PadProbeTypeScheduling PadProbeType = 0b11000000000000
)

func marshalPadProbeType(p uintptr) (interface{}, error) {
	return PadProbeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadProbeType.
func (p PadProbeType) String() string {
	if p == 0 {
		return "PadProbeType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadProbeTypeInvalid:
			builder.WriteString("Invalid|")
		case PadProbeTypeIdle:
			builder.WriteString("Idle|")
		case PadProbeTypeBlock:
			builder.WriteString("Block|")
		case PadProbeTypeBuffer:
			builder.WriteString("Buffer|")
		case PadProbeTypeBufferList:
			builder.WriteString("BufferList|")
		case PadProbeTypeEventDownstream:
			builder.WriteString("EventDownstream|")
		case PadProbeTypeEventUpstream:
			builder.WriteString("EventUpstream|")
		case PadProbeTypeEventFlush:
			builder.WriteString("EventFlush|")
		case PadProbeTypeQueryDownstream:
			builder.WriteString("QueryDownstream|")
		case PadProbeTypeQueryUpstream:
			builder.WriteString("QueryUpstream|")
		case PadProbeTypePush:
			builder.WriteString("Push|")
		case PadProbeTypePull:
			builder.WriteString("Pull|")
		case PadProbeTypeBlocking:
			builder.WriteString("Blocking|")
		case PadProbeTypeDataDownstream:
			builder.WriteString("DataDownstream|")
		case PadProbeTypeDataBoth:
			builder.WriteString("DataBoth|")
		case PadProbeTypeBlockDownstream:
			builder.WriteString("BlockDownstream|")
		case PadProbeTypeBlockUpstream:
			builder.WriteString("BlockUpstream|")
		case PadProbeTypeEventBoth:
			builder.WriteString("EventBoth|")
		case PadProbeTypeQueryBoth:
			builder.WriteString("QueryBoth|")
		case PadProbeTypeAllBoth:
			builder.WriteString("AllBoth|")
		case PadProbeTypeScheduling:
			builder.WriteString("Scheduling|")
		default:
			builder.WriteString(fmt.Sprintf("PadProbeType(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadProbeType) Has(other PadProbeType) bool {
	return (p & other) == other
}

// PadForwardFunction: forward function is called for all internally linked
// pads, see gst_pad_forward().
type PadForwardFunction func(pad *Pad) (ok bool)

// PadProbeCallback: callback used by gst_pad_add_probe(). Gets called to notify
// about the current blocking type.
//
// The callback is allowed to modify the data pointer in info.
type PadProbeCallback func(pad *Pad, info *PadProbeInfo) (padProbeReturn PadProbeReturn)

// PadStickyEventsForEachFunction: callback used by
// gst_pad_sticky_events_foreach().
//
// When this function returns TRUE, the next event will be returned. When FALSE
// is returned, gst_pad_sticky_events_foreach() will return.
//
// When event is set to NULL, the item will be removed from the list of sticky
// events. event can be replaced by assigning a new reference to it. This
// function is responsible for unreffing the old event when removing or
// modifying.
type PadStickyEventsForEachFunction func(pad *Pad, event *Event) (ok bool)

// FlowGetName gets a string representing the given flow return.
//
// The function takes the following parameters:
//
//    - ret to get the name of.
//
// The function returns the following values:
//
//    - utf8: static string with the name of the flow return.
//
func FlowGetName(ret FlowReturn) string {
	var _arg1 C.GstFlowReturn // out
	var _cret *C.gchar        // in

	_arg1 = C.GstFlowReturn(ret)

	_cret = C.gst_flow_get_name(_arg1)
	runtime.KeepAlive(ret)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// FlowToQuark: get the unique quark for the given GstFlowReturn.
//
// The function takes the following parameters:
//
//    - ret to get the quark of.
//
// The function returns the following values:
//
//    - quark associated with the flow return or 0 if an invalid return was
//      specified.
//
func FlowToQuark(ret FlowReturn) glib.Quark {
	var _arg1 C.GstFlowReturn // out
	var _cret C.GQuark        // in

	_arg1 = C.GstFlowReturn(ret)

	_cret = C.gst_flow_to_quark(_arg1)
	runtime.KeepAlive(ret)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// PadOverrides contains methods that are overridable.
type PadOverrides struct {
	// The function takes the following parameters:
	//
	Linked func(peer *Pad)
	// The function takes the following parameters:
	//
	Unlinked func(peer *Pad)
}

func defaultPadOverrides(v *Pad) PadOverrides {
	return PadOverrides{
		Linked:   v.linked,
		Unlinked: v.unlinked,
	}
}

// Pad is linked to other elements via "pads", which are extremely light-weight
// generic link points.
//
// Pads have a PadDirection, source pads produce data, sink pads consume data.
//
// Pads are typically created from a PadTemplate with
// gst_pad_new_from_template() and are then added to a Element. This usually
// happens when the element is created but it can also happen dynamically based
// on the data that the element is processing or based on the pads that the
// application requests.
//
// Pads without pad templates can be created with gst_pad_new(), which takes a
// direction and a name as an argument. If the name is NULL, then a guaranteed
// unique name will be assigned to it.
//
// A Element creating a pad will typically use the various
// gst_pad_set_*_function\() calls to register callbacks for events, queries or
// dataflow on the pads.
//
// gst_pad_get_parent() will retrieve the Element that owns the pad.
//
// After two pads are retrieved from an element by gst_element_get_static_pad(),
// the pads can be linked with gst_pad_link(). (For quick links, you can also
// use gst_element_link(), which will make the obvious link for you if it's
// straightforward.). Pads can be unlinked again with gst_pad_unlink().
// gst_pad_get_peer() can be used to check what the pad is linked to.
//
// Before dataflow is possible on the pads, they need to be activated with
// gst_pad_set_active().
//
// gst_pad_query() and gst_pad_peer_query() can be used to query various
// properties of the pad and the stream.
//
// To send a Event on a pad, use gst_pad_send_event() and gst_pad_push_event().
// Some events will be sticky on the pad, meaning that after they pass on the
// pad they can be queried later with gst_pad_get_sticky_event() and
// gst_pad_sticky_events_foreach(). gst_pad_get_current_caps() and
// gst_pad_has_current_caps() are convenience functions to query the current
// sticky CAPS event on a pad.
//
// GstElements will use gst_pad_push() and gst_pad_pull_range() to push out or
// pull in a buffer.
//
// The dataflow, events and queries that happen on a pad can be monitored with
// probes that can be installed with gst_pad_add_probe(). gst_pad_is_blocked()
// can be used to check if a block probe is installed on the pad.
// gst_pad_is_blocking() checks if the blocking probe is currently blocking the
// pad. gst_pad_remove_probe() is used to remove a previously installed probe
// and unblock blocking probes if any.
//
// Pad have an offset that can be retrieved with gst_pad_get_offset(). This
// offset will be applied to the running_time of all data passing over the pad.
// gst_pad_set_offset() can be used to change the offset.
//
// Convenience functions exist to start, pause and stop the task on a pad with
// gst_pad_start_task(), gst_pad_pause_task() and gst_pad_stop_task()
// respectively.
type Pad struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Pad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Pad, *PadClass, PadOverrides](
		GTypePad,
		initPadClass,
		wrapPad,
		defaultPadOverrides,
	)
}

func initPadClass(gclass unsafe.Pointer, overrides PadOverrides, classInitFunc func(*PadClass)) {
	pclass := (*C.GstPadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePad))))

	if overrides.Linked != nil {
		pclass.linked = (*[0]byte)(C._gotk4_gst1_PadClass_linked)
	}

	if overrides.Unlinked != nil {
		pclass.unlinked = (*[0]byte)(C._gotk4_gst1_PadClass_unlinked)
	}

	if classInitFunc != nil {
		class := (*PadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPad(obj *coreglib.Object) *Pad {
	return &Pad{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPad(p uintptr) (interface{}, error) {
	return wrapPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectLinked signals that a pad has been linked to the peer pad.
func (pad *Pad) ConnectLinked(f func(peer *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(pad, "linked", false, unsafe.Pointer(C._gotk4_gst1_Pad_ConnectLinked), f)
}

// ConnectUnlinked signals that a pad has been unlinked from the peer pad.
func (pad *Pad) ConnectUnlinked(f func(peer *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(pad, "unlinked", false, unsafe.Pointer(C._gotk4_gst1_Pad_ConnectUnlinked), f)
}

// NewPad creates a new pad with the given name in the given direction. If name
// is NULL, a guaranteed unique name (across all pads) will be assigned. This
// function makes a copy of the name so you can safely free the name.
//
// The function takes the following parameters:
//
//    - name (optional) of the new pad.
//    - direction of the pad.
//
// The function returns the following values:
//
//    - pad: new Pad.
//
//      MT safe.
//
func NewPad(name string, direction PadDirection) *Pad {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GstPadDirection(direction)

	_cret = C.gst_pad_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(direction)

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(_cret)))

	return _pad
}

// NewPadFromStaticTemplate creates a new pad with the given name from the given
// static template. If name is NULL, a guaranteed unique name (across all pads)
// will be assigned. This function makes a copy of the name so you can safely
// free the name.
//
// The function takes the following parameters:
//
//    - templ to use.
//    - name of the pad.
//
// The function returns the following values:
//
//    - pad: new Pad.
//
func NewPadFromStaticTemplate(templ *StaticPadTemplate, name string) *Pad {
	var _arg1 *C.GstStaticPadTemplate // out
	var _arg2 *C.gchar                // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(templ)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_pad_new_from_static_template(_arg1, _arg2)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(_cret)))

	return _pad
}

// NewPadFromTemplate creates a new pad with the given name from the given
// template. If name is NULL, a guaranteed unique name (across all pads) will be
// assigned. This function makes a copy of the name so you can safely free the
// name.
//
// The function takes the following parameters:
//
//    - templ: pad template to use.
//    - name (optional) of the pad.
//
// The function returns the following values:
//
//    - pad: new Pad.
//
func NewPadFromTemplate(templ *PadTemplate, name string) *Pad {
	var _arg1 *C.GstPadTemplate // out
	var _arg2 *C.gchar          // out
	var _cret *C.GstPad         // in

	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_pad_new_from_template(_arg1, _arg2)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(_cret)))

	return _pad
}

// ActivateMode activates or deactivates the given pad in mode via dispatching
// to the pad's activatemodefunc. For use from within pad activation functions
// only.
//
// If you don't know what this is, you probably don't want to call it.
//
// The function takes the following parameters:
//
//    - mode: requested activation mode.
//    - active: whether or not the pad should be active.
//
// The function returns the following values:
//
//    - ok: TRUE if the operation was successful.
//
//      MT safe.
//
func (pad *Pad) ActivateMode(mode PadMode, active bool) bool {
	var _arg0 *C.GstPad    // out
	var _arg1 C.GstPadMode // out
	var _arg2 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstPadMode(mode)
	if active {
		_arg2 = C.TRUE
	}

	_cret = C.gst_pad_activate_mode(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddProbe: be notified of different states of pads. The provided callback is
// called for every state that matches mask.
//
// Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
// called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only exception
// here are GST_PAD_PROBE_TYPE_IDLE probes that are called immediately if the
// pad is already idle while calling gst_pad_add_probe(). In each of the groups,
// probes are called in the order in which they were added.
//
// The function takes the following parameters:
//
//    - mask: probe mask.
//    - callback that will be called with notifications of the pad state.
//
// The function returns the following values:
//
//    - gulong: id or 0 if no probe is pending. The id can be used to remove the
//      probe with gst_pad_remove_probe(). When using GST_PAD_PROBE_TYPE_IDLE it
//      can happen that the probe can be run immediately and if the probe returns
//      GST_PAD_PROBE_REMOVE this functions returns 0.
//
//      MT safe.
//
func (pad *Pad) AddProbe(mask PadProbeType, callback PadProbeCallback) uint32 {
	var _arg0 *C.GstPad             // out
	var _arg1 C.GstPadProbeType     // out
	var _arg2 C.GstPadProbeCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.gulong // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstPadProbeType(mask)
	_arg2 = (*[0]byte)(C._gotk4_gst1_PadProbeCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_pad_add_probe(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(callback)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// CanLink checks if the source pad and the sink pad are compatible so they can
// be linked.
//
// The function takes the following parameters:
//
//    - sinkpad: sink Pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the pads can be linked.
//
func (srcpad *Pad) CanLink(sinkpad *Pad) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	_cret = C.gst_pad_can_link(_arg0, _arg1)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Chain a buffer to pad.
//
// The function returns T_FLOW_FLUSHING if the pad was flushing.
//
// If the buffer type is not acceptable for pad (as negotiated with a preceding
// GST_EVENT_CAPS event), this function returns T_FLOW_NOT_NEGOTIATED.
//
// The function proceeds calling the chain function installed on pad (see
// gst_pad_set_chain_function()) and the return value of that function is
// returned to the caller. T_FLOW_NOT_SUPPORTED is returned if pad has no chain
// function.
//
// In all cases, success or failure, the caller loses its reference to buffer
// after calling this function.
//
// The function takes the following parameters:
//
//    - buffer to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//    - flowReturn from the pad.
//
//      MT safe.
//
func (pad *Pad) Chain(buffer *Buffer) FlowReturn {
	var _arg0 *C.GstPad       // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_pad_chain(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(buffer)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// ChainList: chain a bufferlist to pad.
//
// The function returns T_FLOW_FLUSHING if the pad was flushing.
//
// If pad was not negotiated properly with a CAPS event, this function returns
// T_FLOW_NOT_NEGOTIATED.
//
// The function proceeds calling the chainlist function installed on pad (see
// gst_pad_set_chain_list_function()) and the return value of that function is
// returned to the caller. T_FLOW_NOT_SUPPORTED is returned if pad has no
// chainlist function.
//
// In all cases, success or failure, the caller loses its reference to list
// after calling this function.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - list to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//    - flowReturn from the pad.
//
func (pad *Pad) ChainList(list *BufferList) FlowReturn {
	var _arg0 *C.GstPad        // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_pad_chain_list(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(list)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// CheckReconfigure: check and clear the T_PAD_FLAG_NEED_RECONFIGURE flag on pad
// and return TRUE if the flag was set.
//
// The function returns the following values:
//
//    - ok: TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag was set on pad.
//
func (pad *Pad) CheckReconfigure() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_check_reconfigure(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateStreamID creates a stream-id for the source Pad pad by combining the
// upstream information with the optional stream_id of the stream of pad. pad
// must have a parent Element and which must have zero or one sinkpad. stream_id
// can only be NULL if the parent element of pad has only a single source pad.
//
// This function generates an unique stream-id by getting the upstream
// stream-start event stream ID and appending stream_id to it. If the element
// has no sinkpad it will generate an upstream stream-id by doing an URI query
// on the element and in the worst case just uses a random number. Source
// elements that don't implement the URI handler interface should ideally
// generate a unique, deterministic stream-id manually instead.
//
// Since stream IDs are sorted alphabetically, any numbers in the stream ID
// should be printed with a fixed number of characters, preceded by 0's, such as
// by using the format \03u instead of \u.
//
// The function takes the following parameters:
//
//    - parent: parent Element of pad.
//    - streamId (optional): stream-id.
//
// The function returns the following values:
//
//    - utf8: stream-id for pad. g_free() after usage.
//
func (pad *Pad) CreateStreamID(parent Elementer, streamId string) string {
	var _arg0 *C.GstPad     // out
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if streamId != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_pad_create_stream_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(streamId)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// EventDefault invokes the default event handler for the given pad.
//
// The EOS event will pause the task associated with pad before it is forwarded
// to all internally linked pads,
//
// The event is sent to all pads internally linked to pad. This function takes
// ownership of event.
//
// The function takes the following parameters:
//
//    - parent (optional) of pad or NULL.
//    - event to handle.
//
// The function returns the following values:
//
//    - ok: TRUE if the event was sent successfully.
//
func (pad *Pad) EventDefault(parent GstObjector, event *Event) bool {
	var _arg0 *C.GstPad    // out
	var _arg1 *C.GstObject // out
	var _arg2 *C.GstEvent  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_pad_event_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Forward calls forward for all internally linked pads of pad. This function
// deals with dynamically changing internal pads and will make sure that the
// forward function is only called once for each pad.
//
// When forward returns TRUE, no further pads will be processed.
//
// The function takes the following parameters:
//
//    - forward: PadForwardFunction.
//
// The function returns the following values:
//
//    - ok: TRUE if one of the dispatcher functions returned TRUE.
//
func (pad *Pad) Forward(forward PadForwardFunction) bool {
	var _arg0 *C.GstPad               // out
	var _arg1 C.GstPadForwardFunction // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PadForwardFunction)
	_arg2 = C.gpointer(gbox.Assign(forward))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_pad_forward(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(forward)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AllowedCaps gets the capabilities of the allowed media types that can flow
// through pad and its peer.
//
// The allowed capabilities is calculated as the intersection of the results of
// calling gst_pad_query_caps() on pad and its peer. The caller owns a reference
// on the resulting caps.
//
// The function returns the following values:
//
//    - caps (optional): allowed Caps of the pad link. Unref the caps when you no
//      longer need it. This function returns NULL when pad has no peer.
//
//      MT safe.
//
func (pad *Pad) AllowedCaps() *Caps {
	var _arg0 *C.GstPad  // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_allowed_caps(_arg0)
	runtime.KeepAlive(pad)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// CurrentCaps gets the capabilities currently configured on pad with the last
// T_EVENT_CAPS event.
//
// The function returns the following values:
//
//    - caps (optional): current caps of the pad with incremented ref-count or
//      NULL when pad has no caps. Unref after usage.
//
func (pad *Pad) CurrentCaps() *Caps {
	var _arg0 *C.GstPad  // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_current_caps(_arg0)
	runtime.KeepAlive(pad)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// Direction gets the direction of the pad. The direction of the pad is decided
// at construction time so this function does not take the LOCK.
//
// The function returns the following values:
//
//    - padDirection of the pad.
//
//      MT safe.
//
func (pad *Pad) Direction() PadDirection {
	var _arg0 *C.GstPad         // out
	var _cret C.GstPadDirection // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_direction(_arg0)
	runtime.KeepAlive(pad)

	var _padDirection PadDirection // out

	_padDirection = PadDirection(_cret)

	return _padDirection
}

// ElementPrivate gets the private data of a pad. No locking is performed in
// this function.
//
// The function returns the following values:
//
//    - gpointer (optional) to the private data.
//
func (pad *Pad) ElementPrivate() unsafe.Pointer {
	var _arg0 *C.GstPad  // out
	var _cret C.gpointer // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_element_private(_arg0)
	runtime.KeepAlive(pad)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// LastFlowReturn gets the FlowReturn return from the last data passed by this
// pad.
//
// The function returns the following values:
//
func (pad *Pad) LastFlowReturn() FlowReturn {
	var _arg0 *C.GstPad       // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_last_flow_return(_arg0)
	runtime.KeepAlive(pad)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// Offset: get the offset applied to the running time of pad. pad has to be a
// source pad.
//
// The function returns the following values:
//
//    - gint64: offset.
//
func (pad *Pad) Offset() int64 {
	var _arg0 *C.GstPad // out
	var _cret C.gint64  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_offset(_arg0)
	runtime.KeepAlive(pad)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// PadTemplate gets the template for pad.
//
// The function returns the following values:
//
//    - padTemplate (optional) from which this pad was instantiated, or NULL if
//      this pad has no template. Unref after usage.
//
func (pad *Pad) PadTemplate() *PadTemplate {
	var _arg0 *C.GstPad         // out
	var _cret *C.GstPadTemplate // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_pad_template(_arg0)
	runtime.KeepAlive(pad)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// PadTemplateCaps gets the capabilities for pad's template.
//
// The function returns the following values:
//
//    - caps of this pad template. Unref after usage.
//
func (pad *Pad) PadTemplateCaps() *Caps {
	var _arg0 *C.GstPad  // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_pad_template_caps(_arg0)
	runtime.KeepAlive(pad)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// ParentElement gets the parent of pad, cast to a Element. If a pad has no
// parent or its parent is not an element, return NULL.
//
// The function returns the following values:
//
//    - element (optional): parent of the pad. The caller has a reference on the
//      parent, so unref when you're finished with it.
//
//      MT safe.
//
func (pad *Pad) ParentElement() Elementer {
	var _arg0 *C.GstPad     // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_parent_element(_arg0)
	runtime.KeepAlive(pad)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// Peer gets the peer of pad. This function refs the peer pad so you need to
// unref it after use.
//
// The function returns the following values:
//
//    - ret (optional): peer Pad. Unref after usage.
//
//      MT safe.
//
func (pad *Pad) Peer() *Pad {
	var _arg0 *C.GstPad // out
	var _cret *C.GstPad // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_peer(_arg0)
	runtime.KeepAlive(pad)

	var _ret *Pad // out

	if _cret != nil {
		_ret = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// Range: when pad is flushing this function returns T_FLOW_FLUSHING immediately
// and buffer is NULL.
//
// Calls the getrange function of pad, see PadGetRangeFunction for a description
// of a getrange function. If pad has no getrange function installed (see
// gst_pad_set_getrange_function()) this function returns T_FLOW_NOT_SUPPORTED.
//
// If buffer points to a variable holding NULL, a valid new Buffer will be
// placed in buffer when this function returns T_FLOW_OK. The new buffer must be
// freed with gst_buffer_unref() after usage.
//
// When buffer points to a variable that points to a valid Buffer, the buffer
// will be filled with the result data when this function returns T_FLOW_OK. If
// the provided buffer is larger than size, only size bytes will be filled in
// the result buffer and its size will be updated accordingly.
//
// Note that less than size bytes can be returned in buffer when, for example,
// an EOS condition is near or when buffer is not large enough to hold size
// bytes. The caller should check the result buffer size to get the result size.
//
// When this function returns any other result value than T_FLOW_OK, buffer will
// be unchanged.
//
// This is a lowlevel function. Usually gst_pad_pull_range() is used.
//
// The function takes the following parameters:
//
//    - offset: start offset of the buffer.
//    - size: length of the buffer.
//
// The function returns the following values:
//
//    - buffer: pointer to hold the Buffer, returns T_FLOW_ERROR if NULL.
//    - flowReturn from the pad.
//
//      MT safe.
//
func (pad *Pad) Range(offset uint64, size uint) (*Buffer, FlowReturn) {
	var _arg0 *C.GstPad       // out
	var _arg1 C.guint64       // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint(size)

	_cret = C.gst_pad_get_range(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// SingleInternalLink: if there is a single internal link of the given pad, this
// function will return it. Otherwise, it will return NULL.
//
// The function returns the following values:
//
//    - ret (optional) or NULL if pad has none or more than one internal links.
//      Unref returned pad with gst_object_unref().
//
func (pad *Pad) SingleInternalLink() *Pad {
	var _arg0 *C.GstPad // out
	var _cret *C.GstPad // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_single_internal_link(_arg0)
	runtime.KeepAlive(pad)

	var _ret *Pad // out

	if _cret != nil {
		_ret = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// StickyEvent returns a new reference of the sticky event of type event_type
// from the event.
//
// The function takes the following parameters:
//
//    - eventType that should be retrieved.
//    - idx: index of the event.
//
// The function returns the following values:
//
//    - event (optional) of type event_type or NULL when no event of event_type
//      was on pad. Unref after usage.
//
func (pad *Pad) StickyEvent(eventType EventType, idx uint) *Event {
	var _arg0 *C.GstPad      // out
	var _arg1 C.GstEventType // out
	var _arg2 C.guint        // out
	var _cret *C.GstEvent    // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstEventType(eventType)
	_arg2 = C.guint(idx)

	_cret = C.gst_pad_get_sticky_event(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(eventType)
	runtime.KeepAlive(idx)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// Stream returns the current Stream for the pad, or NULL if none has been set
// yet, i.e. the pad has not received a stream-start event yet.
//
// This is a convenience wrapper around gst_pad_get_sticky_event() and
// gst_event_parse_stream().
//
// The function returns the following values:
//
//    - stream (optional): current Stream for pad, or NULL. unref the returned
//      stream when no longer needed.
//
func (pad *Pad) Stream() *Stream {
	var _arg0 *C.GstPad    // out
	var _cret *C.GstStream // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_stream(_arg0)
	runtime.KeepAlive(pad)

	var _stream *Stream // out

	if _cret != nil {
		_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _stream
}

// StreamID returns the current stream-id for the pad, or NULL if none has been
// set yet, i.e. the pad has not received a stream-start event yet.
//
// This is a convenience wrapper around gst_pad_get_sticky_event() and
// gst_event_parse_stream_start().
//
// The returned stream-id string should be treated as an opaque string, its
// contents should not be interpreted.
//
// The function returns the following values:
//
//    - utf8 (optional): newly-allocated copy of the stream-id for pad, or NULL.
//      g_free() the returned string when no longer needed.
//
func (pad *Pad) StreamID() string {
	var _arg0 *C.GstPad // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_stream_id(_arg0)
	runtime.KeepAlive(pad)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TaskState: get pad task state. If no task is currently set, T_TASK_STOPPED is
// returned.
//
// The function returns the following values:
//
//    - taskState: current state of pad's task.
//
func (pad *Pad) TaskState() TaskState {
	var _arg0 *C.GstPad      // out
	var _cret C.GstTaskState // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_task_state(_arg0)
	runtime.KeepAlive(pad)

	var _taskState TaskState // out

	_taskState = TaskState(_cret)

	return _taskState
}

// HasCurrentCaps: check if pad has caps set on it with a T_EVENT_CAPS event.
//
// The function returns the following values:
//
//    - ok: TRUE when pad has caps associated with it.
//
func (pad *Pad) HasCurrentCaps() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_has_current_caps(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive: query if a pad is active.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad is active.
//
//      MT safe.
//
func (pad *Pad) IsActive() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_active(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBlocked checks if the pad is blocked or not. This function returns the last
// requested state of the pad. It is not certain that the pad is actually
// blocking at this point (see gst_pad_is_blocking()).
//
// The function returns the following values:
//
//    - ok: TRUE if the pad is blocked.
//
//      MT safe.
//
func (pad *Pad) IsBlocked() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_blocked(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBlocking checks if the pad is blocking or not. This is a guaranteed state
// of whether the pad is actually blocking on a Buffer or a Event.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad is blocking.
//
//      MT safe.
//
func (pad *Pad) IsBlocking() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_blocking(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLinked checks if a pad is linked to another pad or not.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad is linked, FALSE otherwise.
//
//      MT safe.
//
func (pad *Pad) IsLinked() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_linked(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterateInternalLinks gets an iterator for the pads to which the given pad is
// linked to inside of the parent element.
//
// Each Pad element yielded by the iterator will have its refcount increased, so
// unref after use.
//
// Free-function: gst_iterator_free.
//
// The function returns the following values:
//
//    - iterator (optional): new Iterator of Pad or NULL when the pad does not
//      have an iterator function configured. Use gst_iterator_free() after
//      usage.
//
func (pad *Pad) IterateInternalLinks() *Iterator {
	var _arg0 *C.GstPad      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_iterate_internal_links(_arg0)
	runtime.KeepAlive(pad)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateInternalLinksDefault: iterate the list of pads to which the given pad
// is linked to inside of the parent element. This is the default handler, and
// thus returns an iterator of all of the pads inside the parent element with
// opposite direction.
//
// The caller must free this iterator after use with gst_iterator_free().
//
// The function takes the following parameters:
//
//    - parent (optional) of pad or NULL.
//
// The function returns the following values:
//
//    - iterator (optional) of Pad, or NULL if pad has no parent. Unref each
//      returned pad with gst_object_unref().
//
func (pad *Pad) IterateInternalLinksDefault(parent GstObjector) *Iterator {
	var _arg0 *C.GstPad      // out
	var _arg1 *C.GstObject   // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gst_pad_iterate_internal_links_default(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// Link links the source pad and the sink pad.
//
// The function takes the following parameters:
//
//    - sinkpad: sink Pad to link.
//
// The function returns the following values:
//
//    - padLinkReturn: result code indicating if the connection worked or what
//      went wrong.
//
//      MT Safe.
//
func (srcpad *Pad) Link(sinkpad *Pad) PadLinkReturn {
	var _arg0 *C.GstPad          // out
	var _arg1 *C.GstPad          // out
	var _cret C.GstPadLinkReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	_cret = C.gst_pad_link(_arg0, _arg1)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)

	var _padLinkReturn PadLinkReturn // out

	_padLinkReturn = PadLinkReturn(_cret)

	return _padLinkReturn
}

// LinkFull links the source pad and the sink pad.
//
// This variant of #gst_pad_link provides a more granular control on the checks
// being done when linking. While providing some considerable speedups the
// caller of this method must be aware that wrong usage of those flags can cause
// severe issues. Refer to the documentation of PadLinkCheck for more
// information.
//
// MT Safe.
//
// The function takes the following parameters:
//
//    - sinkpad: sink Pad to link.
//    - flags checks to validate when linking.
//
// The function returns the following values:
//
//    - padLinkReturn: result code indicating if the connection worked or what
//      went wrong.
//
func (srcpad *Pad) LinkFull(sinkpad *Pad, flags PadLinkCheck) PadLinkReturn {
	var _arg0 *C.GstPad          // out
	var _arg1 *C.GstPad          // out
	var _arg2 C.GstPadLinkCheck  // out
	var _cret C.GstPadLinkReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))
	_arg2 = C.GstPadLinkCheck(flags)

	_cret = C.gst_pad_link_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)
	runtime.KeepAlive(flags)

	var _padLinkReturn PadLinkReturn // out

	_padLinkReturn = PadLinkReturn(_cret)

	return _padLinkReturn
}

// LinkMaybeGhosting links src to sink, creating any GhostPad's in between as
// necessary.
//
// This is a convenience function to save having to create and add intermediate
// GhostPad's as required for linking across Bin boundaries.
//
// If src or sink pads don't have parent elements or do not share a common
// ancestor, the link will fail.
//
// The function takes the following parameters:
//
//    - sink: Pad.
//
// The function returns the following values:
//
//    - ok: whether the link succeeded.
//
func (src *Pad) LinkMaybeGhosting(sink *Pad) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_pad_link_maybe_ghosting(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkMaybeGhostingFull links src to sink, creating any GhostPad's in between
// as necessary.
//
// This is a convenience function to save having to create and add intermediate
// GhostPad's as required for linking across Bin boundaries.
//
// If src or sink pads don't have parent elements or do not share a common
// ancestor, the link will fail.
//
// Calling gst_pad_link_maybe_ghosting_full() with flags ==
// GST_PAD_LINK_CHECK_DEFAULT is the recommended way of linking pads with safety
// checks applied.
//
// The function takes the following parameters:
//
//    - sink: Pad.
//    - flags: some PadLinkCheck flags.
//
// The function returns the following values:
//
//    - ok: whether the link succeeded.
//
func (src *Pad) LinkMaybeGhostingFull(sink *Pad, flags PadLinkCheck) bool {
	var _arg0 *C.GstPad         // out
	var _arg1 *C.GstPad         // out
	var _arg2 C.GstPadLinkCheck // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg2 = C.GstPadLinkCheck(flags)

	_cret = C.gst_pad_link_maybe_ghosting_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarkReconfigure: mark a pad for needing reconfiguration. The next call to
// gst_pad_check_reconfigure() will return TRUE after this call.
func (pad *Pad) MarkReconfigure() {
	var _arg0 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_pad_mark_reconfigure(_arg0)
	runtime.KeepAlive(pad)
}

// NeedsReconfigure: check the T_PAD_FLAG_NEED_RECONFIGURE flag on pad and
// return TRUE if the flag was set.
//
// The function returns the following values:
//
//    - ok: TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag is set on pad.
//
func (pad *Pad) NeedsReconfigure() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_needs_reconfigure(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PauseTask: pause the task of pad. This function will also wait until the
// function executed by the task is finished if this function is not called from
// the task function.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be paused or FALSE when the pad has no task.
//
func (pad *Pad) PauseTask() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_pause_task(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeerQuery performs gst_pad_query() on the peer of pad.
//
// The caller is responsible for both the allocation and deallocation of the
// query structure.
//
// The function takes the following parameters:
//
//    - query to perform.
//
// The function returns the following values:
//
//    - ok: TRUE if the query could be performed. This function returns FALSE if
//      pad has no peer.
//
func (pad *Pad) PeerQuery(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_peer_query(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeerQueryAcceptCaps: check if the peer of pad accepts caps. If pad has no
// peer, this function returns TRUE.
//
// The function takes the following parameters:
//
//    - caps to check on the pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the peer of pad can accept the caps or pad has no peer.
//
func (pad *Pad) PeerQueryAcceptCaps(caps *Caps) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pad_peer_query_accept_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeerQueryCaps gets the capabilities of the peer connected to this pad.
// Similar to gst_pad_query_caps().
//
// When called on srcpads filter contains the caps that upstream could produce
// in the order preferred by upstream. When called on sinkpads filter contains
// the caps accepted by downstream in the preferred order. filter might be NULL
// but if it is not NULL the returned caps will be a subset of filter.
//
// The function takes the following parameters:
//
//    - filter (optional) filter, or NULL.
//
// The function returns the following values:
//
//    - caps of the peer pad with incremented ref-count. When there is no peer
//      pad, this function returns filter or, when filter is NULL, ANY caps.
//
func (pad *Pad) PeerQueryCaps(filter *Caps) *Caps {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if filter != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_pad_peer_query_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(filter)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// PeerQueryConvert queries the peer pad of a given sink pad to convert src_val
// in src_format to dest_format.
//
// The function takes the following parameters:
//
//    - srcFormat to convert from.
//    - srcVal: value to convert.
//    - destFormat to convert to.
//
// The function returns the following values:
//
//    - destVal: pointer to the result.
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) PeerQueryConvert(srcFormat Format, srcVal int64, destFormat Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _arg4 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_pad_peer_query_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFormat)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// PeerQueryDuration queries the peer pad of a given sink pad for the total
// stream duration.
//
// The function takes the following parameters:
//
//    - format: Format requested.
//
// The function returns the following values:
//
//    - duration (optional): location in which to store the total duration, or
//      NULL.
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) PeerQueryDuration(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_peer_query_duration(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _duration int64 // out
	var _ok bool        // out

	_duration = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _duration, _ok
}

// PeerQueryPosition queries the peer of a given sink pad for the stream
// position.
//
// The function takes the following parameters:
//
//    - format: Format requested.
//
// The function returns the following values:
//
//    - cur (optional): location in which to store the current position, or NULL.
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) PeerQueryPosition(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_peer_query_position(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _cur int64 // out
	var _ok bool   // out

	_cur = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _cur, _ok
}

// ProxyQueryAcceptCaps checks if all internally linked pads of pad accepts the
// caps in query and returns the intersection of the results.
//
// This function is useful as a default accept caps query function for an
// element that can handle any stream format, but requires caps that are
// acceptable for all opposite pads.
//
// The function takes the following parameters:
//
//    - query: ACCEPT_CAPS Query.
//
// The function returns the following values:
//
//    - ok: TRUE if query could be executed.
//
func (pad *Pad) ProxyQueryAcceptCaps(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_proxy_query_accept_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyQueryCaps calls gst_pad_query_caps() for all internally linked pads of
// pad and returns the intersection of the results.
//
// This function is useful as a default caps query function for an element that
// can handle any stream format, but requires all its pads to have the same
// caps. Two such elements are tee and adder.
//
// The function takes the following parameters:
//
//    - query: CAPS Query.
//
// The function returns the following values:
//
//    - ok: TRUE if query could be executed.
//
func (pad *Pad) ProxyQueryCaps(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_proxy_query_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PullRange pulls a buffer from the peer pad or fills up a provided buffer.
//
// This function will first trigger the pad block signal if it was installed.
//
// When pad is not linked T_FLOW_NOT_LINKED is returned else this function
// returns the result of gst_pad_get_range() on the peer pad. See
// gst_pad_get_range() for a list of return values and for the semantics of the
// arguments of this function.
//
// If buffer points to a variable holding NULL, a valid new Buffer will be
// placed in buffer when this function returns T_FLOW_OK. The new buffer must be
// freed with gst_buffer_unref() after usage. When this function returns any
// other result value, buffer will still point to NULL.
//
// When buffer points to a variable that points to a valid Buffer, the buffer
// will be filled with the result data when this function returns T_FLOW_OK.
// When this function returns any other result value, buffer will be unchanged.
// If the provided buffer is larger than size, only size bytes will be filled in
// the result buffer and its size will be updated accordingly.
//
// Note that less than size bytes can be returned in buffer when, for example,
// an EOS condition is near or when buffer is not large enough to hold size
// bytes. The caller should check the result buffer size to get the result size.
//
// The function takes the following parameters:
//
//    - offset: start offset of the buffer.
//    - size: length of the buffer.
//
// The function returns the following values:
//
//    - buffer: pointer to hold the Buffer, returns GST_FLOW_ERROR if NULL.
//    - flowReturn from the peer pad.
//
//      MT safe.
//
func (pad *Pad) PullRange(offset uint64, size uint) (*Buffer, FlowReturn) {
	var _arg0 *C.GstPad       // out
	var _arg1 C.guint64       // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint(size)

	_cret = C.gst_pad_pull_range(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// Push pushes a buffer to the peer of pad.
//
// This function will call installed block probes before triggering any
// installed data probes.
//
// The function proceeds calling gst_pad_chain() on the peer pad and returns the
// value from that function. If pad has no peer, T_FLOW_NOT_LINKED will be
// returned.
//
// In all cases, success or failure, the caller loses its reference to buffer
// after calling this function.
//
// The function takes the following parameters:
//
//    - buffer to push returns GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//    - flowReturn from the peer pad.
//
//      MT safe.
//
func (pad *Pad) Push(buffer *Buffer) FlowReturn {
	var _arg0 *C.GstPad       // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_pad_push(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(buffer)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// PushEvent sends the event to the peer of the given pad. This function is
// mainly used by elements to send events to their peer elements.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// The function takes the following parameters:
//
//    - event to send to the pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the event was handled.
//
//      MT safe.
//
func (pad *Pad) PushEvent(event *Event) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_pad_push_event(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PushList pushes a buffer list to the peer of pad.
//
// This function will call installed block probes before triggering any
// installed data probes.
//
// The function proceeds calling the chain function on the peer pad and returns
// the value from that function. If pad has no peer, T_FLOW_NOT_LINKED will be
// returned. If the peer pad does not have any installed chainlist function
// every group buffer of the list will be merged into a normal Buffer and
// chained via gst_pad_chain().
//
// In all cases, success or failure, the caller loses its reference to list
// after calling this function.
//
// The function takes the following parameters:
//
//    - list to push returns GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//    - flowReturn from the peer pad.
//
//      MT safe.
//
func (pad *Pad) PushList(list *BufferList) FlowReturn {
	var _arg0 *C.GstPad        // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_pad_push_list(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(list)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// Query dispatches a query to a pad. The query should have been allocated by
// the caller via one of the type-specific allocation functions. The element
// that the pad belongs to is responsible for filling the query with an
// appropriate response, which should then be parsed with a type-specific query
// parsing function.
//
// Again, the caller is responsible for both the allocation and deallocation of
// the query structure.
//
// Please also note that some queries might need a running pipeline to work.
//
// The function takes the following parameters:
//
//    - query to perform.
//
// The function returns the following values:
//
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) Query(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_query(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryAcceptCaps: check if the given pad accepts the caps.
//
// The function takes the following parameters:
//
//    - caps to check on the pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad can accept the caps.
//
func (pad *Pad) QueryAcceptCaps(caps *Caps) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pad_query_accept_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryCaps gets the capabilities this pad can produce or consume. Note that
// this method doesn't necessarily return the caps set by sending a
// gst_event_new_caps() - use gst_pad_get_current_caps() for that instead.
// gst_pad_query_caps returns all possible caps a pad can operate with, using
// the pad's CAPS query function, If the query fails, this function will return
// filter, if not NULL, otherwise ANY.
//
// When called on sinkpads filter contains the caps that upstream could produce
// in the order preferred by upstream. When called on srcpads filter contains
// the caps accepted by downstream in the preferred order. filter might be NULL
// but if it is not NULL the returned caps will be a subset of filter.
//
// Note that this function does not return writable Caps, use
// gst_caps_make_writable() before modifying the caps.
//
// The function takes the following parameters:
//
//    - filter (optional): suggested Caps, or NULL.
//
// The function returns the following values:
//
//    - caps of the pad with incremented ref-count.
//
func (pad *Pad) QueryCaps(filter *Caps) *Caps {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if filter != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_pad_query_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(filter)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// QueryConvert queries a pad to convert src_val in src_format to dest_format.
//
// The function takes the following parameters:
//
//    - srcFormat to convert from.
//    - srcVal: value to convert.
//    - destFormat to convert to.
//
// The function returns the following values:
//
//    - destVal: pointer to the result.
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) QueryConvert(srcFormat Format, srcVal int64, destFormat Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _arg4 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_pad_query_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFormat)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// QueryDefault invokes the default query handler for the given pad. The query
// is sent to all pads internally linked to pad. Note that if there are many
// possible sink pads that are internally linked to pad, only one will be sent
// the query. Multi-sinkpad elements should implement custom query handlers.
//
// The function takes the following parameters:
//
//    - parent (optional) of pad or NULL.
//    - query to handle.
//
// The function returns the following values:
//
//    - ok: TRUE if the query was performed successfully.
//
func (pad *Pad) QueryDefault(parent GstObjector, query *Query) bool {
	var _arg0 *C.GstPad    // out
	var _arg1 *C.GstObject // out
	var _arg2 *C.GstQuery  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_query_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryDuration queries a pad for the total stream duration.
//
// The function takes the following parameters:
//
//    - format: Format requested.
//
// The function returns the following values:
//
//    - duration (optional): location in which to store the total duration, or
//      NULL.
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) QueryDuration(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_query_duration(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _duration int64 // out
	var _ok bool        // out

	_duration = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _duration, _ok
}

// QueryPosition queries a pad for the stream position.
//
// The function takes the following parameters:
//
//    - format: Format requested.
//
// The function returns the following values:
//
//    - cur (optional): location in which to store the current position, or NULL.
//    - ok: TRUE if the query could be performed.
//
func (pad *Pad) QueryPosition(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_query_position(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _cur int64 // out
	var _ok bool   // out

	_cur = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _cur, _ok
}

// RemoveProbe: remove the probe with id from pad.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - id: probe id to remove.
//
func (pad *Pad) RemoveProbe(id uint32) {
	var _arg0 *C.GstPad // out
	var _arg1 C.gulong  // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.gulong(id)

	C.gst_pad_remove_probe(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(id)
}

// SendEvent sends the event to the pad. This function can be used by
// applications to send events in the pipeline.
//
// If pad is a source pad, event should be an upstream event. If pad is a sink
// pad, event should be a downstream event. For example, you would not send a
// T_EVENT_EOS on a src pad; EOS events only propagate downstream. Furthermore,
// some downstream events have to be serialized with data flow, like EOS, while
// some can travel out-of-band, like T_EVENT_FLUSH_START. If the event needs to
// be serialized with data flow, this function will take the pad's stream lock
// while calling its event function.
//
// To find out whether an event type is upstream, downstream, or downstream and
// serialized, see EventTypeFlags, gst_event_type_get_flags(),
// T_EVENT_IS_UPSTREAM, T_EVENT_IS_DOWNSTREAM, and T_EVENT_IS_SERIALIZED. Note
// that in practice that an application or plugin doesn't need to bother itself
// with this information; the core handles all necessary locks and checks.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// The function takes the following parameters:
//
//    - event to send to the pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the event was handled.
//
func (pad *Pad) SendEvent(event *Event) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_pad_send_event(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive activates or deactivates the given pad. Normally called from within
// core state change functions.
//
// If active, makes sure the pad is active. If it is already active, either in
// push or pull mode, just return. Otherwise dispatches to the pad's activate
// function to perform the actual activation.
//
// If not active, calls gst_pad_activate_mode() with the pad's current mode and
// a FALSE argument.
//
// The function takes the following parameters:
//
//    - active: whether or not the pad should be active.
//
// The function returns the following values:
//
//    - ok: TRUE if the operation was successful.
//
//      MT safe.
//
func (pad *Pad) SetActive(active bool) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C.gst_pad_set_active(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetElementPrivate: set the given private data gpointer on the pad. This
// function can only be used by the element that owns the pad. No locking is
// performed in this function.
//
// The function takes the following parameters:
//
//    - priv (optional): private data to attach to the pad.
//
func (pad *Pad) SetElementPrivate(priv unsafe.Pointer) {
	var _arg0 *C.GstPad  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(priv))

	C.gst_pad_set_element_private(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(priv)
}

// SetOffset: set the offset that will be applied to the running time of pad.
//
// The function takes the following parameters:
//
//    - offset: offset.
//
func (pad *Pad) SetOffset(offset int64) {
	var _arg0 *C.GstPad // out
	var _arg1 C.gint64  // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.gint64(offset)

	C.gst_pad_set_offset(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(offset)
}

// StartTask starts a task that repeatedly calls func with user_data. This
// function is mostly used in pad activation functions to start the dataflow.
// The T_PAD_STREAM_LOCK of pad will automatically be acquired before func is
// called.
//
// The function takes the following parameters:
//
//    - fn: task function to call.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be started.
//
func (pad *Pad) StartTask(fn TaskFunction) bool {
	var _arg0 *C.GstPad         // out
	var _arg1 C.GstTaskFunction // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_TaskFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_pad_start_task(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StickyEventsForEach iterates all sticky events on pad and calls foreach_func
// for every event. If foreach_func returns FALSE the iteration is immediately
// stopped.
//
// The function takes the following parameters:
//
//    - foreachFunc that should be called for every event.
//
func (pad *Pad) StickyEventsForEach(foreachFunc PadStickyEventsForEachFunction) {
	var _arg0 *C.GstPad                           // out
	var _arg1 C.GstPadStickyEventsForeachFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PadStickyEventsForEachFunction)
	_arg2 = C.gpointer(gbox.Assign(foreachFunc))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_pad_sticky_events_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(foreachFunc)
}

// StopTask: stop the task of pad. This function will also make sure that the
// function executed by the task will effectively stop if not called from the
// GstTaskFunction.
//
// This function will deadlock if called from the GstTaskFunction of the task.
// Use gst_task_pause() instead.
//
// Regardless of whether the pad has a task, the stream lock is acquired and
// released so as to ensure that streaming through this pad has finished.
//
// The function returns the following values:
//
//    - ok: TRUE if the task could be stopped or FALSE on error.
//
func (pad *Pad) StopTask() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_stop_task(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StoreStickyEvent: store the sticky event on pad.
//
// The function takes the following parameters:
//
//    - event: Event.
//
// The function returns the following values:
//
//    - flowReturn on success, T_FLOW_FLUSHING when the pad was flushing or
//      T_FLOW_EOS when the pad was EOS.
//
func (pad *Pad) StoreStickyEvent(event *Event) FlowReturn {
	var _arg0 *C.GstPad       // out
	var _arg1 *C.GstEvent     // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_pad_store_sticky_event(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// Unlink unlinks the source pad from the sink pad. Will emit the Pad::unlinked
// signal on both pads.
//
// The function takes the following parameters:
//
//    - sinkpad: sink Pad to unlink.
//
// The function returns the following values:
//
//    - ok: TRUE if the pads were unlinked. This function returns FALSE if the
//      pads were not linked together.
//
//      MT safe.
//
func (srcpad *Pad) Unlink(sinkpad *Pad) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	_cret = C.gst_pad_unlink(_arg0, _arg1)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseFixedCaps: helper function you can use that sets the FIXED_CAPS flag This
// way the default CAPS query will always return the negotiated caps or in case
// the pad is not negotiated, the padtemplate caps.
//
// The negotiated caps are the caps of the last CAPS event that passed on the
// pad. Use this function on a pad that, once it negotiated to a CAPS, cannot be
// renegotiated to something else.
func (pad *Pad) UseFixedCaps() {
	var _arg0 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_pad_use_fixed_caps(_arg0)
	runtime.KeepAlive(pad)
}

// The function takes the following parameters:
//
func (pad *Pad) linked(peer *Pad) {
	gclass := (*C.GstPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.linked

	var _arg0 *C.GstPad // out
	var _arg1 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(peer).Native()))

	C._gotk4_gst1_Pad_virtual_linked(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(peer)
}

// The function takes the following parameters:
//
func (pad *Pad) unlinked(peer *Pad) {
	gclass := (*C.GstPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.unlinked

	var _arg0 *C.GstPad // out
	var _arg1 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(peer).Native()))

	C._gotk4_gst1_Pad_virtual_unlinked(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(peer)
}

// PadClass: instance of this type is always passed by reference.
type PadClass struct {
	*padClass
}

// padClass is the struct that's finalized.
type padClass struct {
	native *C.GstPadClass
}

func (p *PadClass) ParentClass() *ObjectClass {
	valptr := &p.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PadProbeInfo: info passed in the PadProbeCallback.
//
// An instance of this type is always passed by reference.
type PadProbeInfo struct {
	*padProbeInfo
}

// padProbeInfo is the struct that's finalized.
type padProbeInfo struct {
	native *C.GstPadProbeInfo
}

// Type: current probe type.
func (p *PadProbeInfo) Type() PadProbeType {
	valptr := &p.native._type
	var _v PadProbeType // out
	_v = PadProbeType(*valptr)
	return _v
}

// ID: id of the probe.
func (p *PadProbeInfo) ID() uint32 {
	valptr := &p.native.id
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// Data: type specific data, check the type field to know the datatype. This
// field can be NULL.
func (p *PadProbeInfo) Data() unsafe.Pointer {
	valptr := &p.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Offset: offset of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) Offset() uint64 {
	valptr := &p.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Size: size of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) Size() uint {
	valptr := &p.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// ID: id of the probe.
func (p *PadProbeInfo) SetID(id uint32) {
	valptr := &p.native.id
	*valptr = C.gulong(id)
}

// Offset: offset of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) SetOffset(offset uint64) {
	valptr := &p.native.offset
	*valptr = C.guint64(offset)
}

// Size: size of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) SetSize(size uint) {
	valptr := &p.native.size
	*valptr = C.guint(size)
}

// The function returns the following values:
//
//    - buffer (optional) from the probe.
//
func (info *PadProbeInfo) Buffer() *Buffer {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_buffer(_arg0)
	runtime.KeepAlive(info)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// The function returns the following values:
//
//    - bufferList (optional) from the probe.
//
func (info *PadProbeInfo) BufferList() *BufferList {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstBufferList   // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_buffer_list(_arg0)
	runtime.KeepAlive(info)

	var _bufferList *BufferList // out

	if _cret != nil {
		_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _bufferList
}

// The function returns the following values:
//
//    - event (optional) from the probe.
//
func (info *PadProbeInfo) Event() *Event {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstEvent        // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_event(_arg0)
	runtime.KeepAlive(info)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _event
}

// The function returns the following values:
//
//    - query (optional) from the probe.
//
func (info *PadProbeInfo) Query() *Query {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstQuery        // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_query(_arg0)
	runtime.KeepAlive(info)

	var _query *Query // out

	if _cret != nil {
		_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _query
}
