// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeDateTime = coreglib.Type(C.gst_date_time_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDateTime, F: marshalDateTime},
	})
}

// DateTime: struct to store date, time and timezone information altogether.
// DateTime is refcounted and immutable.
//
// Date information is handled using the [proleptic Gregorian calendar].
//
// Provides basic creation functions and accessor functions to its fields.
//
// [proleptic Gregorian calendar]:
// https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar
//
// An instance of this type is always passed by reference.
type DateTime struct {
	*dateTime
}

// dateTime is the struct that's finalized.
type dateTime struct {
	native *C.GstDateTime
}

func marshalDateTime(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DateTime{&dateTime{(*C.GstDateTime)(b)}}, nil
}

// NewDateTime constructs a struct DateTime.
func NewDateTime(tzoffset float32, year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 C.gfloat       // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _arg6 C.gint         // out
	var _arg7 C.gdouble      // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gfloat(tzoffset)
	_arg2 = C.gint(year)
	_arg3 = C.gint(month)
	_arg4 = C.gint(day)
	_arg5 = C.gint(hour)
	_arg6 = C.gint(minute)
	_arg7 = C.gdouble(seconds)

	_cret = C.gst_date_time_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(tzoffset)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromGDateTime constructs a struct DateTime.
func NewDateTimeFromGDateTime(dt *glib.DateTime) *DateTime {
	var _arg1 *C.GDateTime   // out
	var _cret *C.GstDateTime // in

	if dt != nil {
		_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(dt)))
	}

	_cret = C.gst_date_time_new_from_g_date_time(_arg1)
	runtime.KeepAlive(dt)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromISO8601String constructs a struct DateTime.
func NewDateTimeFromISO8601String(str string) *DateTime {
	var _arg1 *C.gchar       // out
	var _cret *C.GstDateTime // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_date_time_new_from_iso8601_string(_arg1)
	runtime.KeepAlive(str)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochLocalTime constructs a struct DateTime.
func NewDateTimeFromUnixEpochLocalTime(secs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(secs)

	_cret = C.gst_date_time_new_from_unix_epoch_local_time(_arg1)
	runtime.KeepAlive(secs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochLocalTimeUsecs constructs a struct DateTime.
func NewDateTimeFromUnixEpochLocalTimeUsecs(usecs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(usecs)

	_cret = C.gst_date_time_new_from_unix_epoch_local_time_usecs(_arg1)
	runtime.KeepAlive(usecs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochUTC constructs a struct DateTime.
func NewDateTimeFromUnixEpochUTC(secs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(secs)

	_cret = C.gst_date_time_new_from_unix_epoch_utc(_arg1)
	runtime.KeepAlive(secs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochUTCUsecs constructs a struct DateTime.
func NewDateTimeFromUnixEpochUTCUsecs(usecs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(usecs)

	_cret = C.gst_date_time_new_from_unix_epoch_utc_usecs(_arg1)
	runtime.KeepAlive(usecs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeLocalTime constructs a struct DateTime.
func NewDateTimeLocalTime(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _arg6 C.gdouble      // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)
	_arg3 = C.gint(day)
	_arg4 = C.gint(hour)
	_arg5 = C.gint(minute)
	_arg6 = C.gdouble(seconds)

	_cret = C.gst_date_time_new_local_time(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNowLocalTime constructs a struct DateTime.
func NewDateTimeNowLocalTime() *DateTime {
	var _cret *C.GstDateTime // in

	_cret = C.gst_date_time_new_now_local_time()

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNowUTC constructs a struct DateTime.
func NewDateTimeNowUTC() *DateTime {
	var _cret *C.GstDateTime // in

	_cret = C.gst_date_time_new_now_utc()

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeY constructs a struct DateTime.
func NewDateTimeY(year int) *DateTime {
	var _arg1 C.gint         // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)

	_cret = C.gst_date_time_new_y(_arg1)
	runtime.KeepAlive(year)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeYM constructs a struct DateTime.
func NewDateTimeYM(year int, month int) *DateTime {
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)

	_cret = C.gst_date_time_new_ym(_arg1, _arg2)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeYmd constructs a struct DateTime.
func NewDateTimeYmd(year int, month int, day int) *DateTime {
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)
	_arg3 = C.gint(day)

	_cret = C.gst_date_time_new_ymd(_arg1, _arg2, _arg3)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// Day returns the day of the month of this DateTime.
//
// The function returns the following values:
//
//    - gint: day of this DateTime, or -1 if none is set.
//
func (datetime *DateTime) Day() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_day(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Hour retrieves the hour of the day represented by datetime in the gregorian
// calendar. The return is in the range of 0 to 23.
//
// The function returns the following values:
//
//    - gint: hour of the day, or -1 if none is set.
//
func (datetime *DateTime) Hour() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_hour(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Microsecond retrieves the fractional part of the seconds in microseconds
// represented by datetime in the gregorian calendar.
//
// The function returns the following values:
//
//    - gint: microsecond of the second, or -1 if none is set.
//
func (datetime *DateTime) Microsecond() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_microsecond(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Minute retrieves the minute of the hour represented by datetime in the
// gregorian calendar.
//
// The function returns the following values:
//
//    - gint: minute of the hour, or -1 if none is set.
//
func (datetime *DateTime) Minute() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_minute(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Month returns the month of this DateTime. January is 1, February is 2, etc..
//
// The function returns the following values:
//
//    - gint: month of this DateTime, or -1 if none is set.
//
func (datetime *DateTime) Month() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_month(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Second retrieves the second of the minute represented by datetime in the
// gregorian calendar.
//
// The function returns the following values:
//
//    - gint: second represented by datetime, or -1 if none is set.
//
func (datetime *DateTime) Second() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_second(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TimeZoneOffset retrieves the offset from UTC in hours that the timezone
// specified by datetime represents. Timezones ahead (to the east) of UTC have
// positive values, timezones before (to the west) of UTC have negative values.
// If datetime represents UTC time, then the offset is zero.
//
// The function returns the following values:
//
//    - gfloat: offset from UTC in hours, or G_MAXDOUBLE if none is set.
//
func (datetime *DateTime) TimeZoneOffset() float32 {
	var _arg0 *C.GstDateTime // out
	var _cret C.gfloat       // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_time_zone_offset(_arg0)
	runtime.KeepAlive(datetime)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Year returns the year of this DateTime. Call gst_date_time_has_year() before,
// to avoid warnings.
//
// The function returns the following values:
//
//    - gint: year of this DateTime.
//
func (datetime *DateTime) Year() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_year(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//    - ok: TRUE if datetime<!-- -->'s day field is set, otherwise FALSE.
//
func (datetime *DateTime) HasDay() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_day(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: TRUE if datetime<!-- -->'s month field is set, otherwise FALSE.
//
func (datetime *DateTime) HasMonth() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_month(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: TRUE if datetime<!-- -->'s second field is set, otherwise FALSE.
//
func (datetime *DateTime) HasSecond() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_second(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: TRUE if datetime<!-- -->'s hour and minute fields are set, otherwise
//      FALSE.
//
func (datetime *DateTime) HasTime() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_time(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: TRUE if datetime<!-- -->'s year field is set (which should always be
//      the case), otherwise FALSE.
//
func (datetime *DateTime) HasYear() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_year(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToGDateTime creates a new Time from a fully defined DateTime object.
//
// The function returns the following values:
//
//    - dateTime (optional): newly created Time, or NULL on error or if datetime
//      does not have a year, month, day, hour, minute and second.
//
func (datetime *DateTime) ToGDateTime() *glib.DateTime {
	var _arg0 *C.GstDateTime // out
	var _cret *C.GDateTime   // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_to_g_date_time(_arg0)
	runtime.KeepAlive(datetime)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// ToISO8601String: create a minimal string compatible with ISO-8601. Possible
// output formats are (for example): 2012, 2012-06, 2012-06-23,
// 2012-06-23T23:30Z, 2012-06-23T23:30+0100, 2012-06-23T23:30:59Z,
// 2012-06-23T23:30:59+0100.
//
// The function returns the following values:
//
//    - utf8 (optional): newly allocated string formatted according to ISO 8601
//      and only including the datetime fields that are valid, or NULL in case
//      there was an error.
//
func (datetime *DateTime) ToISO8601String() string {
	var _arg0 *C.GstDateTime // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_to_iso8601_string(_arg0)
	runtime.KeepAlive(datetime)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}
