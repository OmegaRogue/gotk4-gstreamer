// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_PromiseChangeFunc(GstPromise*, gpointer);
import "C"

// GType values.
var (
	GTypePromiseResult = coreglib.Type(C.gst_promise_result_get_type())
	GTypePromise       = coreglib.Type(C.gst_promise_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePromiseResult, F: marshalPromiseResult},
		coreglib.TypeMarshaler{T: GTypePromise, F: marshalPromise},
	})
}

// PromiseResult: result of a Promise.
type PromiseResult C.gint

const (
	// PromiseResultPending: initial state. Waiting for transition to any other
	// state.
	PromiseResultPending PromiseResult = iota
	// PromiseResultInterrupted: interrupted by the consumer as it doesn't want
	// the value anymore.
	PromiseResultInterrupted
	// PromiseResultReplied: producer marked a reply.
	PromiseResultReplied
	// PromiseResultExpired: promise expired (the carrying object lost all refs)
	// and the promise will never be fulfilled.
	PromiseResultExpired
)

func marshalPromiseResult(p uintptr) (interface{}, error) {
	return PromiseResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PromiseResult.
func (p PromiseResult) String() string {
	switch p {
	case PromiseResultPending:
		return "Pending"
	case PromiseResultInterrupted:
		return "Interrupted"
	case PromiseResultReplied:
		return "Replied"
	case PromiseResultExpired:
		return "Expired"
	default:
		return fmt.Sprintf("PromiseResult(%d)", p)
	}
}

type PromiseChangeFunc func(promise *Promise)

// Promise object implements the container for values that may be available
// later. i.e. a Future or a Promise in
// <https://en.wikipedia.org/wiki/Futures_and_promises>. As with all
// Future/Promise-like functionality, there is the concept of the producer of
// the value and the consumer of the value.
//
// A Promise is created with gst_promise_new() by the consumer and passed to the
// producer to avoid thread safety issues with the change callback. A Promise
// can be replied to with a value (or an error) by the producer with
// gst_promise_reply(). The exact value returned is defined by the API contract
// of the producer and NULL may be a valid reply. gst_promise_interrupt() is for
// the consumer to indicate to the producer that the value is not needed anymore
// and producing that value can stop. The GST_PROMISE_RESULT_EXPIRED state set
// by a call to gst_promise_expire() indicates to the consumer that a value will
// never be produced and is intended to be called by a third party that
// implements some notion of message handling such as Bus. A callback can also
// be installed at Promise creation for result changes with
// gst_promise_new_with_change_func(). The change callback can be used to chain
// Promises's together as in the following example.
//
//    const GstStructure *reply;
//    GstPromise *p;
//    if (gst_promise_wait (promise) != GST_PROMISE_RESULT_REPLIED)
//      return; // interrupted or expired value
//    reply = gst_promise_get_reply (promise);
//    if (error in reply)
//      return; // propagate error
//    p = gst_promise_new_with_change_func (another_promise_change_func, user_data, notify);
//    pass p to promise-using API
//
// Each Promise starts out with a PromiseResult of GST_PROMISE_RESULT_PENDING
// and only ever transitions once into one of the other PromiseResult's.
//
// In order to support multi-threaded code, gst_promise_reply(),
// gst_promise_interrupt() and gst_promise_expire() may all be from different
// threads with some restrictions and the final result of the promise is
// whichever call is made first. There are two restrictions on ordering:
//
// 1. That gst_promise_reply() and gst_promise_interrupt() cannot be called
// after gst_promise_expire() 2. That gst_promise_reply() and
// gst_promise_interrupt() cannot be called twice.
//
// The change function set with gst_promise_new_with_change_func() is called
// directly from either the gst_promise_reply(), gst_promise_interrupt() or
// gst_promise_expire() and can be called from an arbitrary thread. Promise
// using APIs can restrict this to a single thread or a subset of threads but
// that is entirely up to the API that uses Promise.
//
// An instance of this type is always passed by reference.
type Promise struct {
	*promise
}

// promise is the struct that's finalized.
type promise struct {
	native *C.GstPromise
}

func marshalPromise(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Promise{&promise{(*C.GstPromise)(b)}}, nil
}

// NewPromise constructs a struct Promise.
func NewPromise() *Promise {
	var _cret *C.GstPromise // in

	_cret = C.gst_promise_new()

	var _promise *Promise // out

	_promise = (*Promise)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_promise)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _promise
}

// NewPromiseWithChangeFunc constructs a struct Promise.
func NewPromiseWithChangeFunc(fn PromiseChangeFunc) *Promise {
	var _arg1 C.GstPromiseChangeFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GstPromise // in

	_arg1 = (*[0]byte)(C._gotk4_gst1_PromiseChangeFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_promise_new_with_change_func(_arg1, _arg2, _arg3)
	runtime.KeepAlive(fn)

	var _promise *Promise // out

	_promise = (*Promise)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_promise)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _promise
}

// Parent: parent MiniObject.
func (p *Promise) Parent() *MiniObject {
	valptr := &p.native.parent
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Expire a promise. This will wake up any waiters with
// GST_PROMISE_RESULT_EXPIRED. Called by a message loop when the parent message
// is handled and/or destroyed (possibly unanswered).
func (promise *Promise) Expire() {
	var _arg0 *C.GstPromise // out

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	C.gst_promise_expire(_arg0)
	runtime.KeepAlive(promise)
}

// GetReply: retrieve the reply set on promise. promise must be in
// GST_PROMISE_RESULT_REPLIED and the returned structure is owned by promise.
//
// The function returns the following values:
//
//    - structure (optional): reply set on promise.
//
func (promise *Promise) GetReply() *Structure {
	var _arg0 *C.GstPromise   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	_cret = C.gst_promise_get_reply(_arg0)
	runtime.KeepAlive(promise)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// Interrupt waiting for a promise. This will wake up any waiters with
// GST_PROMISE_RESULT_INTERRUPTED. Called when the consumer does not want the
// value produced anymore.
func (promise *Promise) Interrupt() {
	var _arg0 *C.GstPromise // out

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	C.gst_promise_interrupt(_arg0)
	runtime.KeepAlive(promise)
}

// Reply: set a reply on promise. This will wake up any waiters with
// GST_PROMISE_RESULT_REPLIED. Called by the producer of the value to indicate
// success (or failure).
//
// If promise has already been interrupted by the consumer, then this reply is
// not visible to the consumer.
//
// The function takes the following parameters:
//
//    - s (optional) with the the reply contents.
//
func (promise *Promise) Reply(s *Structure) {
	var _arg0 *C.GstPromise   // out
	var _arg1 *C.GstStructure // out

	if promise != nil {
		_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))
	}
	if s != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(s)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(s)), nil)
	}

	C.gst_promise_reply(_arg0, _arg1)
	runtime.KeepAlive(promise)
	runtime.KeepAlive(s)
}

// Wait for promise to move out of the GST_PROMISE_RESULT_PENDING state. If
// promise is not in GST_PROMISE_RESULT_PENDING then it will return immediately
// with the current result.
//
// The function returns the following values:
//
//    - promiseResult: result of the promise.
//
func (promise *Promise) Wait() PromiseResult {
	var _arg0 *C.GstPromise      // out
	var _cret C.GstPromiseResult // in

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	_cret = C.gst_promise_wait(_arg0)
	runtime.KeepAlive(promise)

	var _promiseResult PromiseResult // out

	_promiseResult = PromiseResult(_cret)

	return _promiseResult
}
