// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gboolean _gotk4_gst1_BufferListFunc(GstBuffer**, guint, gpointer);
import "C"

// GType values.
var (
	GTypeBufferList = coreglib.Type(C.gst_buffer_list_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBufferList, F: marshalBufferList},
	})
}

// BufferListFunc: function that will be called from gst_buffer_list_foreach().
// The buffer field will point to a the reference of the buffer at idx.
//
// When this function returns TRUE, the next buffer will be returned. When FALSE
// is returned, gst_buffer_list_foreach() will return.
//
// When buffer is set to NULL, the item will be removed from the bufferlist.
// When buffer has been made writable, the new buffer reference can be assigned
// to buffer. This function is responsible for unreffing the old buffer when
// removing or modifying.
type BufferListFunc func(idx uint) (buffer *Buffer, ok bool)

// BufferList: buffer lists are an object containing a list of buffers.
//
// Buffer lists are created with gst_buffer_list_new() and filled with data
// using gst_buffer_list_insert().
//
// Buffer lists can be pushed on a srcpad with gst_pad_push_list(). This is
// interesting when multiple buffers need to be pushed in one go because it can
// reduce the amount of overhead for pushing each buffer individually.
//
// An instance of this type is always passed by reference.
type BufferList struct {
	*bufferList
}

// bufferList is the struct that's finalized.
type bufferList struct {
	native *C.GstBufferList
}

func marshalBufferList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &BufferList{&bufferList{(*C.GstBufferList)(b)}}, nil
}

// NewBufferList constructs a struct BufferList.
func NewBufferList() *BufferList {
	var _cret *C.GstBufferList // in

	_cret = C.gst_buffer_list_new()

	var _bufferList *BufferList // out

	_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bufferList
}

// NewBufferListSized constructs a struct BufferList.
func NewBufferListSized(size uint) *BufferList {
	var _arg1 C.guint          // out
	var _cret *C.GstBufferList // in

	_arg1 = C.guint(size)

	_cret = C.gst_buffer_list_new_sized(_arg1)
	runtime.KeepAlive(size)

	var _bufferList *BufferList // out

	_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bufferList
}

// CalculateSize calculates the size of the data contained in list by adding the
// size of all buffers.
//
// The function returns the following values:
//
//    - gsize: size of the data contained in list in bytes.
//
func (list *BufferList) CalculateSize() uint {
	var _arg0 *C.GstBufferList // out
	var _cret C.gsize          // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_buffer_list_calculate_size(_arg0)
	runtime.KeepAlive(list)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// CopyDeep creates a copy of the given buffer list. This will make a newly
// allocated copy of the buffers that the source buffer list contains.
//
// The function returns the following values:
//
//    - bufferList: new copy of list.
//
func (list *BufferList) CopyDeep() *BufferList {
	var _arg0 *C.GstBufferList // out
	var _cret *C.GstBufferList // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_buffer_list_copy_deep(_arg0)
	runtime.KeepAlive(list)

	var _bufferList *BufferList // out

	_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bufferList
}

// ForEach calls func with data for each buffer in list.
//
// func can modify the passed buffer pointer or its contents. The return value
// of func defines if this function returns or if the remaining buffers in the
// list should be skipped.
//
// The function takes the following parameters:
//
//    - fn to call.
//
// The function returns the following values:
//
//    - ok: TRUE when func returned TRUE for each buffer in list or when list is
//      empty.
//
func (list *BufferList) ForEach(fn BufferListFunc) bool {
	var _arg0 *C.GstBufferList    // out
	var _arg1 C.GstBufferListFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_BufferListFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_buffer_list_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Get gets the buffer at idx.
//
// You must make sure that idx does not exceed the number of buffers available.
//
// The function takes the following parameters:
//
//    - idx: index.
//
// The function returns the following values:
//
//    - buffer (optional) at idx in group or NULL when there is no buffer. The
//      buffer remains valid as long as list is valid and buffer is not removed
//      from the list.
//
func (list *BufferList) Get(idx uint) *Buffer {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.guint          // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_list_get(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// Writable gets the buffer at idx, ensuring it is a writable buffer.
//
// You must make sure that idx does not exceed the number of buffers available.
//
// The function takes the following parameters:
//
//    - idx: index.
//
// The function returns the following values:
//
//    - buffer (optional) at idx in group. The returned buffer remains valid as
//      long as list is valid and the buffer is not removed from the list.
//
func (list *BufferList) Writable(idx uint) *Buffer {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.guint          // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_list_get_writable(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// Insert inserts buffer at idx in list. Other buffers are moved to make room
// for this new buffer.
//
// A -1 value for idx will append the buffer at the end.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - buffer: Buffer.
//
func (list *BufferList) Insert(idx int, buffer *Buffer) {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.gint           // out
	var _arg2 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.gint(idx)
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	C.gst_buffer_list_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(buffer)
}

// Length returns the number of buffers in list.
//
// The function returns the following values:
//
//    - guint: number of buffers in the buffer list.
//
func (list *BufferList) Length() uint {
	var _arg0 *C.GstBufferList // out
	var _cret C.guint          // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_buffer_list_length(_arg0)
	runtime.KeepAlive(list)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Remove removes length buffers starting from idx in list. The following
// buffers are moved to close the gap.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: amount to remove.
//
func (list *BufferList) Remove(idx uint, length uint) {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.guint          // out
	var _arg2 C.guint          // out

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(idx)
	_arg2 = C.guint(length)

	C.gst_buffer_list_remove(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
}
