// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_BufferPoolClass_reset_buffer(GstBufferPool*, GstBuffer*);
// extern void _gotk4_gst1_BufferPoolClass_release_buffer(GstBufferPool*, GstBuffer*);
// extern void _gotk4_gst1_BufferPoolClass_free_buffer(GstBufferPool*, GstBuffer*);
// extern void _gotk4_gst1_BufferPoolClass_flush_stop(GstBufferPool*);
// extern void _gotk4_gst1_BufferPoolClass_flush_start(GstBufferPool*);
// extern gchar** _gotk4_gst1_BufferPoolClass_get_options(GstBufferPool*);
// extern gboolean _gotk4_gst1_BufferPoolClass_stop(GstBufferPool*);
// extern gboolean _gotk4_gst1_BufferPoolClass_start(GstBufferPool*);
// extern gboolean _gotk4_gst1_BufferPoolClass_set_config(GstBufferPool*, GstStructure*);
// extern GstFlowReturn _gotk4_gst1_BufferPoolClass_alloc_buffer(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*);
// extern GstFlowReturn _gotk4_gst1_BufferPoolClass_acquire_buffer(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*);
// GstFlowReturn _gotk4_gst1_BufferPool_virtual_acquire_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer** arg1, GstBufferPoolAcquireParams* arg2) {
//   return ((GstFlowReturn (*)(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gst1_BufferPool_virtual_alloc_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer** arg1, GstBufferPoolAcquireParams* arg2) {
//   return ((GstFlowReturn (*)(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gst1_BufferPool_virtual_set_config(void* fnptr, GstBufferPool* arg0, GstStructure* arg1) {
//   return ((gboolean (*)(GstBufferPool*, GstStructure*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_BufferPool_virtual_start(void* fnptr, GstBufferPool* arg0) {
//   return ((gboolean (*)(GstBufferPool*))(fnptr))(arg0);
// };
// gboolean _gotk4_gst1_BufferPool_virtual_stop(void* fnptr, GstBufferPool* arg0) {
//   return ((gboolean (*)(GstBufferPool*))(fnptr))(arg0);
// };
// gchar** _gotk4_gst1_BufferPool_virtual_get_options(void* fnptr, GstBufferPool* arg0) {
//   return ((gchar** (*)(GstBufferPool*))(fnptr))(arg0);
// };
// void _gotk4_gst1_BufferPool_virtual_flush_start(void* fnptr, GstBufferPool* arg0) {
//   ((void (*)(GstBufferPool*))(fnptr))(arg0);
// };
// void _gotk4_gst1_BufferPool_virtual_flush_stop(void* fnptr, GstBufferPool* arg0) {
//   ((void (*)(GstBufferPool*))(fnptr))(arg0);
// };
// void _gotk4_gst1_BufferPool_virtual_free_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBufferPool*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_BufferPool_virtual_release_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBufferPool*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_BufferPool_virtual_reset_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBufferPool*, GstBuffer*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBufferPoolAcquireFlags = coreglib.Type(C.gst_buffer_pool_acquire_flags_get_type())
	GTypeBufferPool             = coreglib.Type(C.gst_buffer_pool_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBufferPoolAcquireFlags, F: marshalBufferPoolAcquireFlags},
		coreglib.TypeMarshaler{T: GTypeBufferPool, F: marshalBufferPool},
	})
}

// BufferPoolAcquireFlags: additional flags to control the allocation of a
// buffer.
type BufferPoolAcquireFlags C.guint

const (
	// BufferPoolAcquireFlagNone: no flags.
	BufferPoolAcquireFlagNone BufferPoolAcquireFlags = 0b0
	// BufferPoolAcquireFlagKeyUnit: buffer is keyframe.
	BufferPoolAcquireFlagKeyUnit BufferPoolAcquireFlags = 0b1
	// BufferPoolAcquireFlagDontwait: when the bufferpool is empty,
	// acquire_buffer will by default block until a buffer is released into the
	// pool again. Setting this flag makes acquire_buffer return T_FLOW_EOS
	// instead of blocking.
	BufferPoolAcquireFlagDontwait BufferPoolAcquireFlags = 0b10
	// BufferPoolAcquireFlagDiscont: buffer is discont.
	BufferPoolAcquireFlagDiscont BufferPoolAcquireFlags = 0b100
	// BufferPoolAcquireFlagLast: last flag, subclasses can use private flags
	// starting from this value.
	BufferPoolAcquireFlagLast BufferPoolAcquireFlags = 0b10000000000000000
)

func marshalBufferPoolAcquireFlags(p uintptr) (interface{}, error) {
	return BufferPoolAcquireFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BufferPoolAcquireFlags.
func (b BufferPoolAcquireFlags) String() string {
	if b == 0 {
		return "BufferPoolAcquireFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(139)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BufferPoolAcquireFlagNone:
			builder.WriteString("None|")
		case BufferPoolAcquireFlagKeyUnit:
			builder.WriteString("KeyUnit|")
		case BufferPoolAcquireFlagDontwait:
			builder.WriteString("Dontwait|")
		case BufferPoolAcquireFlagDiscont:
			builder.WriteString("Discont|")
		case BufferPoolAcquireFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BufferPoolAcquireFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BufferPoolAcquireFlags) Has(other BufferPoolAcquireFlags) bool {
	return (b & other) == other
}

// BufferPoolOverrides contains methods that are overridable.
type BufferPoolOverrides struct {
	// AcquireBuffer acquires a buffer from pool. buffer should point to a
	// memory location that can hold a pointer to the new buffer.
	//
	// params can contain optional parameters to influence the allocation.
	//
	// The function takes the following parameters:
	//
	//    - params (optional): parameters.
	//
	// The function returns the following values:
	//
	//    - buffer: location for a Buffer.
	//    - flowReturn such as GST_FLOW_FLUSHING when the pool is inactive.
	//
	AcquireBuffer func(params *BufferPoolAcquireParams) (*Buffer, FlowReturn)
	// AllocBuffer: allocate a buffer. the default implementation allocates
	// buffers from the configured memory allocator and with the configured
	// parameters. All metadata that is present on the allocated buffer will be
	// marked as T_META_FLAG_POOLED and T_META_FLAG_LOCKED and will not be
	// removed from the buffer in BufferPoolClass::reset_buffer. The buffer
	// should have the T_BUFFER_FLAG_TAG_MEMORY cleared.
	//
	// The function takes the following parameters:
	//
	//    - params (optional): parameters.
	//
	// The function returns the following values:
	//
	//    - buffer: location for a Buffer.
	//    - flowReturn to indicate whether the allocation was successful.
	//
	AllocBuffer func(params *BufferPoolAcquireParams) (*Buffer, FlowReturn)
	// FlushStart: enter the flushing state.
	FlushStart func()
	// FlushStop: leave the flushing state.
	FlushStop func()
	// FreeBuffer: free a buffer. The default implementation unrefs the buffer.
	//
	// The function takes the following parameters:
	//
	//    - buffer to free.
	//
	FreeBuffer func(buffer *Buffer)
	// Options gets a NULL terminated array of string with supported bufferpool
	// options for pool. An option would typically be enabled with
	// gst_buffer_pool_config_add_option().
	//
	// The function returns the following values:
	//
	//    - utf8s: NULL terminated array of strings.
	//
	Options func() []string
	// ReleaseBuffer releases buffer to pool. buffer should have previously been
	// allocated from pool with gst_buffer_pool_acquire_buffer().
	//
	// This function is usually called automatically when the last ref on buffer
	// disappears.
	//
	// The function takes the following parameters:
	//
	//    - buffer: Buffer.
	//
	ReleaseBuffer func(buffer *Buffer)
	// ResetBuffer: reset the buffer to its state when it was freshly allocated.
	// The default implementation will clear the flags, timestamps and will
	// remove the metadata without the T_META_FLAG_POOLED flag (even the
	// metadata with T_META_FLAG_LOCKED). If the T_BUFFER_FLAG_TAG_MEMORY was
	// set, this function can also try to restore the memory and clear the
	// T_BUFFER_FLAG_TAG_MEMORY again.
	//
	// The function takes the following parameters:
	//
	//    - buffer to reset.
	//
	ResetBuffer func(buffer *Buffer)
	// SetConfig sets the configuration of the pool. If the pool is already
	// configured, and the configuration hasn't changed, this function will
	// return TRUE. If the pool is active, this method will return FALSE and
	// active configuration will remain. Buffers allocated from this pool must
	// be returned or else this function will do nothing and return FALSE.
	//
	// config is a Structure that contains the configuration parameters for the
	// pool. A default and mandatory set of parameters can be configured with
	// gst_buffer_pool_config_set_params(),
	// gst_buffer_pool_config_set_allocator() and
	// gst_buffer_pool_config_add_option().
	//
	// If the parameters in config can not be set exactly, this function returns
	// FALSE and will try to update as much state as possible. The new state can
	// then be retrieved and refined with gst_buffer_pool_get_config().
	//
	// This function takes ownership of config.
	//
	// The function takes the following parameters:
	//
	//    - config: Structure.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE when the configuration could be set.
	//
	SetConfig func(config *Structure) bool
	// Start the bufferpool. The default implementation will preallocate
	// min-buffers buffers and put them in the queue.
	//
	// The function returns the following values:
	//
	//    - ok: whether the pool could be started.
	//
	Start func() bool
	// Stop the bufferpool. the default implementation will free the
	// preallocated buffers. This function is called when all the buffers are
	// returned to the pool.
	//
	// The function returns the following values:
	//
	//    - ok: whether the pool could be stopped.
	//
	Stop func() bool
}

func defaultBufferPoolOverrides(v *BufferPool) BufferPoolOverrides {
	return BufferPoolOverrides{
		AcquireBuffer: v.acquireBuffer,
		AllocBuffer:   v.allocBuffer,
		FlushStart:    v.flushStart,
		FlushStop:     v.flushStop,
		FreeBuffer:    v.freeBuffer,
		Options:       v.options,
		ReleaseBuffer: v.releaseBuffer,
		ResetBuffer:   v.resetBuffer,
		SetConfig:     v.setConfig,
		Start:         v.start,
		Stop:          v.stop,
	}
}

// BufferPool is an object that can be used to pre-allocate and recycle buffers
// of the same size and with the same properties.
//
// A BufferPool is created with gst_buffer_pool_new().
//
// Once a pool is created, it needs to be configured. A call to
// gst_buffer_pool_get_config() returns the current configuration structure from
// the pool. With gst_buffer_pool_config_set_params() and
// gst_buffer_pool_config_set_allocator() the bufferpool parameters and
// allocator can be configured. Other properties can be configured in the pool
// depending on the pool implementation.
//
// A bufferpool can have extra options that can be enabled with
// gst_buffer_pool_config_add_option(). The available options can be retrieved
// with gst_buffer_pool_get_options(). Some options allow for additional
// configuration properties to be set.
//
// After the configuration structure has been configured,
// gst_buffer_pool_set_config() updates the configuration in the pool. This can
// fail when the configuration structure is not accepted.
//
// After the pool has been configured, it can be activated with
// gst_buffer_pool_set_active(). This will preallocate the configured resources
// in the pool.
//
// When the pool is active, gst_buffer_pool_acquire_buffer() can be used to
// retrieve a buffer from the pool.
//
// Buffers allocated from a bufferpool will automatically be returned to the
// pool with gst_buffer_pool_release_buffer() when their refcount drops to 0.
//
// The bufferpool can be deactivated again with gst_buffer_pool_set_active().
// All further gst_buffer_pool_acquire_buffer() calls will return an error. When
// all buffers are returned to the pool they will be freed.
type BufferPool struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*BufferPool)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BufferPool, *BufferPoolClass, BufferPoolOverrides](
		GTypeBufferPool,
		initBufferPoolClass,
		wrapBufferPool,
		defaultBufferPoolOverrides,
	)
}

func initBufferPoolClass(gclass unsafe.Pointer, overrides BufferPoolOverrides, classInitFunc func(*BufferPoolClass)) {
	pclass := (*C.GstBufferPoolClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBufferPool))))

	if overrides.AcquireBuffer != nil {
		pclass.acquire_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_acquire_buffer)
	}

	if overrides.AllocBuffer != nil {
		pclass.alloc_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_alloc_buffer)
	}

	if overrides.FlushStart != nil {
		pclass.flush_start = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_flush_start)
	}

	if overrides.FlushStop != nil {
		pclass.flush_stop = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_flush_stop)
	}

	if overrides.FreeBuffer != nil {
		pclass.free_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_free_buffer)
	}

	if overrides.Options != nil {
		pclass.get_options = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_get_options)
	}

	if overrides.ReleaseBuffer != nil {
		pclass.release_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_release_buffer)
	}

	if overrides.ResetBuffer != nil {
		pclass.reset_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_reset_buffer)
	}

	if overrides.SetConfig != nil {
		pclass.set_config = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_set_config)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_stop)
	}

	if classInitFunc != nil {
		class := (*BufferPoolClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBufferPool(obj *coreglib.Object) *BufferPool {
	return &BufferPool{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalBufferPool(p uintptr) (interface{}, error) {
	return wrapBufferPool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBufferPool creates a new BufferPool instance.
//
// The function returns the following values:
//
//    - bufferPool: new BufferPool instance.
//
func NewBufferPool() *BufferPool {
	var _cret *C.GstBufferPool // in

	_cret = C.gst_buffer_pool_new()

	var _bufferPool *BufferPool // out

	_bufferPool = wrapBufferPool(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferPool
}

// AcquireBuffer acquires a buffer from pool. buffer should point to a memory
// location that can hold a pointer to the new buffer.
//
// params can contain optional parameters to influence the allocation.
//
// The function takes the following parameters:
//
//    - params (optional): parameters.
//
// The function returns the following values:
//
//    - buffer: location for a Buffer.
//    - flowReturn such as GST_FLOW_FLUSHING when the pool is inactive.
//
func (pool *BufferPool) AcquireBuffer(params *BufferPoolAcquireParams) (*Buffer, FlowReturn) {
	var _arg0 *C.GstBufferPool              // out
	var _arg1 *C.GstBuffer                  // in
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if params != nil {
		_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_buffer_pool_acquire_buffer(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(params)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// Config gets a copy of the current configuration of the pool. This
// configuration can be modified and used for the gst_buffer_pool_set_config()
// call.
//
// The function returns the following values:
//
//    - structure: copy of the current configuration of pool.
//
func (pool *BufferPool) Config() *Structure {
	var _arg0 *C.GstBufferPool // out
	var _cret *C.GstStructure  // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_buffer_pool_get_config(_arg0)
	runtime.KeepAlive(pool)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// Options gets a NULL terminated array of string with supported bufferpool
// options for pool. An option would typically be enabled with
// gst_buffer_pool_config_add_option().
//
// The function returns the following values:
//
//    - utf8s: NULL terminated array of strings.
//
func (pool *BufferPool) Options() []string {
	var _arg0 *C.GstBufferPool // out
	var _cret **C.gchar        // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_buffer_pool_get_options(_arg0)
	runtime.KeepAlive(pool)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// HasOption checks if the bufferpool supports option.
//
// The function takes the following parameters:
//
//    - option: option.
//
// The function returns the following values:
//
//    - ok: TRUE if the buffer pool contains option.
//
func (pool *BufferPool) HasOption(option string) bool {
	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_buffer_pool_has_option(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(option)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive checks if pool is active. A pool can be activated with the
// gst_buffer_pool_set_active() call.
//
// The function returns the following values:
//
//    - ok: TRUE when the pool is active.
//
func (pool *BufferPool) IsActive() bool {
	var _arg0 *C.GstBufferPool // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_buffer_pool_is_active(_arg0)
	runtime.KeepAlive(pool)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReleaseBuffer releases buffer to pool. buffer should have previously been
// allocated from pool with gst_buffer_pool_acquire_buffer().
//
// This function is usually called automatically when the last ref on buffer
// disappears.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//
func (pool *BufferPool) ReleaseBuffer(buffer *Buffer) {
	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	C.gst_buffer_pool_release_buffer(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// SetActive controls the active state of pool. When the pool is inactive, new
// calls to gst_buffer_pool_acquire_buffer() will return with GST_FLOW_FLUSHING.
//
// Activating the bufferpool will preallocate all resources in the pool based on
// the configuration of the pool.
//
// Deactivating will free the resources again when there are no outstanding
// buffers. When there are outstanding buffers, they will be freed as soon as
// they are all returned to the pool.
//
// The function takes the following parameters:
//
//    - active: new active state.
//
// The function returns the following values:
//
//    - ok: FALSE when the pool was not configured or when preallocation of the
//      buffers failed.
//
func (pool *BufferPool) SetActive(active bool) bool {
	var _arg0 *C.GstBufferPool // out
	var _arg1 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C.gst_buffer_pool_set_active(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetConfig sets the configuration of the pool. If the pool is already
// configured, and the configuration hasn't changed, this function will return
// TRUE. If the pool is active, this method will return FALSE and active
// configuration will remain. Buffers allocated from this pool must be returned
// or else this function will do nothing and return FALSE.
//
// config is a Structure that contains the configuration parameters for the
// pool. A default and mandatory set of parameters can be configured with
// gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
// and gst_buffer_pool_config_add_option().
//
// If the parameters in config can not be set exactly, this function returns
// FALSE and will try to update as much state as possible. The new state can
// then be retrieved and refined with gst_buffer_pool_get_config().
//
// This function takes ownership of config.
//
// The function takes the following parameters:
//
//    - config: Structure.
//
// The function returns the following values:
//
//    - ok: TRUE when the configuration could be set.
//
func (pool *BufferPool) SetConfig(config *Structure) bool {
	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstStructure  // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)

	_cret = C.gst_buffer_pool_set_config(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlushing enables or disables the flushing state of a pool without freeing
// or allocating buffers.
//
// The function takes the following parameters:
//
//    - flushing: whether to start or stop flushing.
//
func (pool *BufferPool) SetFlushing(flushing bool) {
	var _arg0 *C.GstBufferPool // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if flushing {
		_arg1 = C.TRUE
	}

	C.gst_buffer_pool_set_flushing(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(flushing)
}

// acquireBuffer acquires a buffer from pool. buffer should point to a memory
// location that can hold a pointer to the new buffer.
//
// params can contain optional parameters to influence the allocation.
//
// The function takes the following parameters:
//
//    - params (optional): parameters.
//
// The function returns the following values:
//
//    - buffer: location for a Buffer.
//    - flowReturn such as GST_FLOW_FLUSHING when the pool is inactive.
//
func (pool *BufferPool) acquireBuffer(params *BufferPoolAcquireParams) (*Buffer, FlowReturn) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.acquire_buffer

	var _arg0 *C.GstBufferPool              // out
	var _arg1 *C.GstBuffer                  // in
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if params != nil {
		_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C._gotk4_gst1_BufferPool_virtual_acquire_buffer(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(params)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// allocBuffer: allocate a buffer. the default implementation allocates buffers
// from the configured memory allocator and with the configured parameters. All
// metadata that is present on the allocated buffer will be marked as
// T_META_FLAG_POOLED and T_META_FLAG_LOCKED and will not be removed from the
// buffer in BufferPoolClass::reset_buffer. The buffer should have the
// T_BUFFER_FLAG_TAG_MEMORY cleared.
//
// The function takes the following parameters:
//
//    - params (optional): parameters.
//
// The function returns the following values:
//
//    - buffer: location for a Buffer.
//    - flowReturn to indicate whether the allocation was successful.
//
func (pool *BufferPool) allocBuffer(params *BufferPoolAcquireParams) (*Buffer, FlowReturn) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.alloc_buffer

	var _arg0 *C.GstBufferPool              // out
	var _arg1 *C.GstBuffer                  // in
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if params != nil {
		_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C._gotk4_gst1_BufferPool_virtual_alloc_buffer(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(params)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// flushStart: enter the flushing state.
func (pool *BufferPool) flushStart() {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.flush_start

	var _arg0 *C.GstBufferPool // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C._gotk4_gst1_BufferPool_virtual_flush_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)
}

// flushStop: leave the flushing state.
func (pool *BufferPool) flushStop() {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.flush_stop

	var _arg0 *C.GstBufferPool // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C._gotk4_gst1_BufferPool_virtual_flush_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)
}

// freeBuffer: free a buffer. The default implementation unrefs the buffer.
//
// The function takes the following parameters:
//
//    - buffer to free.
//
func (pool *BufferPool) freeBuffer(buffer *Buffer) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.free_buffer

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C._gotk4_gst1_BufferPool_virtual_free_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// Options gets a NULL terminated array of string with supported bufferpool
// options for pool. An option would typically be enabled with
// gst_buffer_pool_config_add_option().
//
// The function returns the following values:
//
//    - utf8s: NULL terminated array of strings.
//
func (pool *BufferPool) options() []string {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.get_options

	var _arg0 *C.GstBufferPool // out
	var _cret **C.gchar        // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C._gotk4_gst1_BufferPool_virtual_get_options(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// releaseBuffer releases buffer to pool. buffer should have previously been
// allocated from pool with gst_buffer_pool_acquire_buffer().
//
// This function is usually called automatically when the last ref on buffer
// disappears.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//
func (pool *BufferPool) releaseBuffer(buffer *Buffer) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.release_buffer

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	C._gotk4_gst1_BufferPool_virtual_release_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// resetBuffer: reset the buffer to its state when it was freshly allocated. The
// default implementation will clear the flags, timestamps and will remove the
// metadata without the T_META_FLAG_POOLED flag (even the metadata with
// T_META_FLAG_LOCKED). If the T_BUFFER_FLAG_TAG_MEMORY was set, this function
// can also try to restore the memory and clear the T_BUFFER_FLAG_TAG_MEMORY
// again.
//
// The function takes the following parameters:
//
//    - buffer to reset.
//
func (pool *BufferPool) resetBuffer(buffer *Buffer) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.reset_buffer

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C._gotk4_gst1_BufferPool_virtual_reset_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// setConfig sets the configuration of the pool. If the pool is already
// configured, and the configuration hasn't changed, this function will return
// TRUE. If the pool is active, this method will return FALSE and active
// configuration will remain. Buffers allocated from this pool must be returned
// or else this function will do nothing and return FALSE.
//
// config is a Structure that contains the configuration parameters for the
// pool. A default and mandatory set of parameters can be configured with
// gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
// and gst_buffer_pool_config_add_option().
//
// If the parameters in config can not be set exactly, this function returns
// FALSE and will try to update as much state as possible. The new state can
// then be retrieved and refined with gst_buffer_pool_get_config().
//
// This function takes ownership of config.
//
// The function takes the following parameters:
//
//    - config: Structure.
//
// The function returns the following values:
//
//    - ok: TRUE when the configuration could be set.
//
func (pool *BufferPool) setConfig(config *Structure) bool {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.set_config

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstStructure  // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)

	_cret = C._gotk4_gst1_BufferPool_virtual_set_config(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start: start the bufferpool. The default implementation will preallocate
// min-buffers buffers and put them in the queue.
//
// The function returns the following values:
//
//    - ok: whether the pool could be started.
//
func (pool *BufferPool) start() bool {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.start

	var _arg0 *C.GstBufferPool // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C._gotk4_gst1_BufferPool_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop: stop the bufferpool. the default implementation will free the
// preallocated buffers. This function is called when all the buffers are
// returned to the pool.
//
// The function returns the following values:
//
//    - ok: whether the pool could be stopped.
//
func (pool *BufferPool) stop() bool {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.stop

	var _arg0 *C.GstBufferPool // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C._gotk4_gst1_BufferPool_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferPoolConfigAddOption enables the option in config. This will instruct
// the bufferpool to enable the specified option on the buffers that it
// allocates.
//
// The options supported by pool can be retrieved with
// gst_buffer_pool_get_options().
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//    - option to add.
//
func BufferPoolConfigAddOption(config *Structure, option string) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.gchar        // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_buffer_pool_config_add_option(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(option)
}

// BufferPoolConfigGetAllocator gets the allocator and params from config.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//
// The function returns the following values:
//
//    - allocator (optional) or NULL.
//    - params (optional) or NULL.
//    - ok: TRUE, if the values are set.
//
func BufferPoolConfigGetAllocator(config *Structure) (Allocatorrer, *AllocationParams, bool) {
	var _arg1 *C.GstStructure       // out
	var _arg2 *C.GstAllocator       // in
	var _arg3 C.GstAllocationParams // in
	var _cret C.gboolean            // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_get_allocator(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(config)

	var _allocator Allocatorrer   // out
	var _params *AllocationParams // out
	var _ok bool                  // out

	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Allocatorrer)
				return ok
			})
			rv, ok := casted.(Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _allocator, _params, _ok
}

// BufferPoolConfigGetOption parses an available config and gets the option at
// index of the options API array.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//    - index: position in the option array to read.
//
// The function returns the following values:
//
//    - utf8 (optional): option at index.
//
func BufferPoolConfigGetOption(config *Structure, index uint) string {
	var _arg1 *C.GstStructure // out
	var _arg2 C.guint         // out
	var _cret *C.gchar        // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = C.guint(index)

	_cret = C.gst_buffer_pool_config_get_option(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(index)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// BufferPoolConfigGetParams gets the configuration values from config.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//
// The function returns the following values:
//
//    - caps (optional) of buffers.
//    - size (optional) of each buffer, not including prefix and padding.
//    - minBuffers (optional): minimum amount of buffers to allocate.
//    - maxBuffers (optional): maximum amount of buffers to allocate or 0 for
//      unlimited.
//    - ok: TRUE if all parameters could be fetched.
//
func BufferPoolConfigGetParams(config *Structure) (caps *Caps, size, minBuffers, maxBuffers uint, ok bool) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.GstCaps      // in
	var _arg3 C.guint         // in
	var _arg4 C.guint         // in
	var _arg5 C.guint         // in
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_get_params(_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(config)

	var _caps *Caps      // out
	var _size uint       // out
	var _minBuffers uint // out
	var _maxBuffers uint // out
	var _ok bool         // out

	if _arg2 != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	}
	_size = uint(_arg3)
	_minBuffers = uint(_arg4)
	_maxBuffers = uint(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _caps, _size, _minBuffers, _maxBuffers, _ok
}

// BufferPoolConfigHasOption checks if config contains option.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//    - option: option.
//
// The function returns the following values:
//
//    - ok: TRUE if the options array contains option.
//
func BufferPoolConfigHasOption(config *Structure, option string) bool {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_buffer_pool_config_has_option(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(option)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferPoolConfigNOptions retrieves the number of values currently stored in
// the options array of the config structure.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//
// The function returns the following values:
//
//    - guint options array size as a #guint.
//
func BufferPoolConfigNOptions(config *Structure) uint {
	var _arg1 *C.GstStructure // out
	var _cret C.guint         // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_n_options(_arg1)
	runtime.KeepAlive(config)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// BufferPoolConfigSetAllocator sets the allocator and params on config.
//
// One of allocator and params can be NULL, but not both. When allocator is
// NULL, the default allocator of the pool will use the values in param to
// perform its allocation. When param is NULL, the pool will use the provided
// allocator with its default AllocationParams.
//
// A call to gst_buffer_pool_set_config() can update the allocator and params
// with the values that it is able to do. Some pools are, for example, not able
// to operate with different allocators or cannot allocate with the values
// specified in params. Use gst_buffer_pool_get_config() to get the currently
// used values.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//    - allocator (optional): Allocator.
//    - params (optional): AllocationParams.
//
func BufferPoolConfigSetAllocator(config *Structure, allocator Allocatorrer, params *AllocationParams) {
	var _arg1 *C.GstStructure        // out
	var _arg2 *C.GstAllocator        // out
	var _arg3 *C.GstAllocationParams // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if allocator != nil {
		_arg2 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_buffer_pool_config_set_allocator(_arg1, _arg2, _arg3)
	runtime.KeepAlive(config)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// BufferPoolConfigSetParams configures config with the given parameters.
//
// The function takes the following parameters:
//
//    - config: BufferPool configuration.
//    - caps (optional) for the buffers.
//    - size of each buffer, not including prefix and padding.
//    - minBuffers: minimum amount of buffers to allocate.
//    - maxBuffers: maximum amount of buffers to allocate or 0 for unlimited.
//
func BufferPoolConfigSetParams(config *Structure, caps *Caps, size, minBuffers, maxBuffers uint) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.GstCaps      // out
	var _arg3 C.guint         // out
	var _arg4 C.guint         // out
	var _arg5 C.guint         // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg3 = C.guint(size)
	_arg4 = C.guint(minBuffers)
	_arg5 = C.guint(maxBuffers)

	C.gst_buffer_pool_config_set_params(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(config)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)
}

// BufferPoolAcquireParams parameters passed to the
// gst_buffer_pool_acquire_buffer() function to control the allocation of the
// buffer.
//
// The default implementation ignores the start and stop members but other
// implementations can use this extra information to decide what buffer to
// return.
//
// An instance of this type is always passed by reference.
type BufferPoolAcquireParams struct {
	*bufferPoolAcquireParams
}

// bufferPoolAcquireParams is the struct that's finalized.
type bufferPoolAcquireParams struct {
	native *C.GstBufferPoolAcquireParams
}

// Format: format of start and stop.
func (b *BufferPoolAcquireParams) Format() Format {
	valptr := &b.native.format
	var _v Format // out
	_v = Format(*valptr)
	return _v
}

// Start: start position.
func (b *BufferPoolAcquireParams) Start() int64 {
	valptr := &b.native.start
	var _v int64 // out
	_v = int64(*valptr)
	return _v
}

// Stop: stop position.
func (b *BufferPoolAcquireParams) Stop() int64 {
	valptr := &b.native.stop
	var _v int64 // out
	_v = int64(*valptr)
	return _v
}

// Flags: additional flags.
func (b *BufferPoolAcquireParams) Flags() BufferPoolAcquireFlags {
	valptr := &b.native.flags
	var _v BufferPoolAcquireFlags // out
	_v = BufferPoolAcquireFlags(*valptr)
	return _v
}

// Start: start position.
func (b *BufferPoolAcquireParams) SetStart(start int64) {
	valptr := &b.native.start
	*valptr = C.gint64(start)
}

// Stop: stop position.
func (b *BufferPoolAcquireParams) SetStop(stop int64) {
	valptr := &b.native.stop
	*valptr = C.gint64(stop)
}

// BufferPoolClass class.
//
// An instance of this type is always passed by reference.
type BufferPoolClass struct {
	*bufferPoolClass
}

// bufferPoolClass is the struct that's finalized.
type bufferPoolClass struct {
	native *C.GstBufferPoolClass
}

// ObjectClass: object parent class.
func (b *BufferPoolClass) ObjectClass() *ObjectClass {
	valptr := &b.native.object_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
