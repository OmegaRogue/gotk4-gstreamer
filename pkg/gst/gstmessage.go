// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeProgressType        = coreglib.Type(C.gst_progress_type_get_type())
	GTypeStreamStatusType    = coreglib.Type(C.gst_stream_status_type_get_type())
	GTypeStructureChangeType = coreglib.Type(C.gst_structure_change_type_get_type())
	GTypeMessageType         = coreglib.Type(C.gst_message_type_get_type())
	GTypeMessage             = coreglib.Type(C.gst_message_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeProgressType, F: marshalProgressType},
		coreglib.TypeMarshaler{T: GTypeStreamStatusType, F: marshalStreamStatusType},
		coreglib.TypeMarshaler{T: GTypeStructureChangeType, F: marshalStructureChangeType},
		coreglib.TypeMarshaler{T: GTypeMessageType, F: marshalMessageType},
		coreglib.TypeMarshaler{T: GTypeMessage, F: marshalMessage},
	})
}

// ProgressType: type of a GST_MESSAGE_PROGRESS. The progress messages inform
// the application of the status of asynchronous tasks.
type ProgressType C.gint

const (
	// ProgressTypeStart: new task started.
	ProgressTypeStart ProgressType = iota
	// ProgressTypeContinue: task completed and a new one continues.
	ProgressTypeContinue
	// ProgressTypeComplete: task completed.
	ProgressTypeComplete
	// ProgressTypeCanceled: task was canceled.
	ProgressTypeCanceled
	// ProgressTypeError: task caused an error. An error message is also posted
	// on the bus.
	ProgressTypeError
)

func marshalProgressType(p uintptr) (interface{}, error) {
	return ProgressType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ProgressType.
func (p ProgressType) String() string {
	switch p {
	case ProgressTypeStart:
		return "Start"
	case ProgressTypeContinue:
		return "Continue"
	case ProgressTypeComplete:
		return "Complete"
	case ProgressTypeCanceled:
		return "Canceled"
	case ProgressTypeError:
		return "Error"
	default:
		return fmt.Sprintf("ProgressType(%d)", p)
	}
}

// StreamStatusType: type of a GST_MESSAGE_STREAM_STATUS. The stream status
// messages inform the application of new streaming threads and their status.
type StreamStatusType C.gint

const (
	// StreamStatusTypeCreate: new thread need to be created.
	StreamStatusTypeCreate StreamStatusType = 0
	// StreamStatusTypeEnter: thread entered its loop function.
	StreamStatusTypeEnter StreamStatusType = 1
	// StreamStatusTypeLeave: thread left its loop function.
	StreamStatusTypeLeave StreamStatusType = 2
	// StreamStatusTypeDestroy: thread is destroyed.
	StreamStatusTypeDestroy StreamStatusType = 3
	// StreamStatusTypeStart: thread is started.
	StreamStatusTypeStart StreamStatusType = 8
	// StreamStatusTypePause: thread is paused.
	StreamStatusTypePause StreamStatusType = 9
	// StreamStatusTypeStop: thread is stopped.
	StreamStatusTypeStop StreamStatusType = 10
)

func marshalStreamStatusType(p uintptr) (interface{}, error) {
	return StreamStatusType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StreamStatusType.
func (s StreamStatusType) String() string {
	switch s {
	case StreamStatusTypeCreate:
		return "Create"
	case StreamStatusTypeEnter:
		return "Enter"
	case StreamStatusTypeLeave:
		return "Leave"
	case StreamStatusTypeDestroy:
		return "Destroy"
	case StreamStatusTypeStart:
		return "Start"
	case StreamStatusTypePause:
		return "Pause"
	case StreamStatusTypeStop:
		return "Stop"
	default:
		return fmt.Sprintf("StreamStatusType(%d)", s)
	}
}

// StructureChangeType: type of a GST_MESSAGE_STRUCTURE_CHANGE.
type StructureChangeType C.gint

const (
	// StructureChangeTypePadLink: pad linking is starting or done.
	StructureChangeTypePadLink StructureChangeType = iota
	// StructureChangeTypePadUnlink: pad unlinking is starting or done.
	StructureChangeTypePadUnlink
)

func marshalStructureChangeType(p uintptr) (interface{}, error) {
	return StructureChangeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StructureChangeType.
func (s StructureChangeType) String() string {
	switch s {
	case StructureChangeTypePadLink:
		return "Link"
	case StructureChangeTypePadUnlink:
		return "Unlink"
	default:
		return fmt.Sprintf("StructureChangeType(%d)", s)
	}
}

// MessageType: different message types that are available.
type MessageType C.guint

const (
	// MessageUnknown: undefined message.
	MessageUnknown MessageType = 0b0
	// MessageEos: end-of-stream reached in a pipeline. The application will
	// only receive this message in the PLAYING state and every time it sets a
	// pipeline to PLAYING that is in the EOS state. The application can perform
	// a flushing seek in the pipeline, which will undo the EOS state again.
	MessageEos MessageType = 0b1
	// MessageError: error occurred. When the application receives an error
	// message it should stop playback of the pipeline and not assume that more
	// data will be played. It is possible to specify a redirection url to the
	// error messages by setting a redirect-location field into the error
	// message, application or high level bins might use the information as
	// required.
	MessageError MessageType = 0b10
	// MessageWarning: warning occurred.
	MessageWarning MessageType = 0b100
	// MessageInfo: info message occurred.
	MessageInfo MessageType = 0b1000
	// MessageTag: tag was found.
	MessageTag MessageType = 0b10000
	// MessageBuffering: pipeline is buffering. When the application receives a
	// buffering message in the PLAYING state for a non-live pipeline it must
	// PAUSE the pipeline until the buffering completes, when the percentage
	// field in the message is 100%. For live pipelines, no action must be
	// performed and the buffering percentage can be used to inform the user
	// about the progress.
	MessageBuffering MessageType = 0b100000
	// MessageStateChanged: state change happened.
	MessageStateChanged MessageType = 0b1000000
	// MessageStateDirty: element changed state in a streaming thread. This
	// message is deprecated.
	MessageStateDirty MessageType = 0b10000000
	// MessageStepDone: stepping operation finished.
	MessageStepDone MessageType = 0b100000000
	// MessageClockProvide: element notifies its capability of providing a
	// clock. This message is used internally and never forwarded to the
	// application.
	MessageClockProvide MessageType = 0b1000000000
	// MessageClockLost: current clock as selected by the pipeline became
	// unusable. The pipeline will select a new clock on the next PLAYING state
	// change. The application should set the pipeline to PAUSED and back to
	// PLAYING when this message is received.
	MessageClockLost MessageType = 0b10000000000
	// MessageNewClock: new clock was selected in the pipeline.
	MessageNewClock MessageType = 0b100000000000
	// MessageStructureChange: structure of the pipeline changed. This message
	// is used internally and never forwarded to the application.
	MessageStructureChange MessageType = 0b1000000000000
	// MessageStreamStatus status about a stream, emitted when it starts, stops,
	// errors, etc..
	MessageStreamStatus MessageType = 0b10000000000000
	// MessageApplication: message posted by the application, possibly via an
	// application-specific element.
	MessageApplication MessageType = 0b100000000000000
	// MessageElement: element-specific message, see the specific element's
	// documentation.
	MessageElement MessageType = 0b1000000000000000
	// MessageSegmentStart: pipeline started playback of a segment. This message
	// is used internally and never forwarded to the application.
	MessageSegmentStart MessageType = 0b10000000000000000
	// MessageSegmentDone: pipeline completed playback of a segment. This
	// message is forwarded to the application after all elements that posted
	// GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.
	MessageSegmentDone MessageType = 0b100000000000000000
	// MessageDurationChanged: duration of a pipeline changed. The application
	// can get the new duration with a duration query.
	MessageDurationChanged MessageType = 0b1000000000000000000
	// MessageLatency: posted by elements when their latency changes. The
	// application should recalculate and distribute a new latency.
	MessageLatency MessageType = 0b10000000000000000000
	// MessageAsyncStart: posted by elements when they start an ASYNC
	// StateChange. This message is not forwarded to the application but is used
	// internally.
	MessageAsyncStart MessageType = 0b100000000000000000000
	// MessageAsyncDone: posted by elements when they complete an ASYNC
	// StateChange. The application will only receive this message from the
	// toplevel pipeline.
	MessageAsyncDone MessageType = 0b1000000000000000000000
	// MessageRequestState: posted by elements when they want the pipeline to
	// change state. This message is a suggestion to the application which can
	// decide to perform the state change on (part of) the pipeline.
	MessageRequestState MessageType = 0b10000000000000000000000
	// MessageStepStart: stepping operation was started.
	MessageStepStart MessageType = 0b100000000000000000000000
	// MessageQos: buffer was dropped or an element changed its processing
	// strategy for Quality of Service reasons.
	MessageQos MessageType = 0b1000000000000000000000000
	// MessageProgress progress message.
	MessageProgress MessageType = 0b10000000000000000000000000
	// MessageToc: new table of contents (TOC) was found or previously found TOC
	// was updated.
	MessageToc MessageType = 0b100000000000000000000000000
	// MessageResetTime: message to request resetting the pipeline's running
	// time from the pipeline. This is an internal message which applications
	// will likely never receive.
	MessageResetTime MessageType = 0b1000000000000000000000000000
	// MessageStreamStart: message indicating start of a new stream. Useful e.g.
	// when using playbin in gapless playback mode, to get notified when the
	// next title actually starts playing (which will be some time after the URI
	// for the next title has been set).
	MessageStreamStart MessageType = 0b10000000000000000000000000000
	// MessageNeedContext: message indicating that an element wants a specific
	// context (Since: 1.2).
	MessageNeedContext MessageType = 0b100000000000000000000000000000
	// MessageHaveContext: message indicating that an element created a context
	// (Since: 1.2).
	MessageHaveContext MessageType = 0b1000000000000000000000000000000
	// MessageExtended: message is an extended message type (see below). These
	// extended message IDs can't be used directly with mask-based API like
	// gst_bus_poll() or gst_bus_timed_pop_filtered(), but you can still filter
	// for GST_MESSAGE_EXTENDED and then check the result for the specific type.
	// (Since: 1.4).
	MessageExtended MessageType = 0b10000000000000000000000000000000
	// MessageDeviceAdded: message indicating a Device was added to a
	// DeviceProvider (Since: 1.4).
	MessageDeviceAdded MessageType = 0b10000000000000000000000000000001
	// MessageDeviceRemoved: message indicating a Device was removed from a
	// DeviceProvider (Since: 1.4).
	MessageDeviceRemoved MessageType = 0b10000000000000000000000000000010
	// MessagePropertyNotify: message indicating a #GObject property has changed
	// (Since: 1.10).
	MessagePropertyNotify MessageType = 0b10000000000000000000000000000011
	// MessageStreamCollection: message indicating a new StreamCollection is
	// available (Since: 1.10).
	MessageStreamCollection MessageType = 0b10000000000000000000000000000100
	// MessageStreamsSelected: message indicating the active selection of
	// Streams has changed (Since: 1.10).
	MessageStreamsSelected MessageType = 0b10000000000000000000000000000101
	// MessageRedirect: message indicating to request the application to try to
	// play the given URL(s). Useful if for example a HTTP 302/303 response is
	// received with a non-HTTP URL inside. (Since: 1.10).
	MessageRedirect MessageType = 0b10000000000000000000000000000110
	// MessageDeviceChanged: message indicating a Device was changed a
	// DeviceProvider (Since: 1.16).
	MessageDeviceChanged MessageType = 0b10000000000000000000000000000111
	// MessageInstantRateRequest: message sent by elements to request the
	// running time from the pipeline when an instant rate change should be
	// applied (which may be in the past when the answer arrives). (Since:
	// 1.18).
	MessageInstantRateRequest MessageType = 0b10000000000000000000000000001000
	// MessageAny: mask for all of the above messages.
	MessageAny MessageType = 0b11111111111111111111111111111111
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MessageType.
func (m MessageType) String() string {
	if m == 0 {
		return "MessageType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MessageUnknown:
			builder.WriteString("Unknown|")
		case MessageEos:
			builder.WriteString("Eos|")
		case MessageError:
			builder.WriteString("Error|")
		case MessageWarning:
			builder.WriteString("Warning|")
		case MessageInfo:
			builder.WriteString("Info|")
		case MessageTag:
			builder.WriteString("Tag|")
		case MessageBuffering:
			builder.WriteString("Buffering|")
		case MessageStateChanged:
			builder.WriteString("StateChanged|")
		case MessageStateDirty:
			builder.WriteString("StateDirty|")
		case MessageStepDone:
			builder.WriteString("StepDone|")
		case MessageClockProvide:
			builder.WriteString("ClockProvide|")
		case MessageClockLost:
			builder.WriteString("ClockLost|")
		case MessageNewClock:
			builder.WriteString("NewClock|")
		case MessageStructureChange:
			builder.WriteString("StructureChange|")
		case MessageStreamStatus:
			builder.WriteString("StreamStatus|")
		case MessageApplication:
			builder.WriteString("Application|")
		case MessageElement:
			builder.WriteString("Element|")
		case MessageSegmentStart:
			builder.WriteString("SegmentStart|")
		case MessageSegmentDone:
			builder.WriteString("SegmentDone|")
		case MessageDurationChanged:
			builder.WriteString("DurationChanged|")
		case MessageLatency:
			builder.WriteString("Latency|")
		case MessageAsyncStart:
			builder.WriteString("AsyncStart|")
		case MessageAsyncDone:
			builder.WriteString("AsyncDone|")
		case MessageRequestState:
			builder.WriteString("RequestState|")
		case MessageStepStart:
			builder.WriteString("StepStart|")
		case MessageQos:
			builder.WriteString("Qos|")
		case MessageProgress:
			builder.WriteString("Progress|")
		case MessageToc:
			builder.WriteString("Toc|")
		case MessageResetTime:
			builder.WriteString("ResetTime|")
		case MessageStreamStart:
			builder.WriteString("StreamStart|")
		case MessageNeedContext:
			builder.WriteString("NeedContext|")
		case MessageHaveContext:
			builder.WriteString("HaveContext|")
		case MessageExtended:
			builder.WriteString("Extended|")
		case MessageDeviceAdded:
			builder.WriteString("DeviceAdded|")
		case MessageDeviceRemoved:
			builder.WriteString("DeviceRemoved|")
		case MessagePropertyNotify:
			builder.WriteString("PropertyNotify|")
		case MessageStreamCollection:
			builder.WriteString("StreamCollection|")
		case MessageStreamsSelected:
			builder.WriteString("StreamsSelected|")
		case MessageRedirect:
			builder.WriteString("Redirect|")
		case MessageDeviceChanged:
			builder.WriteString("DeviceChanged|")
		case MessageInstantRateRequest:
			builder.WriteString("InstantRateRequest|")
		case MessageAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("MessageType(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MessageType) Has(other MessageType) bool {
	return (m & other) == other
}

// MessageTypeGetName: get a printable name for the given message type. Do not
// modify or free.
//
// The function takes the following parameters:
//
//    - typ: message type.
//
// The function returns the following values:
//
//    - utf8: reference to the static name of the message.
//
func MessageTypeGetName(typ MessageType) string {
	var _arg1 C.GstMessageType // out
	var _cret *C.gchar         // in

	_arg1 = C.GstMessageType(typ)

	_cret = C.gst_message_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// MessageTypeToQuark: get the unique quark for the given message type.
//
// The function takes the following parameters:
//
//    - typ: message type.
//
// The function returns the following values:
//
//    - quark associated with the message type.
//
func MessageTypeToQuark(typ MessageType) glib.Quark {
	var _arg1 C.GstMessageType // out
	var _cret C.GQuark         // in

	_arg1 = C.GstMessageType(typ)

	_cret = C.gst_message_type_to_quark(_arg1)
	runtime.KeepAlive(typ)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// Message messages are implemented as a subclass of MiniObject with a generic
// Structure as the content. This allows for writing custom messages without
// requiring an API change while allowing a wide range of different types of
// messages.
//
// Messages are posted by objects in the pipeline and are passed to the
// application using the Bus.
//
// The basic use pattern of posting a message on a Bus is as follows:
//
//    gst_bus_post (bus, gst_message_new_eos());
//
// A Element usually posts messages on the bus provided by the parent container
// using gst_element_post_message().
//
// An instance of this type is always passed by reference.
type Message struct {
	*message
}

// message is the struct that's finalized.
type message struct {
	native *C.GstMessage
}

func marshalMessage(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Message{&message{(*C.GstMessage)(b)}}, nil
}

// NewMessageApplication constructs a struct Message.
func NewMessageApplication(src GstObjector, structure *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_message_new_application(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(structure)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessageAsyncDone constructs a struct Message.
func NewMessageAsyncDone(src GstObjector, runningTime ClockTime) *Message {
	var _arg1 *C.GstObject   // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GstMessage  // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.guint64(runningTime)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_message_new_async_done(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(runningTime)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageAsyncStart constructs a struct Message.
func NewMessageAsyncStart(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_async_start(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageBuffering constructs a struct Message.
func NewMessageBuffering(src GstObjector, percent int) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gint        // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.gint(percent)

	_cret = C.gst_message_new_buffering(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(percent)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessageClockLost constructs a struct Message.
func NewMessageClockLost(src GstObjector, clock Clocker) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstClock   // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_message_new_clock_lost(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(clock)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageClockProvide constructs a struct Message.
func NewMessageClockProvide(src GstObjector, clock Clocker, ready bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstClock   // out
	var _arg3 C.gboolean    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if ready {
		_arg3 = C.TRUE
	}

	_cret = C.gst_message_new_clock_provide(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(ready)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageCustom constructs a struct Message.
func NewMessageCustom(typ MessageType, src GstObjector, structure *Structure) *Message {
	var _arg1 C.GstMessageType // out
	var _arg2 *C.GstObject     // out
	var _arg3 *C.GstStructure  // out
	var _cret *C.GstMessage    // in

	_arg1 = C.GstMessageType(typ)
	if src != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if structure != nil {
		_arg3 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	}

	_cret = C.gst_message_new_custom(_arg1, _arg2, _arg3)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(src)
	runtime.KeepAlive(structure)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessageDeviceAdded constructs a struct Message.
func NewMessageDeviceAdded(src GstObjector, device Devicer) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstDevice  // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_message_new_device_added(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDeviceChanged constructs a struct Message.
func NewMessageDeviceChanged(src GstObjector, device Devicer, changedDevice Devicer) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstDevice  // out
	var _arg3 *C.GstDevice  // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg3 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(changedDevice).Native()))

	_cret = C.gst_message_new_device_changed(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)
	runtime.KeepAlive(changedDevice)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDeviceRemoved constructs a struct Message.
func NewMessageDeviceRemoved(src GstObjector, device Devicer) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstDevice  // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_message_new_device_removed(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDurationChanged constructs a struct Message.
func NewMessageDurationChanged(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_duration_changed(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageElement constructs a struct Message.
func NewMessageElement(src GstObjector, structure *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_message_new_element(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(structure)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessageEos constructs a struct Message.
func NewMessageEos(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_eos(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageError constructs a struct Message.
func NewMessageError(src GstObjector, err error, debug string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GError     // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_message_new_error(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageErrorWithDetails constructs a struct Message.
func NewMessageErrorWithDetails(src GstObjector, err error, debug string, details *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GError       // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))
	if details != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(details)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(details)), nil)
	}

	_cret = C.gst_message_new_error_with_details(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(details)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessageHaveContext constructs a struct Message.
func NewMessageHaveContext(src GstObjector, context *Context) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstContext // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(context)), nil)

	_cret = C.gst_message_new_have_context(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(context)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageInfo constructs a struct Message.
func NewMessageInfo(src GstObjector, err error, debug string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GError     // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_message_new_info(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageInfoWithDetails constructs a struct Message.
func NewMessageInfoWithDetails(src GstObjector, err error, debug string, details *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GError       // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))
	if details != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(details)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(details)), nil)
	}

	_cret = C.gst_message_new_info_with_details(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(details)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessageInstantRateRequest constructs a struct Message.
func NewMessageInstantRateRequest(src GstObjector, rateMultiplier float64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gdouble     // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = C.gdouble(rateMultiplier)

	_cret = C.gst_message_new_instant_rate_request(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(rateMultiplier)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageLatency constructs a struct Message.
func NewMessageLatency(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_latency(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageNeedContext constructs a struct Message.
func NewMessageNeedContext(src GstObjector, contextType string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_message_new_need_context(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(contextType)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageNewClock constructs a struct Message.
func NewMessageNewClock(src GstObjector, clock Clocker) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstClock   // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_message_new_new_clock(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(clock)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageProgress constructs a struct Message.
func NewMessageProgress(src GstObjector, typ ProgressType, code string, text string) *Message {
	var _arg1 *C.GstObject      // out
	var _arg2 C.GstProgressType // out
	var _arg3 *C.gchar          // out
	var _arg4 *C.gchar          // out
	var _cret *C.GstMessage     // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = C.GstProgressType(typ)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.gst_message_new_progress(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(code)
	runtime.KeepAlive(text)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// NewMessagePropertyNotify constructs a struct Message.
func NewMessagePropertyNotify(src GstObjector, propertyName string, val *coreglib.Value) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GValue     // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))
	if val != nil {
		_arg3 = (*C.GValue)(unsafe.Pointer(val.Native()))
	}

	_cret = C.gst_message_new_property_notify(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(val)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageQos constructs a struct Message.
func NewMessageQos(src GstObjector, live bool, runningTime uint64, streamTime uint64, timestamp uint64, duration uint64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gboolean    // out
	var _arg3 C.guint64     // out
	var _arg4 C.guint64     // out
	var _arg5 C.guint64     // out
	var _arg6 C.guint64     // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if live {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint64(runningTime)
	_arg4 = C.guint64(streamTime)
	_arg5 = C.guint64(timestamp)
	_arg6 = C.guint64(duration)

	_cret = C.gst_message_new_qos(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(src)
	runtime.KeepAlive(live)
	runtime.KeepAlive(runningTime)
	runtime.KeepAlive(streamTime)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageRequestState constructs a struct Message.
func NewMessageRequestState(src GstObjector, state State) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstState    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstState(state)

	_cret = C.gst_message_new_request_state(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(state)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageResetTime constructs a struct Message.
func NewMessageResetTime(src GstObjector, runningTime ClockTime) *Message {
	var _arg1 *C.GstObject   // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GstMessage  // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.guint64(runningTime)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_message_new_reset_time(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(runningTime)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageSegmentDone constructs a struct Message.
func NewMessageSegmentDone(src GstObjector, format Format, position int64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstFormat   // out
	var _arg3 C.gint64      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstFormat(format)
	_arg3 = C.gint64(position)

	_cret = C.gst_message_new_segment_done(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageSegmentStart constructs a struct Message.
func NewMessageSegmentStart(src GstObjector, format Format, position int64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstFormat   // out
	var _arg3 C.gint64      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstFormat(format)
	_arg3 = C.gint64(position)

	_cret = C.gst_message_new_segment_start(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStateChanged constructs a struct Message.
func NewMessageStateChanged(src GstObjector, oldstate State, newstate State, pending State) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstState    // out
	var _arg3 C.GstState    // out
	var _arg4 C.GstState    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstState(oldstate)
	_arg3 = C.GstState(newstate)
	_arg4 = C.GstState(pending)

	_cret = C.gst_message_new_state_changed(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(oldstate)
	runtime.KeepAlive(newstate)
	runtime.KeepAlive(pending)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStateDirty constructs a struct Message.
func NewMessageStateDirty(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_state_dirty(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStepDone constructs a struct Message.
func NewMessageStepDone(src GstObjector, format Format, amount uint64, rate float64, flush bool, intermediate bool, duration uint64, eos bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstFormat   // out
	var _arg3 C.guint64     // out
	var _arg4 C.gdouble     // out
	var _arg5 C.gboolean    // out
	var _arg6 C.gboolean    // out
	var _arg7 C.guint64     // out
	var _arg8 C.gboolean    // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = C.GstFormat(format)
	_arg3 = C.guint64(amount)
	_arg4 = C.gdouble(rate)
	if flush {
		_arg5 = C.TRUE
	}
	if intermediate {
		_arg6 = C.TRUE
	}
	_arg7 = C.guint64(duration)
	if eos {
		_arg8 = C.TRUE
	}

	_cret = C.gst_message_new_step_done(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
	runtime.KeepAlive(amount)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(flush)
	runtime.KeepAlive(intermediate)
	runtime.KeepAlive(duration)
	runtime.KeepAlive(eos)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStepStart constructs a struct Message.
func NewMessageStepStart(src GstObjector, active bool, format Format, amount uint64, rate float64, flush bool, intermediate bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gboolean    // out
	var _arg3 C.GstFormat   // out
	var _arg4 C.guint64     // out
	var _arg5 C.gdouble     // out
	var _arg6 C.gboolean    // out
	var _arg7 C.gboolean    // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if active {
		_arg2 = C.TRUE
	}
	_arg3 = C.GstFormat(format)
	_arg4 = C.guint64(amount)
	_arg5 = C.gdouble(rate)
	if flush {
		_arg6 = C.TRUE
	}
	if intermediate {
		_arg7 = C.TRUE
	}

	_cret = C.gst_message_new_step_start(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(src)
	runtime.KeepAlive(active)
	runtime.KeepAlive(format)
	runtime.KeepAlive(amount)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(flush)
	runtime.KeepAlive(intermediate)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamCollection constructs a struct Message.
func NewMessageStreamCollection(src GstObjector, collection *StreamCollection) *Message {
	var _arg1 *C.GstObject           // out
	var _arg2 *C.GstStreamCollection // out
	var _cret *C.GstMessage          // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_message_new_stream_collection(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(collection)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamStart constructs a struct Message.
func NewMessageStreamStart(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_stream_start(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamStatus constructs a struct Message.
func NewMessageStreamStatus(src GstObjector, typ StreamStatusType, owner Elementer) *Message {
	var _arg1 *C.GstObject          // out
	var _arg2 C.GstStreamStatusType // out
	var _arg3 *C.GstElement         // out
	var _cret *C.GstMessage         // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = C.GstStreamStatusType(typ)
	_arg3 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(owner).Native()))

	_cret = C.gst_message_new_stream_status(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(owner)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamsSelected constructs a struct Message.
func NewMessageStreamsSelected(src GstObjector, collection *StreamCollection) *Message {
	var _arg1 *C.GstObject           // out
	var _arg2 *C.GstStreamCollection // out
	var _cret *C.GstMessage          // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_message_new_streams_selected(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(collection)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStructureChange constructs a struct Message.
func NewMessageStructureChange(src GstObjector, typ StructureChangeType, owner Elementer, busy bool) *Message {
	var _arg1 *C.GstObject             // out
	var _arg2 C.GstStructureChangeType // out
	var _arg3 *C.GstElement            // out
	var _arg4 C.gboolean               // out
	var _cret *C.GstMessage            // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstStructureChangeType(typ)
	_arg3 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(owner).Native()))
	if busy {
		_arg4 = C.TRUE
	}

	_cret = C.gst_message_new_structure_change(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(owner)
	runtime.KeepAlive(busy)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageToc constructs a struct Message.
func NewMessageToc(src GstObjector, toc *Toc, updated bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstToc     // out
	var _arg3 C.gboolean    // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	if updated {
		_arg3 = C.TRUE
	}

	_cret = C.gst_message_new_toc(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(updated)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageWarning constructs a struct Message.
func NewMessageWarning(src GstObjector, err error, debug string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GError     // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_message_new_warning(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageWarningWithDetails constructs a struct Message.
func NewMessageWarningWithDetails(src GstObjector, err error, debug string, details *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GError       // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))
	if details != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(details)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(details)), nil)
	}

	_cret = C.gst_message_new_warning_with_details(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(details)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// MiniObject: parent structure.
func (m *Message) MiniObject() *MiniObject {
	valptr := &m.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Type of the message.
func (m *Message) Type() MessageType {
	valptr := &m.native._type
	var _v MessageType // out
	_v = MessageType(*valptr)
	return _v
}

// Timestamp: timestamp of the message.
func (m *Message) Timestamp() uint64 {
	valptr := &m.native.timestamp
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Src: src of the message.
func (m *Message) Src() GstObjector {
	valptr := &m.native.src
	var _v GstObjector // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gst.GstObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GstObjector)
			return ok
		})
		rv, ok := casted.(GstObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
		}
		_v = rv
	}
	return _v
}

// Timestamp: timestamp of the message.
func (m *Message) SetTimestamp(timestamp uint64) {
	valptr := &m.native.timestamp
	*valptr = C.guint64(timestamp)
}

// The function returns the following values:
//
//    - gsize: number of entries stored in the message.
//
func (message *Message) NumRedirectEntries() uint {
	var _arg0 *C.GstMessage // out
	var _cret C.gsize       // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_num_redirect_entries(_arg0)
	runtime.KeepAlive(message)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Seqnum: retrieve the sequence number of a message.
//
// Messages have ever-incrementing sequence numbers, which may also be set
// explicitly via gst_message_set_seqnum(). Sequence numbers are typically used
// to indicate that a message corresponds to some other set of messages or
// events, for example a SEGMENT_DONE message corresponding to a SEEK event. It
// is considered good practice to make this correspondence when possible, though
// it is not required.
//
// Note that events and messages share the same sequence number incrementor; two
// events or messages will never have the same sequence number unless that
// correspondence was made explicitly.
//
// The function returns the following values:
//
//    - guint32 message's sequence number.
//
//      MT safe.
//
func (message *Message) Seqnum() uint32 {
	var _arg0 *C.GstMessage // out
	var _cret C.guint32     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_seqnum(_arg0)
	runtime.KeepAlive(message)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// StreamStatusObject extracts the object managing the streaming thread from
// message.
//
// The function returns the following values:
//
//    - value (optional): GValue containing the object that manages the streaming
//      thread. This object is usually of type GstTask but other types can be
//      added in the future. The object remains valid as long as message is
//      valid.
//
func (message *Message) StreamStatusObject() *coreglib.Value {
	var _arg0 *C.GstMessage // out
	var _cret *C.GValue     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_stream_status_object(_arg0)
	runtime.KeepAlive(message)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// Structure access the structure of the message.
//
// The function returns the following values:
//
//    - structure (optional) of the message. The structure is still owned by the
//      message, which means that you should not free it and that the pointer
//      becomes invalid when you free the message.
//
//      MT safe.
//
func (message *Message) Structure() *Structure {
	var _arg0 *C.GstMessage   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_structure(_arg0)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// HasName checks if message has the given name. This function is usually used
// to check the name of a custom message.
//
// The function takes the following parameters:
//
//    - name to check.
//
// The function returns the following values:
//
//    - ok: TRUE if name matches the name of the message structure.
//
func (message *Message) HasName(name string) bool {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_message_has_name(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseAsyncDone: extract the running_time from the async_done message.
//
// MT safe.
//
// The function returns the following values:
//
//    - runningTime (optional): result location for the running_time or NULL.
//
func (message *Message) ParseAsyncDone() ClockTime {
	var _arg0 *C.GstMessage  // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_async_done(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _runningTime ClockTime // out

	_runningTime = uint64(_arg1)
	type _ = ClockTime
	type _ = uint64

	return _runningTime
}

// ParseBuffering extracts the buffering percent from the GstMessage. see also
// gst_message_new_buffering().
//
// MT safe.
//
// The function returns the following values:
//
//    - percent (optional): return location for the percent.
//
func (message *Message) ParseBuffering() int {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gint        // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_buffering(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _percent int // out

	_percent = int(_arg1)

	return _percent
}

// ParseBufferingStats extracts the buffering stats values from message.
//
// The function returns the following values:
//
//    - mode (optional): buffering mode, or NULL.
//    - avgIn (optional): average input rate, or NULL.
//    - avgOut (optional): average output rate, or NULL.
//    - bufferingLeft (optional): amount of buffering time left in milliseconds,
//      or NULL.
//
func (message *Message) ParseBufferingStats() (mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstMessage      // out
	var _arg1 C.GstBufferingMode // in
	var _arg2 C.gint             // in
	var _arg3 C.gint             // in
	var _arg4 C.gint64           // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_buffering_stats(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(message)

	var _mode BufferingMode  // out
	var _avgIn int           // out
	var _avgOut int          // out
	var _bufferingLeft int64 // out

	_mode = BufferingMode(_arg1)
	_avgIn = int(_arg2)
	_avgOut = int(_arg3)
	_bufferingLeft = int64(_arg4)

	return _mode, _avgIn, _avgOut, _bufferingLeft
}

// ParseClockLost extracts the lost clock from the GstMessage. The clock object
// returned remains valid until the message is freed.
//
// MT safe.
//
// The function returns the following values:
//
//    - clock (optional): pointer to hold the lost clock.
//
func (message *Message) ParseClockLost() Clocker {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstClock   // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_clock_lost(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _clock Clocker // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// ParseClockProvide extracts the clock and ready flag from the GstMessage. The
// clock object returned remains valid until the message is freed.
//
// MT safe.
//
// The function returns the following values:
//
//    - clock (optional): pointer to hold a clock object, or NULL.
//    - ready (optional): pointer to hold the ready flag, or NULL.
//
func (message *Message) ParseClockProvide() (Clocker, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstClock   // in
	var _arg2 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_clock_provide(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _clock Clocker // out
	var _ready bool    // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}
	if _arg2 != 0 {
		_ready = true
	}

	return _clock, _ready
}

// ParseContextType: parse a context type from an existing
// GST_MESSAGE_NEED_CONTEXT message.
//
// The function returns the following values:
//
//    - contextType (optional): context type, or NULL.
//    - ok indicating if the parsing succeeded.
//
func (message *Message) ParseContextType() (string, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.gchar      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_parse_context_type(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _contextType string // out
	var _ok bool            // out

	if _arg1 != nil {
		_contextType = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _contextType, _ok
}

// ParseDeviceAdded parses a device-added message. The device-added message is
// produced by DeviceProvider or a DeviceMonitor. It announces the appearance of
// monitored devices.
//
// The function returns the following values:
//
//    - device (optional): location where to store a pointer to the new Device,
//      or NULL.
//
func (message *Message) ParseDeviceAdded() Devicer {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstDevice  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_device_added(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _device Devicer // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// ParseDeviceChanged parses a device-changed message. The device-changed
// message is produced by DeviceProvider or a DeviceMonitor. It announces the
// disappearance of monitored devices. * It announce that a device properties
// has changed and device represents the new modified version of changed_device.
//
// The function returns the following values:
//
//    - device (optional): location where to store a pointer to the updated
//      version of the Device, or NULL.
//    - changedDevice (optional): location where to store a pointer to the old
//      version of the Device, or NULL.
//
func (message *Message) ParseDeviceChanged() (device Devicer, changedDevice Devicer) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstDevice  // in
	var _arg2 *C.GstDevice  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_device_changed(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _device Devicer        // out
	var _changedDevice Devicer // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_device = rv
		}
	}
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_changedDevice = rv
		}
	}

	return _device, _changedDevice
}

// ParseDeviceRemoved parses a device-removed message. The device-removed
// message is produced by DeviceProvider or a DeviceMonitor. It announces the
// disappearance of monitored devices.
//
// The function returns the following values:
//
//    - device (optional): location where to store a pointer to the removed
//      Device, or NULL.
//
func (message *Message) ParseDeviceRemoved() Devicer {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstDevice  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_device_removed(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _device Devicer // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// ParseError extracts the GError and debug string from the GstMessage. The
// values returned in the output arguments are copies; the caller must free them
// when done.
//
// Typical usage of this function might be:
//
//      ...
//      switch (GST_MESSAGE_TYPE (msg)) {
//        case GST_MESSAGE_ERROR: {
//          GError *err = NULL;
//          gchar *dbg_info = NULL;
//
//          gst_message_parse_error (msg, &err, &dbg_info);
//          g_printerr ("ERROR from element s: s\n",
//              GST_OBJECT_NAME (msg->src), err->message);
//          g_printerr ("Debugging info: s\n", (dbg_info) ? dbg_info : "none");
//          g_error_free (err);
//          g_free (dbg_info);
//          break;
//        }
//        ...
//      }
//      ...
//
// MT safe.
//
// The function returns the following values:
//
//    - gerror (optional): location for the GError.
//    - debug (optional): location for the debug message, or NULL.
//
func (message *Message) ParseError() (error, string) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GError     // in
	var _arg2 *C.gchar      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_error(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _gerror error // out
	var _debug string // out

	if _arg1 != nil {
		_gerror = gerror.Take(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_debug = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	return _gerror, _debug
}

// ParseErrorDetails returns the optional details structure, may be NULL if
// none. The returned structure must not be freed.
//
// The function returns the following values:
//
//    - structure: pointer to the returned details.
//
func (message *Message) ParseErrorDetails() *Structure {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_error_details(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _structure
}

// ParseGroupID: extract the group from the STREAM_START message.
//
// The function returns the following values:
//
//    - groupId (optional): result location for the group id or NULL.
//    - ok: TRUE if the message had a group id set, FALSE otherwise
//
//      MT safe.
//
func (message *Message) ParseGroupID() (uint, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint       // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_parse_group_id(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _groupId uint // out
	var _ok bool      // out

	_groupId = uint(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _groupId, _ok
}

// ParseHaveContext: extract the context from the HAVE_CONTEXT message.
//
// MT safe.
//
// The function returns the following values:
//
//    - context (optional): result location for the context or NULL.
//
func (message *Message) ParseHaveContext() *Context {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstContext // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_have_context(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _context *Context // out

	if _arg1 != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_context)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _context
}

// ParseInfo extracts the GError and debug string from the GstMessage. The
// values returned in the output arguments are copies; the caller must free them
// when done.
//
// MT safe.
//
// The function returns the following values:
//
//    - gerror (optional): location for the GError.
//    - debug (optional): location for the debug message, or NULL.
//
func (message *Message) ParseInfo() (error, string) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GError     // in
	var _arg2 *C.gchar      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_info(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _gerror error // out
	var _debug string // out

	if _arg1 != nil {
		_gerror = gerror.Take(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_debug = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	return _gerror, _debug
}

// ParseInfoDetails returns the optional details structure, may be NULL if none
// The returned structure must not be freed.
//
// The function returns the following values:
//
//    - structure: pointer to the returned details structure.
//
func (message *Message) ParseInfoDetails() *Structure {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_info_details(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _structure
}

// ParseInstantRateRequest parses the rate_multiplier from the
// instant-rate-request message.
//
// The function returns the following values:
//
//    - rateMultiplier (optional): return location for the rate, or NULL.
//
func (message *Message) ParseInstantRateRequest() float64 {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gdouble     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_instant_rate_request(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _rateMultiplier float64 // out

	_rateMultiplier = float64(_arg1)

	return _rateMultiplier
}

// ParseNewClock extracts the new clock from the GstMessage. The clock object
// returned remains valid until the message is freed.
//
// MT safe.
//
// The function returns the following values:
//
//    - clock (optional): pointer to hold the selected new clock.
//
func (message *Message) ParseNewClock() Clocker {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstClock   // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_new_clock(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _clock Clocker // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// ParseProgress parses the progress type, code and text.
//
// The function returns the following values:
//
//    - typ (optional): location for the type.
//    - code (optional): location for the code.
//    - text (optional): location for the text.
//
func (message *Message) ParseProgress() (typ ProgressType, code string, text string) {
	var _arg0 *C.GstMessage     // out
	var _arg1 C.GstProgressType // in
	var _arg2 *C.gchar          // in
	var _arg3 *C.gchar          // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_progress(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _typ ProgressType // out
	var _code string      // out
	var _text string      // out

	_typ = ProgressType(_arg1)
	if _arg2 != nil {
		_code = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	return _typ, _code, _text
}

// ParsePropertyNotify parses a property-notify message. These will be posted on
// the bus only when set up with gst_element_add_property_notify_watch() or
// gst_element_add_property_deep_notify_watch().
//
// The function returns the following values:
//
//    - object (optional): location where to store a pointer to the object whose
//      property got changed, or NULL.
//    - propertyName (optional): return location for the name of the property
//      that got changed, or NULL.
//    - propertyValue (optional): return location for the new value of the
//      property that got changed, or NULL. This will only be set if the property
//      notify watch was told to include the value when it was set up.
//
func (message *Message) ParsePropertyNotify() (GstObjector, string, *coreglib.Value) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstObject  // in
	var _arg2 *C.gchar      // in
	var _arg3 *C.GValue     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_property_notify(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _object GstObjector            // out
	var _propertyName string           // out
	var _propertyValue *coreglib.Value // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GstObjector)
				return ok
			})
			rv, ok := casted.(GstObjector)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
			}
			_object = rv
		}
	}
	if _arg2 != nil {
		_propertyName = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	}
	if _arg3 != nil {
		_propertyValue = coreglib.ValueFromNative(unsafe.Pointer(_arg3))
	}

	return _object, _propertyName, _propertyValue
}

// ParseQos: extract the timestamps and live status from the QoS message.
//
// The returned values give the running_time, stream_time, timestamp and
// duration of the dropped buffer. Values of GST_CLOCK_TIME_NONE mean unknown
// values.
//
// MT safe.
//
// The function returns the following values:
//
//    - live (optional): if the message was generated by a live element.
//    - runningTime (optional): running time of the buffer that generated the
//      message.
//    - streamTime (optional): stream time of the buffer that generated the
//      message.
//    - timestamp (optional) timestamps of the buffer that generated the message.
//    - duration (optional) of the buffer that generated the message.
//
func (message *Message) ParseQos() (live bool, runningTime uint64, streamTime uint64, timestamp uint64, duration uint64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gboolean    // in
	var _arg2 C.guint64     // in
	var _arg3 C.guint64     // in
	var _arg4 C.guint64     // in
	var _arg5 C.guint64     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_qos(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(message)

	var _live bool          // out
	var _runningTime uint64 // out
	var _streamTime uint64  // out
	var _timestamp uint64   // out
	var _duration uint64    // out

	if _arg1 != 0 {
		_live = true
	}
	_runningTime = uint64(_arg2)
	_streamTime = uint64(_arg3)
	_timestamp = uint64(_arg4)
	_duration = uint64(_arg5)

	return _live, _runningTime, _streamTime, _timestamp, _duration
}

// ParseQosStats: extract the QoS stats representing the history of the current
// continuous pipeline playback period.
//
// When format is GST_FORMAT_UNDEFINED both dropped and processed are invalid.
// Values of -1 for either processed or dropped mean unknown values.
//
// MT safe.
//
// The function returns the following values:
//
//    - format (optional) units of the 'processed' and 'dropped' fields. Video
//      sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks
//      and audio filters will likely use GST_FORMAT_DEFAULT (samples).
//    - processed (optional): total number of units correctly processed since the
//      last state change to READY or a flushing operation.
//    - dropped (optional): total number of units dropped since the last state
//      change to READY or a flushing operation.
//
func (message *Message) ParseQosStats() (format Format, processed uint64, dropped uint64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.guint64     // in
	var _arg3 C.guint64     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_qos_stats(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _format Format    // out
	var _processed uint64 // out
	var _dropped uint64   // out

	_format = Format(_arg1)
	_processed = uint64(_arg2)
	_dropped = uint64(_arg3)

	return _format, _processed, _dropped
}

// ParseQosValues: extract the QoS values that have been calculated/analysed
// from the QoS data
//
// MT safe.
//
// The function returns the following values:
//
//    - jitter (optional): difference of the running-time against the deadline.
//    - proportion (optional): long term prediction of the ideal rate relative to
//      normal rate to get optimal quality.
//    - quality (optional): element dependent integer value that specifies the
//      current quality level of the element. The default maximum quality is
//      1000000.
//
func (message *Message) ParseQosValues() (int64, float64, int) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gint64      // in
	var _arg2 C.gdouble     // in
	var _arg3 C.gint        // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_qos_values(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _jitter int64       // out
	var _proportion float64 // out
	var _quality int        // out

	_jitter = int64(_arg1)
	_proportion = float64(_arg2)
	_quality = int(_arg3)

	return _jitter, _proportion, _quality
}

// ParseRequestState: extract the requested state from the request_state
// message.
//
// MT safe.
//
// The function returns the following values:
//
//    - state (optional): result location for the requested state or NULL.
//
func (message *Message) ParseRequestState() State {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstState    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_request_state(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _state State // out

	_state = State(_arg1)

	return _state
}

// ParseResetTime: extract the running-time from the RESET_TIME message.
//
// MT safe.
//
// The function returns the following values:
//
//    - runningTime (optional): result location for the running_time or NULL.
//
func (message *Message) ParseResetTime() ClockTime {
	var _arg0 *C.GstMessage  // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_reset_time(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _runningTime ClockTime // out

	_runningTime = uint64(_arg1)
	type _ = ClockTime
	type _ = uint64

	return _runningTime
}

// ParseSegmentDone extracts the position and format from the segment done
// message.
//
// MT safe.
//
// The function returns the following values:
//
//    - format (optional): result location for the format, or NULL.
//    - position (optional): result location for the position, or NULL.
//
func (message *Message) ParseSegmentDone() (Format, int64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.gint64      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_segment_done(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _format Format  // out
	var _position int64 // out

	_format = Format(_arg1)
	_position = int64(_arg2)

	return _format, _position
}

// ParseSegmentStart extracts the position and format from the segment start
// message.
//
// MT safe.
//
// The function returns the following values:
//
//    - format (optional): result location for the format, or NULL.
//    - position (optional): result location for the position, or NULL.
//
func (message *Message) ParseSegmentStart() (Format, int64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.gint64      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_segment_start(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _format Format  // out
	var _position int64 // out

	_format = Format(_arg1)
	_position = int64(_arg2)

	return _format, _position
}

// ParseStateChanged extracts the old and new states from the GstMessage.
//
// Typical usage of this function might be:
//
//      ...
//      switch (GST_MESSAGE_TYPE (msg)) {
//        case GST_MESSAGE_STATE_CHANGED: {
//          GstState old_state, new_state;
//
//          gst_message_parse_state_changed (msg, &old_state, &new_state, NULL);
//          g_print ("Element s changed state from s to s.\n",
//              GST_OBJECT_NAME (msg->src),
//              gst_element_state_get_name (old_state),
//              gst_element_state_get_name (new_state));
//          break;
//        }
//        ...
//      }
//      ...
//
// MT safe.
//
// The function returns the following values:
//
//    - oldstate (optional) previous state, or NULL.
//    - newstate (optional): new (current) state, or NULL.
//    - pending (optional) (target) state, or NULL.
//
func (message *Message) ParseStateChanged() (oldstate State, newstate State, pending State) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstState    // in
	var _arg2 C.GstState    // in
	var _arg3 C.GstState    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_state_changed(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _oldstate State // out
	var _newstate State // out
	var _pending State  // out

	_oldstate = State(_arg1)
	_newstate = State(_arg2)
	_pending = State(_arg3)

	return _oldstate, _newstate, _pending
}

// ParseStepDone: extract the values the step_done message.
//
// MT safe.
//
// The function returns the following values:
//
//    - format (optional): result location for the format.
//    - amount (optional): result location for the amount.
//    - rate (optional): result location for the rate.
//    - flush (optional): result location for the flush flag.
//    - intermediate (optional): result location for the intermediate flag.
//    - duration (optional): result location for the duration.
//    - eos (optional): result location for the EOS flag.
//
func (message *Message) ParseStepDone() (format Format, amount uint64, rate float64, flush bool, intermediate bool, duration uint64, eos bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.guint64     // in
	var _arg3 C.gdouble     // in
	var _arg4 C.gboolean    // in
	var _arg5 C.gboolean    // in
	var _arg6 C.guint64     // in
	var _arg7 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_step_done(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(message)

	var _format Format     // out
	var _amount uint64     // out
	var _rate float64      // out
	var _flush bool        // out
	var _intermediate bool // out
	var _duration uint64   // out
	var _eos bool          // out

	_format = Format(_arg1)
	_amount = uint64(_arg2)
	_rate = float64(_arg3)
	if _arg4 != 0 {
		_flush = true
	}
	if _arg5 != 0 {
		_intermediate = true
	}
	_duration = uint64(_arg6)
	if _arg7 != 0 {
		_eos = true
	}

	return _format, _amount, _rate, _flush, _intermediate, _duration, _eos
}

// ParseStepStart: extract the values from step_start message.
//
// MT safe.
//
// The function returns the following values:
//
//    - active (optional): result location for the active flag.
//    - format (optional): result location for the format.
//    - amount (optional): result location for the amount.
//    - rate (optional): result location for the rate.
//    - flush (optional): result location for the flush flag.
//    - intermediate (optional): result location for the intermediate flag.
//
func (message *Message) ParseStepStart() (active bool, format Format, amount uint64, rate float64, flush bool, intermediate bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gboolean    // in
	var _arg2 C.GstFormat   // in
	var _arg3 C.guint64     // in
	var _arg4 C.gdouble     // in
	var _arg5 C.gboolean    // in
	var _arg6 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_step_start(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(message)

	var _active bool       // out
	var _format Format     // out
	var _amount uint64     // out
	var _rate float64      // out
	var _flush bool        // out
	var _intermediate bool // out

	if _arg1 != 0 {
		_active = true
	}
	_format = Format(_arg2)
	_amount = uint64(_arg3)
	_rate = float64(_arg4)
	if _arg5 != 0 {
		_flush = true
	}
	if _arg6 != 0 {
		_intermediate = true
	}

	return _active, _format, _amount, _rate, _flush, _intermediate
}

// ParseStreamCollection parses a stream-collection message.
//
// The function returns the following values:
//
//    - collection (optional): location where to store a pointer to the
//      StreamCollection, or NULL.
//
func (message *Message) ParseStreamCollection() *StreamCollection {
	var _arg0 *C.GstMessage          // out
	var _arg1 *C.GstStreamCollection // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_stream_collection(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _collection *StreamCollection // out

	if _arg1 != nil {
		_collection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}

	return _collection
}

// ParseStreamStatus extracts the stream status type and owner the GstMessage.
// The returned owner remains valid for as long as the reference to message is
// valid and should thus not be unreffed.
//
// MT safe.
//
// The function returns the following values:
//
//    - typ: pointer to hold the status type.
//    - owner element of the message source.
//
func (message *Message) ParseStreamStatus() (StreamStatusType, Elementer) {
	var _arg0 *C.GstMessage         // out
	var _arg1 C.GstStreamStatusType // in
	var _arg2 *C.GstElement         // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_stream_status(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _typ StreamStatusType // out
	var _owner Elementer      // out

	_typ = StreamStatusType(_arg1)
	{
		objptr := unsafe.Pointer(_arg2)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_owner = rv
	}

	return _typ, _owner
}

// ParseStreamsSelected parses a streams-selected message.
//
// The function returns the following values:
//
//    - collection (optional): location where to store a pointer to the
//      StreamCollection, or NULL.
//
func (message *Message) ParseStreamsSelected() *StreamCollection {
	var _arg0 *C.GstMessage          // out
	var _arg1 *C.GstStreamCollection // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_streams_selected(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _collection *StreamCollection // out

	if _arg1 != nil {
		_collection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}

	return _collection
}

// ParseStructureChange extracts the change type and completion status from the
// GstMessage.
//
// MT safe.
//
// The function returns the following values:
//
//    - typ: pointer to hold the change type.
//    - owner (optional) element of the message source.
//    - busy (optional): pointer to hold whether the change is in progress or has
//      been completed.
//
func (message *Message) ParseStructureChange() (StructureChangeType, Elementer, bool) {
	var _arg0 *C.GstMessage            // out
	var _arg1 C.GstStructureChangeType // in
	var _arg2 *C.GstElement            // in
	var _arg3 C.gboolean               // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_structure_change(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _typ StructureChangeType // out
	var _owner Elementer         // out
	var _busy bool               // out

	_typ = StructureChangeType(_arg1)
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_owner = rv
		}
	}
	if _arg3 != 0 {
		_busy = true
	}

	return _typ, _owner, _busy
}

// ParseToc: extract the TOC from the Message. The TOC returned in the output
// argument is a copy; the caller must free it with gst_toc_unref() when done.
//
// MT safe.
//
// The function returns the following values:
//
//    - toc: return location for the TOC.
//    - updated: return location for the updated flag.
//
func (message *Message) ParseToc() (*Toc, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstToc     // in
	var _arg2 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_toc(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _toc *Toc     // out
	var _updated bool // out

	_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toc)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _arg2 != 0 {
		_updated = true
	}

	return _toc, _updated
}

// ParseWarning extracts the GError and debug string from the GstMessage. The
// values returned in the output arguments are copies; the caller must free them
// when done.
//
// MT safe.
//
// The function returns the following values:
//
//    - gerror (optional): location for the GError.
//    - debug (optional): location for the debug message, or NULL.
//
func (message *Message) ParseWarning() (error, string) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GError     // in
	var _arg2 *C.gchar      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_warning(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _gerror error // out
	var _debug string // out

	if _arg1 != nil {
		_gerror = gerror.Take(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_debug = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	return _gerror, _debug
}

// ParseWarningDetails returns the optional details structure, may be NULL if
// none The returned structure must not be freed.
//
// The function returns the following values:
//
//    - structure: pointer to the returned details structure.
//
func (message *Message) ParseWarningDetails() *Structure {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_warning_details(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _structure
}

// SetBufferingStats configures the buffering stats values in message.
//
// The function takes the following parameters:
//
//    - mode: buffering mode.
//    - avgIn: average input rate.
//    - avgOut: average output rate.
//    - bufferingLeft: amount of buffering time left in milliseconds.
//
func (message *Message) SetBufferingStats(mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstMessage      // out
	var _arg1 C.GstBufferingMode // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // out
	var _arg4 C.gint64           // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.GstBufferingMode(mode)
	_arg2 = C.gint(avgIn)
	_arg3 = C.gint(avgOut)
	_arg4 = C.gint64(bufferingLeft)

	C.gst_message_set_buffering_stats(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(message)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(avgIn)
	runtime.KeepAlive(avgOut)
	runtime.KeepAlive(bufferingLeft)
}

// SetGroupID sets the group id on the stream-start message.
//
// All streams that have the same group id are supposed to be played together,
// i.e. all streams inside a container file should have the same group id but
// different stream ids. The group id should change each time the stream is
// started, resulting in different group ids each time a file is played for
// example.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - groupId: group id.
//
func (message *Message) SetGroupID(groupId uint) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.guint(groupId)

	C.gst_message_set_group_id(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(groupId)
}

// SetQosStats: set the QoS stats representing the history of the current
// continuous pipeline playback period.
//
// When format is GST_FORMAT_UNDEFINED both dropped and processed are invalid.
// Values of -1 for either processed or dropped mean unknown values.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - format units of the 'processed' and 'dropped' fields. Video sinks and
//      video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio
//      filters will likely use GST_FORMAT_DEFAULT (samples).
//    - processed: total number of units correctly processed since the last state
//      change to READY or a flushing operation.
//    - dropped: total number of units dropped since the last state change to
//      READY or a flushing operation.
//
func (message *Message) SetQosStats(format Format, processed uint64, dropped uint64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(processed)
	_arg3 = C.guint64(dropped)

	C.gst_message_set_qos_stats(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(message)
	runtime.KeepAlive(format)
	runtime.KeepAlive(processed)
	runtime.KeepAlive(dropped)
}

// SetQosValues: set the QoS values that have been calculated/analysed from the
// QoS data
//
// MT safe.
//
// The function takes the following parameters:
//
//    - jitter: difference of the running-time against the deadline.
//    - proportion: long term prediction of the ideal rate relative to normal
//      rate to get optimal quality.
//    - quality: element dependent integer value that specifies the current
//      quality level of the element. The default maximum quality is 1000000.
//
func (message *Message) SetQosValues(jitter int64, proportion float64, quality int) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gint64      // out
	var _arg2 C.gdouble     // out
	var _arg3 C.gint        // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.gint64(jitter)
	_arg2 = C.gdouble(proportion)
	_arg3 = C.gint(quality)

	C.gst_message_set_qos_values(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(message)
	runtime.KeepAlive(jitter)
	runtime.KeepAlive(proportion)
	runtime.KeepAlive(quality)
}

// SetSeqnum: set the sequence number of a message.
//
// This function might be called by the creator of a message to indicate that
// the message relates to other messages or events. See gst_message_get_seqnum()
// for more information.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - seqnum: sequence number.
//
func (message *Message) SetSeqnum(seqnum uint32) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint32     // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.guint32(seqnum)

	C.gst_message_set_seqnum(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(seqnum)
}

// SetStreamStatusObject configures the object handling the streaming thread.
// This is usually a GstTask object but other objects might be added in the
// future.
//
// The function takes the following parameters:
//
//    - object controlling the streaming.
//
func (message *Message) SetStreamStatusObject(object *coreglib.Value) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GValue     // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.GValue)(unsafe.Pointer(object.Native()))

	C.gst_message_set_stream_status_object(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(object)
}

// StreamsSelectedAdd adds the stream to the message.
//
// The function takes the following parameters:
//
//    - stream to add to message.
//
func (message *Message) StreamsSelectedAdd(stream *Stream) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstStream  // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.gst_message_streams_selected_add(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(stream)
}

// StreamsSelectedGetSize returns the number of streams contained in the
// message.
//
// The function returns the following values:
//
//    - guint: number of streams contained within.
//
func (message *Message) StreamsSelectedGetSize() uint {
	var _arg0 *C.GstMessage // out
	var _cret C.guint       // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_streams_selected_get_size(_arg0)
	runtime.KeepAlive(message)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// StreamsSelectedGetStream retrieves the Stream with index index from the
// message.
//
// The function takes the following parameters:
//
//    - idx: index of the stream to retrieve.
//
// The function returns the following values:
//
//    - stream (optional): Stream.
//
func (message *Message) StreamsSelectedGetStream(idx uint) *Stream {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint       // out
	var _cret *C.GstStream  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.guint(idx)

	_cret = C.gst_message_streams_selected_get_stream(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(idx)

	var _stream *Stream // out

	if _cret != nil {
		_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _stream
}

// WritableStructure: get a writable version of the structure.
//
// The function returns the following values:
//
//    - structure of the message. The structure is still owned by the message,
//      which means that you should not free it and that the pointer becomes
//      invalid when you free the message. This function checks if message is
//      writable and will never return NULL.
//
//      MT safe.
//
func (message *Message) WritableStructure() *Structure {
	var _arg0 *C.GstMessage   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_writable_structure(_arg0)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}
