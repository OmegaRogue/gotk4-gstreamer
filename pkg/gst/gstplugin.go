// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gboolean _gotk4_gst1_PluginInitFullFunc(GstPlugin*, gpointer);
import "C"

// GType values.
var (
	GTypePluginError           = coreglib.Type(C.gst_plugin_error_get_type())
	GTypePluginDependencyFlags = coreglib.Type(C.gst_plugin_dependency_flags_get_type())
	GTypePluginFlags           = coreglib.Type(C.gst_plugin_flags_get_type())
	GTypePlugin                = coreglib.Type(C.gst_plugin_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePluginError, F: marshalPluginError},
		coreglib.TypeMarshaler{T: GTypePluginDependencyFlags, F: marshalPluginDependencyFlags},
		coreglib.TypeMarshaler{T: GTypePluginFlags, F: marshalPluginFlags},
		coreglib.TypeMarshaler{T: GTypePlugin, F: marshalPlugin},
	})
}

// LICENSE_UNKNOWN: to be used in GST_PLUGIN_DEFINE if unsure about the licence.
const LICENSE_UNKNOWN = "unknown"

// PluginError: plugin loading errors.
type PluginError C.gint

const (
	// PluginErrorModule: plugin could not be loaded.
	PluginErrorModule PluginError = iota
	// PluginErrorDependencies: plugin has unresolved dependencies.
	PluginErrorDependencies
	// PluginErrorNameMismatch: plugin has already be loaded from a different
	// file.
	PluginErrorNameMismatch
)

func marshalPluginError(p uintptr) (interface{}, error) {
	return PluginError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PluginError.
func (p PluginError) String() string {
	switch p {
	case PluginErrorModule:
		return "Module"
	case PluginErrorDependencies:
		return "Dependencies"
	case PluginErrorNameMismatch:
		return "NameMismatch"
	default:
		return fmt.Sprintf("PluginError(%d)", p)
	}
}

// PluginErrorQuark: get the error quark.
//
// The function returns the following values:
//
//    - quark: error quark used in GError messages.
//
func PluginErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_plugin_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// PluginDependencyFlags flags used in connection with
// gst_plugin_add_dependency().
type PluginDependencyFlags C.guint

const (
	// PluginDependencyFlagNone: no special flags.
	PluginDependencyFlagNone PluginDependencyFlags = 0b0
	// PluginDependencyFlagRecurse: recurse into subdirectories.
	PluginDependencyFlagRecurse PluginDependencyFlags = 0b1
	// PluginDependencyFlagPathsAreDefaultOnly: use paths argument only if none
	// of the environment variables is set.
	PluginDependencyFlagPathsAreDefaultOnly PluginDependencyFlags = 0b10
	// PluginDependencyFlagFileNameIsSuffix: interpret filename argument as
	// filter suffix and check all matching files in the directory.
	PluginDependencyFlagFileNameIsSuffix PluginDependencyFlags = 0b100
	// PluginDependencyFlagFileNameIsPrefix: interpret filename argument as
	// filter prefix and check all matching files in the directory. Since: 1.8.
	PluginDependencyFlagFileNameIsPrefix PluginDependencyFlags = 0b1000
	// PluginDependencyFlagPathsAreRelativeToExe: interpret non-absolute paths
	// as relative to the main executable directory. Since 1.14.
	PluginDependencyFlagPathsAreRelativeToExe PluginDependencyFlags = 0b10000
)

func marshalPluginDependencyFlags(p uintptr) (interface{}, error) {
	return PluginDependencyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PluginDependencyFlags.
func (p PluginDependencyFlags) String() string {
	if p == 0 {
		return "PluginDependencyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(208)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PluginDependencyFlagNone:
			builder.WriteString("None|")
		case PluginDependencyFlagRecurse:
			builder.WriteString("Recurse|")
		case PluginDependencyFlagPathsAreDefaultOnly:
			builder.WriteString("PathsAreDefaultOnly|")
		case PluginDependencyFlagFileNameIsSuffix:
			builder.WriteString("FileNameIsSuffix|")
		case PluginDependencyFlagFileNameIsPrefix:
			builder.WriteString("FileNameIsPrefix|")
		case PluginDependencyFlagPathsAreRelativeToExe:
			builder.WriteString("PathsAreRelativeToExe|")
		default:
			builder.WriteString(fmt.Sprintf("PluginDependencyFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PluginDependencyFlags) Has(other PluginDependencyFlags) bool {
	return (p & other) == other
}

// PluginFlags: plugin loading state.
type PluginFlags C.guint

const (
	// PluginFlagCached: temporarily loaded plugins.
	PluginFlagCached PluginFlags = 0b10000
	// PluginFlagBlacklisted: plugin won't be scanned (again).
	PluginFlagBlacklisted PluginFlags = 0b100000
)

func marshalPluginFlags(p uintptr) (interface{}, error) {
	return PluginFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PluginFlags.
func (p PluginFlags) String() string {
	if p == 0 {
		return "PluginFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(38)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PluginFlagCached:
			builder.WriteString("Cached|")
		case PluginFlagBlacklisted:
			builder.WriteString("Blacklisted|")
		default:
			builder.WriteString(fmt.Sprintf("PluginFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PluginFlags) Has(other PluginFlags) bool {
	return (p & other) == other
}

// PluginFilter: function that can be used with e.g.
// gst_registry_plugin_filter() to get a list of plugins that match certain
// criteria.
type PluginFilter func(plugin *Plugin) (ok bool)

// PluginInitFullFunc: plugin should provide a pointer to a function of either
// PluginInitFunc or this type in the plugin_desc struct. The function will be
// called by the loader at startup. One would then register each PluginFeature.
// This version allows user data to be passed to init function (useful for
// bindings).
type PluginInitFullFunc func(plugin *Plugin) (ok bool)

// Plugin: GStreamer is extensible, so Element instances can be loaded at
// runtime. A plugin system can provide one or more of the basic GStreamer
// PluginFeature subclasses.
//
// A plugin should export a symbol gst_plugin_desc that is a struct of type
// PluginDesc. the plugin loader will check the version of the core library the
// plugin was linked against and will create a new Plugin. It will then call the
// PluginInitFunc function that was provided in the gst_plugin_desc.
//
// Once you have a handle to a Plugin (e.g. from the Registry), you can add any
// object that subclasses PluginFeature.
//
// Usually plugins are always automatically loaded so you don't need to call
// gst_plugin_load() explicitly to bring it into memory. There are options to
// statically link plugins to an app or even use GStreamer without a plugin
// repository in which case gst_plugin_load() can be needed to bring the plugin
// into memory.
type Plugin struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Plugin)(nil)
)

func wrapPlugin(obj *coreglib.Object) *Plugin {
	return &Plugin{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPlugin(p uintptr) (interface{}, error) {
	return wrapPlugin(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddDependency: make GStreamer aware of external dependencies which affect the
// feature set of this plugin (ie. the elements or typefinders associated with
// it).
//
// GStreamer will re-inspect plugins with external dependencies whenever any of
// the external dependencies change. This is useful for plugins which wrap other
// plugin systems, e.g. a plugin which wraps a plugin-based visualisation
// library and makes visualisations available as GStreamer elements, or a codec
// loader which exposes elements and/or caps dependent on what external codec
// libraries are currently installed.
//
// The function takes the following parameters:
//
//    - envVars (optional): NULL-terminated array of environment variables
//      affecting the feature set of the plugin (e.g. an environment variable
//      containing paths where to look for additional modules/plugins of a
//      library), or NULL. Environment variable names may be followed by a path
//      component which will be added to the content of the environment variable,
//      e.g. "HOME/.mystuff/plugins".
//    - paths (optional): NULL-terminated array of directories/paths where
//      dependent files may be, or NULL.
//    - names (optional): NULL-terminated array of file names (or file name
//      suffixes, depending on flags) to be used in combination with the paths
//      from paths and/or the paths extracted from the environment variables in
//      env_vars, or NULL.
//    - flags: optional flags, or T_PLUGIN_DEPENDENCY_FLAG_NONE.
//
func (plugin *Plugin) AddDependency(envVars, paths, names []string, flags PluginDependencyFlags) {
	var _arg0 *C.GstPlugin               // out
	var _arg1 **C.gchar                  // out
	var _arg2 **C.gchar                  // out
	var _arg3 **C.gchar                  // out
	var _arg4 C.GstPluginDependencyFlags // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(envVars) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(envVars)+1)
			var zero *C.gchar
			out[len(envVars)] = zero
			for i := range envVars {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envVars[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(paths) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(paths)+1)
			var zero *C.gchar
			out[len(paths)] = zero
			for i := range paths {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(paths[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg3 = (**C.gchar)(C.calloc(C.size_t((len(names) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(names)+1)
			var zero *C.gchar
			out[len(names)] = zero
			for i := range names {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(names[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = C.GstPluginDependencyFlags(flags)

	C.gst_plugin_add_dependency(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(envVars)
	runtime.KeepAlive(paths)
	runtime.KeepAlive(names)
	runtime.KeepAlive(flags)
}

// AddDependencySimple: make GStreamer aware of external dependencies which
// affect the feature set of this plugin (ie. the elements or typefinders
// associated with it).
//
// GStreamer will re-inspect plugins with external dependencies whenever any of
// the external dependencies change. This is useful for plugins which wrap other
// plugin systems, e.g. a plugin which wraps a plugin-based visualisation
// library and makes visualisations available as GStreamer elements, or a codec
// loader which exposes elements and/or caps dependent on what external codec
// libraries are currently installed.
//
// Convenience wrapper function for gst_plugin_add_dependency() which takes
// simple strings as arguments instead of string arrays, with multiple arguments
// separated by predefined delimiters (see above).
//
// The function takes the following parameters:
//
//    - envVars (optional): one or more environment variables (separated by ':',
//      ';' or ','), or NULL. Environment variable names may be followed by a
//      path component which will be added to the content of the environment
//      variable, e.g. "HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH".
//    - paths (optional): one ore more directory paths (separated by ':' or ';'
//      or ','), or NULL. Example: "/usr/lib/mystuff/plugins".
//    - names (optional): one or more file names or file name suffixes (separated
//      by commas), or NULL.
//    - flags: optional flags, or T_PLUGIN_DEPENDENCY_FLAG_NONE.
//
func (plugin *Plugin) AddDependencySimple(envVars, paths, names string, flags PluginDependencyFlags) {
	var _arg0 *C.GstPlugin               // out
	var _arg1 *C.gchar                   // out
	var _arg2 *C.gchar                   // out
	var _arg3 *C.gchar                   // out
	var _arg4 C.GstPluginDependencyFlags // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	if envVars != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(envVars)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if paths != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(paths)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if names != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(names)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.GstPluginDependencyFlags(flags)

	C.gst_plugin_add_dependency_simple(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(envVars)
	runtime.KeepAlive(paths)
	runtime.KeepAlive(names)
	runtime.KeepAlive(flags)
}

// CacheData gets the plugin specific data cache. If it is NULL there is no
// cached data stored. This is the case when the registry is getting rebuilt.
//
// The function returns the following values:
//
//    - structure (optional): cached data as a Structure or NULL.
//
func (plugin *Plugin) CacheData() *Structure {
	var _arg0 *C.GstPlugin    // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_cache_data(_arg0)
	runtime.KeepAlive(plugin)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// Description: get the long descriptive name of the plugin.
//
// The function returns the following values:
//
//    - utf8: long name of the plugin.
//
func (plugin *Plugin) Description() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_description(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Filename: get the filename of the plugin.
//
// The function returns the following values:
//
//    - filename (optional) of the plugin.
//
func (plugin *Plugin) Filename() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_filename(_arg0)
	runtime.KeepAlive(plugin)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// License: get the license of the plugin.
//
// The function returns the following values:
//
//    - utf8: license of the plugin.
//
func (plugin *Plugin) License() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_license(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name: get the short name of the plugin.
//
// The function returns the following values:
//
//    - utf8: name of the plugin.
//
func (plugin *Plugin) Name() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_name(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Origin: get the URL where the plugin comes from.
//
// The function returns the following values:
//
//    - utf8: origin of the plugin.
//
func (plugin *Plugin) Origin() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_origin(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Package: get the package the plugin belongs to.
//
// The function returns the following values:
//
//    - utf8: package of the plugin.
//
func (plugin *Plugin) Package() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_package(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ReleaseDateString: get the release date (and possibly time) in form of a
// string, if available.
//
// For normal GStreamer plugin releases this will usually just be a date in the
// form of "YYYY-MM-DD", while pre-releases and builds from git may contain a
// time component after the date as well, in which case the string will be
// formatted like "YYYY-MM-DDTHH:MMZ" (e.g. "2012-04-30T09:30Z").
//
// There may be plugins that do not have a valid release date set on them.
//
// The function returns the following values:
//
//    - utf8 (optional): date string of the plugin, or NULL if not available.
//
func (plugin *Plugin) ReleaseDateString() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_release_date_string(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Source: get the source module the plugin belongs to.
//
// The function returns the following values:
//
//    - utf8: source of the plugin.
//
func (plugin *Plugin) Source() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_source(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Version: get the version of the plugin.
//
// The function returns the following values:
//
//    - utf8: version of the plugin.
//
func (plugin *Plugin) Version() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_version(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsLoaded queries if the plugin is loaded into memory.
//
// The function returns the following values:
//
//    - ok: TRUE is loaded, FALSE otherwise.
//
func (plugin *Plugin) IsLoaded() bool {
	var _arg0 *C.GstPlugin // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_is_loaded(_arg0)
	runtime.KeepAlive(plugin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Load loads plugin. Note that the *return value* is the loaded plugin; plugin
// is untouched. The normal use pattern of this function goes like this:
//
//    GstPlugin *loaded_plugin;
//    loaded_plugin = gst_plugin_load (plugin);
//    // presumably, we're no longer interested in the potentially-unloaded plugin
//    gst_object_unref (plugin);
//    plugin = loaded_plugin;.
//
// The function returns the following values:
//
//    - ret (optional): reference to a loaded plugin, or NULL on error.
//
func (plugin *Plugin) Load() *Plugin {
	var _arg0 *C.GstPlugin // out
	var _cret *C.GstPlugin // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_load(_arg0)
	runtime.KeepAlive(plugin)

	var _ret *Plugin // out

	if _cret != nil {
		_ret = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// SetCacheData adds plugin specific data to cache. Passes the ownership of the
// structure to the plugin.
//
// The cache is flushed every time the registry is rebuilt.
//
// The function takes the following parameters:
//
//    - cacheData: structure containing the data to cache.
//
func (plugin *Plugin) SetCacheData(cacheData *Structure) {
	var _arg0 *C.GstPlugin    // out
	var _arg1 *C.GstStructure // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(cacheData)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cacheData)), nil)

	C.gst_plugin_set_cache_data(_arg0, _arg1)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(cacheData)
}

// PluginLoadByName: load the named plugin. Refs the plugin.
//
// The function takes the following parameters:
//
//    - name of plugin to load.
//
// The function returns the following values:
//
//    - plugin (optional): reference to a loaded plugin, or NULL on error.
//
func PluginLoadByName(name string) *Plugin {
	var _arg1 *C.gchar     // out
	var _cret *C.GstPlugin // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_plugin_load_by_name(_arg1)
	runtime.KeepAlive(name)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// PluginLoadFile loads the given plugin and refs it. Caller needs to unref
// after use.
//
// The function takes the following parameters:
//
//    - filename: plugin filename to load.
//
// The function returns the following values:
//
//    - plugin: reference to the existing loaded GstPlugin, a reference to the
//      newly-loaded GstPlugin, or NULL if an error occurred.
//
func PluginLoadFile(filename string) (*Plugin, error) {
	var _arg1 *C.gchar     // out
	var _cret *C.GstPlugin // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_plugin_load_file(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _plugin *Plugin // out
	var _goerr error    // out

	_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _plugin, _goerr
}

// PluginRegisterStaticFull registers a static plugin, ie. a plugin which is
// private to an application or library and contained within the application or
// library (as opposed to being shipped as a separate module file) with a
// PluginInitFullFunc which allows user data to be passed to the callback
// function (useful for bindings).
//
// You must make sure that GStreamer has been initialised (with gst_init() or
// via gst_init_get_option_group()) before calling this function.
//
// The function takes the following parameters:
//
//    - majorVersion: major version number of the GStreamer core that the plugin
//      was compiled for, you can just use GST_VERSION_MAJOR here.
//    - minorVersion: minor version number of the GStreamer core that the plugin
//      was compiled for, you can just use GST_VERSION_MINOR here.
//    - name: unique name of the plugin (ideally prefixed with an application- or
//      library-specific namespace prefix in order to avoid name conflicts in
//      case a similar plugin with the same name ever gets added to GStreamer).
//    - description of the plugin.
//    - initFullFunc: pointer to the init function with user data of this plugin.
//    - version string of the plugin.
//    - license: effective license of plugin. Must be one of the approved
//      licenses (see PluginDesc above) or the plugin will not be registered.
//    - source module plugin belongs to.
//    - pkg: shipped package plugin belongs to.
//    - origin: URL to provider of plugin.
//
// The function returns the following values:
//
//    - ok: TRUE if the plugin was registered correctly, otherwise FALSE.
//
func PluginRegisterStaticFull(majorVersion, minorVersion int, name, description string, initFullFunc PluginInitFullFunc, version, license, source, pkg, origin string) bool {
	var _arg1 C.gint                  // out
	var _arg2 C.gint                  // out
	var _arg3 *C.gchar                // out
	var _arg4 *C.gchar                // out
	var _arg5 C.GstPluginInitFullFunc // out
	var _arg11 C.gpointer
	var _arg6 *C.gchar   // out
	var _arg7 *C.gchar   // out
	var _arg8 *C.gchar   // out
	var _arg9 *C.gchar   // out
	var _arg10 *C.gchar  // out
	var _cret C.gboolean // in

	_arg1 = C.gint(majorVersion)
	_arg2 = C.gint(minorVersion)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*[0]byte)(C._gotk4_gst1_PluginInitFullFunc)
	_arg11 = C.gpointer(gbox.Assign(initFullFunc))
	defer gbox.Delete(uintptr(_arg11))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(version)))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(license)))
	defer C.free(unsafe.Pointer(_arg7))
	_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(_arg8))
	_arg9 = (*C.gchar)(unsafe.Pointer(C.CString(pkg)))
	defer C.free(unsafe.Pointer(_arg9))
	_arg10 = (*C.gchar)(unsafe.Pointer(C.CString(origin)))
	defer C.free(unsafe.Pointer(_arg10))

	_cret = C.gst_plugin_register_static_full(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
	runtime.KeepAlive(majorVersion)
	runtime.KeepAlive(minorVersion)
	runtime.KeepAlive(name)
	runtime.KeepAlive(description)
	runtime.KeepAlive(initFullFunc)
	runtime.KeepAlive(version)
	runtime.KeepAlive(license)
	runtime.KeepAlive(source)
	runtime.KeepAlive(pkg)
	runtime.KeepAlive(origin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PluginDesc: plugin should export a variable of this type called plugin_desc.
// The plugin loader will use the data provided there to initialize the plugin.
//
// The licence parameter must be one of: LGPL, GPL, QPL, GPL/QPL, MPL, BSD,
// MIT/X11, Proprietary, unknown.
//
// An instance of this type is always passed by reference.
type PluginDesc struct {
	*pluginDesc
}

// pluginDesc is the struct that's finalized.
type pluginDesc struct {
	native *C.GstPluginDesc
}
