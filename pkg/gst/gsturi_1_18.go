// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/gst.h>
import "C"

// URIFromStringEscaped parses a URI string into a new Uri object. Will return
// NULL if the URI cannot be parsed. This is identical to gst_uri_from_string()
// except that the userinfo and fragment components of the URI will not be
// unescaped while parsing.
//
// Use this when you need to extract a username and password from the userinfo
// such as https://user:passwordexample.com since either may contain a
// URI-escaped ':' character. gst_uri_from_string() will unescape the entire
// userinfo component, which will make it impossible to know which ':'
// delineates the username and password.
//
// The same applies to the fragment component of the URI, such as
// https://example.com/path#fragment which may contain a URI-escaped '#'.
//
// The function takes the following parameters:
//
//    - uri: URI string to parse.
//
// The function returns the following values:
//
//    - ret (optional): new Uri object, or NULL.
//
func URIFromStringEscaped(uri string) *URI {
	var _arg1 *C.gchar  // out
	var _cret *C.GstUri // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_from_string_escaped(_arg1)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	if _cret != nil {
		_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _ret
}
