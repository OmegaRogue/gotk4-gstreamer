// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gint _gotk4_gst1_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gint _gotk4_glib2_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
import "C"

// GType values.
var (
	GTypeSearchMode = coreglib.Type(C.gst_search_mode_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSearchMode, F: marshalSearchMode},
	})
}

// SearchMode: different search modes.
type SearchMode C.gint

const (
	// SearchModeExact: only search for exact matches.
	SearchModeExact SearchMode = iota
	// SearchModeBefore: search for an exact match or the element just before.
	SearchModeBefore
	// SearchModeAfter: search for an exact match or the element just after.
	SearchModeAfter
)

func marshalSearchMode(p uintptr) (interface{}, error) {
	return SearchMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SearchMode.
func (s SearchMode) String() string {
	switch s {
	case SearchModeExact:
		return "Exact"
	case SearchModeBefore:
		return "Before"
	case SearchModeAfter:
		return "After"
	default:
		return fmt.Sprintf("SearchMode(%d)", s)
	}
}

// ParseBinFromDescription: this is a convenience wrapper around
// gst_parse_launch() to create a Bin from a gst-launch-style pipeline
// description. See gst_parse_launch() and the gst-launch man page for details
// about the syntax. Ghost pads on the bin for unlinked source or sink pads
// within the bin can automatically be created (but only a maximum of one ghost
// pad for each direction will be created; if you expect multiple unlinked
// source pads or multiple unlinked sink pads and want them all ghosted, you
// will have to create the ghost pads yourself).
//
// The function takes the following parameters:
//
//    - binDescription: command line describing the bin.
//    - ghostUnlinkedPads: whether to automatically create ghost pads for
//      unlinked source or sink pads within the bin.
//
// The function returns the following values:
//
//    - bin: a newly-created bin, or NULL if an error occurred.
//
func ParseBinFromDescription(binDescription string, ghostUnlinkedPads bool) (*Bin, error) {
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(binDescription)))
	defer C.free(unsafe.Pointer(_arg1))
	if ghostUnlinkedPads {
		_arg2 = C.TRUE
	}

	_cret = C.gst_parse_bin_from_description(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(binDescription)
	runtime.KeepAlive(ghostUnlinkedPads)

	var _bin *Bin    // out
	var _goerr error // out

	_bin = wrapBin(coreglib.Take(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bin, _goerr
}

// ParseBinFromDescriptionFull: this is a convenience wrapper around
// gst_parse_launch() to create a Bin from a gst-launch-style pipeline
// description. See gst_parse_launch() and the gst-launch man page for details
// about the syntax. Ghost pads on the bin for unlinked source or sink pads
// within the bin can automatically be created (but only a maximum of one ghost
// pad for each direction will be created; if you expect multiple unlinked
// source pads or multiple unlinked sink pads and want them all ghosted, you
// will have to create the ghost pads yourself).
//
// The function takes the following parameters:
//
//    - binDescription: command line describing the bin.
//    - ghostUnlinkedPads: whether to automatically create ghost pads for
//      unlinked source or sink pads within the bin.
//    - context (optional): parse context allocated with gst_parse_context_new(),
//      or NULL.
//    - flags: parsing options, or T_PARSE_FLAG_NONE.
//
// The function returns the following values:
//
//    - element: newly-created element, which is guaranteed to be a bin unless
//      T_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS was passed, or NULL if an error
//      occurred.
//
func ParseBinFromDescriptionFull(binDescription string, ghostUnlinkedPads bool, context *ParseContext, flags ParseFlags) (Elementer, error) {
	var _arg1 *C.gchar           // out
	var _arg2 C.gboolean         // out
	var _arg3 *C.GstParseContext // out
	var _arg4 C.GstParseFlags    // out
	var _cret *C.GstElement      // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(binDescription)))
	defer C.free(unsafe.Pointer(_arg1))
	if ghostUnlinkedPads {
		_arg2 = C.TRUE
	}
	if context != nil {
		_arg3 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg4 = C.GstParseFlags(flags)

	_cret = C.gst_parse_bin_from_description_full(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(binDescription)
	runtime.KeepAlive(ghostUnlinkedPads)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// UtilArrayBinarySearch searches inside array for search_data by using the
// comparison function search_func. array must be sorted ascending.
//
// As search_data is always passed as second argument to search_func it's not
// required that search_data has the same type as the array elements.
//
// The complexity of this search function is O(log (num_elements)).
//
// The function takes the following parameters:
//
//    - array (optional): sorted input array.
//    - numElements: number of elements in the array.
//    - elementSize: size of every element in bytes.
//    - searchFunc: function to compare two elements, search_data will always be
//      passed as second argument.
//    - mode: search mode that should be used.
//    - searchData (optional): element that should be found.
//
// The function returns the following values:
//
//    - gpointer (optional) address of the found element or NULL if nothing was
//      found.
//
func UtilArrayBinarySearch(array unsafe.Pointer, numElements, elementSize uint, searchFunc glib.CompareDataFunc, mode SearchMode, searchData unsafe.Pointer) unsafe.Pointer {
	var _arg1 C.gpointer         // out
	var _arg2 C.guint            // out
	var _arg3 C.gsize            // out
	var _arg4 C.GCompareDataFunc // out
	var _arg7 C.gpointer
	var _arg5 C.GstSearchMode // out
	var _arg6 C.gconstpointer // out
	var _cret C.gpointer      // in

	_arg1 = (C.gpointer)(unsafe.Pointer(array))
	_arg2 = C.guint(numElements)
	_arg3 = C.gsize(elementSize)
	_arg4 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg7 = C.gpointer(gbox.Assign(searchFunc))
	defer gbox.Delete(uintptr(_arg7))
	_arg5 = C.GstSearchMode(mode)
	_arg6 = (C.gconstpointer)(unsafe.Pointer(searchData))

	_cret = C.gst_util_array_binary_search(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(array)
	runtime.KeepAlive(numElements)
	runtime.KeepAlive(elementSize)
	runtime.KeepAlive(searchFunc)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(searchData)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// UtilDoubleToFraction transforms a #gdouble to a fraction and simplifies the
// result.
//
// The function takes the following parameters:
//
//    - src to transform.
//
// The function returns the following values:
//
//    - destN: pointer to a #gint to hold the result numerator.
//    - destD: pointer to a #gint to hold the result denominator.
//
func UtilDoubleToFraction(src float64) (destN, destD int) {
	var _arg1 C.gdouble // out
	var _arg2 C.gint    // in
	var _arg3 C.gint    // in

	_arg1 = C.gdouble(src)

	C.gst_util_double_to_fraction(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(src)

	var _destN int // out
	var _destD int // out

	_destN = int(_arg2)
	_destD = int(_arg3)

	return _destN, _destD
}

// UtilDumpMem dumps the memory block into a hex representation. Useful for
// debugging.
//
// The function takes the following parameters:
//
//    - mem: pointer to the memory to dump.
//
func UtilDumpMem(mem []byte) {
	var _arg1 *C.guchar // out
	var _arg2 C.guint

	_arg2 = (C.guint)(len(mem))
	if len(mem) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&mem[0]))
	}

	C.gst_util_dump_mem(_arg1, _arg2)
	runtime.KeepAlive(mem)
}

// UtilFractionAdd adds the fractions a_n/a_d and b_n/b_d and stores the result
// in res_n and res_d.
//
// The function takes the following parameters:
//
//    - aN: numerator of first value.
//    - aD: denominator of first value.
//    - bN: numerator of second value.
//    - bD: denominator of second value.
//
// The function returns the following values:
//
//    - resN: pointer to #gint to hold the result numerator.
//    - resD: pointer to #gint to hold the result denominator.
//    - ok: FALSE on overflow, TRUE otherwise.
//
func UtilFractionAdd(aN, aD, bN, bD int) (resN, resD int, ok bool) {
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _arg4 C.gint     // out
	var _arg5 C.gint     // in
	var _arg6 C.gint     // in
	var _cret C.gboolean // in

	_arg1 = C.gint(aN)
	_arg2 = C.gint(aD)
	_arg3 = C.gint(bN)
	_arg4 = C.gint(bD)

	_cret = C.gst_util_fraction_add(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(aN)
	runtime.KeepAlive(aD)
	runtime.KeepAlive(bN)
	runtime.KeepAlive(bD)

	var _resN int // out
	var _resD int // out
	var _ok bool  // out

	_resN = int(_arg5)
	_resD = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _resN, _resD, _ok
}

// UtilFractionCompare compares the fractions a_n/a_d and b_n/b_d and returns -1
// if a < b, 0 if a = b and 1 if a > b.
//
// The function takes the following parameters:
//
//    - aN: numerator of first value.
//    - aD: denominator of first value.
//    - bN: numerator of second value.
//    - bD: denominator of second value.
//
// The function returns the following values:
//
//    - gint: -1 if a < b; 0 if a = b; 1 if a > b.
//
func UtilFractionCompare(aN, aD, bN, bD int) int {
	var _arg1 C.gint // out
	var _arg2 C.gint // out
	var _arg3 C.gint // out
	var _arg4 C.gint // out
	var _cret C.gint // in

	_arg1 = C.gint(aN)
	_arg2 = C.gint(aD)
	_arg3 = C.gint(bN)
	_arg4 = C.gint(bD)

	_cret = C.gst_util_fraction_compare(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(aN)
	runtime.KeepAlive(aD)
	runtime.KeepAlive(bN)
	runtime.KeepAlive(bD)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UtilFractionMultiply multiplies the fractions a_n/a_d and b_n/b_d and stores
// the result in res_n and res_d.
//
// The function takes the following parameters:
//
//    - aN: numerator of first value.
//    - aD: denominator of first value.
//    - bN: numerator of second value.
//    - bD: denominator of second value.
//
// The function returns the following values:
//
//    - resN: pointer to #gint to hold the result numerator.
//    - resD: pointer to #gint to hold the result denominator.
//    - ok: FALSE on overflow, TRUE otherwise.
//
func UtilFractionMultiply(aN, aD, bN, bD int) (resN, resD int, ok bool) {
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _arg4 C.gint     // out
	var _arg5 C.gint     // in
	var _arg6 C.gint     // in
	var _cret C.gboolean // in

	_arg1 = C.gint(aN)
	_arg2 = C.gint(aD)
	_arg3 = C.gint(bN)
	_arg4 = C.gint(bD)

	_cret = C.gst_util_fraction_multiply(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(aN)
	runtime.KeepAlive(aD)
	runtime.KeepAlive(bN)
	runtime.KeepAlive(bD)

	var _resN int // out
	var _resD int // out
	var _ok bool  // out

	_resN = int(_arg5)
	_resD = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _resN, _resD, _ok
}

// UtilFractionToDouble transforms a fraction to a #gdouble.
//
// The function takes the following parameters:
//
//    - srcN: fraction numerator as #gint.
//    - srcD: fraction denominator #gint.
//
// The function returns the following values:
//
//    - dest: pointer to a #gdouble for the result.
//
func UtilFractionToDouble(srcN, srcD int) float64 {
	var _arg1 C.gint    // out
	var _arg2 C.gint    // out
	var _arg3 C.gdouble // in

	_arg1 = C.gint(srcN)
	_arg2 = C.gint(srcD)

	C.gst_util_fraction_to_double(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(srcN)
	runtime.KeepAlive(srcD)

	var _dest float64 // out

	_dest = float64(_arg3)

	return _dest
}

// The function takes the following parameters:
//
//    - value value to convert guint64 double.
//
// The function returns the following values:
//
//    - guint64: value casted to #guint64.
//
func UtilGdoubleToGuint64(value float64) uint64 {
	var _arg1 C.gdouble // out
	var _cret C.guint64 // in

	_arg1 = C.gdouble(value)

	_cret = C.gst_util_gdouble_to_guint64(_arg1)
	runtime.KeepAlive(value)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilGetTimestamp: get a timestamp as GstClockTime to be used for interval
// measurements. The timestamp should not be interpreted in any other way.
//
// The function returns the following values:
//
//    - clockTime: timestamp.
//
func UtilGetTimestamp() ClockTime {
	var _cret C.GstClockTime // in

	_cret = C.gst_util_get_timestamp()

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// UtilGreatestCommonDivisor calculates the greatest common divisor of a and b.
//
// The function takes the following parameters:
//
//    - a: first value as #gint.
//    - b: second value as #gint.
//
// The function returns the following values:
//
//    - gint: greatest common divisor of a and b.
//
func UtilGreatestCommonDivisor(a, b int) int {
	var _arg1 C.gint // out
	var _arg2 C.gint // out
	var _cret C.gint // in

	_arg1 = C.gint(a)
	_arg2 = C.gint(b)

	_cret = C.gst_util_greatest_common_divisor(_arg1, _arg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UtilGreatestCommonDivisorInt64 calculates the greatest common divisor of a
// and b.
//
// The function takes the following parameters:
//
//    - a: first value as #gint64.
//    - b: second value as #gint64.
//
// The function returns the following values:
//
//    - gint64: greatest common divisor of a and b.
//
func UtilGreatestCommonDivisorInt64(a, b int64) int64 {
	var _arg1 C.gint64 // out
	var _arg2 C.gint64 // out
	var _cret C.gint64 // in

	_arg1 = C.gint64(a)
	_arg2 = C.gint64(b)

	_cret = C.gst_util_greatest_common_divisor_int64(_arg1, _arg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// UtilGroupIDNext: return a constantly incrementing group id.
//
// This function is used to generate a new group-id for the stream-start event.
//
// This function never returns GST_GROUP_ID_INVALID (which is 0).
//
// The function returns the following values:
//
//    - guint: constantly incrementing unsigned integer, which might overflow
//      back to 0 at some point.
//
func UtilGroupIDNext() uint {
	var _cret C.guint // in

	_cret = C.gst_util_group_id_next()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//    - value value to convert to double.
//
// The function returns the following values:
//
//    - gdouble: value casted to #gdouble.
//
func UtilGuint64ToGdouble(value uint64) float64 {
	var _arg1 C.guint64 // out
	var _cret C.gdouble // in

	_arg1 = C.guint64(value)

	_cret = C.gst_util_guint64_to_gdouble(_arg1)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// UtilSeqnumCompare: compare two sequence numbers, handling wraparound.
//
// The current implementation just returns (gint32)(s1 - s2).
//
// The function takes the following parameters:
//
//    - s1: sequence number.
//    - s2: another sequence number.
//
// The function returns the following values:
//
//    - gint32: negative number if s1 is before s2, 0 if they are equal, or a
//      positive number if s1 is after s2.
//
func UtilSeqnumCompare(s1, s2 uint32) int32 {
	var _arg1 C.guint32 // out
	var _arg2 C.guint32 // out
	var _cret C.gint32  // in

	_arg1 = C.guint32(s1)
	_arg2 = C.guint32(s2)

	_cret = C.gst_util_seqnum_compare(_arg1, _arg2)
	runtime.KeepAlive(s1)
	runtime.KeepAlive(s2)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// UtilSeqnumNext: return a constantly incrementing sequence number.
//
// This function is used internally to GStreamer to be able to determine which
// events and messages are "the same". For example, elements may set the seqnum
// on a segment-done message to be the same as that of the last seek event, to
// indicate that event and the message correspond to the same segment.
//
// This function never returns GST_SEQNUM_INVALID (which is 0).
//
// The function returns the following values:
//
//    - guint32: constantly incrementing 32-bit unsigned integer, which might
//      overflow at some point. Use gst_util_seqnum_compare() to make sure you
//      handle wraparound correctly.
//
func UtilSeqnumNext() uint32 {
	var _cret C.guint32 // in

	_cret = C.gst_util_seqnum_next()

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// UtilSetObjectArg converts the string value to the type of the objects
// argument and sets the argument with it.
//
// Note that this function silently returns if object has no property named name
// or when value cannot be converted to the type of the property.
//
// The function takes the following parameters:
//
//    - object to set the argument of.
//    - name of the argument to set.
//    - value: string value to set.
//
func UtilSetObjectArg(object *coreglib.Object, name, value string) {
	var _arg1 *C.GObject // out
	var _arg2 *C.gchar   // out
	var _arg3 *C.gchar   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_util_set_object_arg(_arg1, _arg2, _arg3)
	runtime.KeepAlive(object)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// UtilSetValueFromString converts the string to the type of the value and sets
// the value with it.
//
// Note that this function is dangerous as it does not return any indication if
// the conversion worked or not.
//
// The function takes the following parameters:
//
//    - valueStr: string to get the value from.
//
// The function returns the following values:
//
//    - value to set.
//
func UtilSetValueFromString(valueStr string) coreglib.Value {
	var _arg1 C.GValue // in
	var _arg2 *C.gchar // out

	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(valueStr)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_util_set_value_from_string(&_arg1, _arg2)
	runtime.KeepAlive(valueStr)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _value
}

// UtilUint64Scale: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision.
//
// This function can potentially be very slow if val and num are both greater
// than G_MAXUINT32.
//
// The function takes the following parameters:
//
//    - val: number to scale.
//    - num: numerator of the scale ratio.
//    - denom: denominator of the scale ratio.
//
// The function returns the following values:
//
//    - guint64: val * num / denom. In the case of an overflow, this function
//      returns G_MAXUINT64. If the result is not exactly representable as an
//      integer it is truncated. See also gst_util_uint64_scale_round(),
//      gst_util_uint64_scale_ceil(), gst_util_uint64_scale_int(),
//      gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().
//
func UtilUint64Scale(val, num, denom uint64) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.guint64 // out
	var _arg3 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.guint64(num)
	_arg3 = C.guint64(denom)

	_cret = C.gst_util_uint64_scale(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleCeil: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision.
//
// This function can potentially be very slow if val and num are both greater
// than G_MAXUINT32.
//
// The function takes the following parameters:
//
//    - val: number to scale.
//    - num: numerator of the scale ratio.
//    - denom: denominator of the scale ratio.
//
// The function returns the following values:
//
//    - guint64: val * num / denom. In the case of an overflow, this function
//      returns G_MAXUINT64. If the result is not exactly representable as an
//      integer, it is rounded up. See also gst_util_uint64_scale(),
//      gst_util_uint64_scale_round(), gst_util_uint64_scale_int(),
//      gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().
//
func UtilUint64ScaleCeil(val, num, denom uint64) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.guint64 // out
	var _arg3 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.guint64(num)
	_arg3 = C.guint64(denom)

	_cret = C.gst_util_uint64_scale_ceil(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleInt: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision. num must be
// non-negative and denom must be positive.
//
// The function takes the following parameters:
//
//    - val: guint64 (such as a ClockTime) to scale.
//    - num: numerator of the scale factor.
//    - denom: denominator of the scale factor.
//
// The function returns the following values:
//
//    - guint64: val * num / denom. In the case of an overflow, this function
//      returns G_MAXUINT64. If the result is not exactly representable as an
//      integer, it is truncated. See also gst_util_uint64_scale_int_round(),
//      gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(),
//      gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().
//
func UtilUint64ScaleInt(val uint64, num, denom int) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.gint(num)
	_arg3 = C.gint(denom)

	_cret = C.gst_util_uint64_scale_int(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleIntCeil: scale val by the rational number num / denom,
// avoiding overflows and underflows and without loss of precision. num must be
// non-negative and denom must be positive.
//
// The function takes the following parameters:
//
//    - val: guint64 (such as a ClockTime) to scale.
//    - num: numerator of the scale factor.
//    - denom: denominator of the scale factor.
//
// The function returns the following values:
//
//    - guint64: val * num / denom. In the case of an overflow, this function
//      returns G_MAXUINT64. If the result is not exactly representable as an
//      integer, it is rounded up. See also gst_util_uint64_scale_int(),
//      gst_util_uint64_scale_int_round(), gst_util_uint64_scale(),
//      gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().
//
func UtilUint64ScaleIntCeil(val uint64, num, denom int) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.gint(num)
	_arg3 = C.gint(denom)

	_cret = C.gst_util_uint64_scale_int_ceil(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleIntRound: scale val by the rational number num / denom,
// avoiding overflows and underflows and without loss of precision. num must be
// non-negative and denom must be positive.
//
// The function takes the following parameters:
//
//    - val: guint64 (such as a ClockTime) to scale.
//    - num: numerator of the scale factor.
//    - denom: denominator of the scale factor.
//
// The function returns the following values:
//
//    - guint64: val * num / denom. In the case of an overflow, this function
//      returns G_MAXUINT64. If the result is not exactly representable as an
//      integer, it is rounded to the nearest integer (half-way cases are rounded
//      up). See also gst_util_uint64_scale_int(),
//      gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(),
//      gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().
//
func UtilUint64ScaleIntRound(val uint64, num, denom int) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.gint(num)
	_arg3 = C.gint(denom)

	_cret = C.gst_util_uint64_scale_int_round(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleRound: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision.
//
// This function can potentially be very slow if val and num are both greater
// than G_MAXUINT32.
//
// The function takes the following parameters:
//
//    - val: number to scale.
//    - num: numerator of the scale ratio.
//    - denom: denominator of the scale ratio.
//
// The function returns the following values:
//
//    - guint64: val * num / denom. In the case of an overflow, this function
//      returns G_MAXUINT64. If the result is not exactly representable as an
//      integer, it is rounded to the nearest integer (half-way cases are rounded
//      up). See also gst_util_uint64_scale(), gst_util_uint64_scale_ceil(),
//      gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(),
//      gst_util_uint64_scale_int_ceil().
//
func UtilUint64ScaleRound(val, num, denom uint64) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.guint64 // out
	var _arg3 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.guint64(num)
	_arg3 = C.guint64(denom)

	_cret = C.gst_util_uint64_scale_round(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ElementStateChangeReturnGetName gets a string representing the given state
// change result.
//
// The function takes the following parameters:
//
//    - stateRet to get the name of.
//
// The function returns the following values:
//
//    - utf8: string with the name of the state result.
//
func ElementStateChangeReturnGetName(stateRet StateChangeReturn) string {
	var _arg1 C.GstStateChangeReturn // out
	var _cret *C.gchar               // in

	_arg1 = C.GstStateChangeReturn(stateRet)

	_cret = C.gst_element_state_change_return_get_name(_arg1)
	runtime.KeepAlive(stateRet)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ElementStateGetName gets a string representing the given state.
//
// The function takes the following parameters:
//
//    - state to get the name of.
//
// The function returns the following values:
//
//    - utf8: string with the name of the state.
//
func ElementStateGetName(state State) string {
	var _arg1 C.GstState // out
	var _cret *C.gchar   // in

	_arg1 = C.GstState(state)

	_cret = C.gst_element_state_get_name(_arg1)
	runtime.KeepAlive(state)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}
