// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gboolean _gotk4_gst1_StructureMapFunc(GQuark, GValue*, gpointer);
// extern gboolean _gotk4_gst1_StructureForEachFunc(GQuark, GValue*, gpointer);
// extern gboolean _gotk4_gst1_StructureFilterMapFunc(GQuark, GValue*, gpointer);
import "C"

// GType values.
var (
	GTypeStructure = coreglib.Type(C.gst_structure_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStructure, F: marshalStructure},
	})
}

// StructureFilterMapFunc: function that will be called in
// gst_structure_filter_and_map_in_place(). The function may modify value, and
// the value will be removed from the structure if FALSE is returned.
type StructureFilterMapFunc func(fieldId glib.Quark, value *coreglib.Value) (ok bool)

// StructureForEachFunc: function that will be called in
// gst_structure_foreach(). The function may not modify value.
type StructureForEachFunc func(fieldId glib.Quark, value *coreglib.Value) (ok bool)

// StructureMapFunc: function that will be called in
// gst_structure_map_in_place(). The function may modify value.
type StructureMapFunc func(fieldId glib.Quark, value *coreglib.Value) (ok bool)

// Structure is a collection of key/value pairs. The keys are expressed as
// GQuarks and the values can be of any GType.
//
// In addition to the key/value pairs, a Structure also has a name. The name
// starts with a letter and can be filled by letters, numbers and any of
// "/-_.:".
//
// Structure is used by various GStreamer subsystems to store information in a
// flexible and extensible way. A Structure does not have a refcount because it
// usually is part of a higher level object such as Caps, Message, Event, Query.
// It provides a means to enforce mutability using the refcount of the parent
// with the gst_structure_set_parent_refcount() method.
//
// A Structure can be created with gst_structure_new_empty() or
// gst_structure_new(), which both take a name and an optional set of key/value
// pairs along with the types of the values.
//
// Field values can be changed with gst_structure_set_value() or
// gst_structure_set().
//
// Field values can be retrieved with gst_structure_get_value() or the more
// convenient gst_structure_get_*() functions.
//
// Fields can be removed with gst_structure_remove_field() or
// gst_structure_remove_fields().
//
// Strings in structures must be ASCII or UTF-8 encoded. Other encodings are not
// allowed. Strings may be NULL however.
//
//
// The serialization format
//
// GstStructure serialization format serialize the GstStructure name,
// keys/GType/values in a comma separated list with the structure name as first
// field without value followed by separated key/value pairs in the form
// key=value, for example:
//
//    a-structure, key=value
//
//
// `
//
// The values type will be inferred if not explicitly specified with the
// (GTypeName)value syntax, for example the following struct will have one field
// called 'is-string' which has the string 'true' as a value:
//
//    a-struct, field-is-string=(string)true, field-is-boolean=true
//
//
// *Note*: without specifying (string), field-is-string` type would have been
// inferred as boolean.
//
// *Note*: we specified (string) as a type even if gchararray is the actual
// GType name as for convenience some well known types have been aliased or
// abbreviated.
//
// To avoid specifying the type, you can give some hints to the "type system".
// For example to specify a value as a double, you should add a decimal (ie. 1
// is an int while 1.0 is a double).
//
// *Note*: when a structure is serialized with #gst_structure_to_string, all
// values are explicitly typed.
//
// Some types have special delimiters:
//
// - GstValueArray (GST_TYPE_ARRAY) are inside curly brackets ({ and }). For
// example a-structure, array={1, 2, 3}
//
// - Ranges are inside brackets ([ and ]). For example a-structure, range=[1, 6,
// 2] 1 being the min value, 6 the maximum and 2 the step. To specify a
// T_TYPE_INT64_RANGE you need to explicitly specify it like: a-structure,
// a-int64-range=(gint64) [1, 5]
//
// - GstValueList (GST_TYPE_LIST) are inside "less and greater than" (< and >).
// For example `a-structure, list=<1, 2, 3>
//
// Structures are delimited either by a null character \0 or a semicolon ; the
// latter allowing to store multiple structures in the same string (see Caps).
//
// Quotes are used as "default" delimiters and can be used around any types that
// don't use other delimiters (for example a-struct, i=(int)"1"). They are use
// to allow adding spaces or special characters (such as delimiters,
// semicolumns, etc..) inside strings and you can use backslashes \ to escape
// characters inside them, for example:
//
//    a-struct, special="\"{[(;)]}\" can be used inside quotes"
//
//
// They also allow for nested structure, such as:
//
//    a-struct, nested=(GstStructure)"nested-struct, nested=true"
//
//
// Since 1.20, nested structures and caps can be specified using brackets ([ and
// ]), for example:
//
//    a-struct, nested=[nested-struct, nested=true]
//
//
// > *note*: gst_structure_to_string() won't use that syntax for backward >
// compatibility reason, gst_structure_serialize() has been added for > that
// purpose.
//
// An instance of this type is always passed by reference.
type Structure struct {
	*structure
}

// structure is the struct that's finalized.
type structure struct {
	native *C.GstStructure
}

func marshalStructure(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Structure{&structure{(*C.GstStructure)(b)}}, nil
}

// NewStructureEmpty constructs a struct Structure.
func NewStructureEmpty(name string) *Structure {
	var _arg1 *C.gchar        // out
	var _cret *C.GstStructure // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_new_empty(_arg1)
	runtime.KeepAlive(name)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// NewStructureFromString constructs a struct Structure.
func NewStructureFromString(str string) *Structure {
	var _arg1 *C.gchar        // out
	var _cret *C.GstStructure // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_new_from_string(_arg1)
	runtime.KeepAlive(str)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// NewStructureIDEmpty constructs a struct Structure.
func NewStructureIDEmpty(quark glib.Quark) *Structure {
	var _arg1 C.GQuark        // out
	var _cret *C.GstStructure // in

	_arg1 = C.guint32(quark)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_structure_new_id_empty(_arg1)
	runtime.KeepAlive(quark)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// Type of a structure.
func (s *Structure) Type() coreglib.Type {
	valptr := &s.native._type
	var _v coreglib.Type // out
	_v = coreglib.Type(*valptr)
	return _v
}

// CanIntersect tries intersecting struct1 and struct2 and reports whether the
// result would not be empty.
//
// The function takes the following parameters:
//
//    - struct2: Structure.
//
// The function returns the following values:
//
//    - ok: TRUE if intersection would not be empty.
//
func (struct1 *Structure) CanIntersect(struct2 *Structure) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct1)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct2)))

	_cret = C.gst_structure_can_intersect(_arg0, _arg1)
	runtime.KeepAlive(struct1)
	runtime.KeepAlive(struct2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy duplicates a Structure and all its fields and values.
//
// Free-function: gst_structure_free.
//
// The function returns the following values:
//
//    - ret: new Structure.
//
func (structure *Structure) Copy() *Structure {
	var _arg0 *C.GstStructure // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_copy(_arg0)
	runtime.KeepAlive(structure)

	var _ret *Structure // out

	_ret = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _ret
}

// FilterAndMapInPlace calls the provided function once for each field in the
// Structure. In contrast to gst_structure_foreach(), the function may modify
// the fields. In contrast to gst_structure_map_in_place(), the field is removed
// from the structure if FALSE is returned from the function. The structure must
// be mutable.
//
// The function takes the following parameters:
//
//    - fn: function to call for each field.
//
func (structure *Structure) FilterAndMapInPlace(fn StructureFilterMapFunc) {
	var _arg0 *C.GstStructure             // out
	var _arg1 C.GstStructureFilterMapFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_StructureFilterMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_structure_filter_and_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fn)
}

// Fixate all values in structure using gst_value_fixate(). structure will be
// modified in-place and should be writable.
func (structure *Structure) Fixate() {
	var _arg0 *C.GstStructure // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_structure_fixate(_arg0)
	runtime.KeepAlive(structure)
}

// FixateField fixates a Structure by changing the given field with its fixated
// value.
//
// The function takes the following parameters:
//
//    - fieldName: field in structure.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure field could be fixated.
//
func (structure *Structure) FixateField(fieldName string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_fixate_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldBoolean fixates a Structure by changing the given field_name field
// to the given target boolean if that field is not fixed yet.
//
// The function takes the following parameters:
//
//    - fieldName: field in structure.
//    - target value of the fixation.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure could be fixated.
//
func (structure *Structure) FixateFieldBoolean(fieldName string, target bool) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	if target {
		_arg2 = C.TRUE
	}

	_cret = C.gst_structure_fixate_field_boolean(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldNearestDouble fixates a Structure by changing the given field to
// the nearest double to target that is a subset of the existing field.
//
// The function takes the following parameters:
//
//    - fieldName: field in structure.
//    - target value of the fixation.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure could be fixated.
//
func (structure *Structure) FixateFieldNearestDouble(fieldName string, target float64) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.double        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(target)

	_cret = C.gst_structure_fixate_field_nearest_double(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldNearestFraction fixates a Structure by changing the given field to
// the nearest fraction to target_numerator/target_denominator that is a subset
// of the existing field.
//
// The function takes the following parameters:
//
//    - fieldName: field in structure.
//    - targetNumerator: numerator of the target value of the fixation.
//    - targetDenominator: denominator of the target value of the fixation.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure could be fixated.
//
func (structure *Structure) FixateFieldNearestFraction(fieldName string, targetNumerator int, targetDenominator int) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(targetNumerator)
	_arg3 = C.gint(targetDenominator)

	_cret = C.gst_structure_fixate_field_nearest_fraction(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(targetNumerator)
	runtime.KeepAlive(targetDenominator)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldNearestInt fixates a Structure by changing the given field to the
// nearest integer to target that is a subset of the existing field.
//
// The function takes the following parameters:
//
//    - fieldName: field in structure.
//    - target value of the fixation.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure could be fixated.
//
func (structure *Structure) FixateFieldNearestInt(fieldName string, target int) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(target)

	_cret = C.gst_structure_fixate_field_nearest_int(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldString fixates a Structure by changing the given field_name field
// to the given target string if that field is not fixed yet.
//
// The function takes the following parameters:
//
//    - fieldName: field in structure.
//    - target value of the fixation.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure could be fixated.
//
func (structure *Structure) FixateFieldString(fieldName string, target string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(target)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_structure_fixate_field_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEach calls the provided function once for each field in the Structure. The
// function must not modify the fields. Also see gst_structure_map_in_place()
// and gst_structure_filter_and_map_in_place().
//
// The function takes the following parameters:
//
//    - fn: function to call for each field.
//
// The function returns the following values:
//
//    - ok: TRUE if the supplied function returns TRUE For each of the fields,
//      FALSE otherwise.
//
func (structure *Structure) ForEach(fn StructureForEachFunc) bool {
	var _arg0 *C.GstStructure           // out
	var _arg1 C.GstStructureForeachFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_StructureForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_structure_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean sets the boolean pointed to by value corresponding to the value of
// the given field. Caller is responsible for making sure the field exists and
// has the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a #gboolean to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a boolean, this function
//      returns FALSE.
//
func (structure *Structure) Boolean(fieldname string) (value bool, ok bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_boolean(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value bool // out
	var _ok bool    // out

	if _arg2 != 0 {
		_value = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// ClockTime sets the clock time pointed to by value corresponding to the clock
// time of the given field. Caller is responsible for making sure the field
// exists and has the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a ClockTime to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a ClockTime, this
//      function returns FALSE.
//
func (structure *Structure) ClockTime(fieldname string) (ClockTime, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GstClockTime  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_clock_time(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value ClockTime // out
	var _ok bool         // out

	_value = uint64(_arg2)
	type _ = ClockTime
	type _ = uint64
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// DateTime sets the datetime pointed to by value corresponding to the datetime
// of the given field. Caller is responsible for making sure the field exists
// and has the correct type.
//
// On success value will point to a reference of the datetime which should be
// unreffed with gst_date_time_unref() when no longer needed (note: this is
// inconsistent with e.g. gst_structure_get_string() which doesn't return a copy
// of the string).
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a DateTime to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a data, this function
//      returns FALSE.
//
func (structure *Structure) DateTime(fieldname string) (*DateTime, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GstDateTime  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_date_time(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value *DateTime // out
	var _ok bool         // out

	_value = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_date_time_unref((*C.GstDateTime)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Double sets the double pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists and has
// the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a gdouble to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a double, this function
//      returns FALSE.
//
func (structure *Structure) Double(fieldname string) (float64, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gdouble       // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_double(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Enum sets the int pointed to by value corresponding to the value of the given
// field. Caller is responsible for making sure the field exists, has the
// correct type and that the enumtype is correct.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//    - enumtype: enum type of a field.
//
// The function returns the following values:
//
//    - value: pointer to an int to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain an enum of the given
//      type, this function returns FALSE.
//
func (structure *Structure) Enum(fieldname string, enumtype coreglib.Type) (int, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GType         // out
	var _arg3 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(enumtype)

	_cret = C.gst_structure_get_enum(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(enumtype)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// FieldType finds the field with the given name, and returns the type of the
// value it contains. If the field is not found, G_TYPE_INVALID is returned.
//
// The function takes the following parameters:
//
//    - fieldname: name of the field.
//
// The function returns the following values:
//
//    - gType of the field.
//
func (structure *Structure) FieldType(fieldname string) coreglib.Type {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret C.GType         // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_field_type(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Flagset: read the GstFlagSet flags and mask out of the structure into the
// provided pointers.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - valueFlags (optional): pointer to a guint for the flags field.
//    - valueMask (optional): pointer to a guint for the mask field.
//    - ok: TRUE if the values could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a GstFlagSet, this
//      function returns FALSE.
//
func (structure *Structure) Flagset(fieldname string) (valueFlags uint, valueMask uint, ok bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.guint         // in
	var _arg3 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_flagset(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _valueFlags uint // out
	var _valueMask uint  // out
	var _ok bool         // out

	_valueFlags = uint(_arg2)
	_valueMask = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _valueFlags, _valueMask, _ok
}

// Fraction sets the integers pointed to by value_numerator and
// value_denominator corresponding to the value of the given field. Caller is
// responsible for making sure the field exists and has the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - valueNumerator: pointer to an int to set.
//    - valueDenominator: pointer to an int to set.
//    - ok: TRUE if the values could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a GstFraction, this
//      function returns FALSE.
//
func (structure *Structure) Fraction(fieldname string) (valueNumerator int, valueDenominator int, ok bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint          // in
	var _arg3 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_fraction(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _valueNumerator int   // out
	var _valueDenominator int // out
	var _ok bool              // out

	_valueNumerator = int(_arg2)
	_valueDenominator = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _valueNumerator, _valueDenominator, _ok
}

// Int sets the int pointed to by value corresponding to the value of the given
// field. Caller is responsible for making sure the field exists and has the
// correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to an int to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain an int, this function
//      returns FALSE.
//
func (structure *Structure) Int(fieldname string) (int, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_int(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Int64 sets the #gint64 pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists and has
// the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a #gint64 to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a #gint64, this function
//      returns FALSE.
//
func (structure *Structure) Int64(fieldname string) (int64, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint64        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_int64(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value int64 // out
	var _ok bool     // out

	_value = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Name: get the name of structure as a string.
//
// The function returns the following values:
//
//    - utf8: name of the structure.
//
func (structure *Structure) Name() string {
	var _arg0 *C.GstStructure // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_get_name(_arg0)
	runtime.KeepAlive(structure)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NameID: get the name of structure as a GQuark.
//
// The function returns the following values:
//
//    - quark representing the name of the structure.
//
func (structure *Structure) NameID() glib.Quark {
	var _arg0 *C.GstStructure // out
	var _cret C.GQuark        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_get_name_id(_arg0)
	runtime.KeepAlive(structure)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// String finds the field corresponding to fieldname, and returns the string
// contained in the field's value. Caller is responsible for making sure the
// field exists and has the correct type.
//
// The string should not be modified, and remains valid until the next call to a
// gst_structure_*() function with the given structure.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - utf8 (optional): pointer to the string or NULL when the field did not
//      exist or did not contain a string.
//
func (structure *Structure) String(fieldname string) string {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_string(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Uint sets the uint pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists and has
// the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a uint to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a uint, this function
//      returns FALSE.
//
func (structure *Structure) Uint(fieldname string) (uint, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_uint(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Uint64 sets the #guint64 pointed to by value corresponding to the value of
// the given field. Caller is responsible for making sure the field exists and
// has the correct type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - value: pointer to a #guint64 to set.
//    - ok: TRUE if the value could be set correctly. If there was no field with
//      fieldname or the existing field did not contain a #guint64, this function
//      returns FALSE.
//
func (structure *Structure) Uint64(fieldname string) (uint64, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.guint64       // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_uint64(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value uint64 // out
	var _ok bool      // out

	_value = uint64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Value: get the value of the field with name fieldname.
//
// The function takes the following parameters:
//
//    - fieldname: name of the field to get.
//
// The function returns the following values:
//
//    - value (optional) corresponding to the field with the given name.
//
func (structure *Structure) Value(fieldname string) *coreglib.Value {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret *C.GValue       // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_value(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// HasField: check if structure contains a field named fieldname.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure contains a field with the given name.
//
func (structure *Structure) HasField(fieldname string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_has_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFieldTyped: check if structure contains a field named fieldname and with
// GType type.
//
// The function takes the following parameters:
//
//    - fieldname: name of a field.
//    - typ: type of a value.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure contains a field with the given name and type.
//
func (structure *Structure) HasFieldTyped(fieldname string, typ coreglib.Type) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GType         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(typ)

	_cret = C.gst_structure_has_field_typed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasName checks if the structure has the given name.
//
// The function takes the following parameters:
//
//    - name: structure name to check for.
//
// The function returns the following values:
//
//    - ok: TRUE if name matches the name of the structure.
//
func (structure *Structure) HasName(name string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_has_name(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDGetValue: get the value of the field with GQuark field.
//
// The function takes the following parameters:
//
//    - field of the field to get.
//
// The function returns the following values:
//
//    - value (optional) corresponding to the field with the given name
//      identifier.
//
func (structure *Structure) IDGetValue(field glib.Quark) *coreglib.Value {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _cret *C.GValue       // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint32(field)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_structure_id_get_value(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// IDHasField: check if structure contains a field named field.
//
// The function takes the following parameters:
//
//    - field of the field name.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure contains a field with the given name.
//
func (structure *Structure) IDHasField(field glib.Quark) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint32(field)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_structure_id_has_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDHasFieldTyped: check if structure contains a field named field and with
// GType type.
//
// The function takes the following parameters:
//
//    - field of the field name.
//    - typ: type of a value.
//
// The function returns the following values:
//
//    - ok: TRUE if the structure contains a field with the given name and type.
//
func (structure *Structure) IDHasFieldTyped(field glib.Quark, typ coreglib.Type) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _arg2 C.GType         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint32(field)
	type _ = glib.Quark
	type _ = uint32
	_arg2 = C.GType(typ)

	_cret = C.gst_structure_id_has_field_typed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDSetValue sets the field with the given GQuark field to value. If the field
// does not exist, it is created. If the field exists, the previous value is
// replaced and freed.
//
// The function takes the following parameters:
//
//    - field representing a field.
//    - value: new value of the field.
//
func (structure *Structure) IDSetValue(field glib.Quark, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint32(field)
	type _ = glib.Quark
	type _ = uint32
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_id_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)
	runtime.KeepAlive(value)
}

// IDTakeValue sets the field with the given GQuark field to value. If the field
// does not exist, it is created. If the field exists, the previous value is
// replaced and freed.
//
// The function takes the following parameters:
//
//    - field representing a field.
//    - value: new value of the field.
//
func (structure *Structure) IDTakeValue(field glib.Quark, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint32(field)
	type _ = glib.Quark
	type _ = uint32
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_id_take_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)
	runtime.KeepAlive(value)
}

// Intersect intersects struct1 and struct2 and returns the intersection.
//
// The function takes the following parameters:
//
//    - struct2: Structure.
//
// The function returns the following values:
//
//    - structure (optional): intersection of struct1 and struct2.
//
func (struct1 *Structure) Intersect(struct2 *Structure) *Structure {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct1)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct2)))

	_cret = C.gst_structure_intersect(_arg0, _arg1)
	runtime.KeepAlive(struct1)
	runtime.KeepAlive(struct2)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// IsEqual tests if the two Structure are equal.
//
// The function takes the following parameters:
//
//    - structure2: Structure.
//
// The function returns the following values:
//
//    - ok: TRUE if the two structures have the same name and field.
//
func (structure1 *Structure) IsEqual(structure2 *Structure) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure1)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure2)))

	_cret = C.gst_structure_is_equal(_arg0, _arg1)
	runtime.KeepAlive(structure1)
	runtime.KeepAlive(structure2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubset checks if subset is a subset of superset, i.e. has the same
// structure name and for all fields that are existing in superset, subset has a
// value that is a subset of the value in superset.
//
// The function takes the following parameters:
//
//    - superset: potentially greater Structure.
//
// The function returns the following values:
//
//    - ok: TRUE if subset is a subset of superset.
//
func (subset *Structure) IsSubset(superset *Structure) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(subset)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(superset)))

	_cret = C.gst_structure_is_subset(_arg0, _arg1)
	runtime.KeepAlive(subset)
	runtime.KeepAlive(superset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MapInPlace calls the provided function once for each field in the Structure.
// In contrast to gst_structure_foreach(), the function may modify but not
// delete the fields. The structure must be mutable.
//
// The function takes the following parameters:
//
//    - fn: function to call for each field.
//
// The function returns the following values:
//
//    - ok: TRUE if the supplied function returns TRUE For each of the fields,
//      FALSE otherwise.
//
func (structure *Structure) MapInPlace(fn StructureMapFunc) bool {
	var _arg0 *C.GstStructure       // out
	var _arg1 C.GstStructureMapFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_StructureMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_structure_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NFields: get the number of fields in the structure.
//
// The function returns the following values:
//
//    - gint: number of fields in the structure.
//
func (structure *Structure) NFields() int {
	var _arg0 *C.GstStructure // out
	var _cret C.gint          // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_n_fields(_arg0)
	runtime.KeepAlive(structure)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthFieldName: get the name of the given field number, counting from 0
// onwards.
//
// The function takes the following parameters:
//
//    - index to get the name of.
//
// The function returns the following values:
//
//    - utf8: name of the given field number.
//
func (structure *Structure) NthFieldName(index uint) string {
	var _arg0 *C.GstStructure // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint(index)

	_cret = C.gst_structure_nth_field_name(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(index)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RemoveAllFields removes all fields in a GstStructure.
func (structure *Structure) RemoveAllFields() {
	var _arg0 *C.GstStructure // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_structure_remove_all_fields(_arg0)
	runtime.KeepAlive(structure)
}

// RemoveField removes the field with the given name. If the field with the
// given name does not exist, the structure is unchanged.
//
// The function takes the following parameters:
//
//    - fieldname: name of the field to remove.
//
func (structure *Structure) RemoveField(fieldname string) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_structure_remove_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
}

// Serialize converts structure to a human-readable string representation.
//
// This version of the caps serialization function introduces support for nested
// structures and caps but the resulting strings won't be parsable with
// GStreamer prior to 1.20 unless T_SERIALIZE_FLAG_BACKWARD_COMPAT is passed as
// flag.
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//    - flags to use to serialize structure.
//
// The function returns the following values:
//
//    - utf8: pointer to string allocated by g_malloc(). g_free() after usage.
//
func (structure *Structure) Serialize(flags SerializeFlags) string {
	var _arg0 *C.GstStructure     // out
	var _arg1 C.GstSerializeFlags // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GstSerializeFlags(flags)

	_cret = C.gst_structure_serialize(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetName sets the name of the structure to the given name. The string provided
// is copied before being used. It must not be empty, start with a letter and
// can be followed by letters, numbers and any of "/-_.:".
//
// The function takes the following parameters:
//
//    - name: new name of the structure.
//
func (structure *Structure) SetName(name string) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_structure_set_name(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(name)
}

// SetParentRefcount sets the parent_refcount field of Structure. This field is
// used to determine whether a structure is mutable or not. This function should
// only be called by code implementing parent objects of Structure, as described
// in the MT Refcounting section of the design documents.
//
// The function takes the following parameters:
//
//    - refcount: pointer to the parent's refcount.
//
// The function returns the following values:
//
//    - ok: TRUE if the parent refcount could be set.
//
func (structure *Structure) SetParentRefcount(refcount *int) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gint         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gint)(unsafe.Pointer(refcount))

	_cret = C.gst_structure_set_parent_refcount(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(refcount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetValue sets the field with the given name field to value. If the field does
// not exist, it is created. If the field exists, the previous value is replaced
// and freed.
//
// The function takes the following parameters:
//
//    - fieldname: name of the field to set.
//    - value: new value of the field.
//
func (structure *Structure) SetValue(fieldname string, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(value)
}

// TakeValue sets the field with the given name field to value. If the field
// does not exist, it is created. If the field exists, the previous value is
// replaced and freed. The function will take ownership of value.
//
// The function takes the following parameters:
//
//    - fieldname: name of the field to set.
//    - value: new value of the field.
//
func (structure *Structure) TakeValue(fieldname string, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_take_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(value)
}

// ToString converts structure to a human-readable string representation.
//
// For debugging purposes its easier to do something like this: |[<!--
// language="C" --> GST_LOG ("structure is %" GST_PTR_FORMAT, structure); ]|
// This prints the structure in human readable form.
//
// This function will lead to unexpected results when there are nested Caps /
// Structure deeper than one level, you should user gst_structure_serialize()
// instead for those cases.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//    - utf8: pointer to string allocated by g_malloc(). g_free() after usage.
//
func (structure *Structure) ToString() string {
	var _arg0 *C.GstStructure // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_to_string(_arg0)
	runtime.KeepAlive(structure)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}
