// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeElementFactory = coreglib.Type(C.gst_element_factory_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeElementFactory, F: marshalElementFactory},
	})
}

const ELEMENT_FACTORY_KLASS_DECODER = "Decoder"
const ELEMENT_FACTORY_KLASS_DECRYPTOR = "Decryptor"
const ELEMENT_FACTORY_KLASS_DEMUXER = "Demuxer"
const ELEMENT_FACTORY_KLASS_DEPAYLOADER = "Depayloader"
const ELEMENT_FACTORY_KLASS_ENCODER = "Encoder"
const ELEMENT_FACTORY_KLASS_ENCRYPTOR = "Encryptor"
const ELEMENT_FACTORY_KLASS_FORMATTER = "Formatter"
const ELEMENT_FACTORY_KLASS_MEDIA_AUDIO = "Audio"
const ELEMENT_FACTORY_KLASS_MEDIA_IMAGE = "Image"
const ELEMENT_FACTORY_KLASS_MEDIA_METADATA = "Metadata"
const ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE = "Subtitle"
const ELEMENT_FACTORY_KLASS_MEDIA_VIDEO = "Video"
const ELEMENT_FACTORY_KLASS_MUXER = "Muxer"
const ELEMENT_FACTORY_KLASS_PARSER = "Parser"
const ELEMENT_FACTORY_KLASS_PAYLOADER = "Payloader"
const ELEMENT_FACTORY_KLASS_SINK = "Sink"
const ELEMENT_FACTORY_KLASS_SRC = "Source"

// ElementFactoryListType: type defining the type of an element factory.
type ElementFactoryListType = uint64

// ElementRegister: create a new elementfactory capable of instantiating objects
// of the type and add the factory to plugin.
//
// The function takes the following parameters:
//
//    - plugin (optional) to register the element with, or NULL for a static
//      element.
//    - name of elements of this type.
//    - rank of element (higher rank means more importance when autoplugging).
//    - typ: GType of element to register.
//
// The function returns the following values:
//
//    - ok: TRUE, if the registering succeeded, FALSE on error.
//
func ElementRegister(plugin *Plugin, name string, rank uint, typ coreglib.Type) bool {
	var _arg1 *C.GstPlugin // out
	var _arg2 *C.gchar     // out
	var _arg3 C.guint      // out
	var _arg4 C.GType      // out
	var _cret C.gboolean   // in

	if plugin != nil {
		_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(rank)
	_arg4 = C.GType(typ)

	_cret = C.gst_element_register(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(name)
	runtime.KeepAlive(rank)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ElementFactory is used to create instances of elements. A GstElementFactory
// can be added to a Plugin as it is also a PluginFeature.
//
// Use the gst_element_factory_find() and gst_element_factory_create() functions
// to create element instances or use gst_element_factory_make() as a convenient
// shortcut.
//
// The following code example shows you how to create a GstFileSrc element.
//
// Using an element factory
//
//      #include <gst/gst.h>
//
//      GstElement *src;
//      GstElementFactory *srcfactory;
//
//      gst_init (&argc, &argv);
//
//      srcfactory = gst_element_factory_find ("filesrc");
//      g_return_if_fail (srcfactory != NULL);
//      src = gst_element_factory_create (srcfactory, "src");
//      g_return_if_fail (src != NULL);
//      ...
type ElementFactory struct {
	_ [0]func() // equal guard
	PluginFeature
}

var (
	_ PluginFeaturer = (*ElementFactory)(nil)
)

func wrapElementFactory(obj *coreglib.Object) *ElementFactory {
	return &ElementFactory{
		PluginFeature: PluginFeature{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalElementFactory(p uintptr) (interface{}, error) {
	return wrapElementFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CanSinkAllCaps checks if the factory can sink all possible capabilities.
//
// The function takes the following parameters:
//
//    - caps to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps are fully compatible.
//
func (factory *ElementFactory) CanSinkAllCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_sink_all_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSinkAnyCaps checks if the factory can sink any possible capability.
//
// The function takes the following parameters:
//
//    - caps to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps have a common subset.
//
func (factory *ElementFactory) CanSinkAnyCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_sink_any_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSrcAllCaps checks if the factory can src all possible capabilities.
//
// The function takes the following parameters:
//
//    - caps to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps are fully compatible.
//
func (factory *ElementFactory) CanSrcAllCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_src_all_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSrcAnyCaps checks if the factory can src any possible capability.
//
// The function takes the following parameters:
//
//    - caps to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps have a common subset.
//
func (factory *ElementFactory) CanSrcAnyCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_src_any_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Create a new element of the type defined by the given elementfactory. It will
// be given the name supplied, since all elements require a name as their first
// argument.
//
// The function takes the following parameters:
//
//    - name (optional) of new element, or NULL to automatically create a unique
//      name.
//
// The function returns the following values:
//
//    - element (optional): new Element or NULL if the element couldn't be
//      created.
//
func (factory *ElementFactory) Create(name string) Elementer {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.gchar             // out
	var _cret *C.GstElement        // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_element_factory_create(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// CreateWithProperties: create a new element of the type defined by the given
// elementfactory. The supplied list of properties, will be passed at object
// construction.
//
// The function takes the following parameters:
//
//    - names (optional): array of properties names.
//    - values (optional): array of associated properties values.
//
// The function returns the following values:
//
//    - element (optional): new Element or NULL if the element couldn't be
//      created.
//
func (factory *ElementFactory) CreateWithProperties(names []string, values []coreglib.Value) Elementer {
	var _arg0 *C.GstElementFactory // out
	var _arg2 **C.gchar            // out
	var _arg1 C.guint
	var _arg3 *C.GValue     // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (C.guint)(len(names))
	_arg2 = (**C.gchar)(C.calloc(C.size_t(len(names)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((**C.gchar)(_arg2), len(names))
		for i := range names {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(names[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg1 = (C.guint)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_element_factory_create_with_properties(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(names)
	runtime.KeepAlive(values)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ElementType: get the #GType for elements managed by this factory. The type
// can only be retrieved if the element factory is loaded, which can be assured
// with gst_plugin_feature_load().
//
// The function returns the following values:
//
//    - gType for elements managed by this factory or 0 if the factory is not
//      loaded.
//
func (factory *ElementFactory) ElementType() coreglib.Type {
	var _arg0 *C.GstElementFactory // out
	var _cret C.GType              // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_element_type(_arg0)
	runtime.KeepAlive(factory)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Metadata: get the metadata on factory with key.
//
// The function takes the following parameters:
//
//    - key: key.
//
// The function returns the following values:
//
//    - utf8 (optional): metadata with key on factory or NULL when there was no
//      metadata with the given key.
//
func (factory *ElementFactory) Metadata(key string) string {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.gchar             // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_factory_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MetadataKeys: get the available keys for the metadata on factory.
//
// The function returns the following values:
//
//    - utf8s (optional): a NULL-terminated array of key strings, or NULL when
//      there is no metadata. Free with g_strfreev() when no longer needed.
//
func (factory *ElementFactory) MetadataKeys() []string {
	var _arg0 *C.GstElementFactory // out
	var _cret **C.gchar            // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_metadata_keys(_arg0)
	runtime.KeepAlive(factory)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// NumPadTemplates gets the number of pad_templates in this factory.
//
// The function returns the following values:
//
//    - guint: number of pad_templates.
//
func (factory *ElementFactory) NumPadTemplates() uint {
	var _arg0 *C.GstElementFactory // out
	var _cret C.guint              // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_num_pad_templates(_arg0)
	runtime.KeepAlive(factory)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SkipDocumentation queries whether registered element managed by factory needs
// to be excluded from documentation system or not.
//
// The function returns the following values:
//
//    - ok: TRUE if documentation should be skipped.
//
func (factory *ElementFactory) SkipDocumentation() bool {
	var _arg0 *C.GstElementFactory // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_skip_documentation(_arg0)
	runtime.KeepAlive(factory)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StaticPadTemplates gets the #GList of StaticPadTemplate for this factory.
//
// The function returns the following values:
//
//    - list: the static pad templates.
//
func (factory *ElementFactory) StaticPadTemplates() []*StaticPadTemplate {
	var _arg0 *C.GstElementFactory // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_static_pad_templates(_arg0)
	runtime.KeepAlive(factory)

	var _list []*StaticPadTemplate // out

	_list = make([]*StaticPadTemplate, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstStaticPadTemplate)(v)
		var dst *StaticPadTemplate // out
		dst = (*StaticPadTemplate)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// URIProtocols gets a NULL-terminated array of protocols this element supports
// or NULL if no protocols are supported. You may not change the contents of the
// returned array, as it is still owned by the element factory. Use g_strdupv()
// to make a copy of the protocol string array if you need to.
//
// The function returns the following values:
//
//    - utf8s: supported protocols or NULL.
//
func (factory *ElementFactory) URIProtocols() []string {
	var _arg0 *C.GstElementFactory // out
	var _cret **C.gchar            // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_uri_protocols(_arg0)
	runtime.KeepAlive(factory)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// URIType gets the type of URIs the element supports or T_URI_UNKNOWN if none.
//
// The function returns the following values:
//
//    - uriType: type of URIs this element supports.
//
func (factory *ElementFactory) URIType() URIType {
	var _arg0 *C.GstElementFactory // out
	var _cret C.GstURIType         // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_uri_type(_arg0)
	runtime.KeepAlive(factory)

	var _uriType URIType // out

	_uriType = URIType(_cret)

	return _uriType
}

// HasInterface: check if factory implements the interface with name
// interfacename.
//
// The function takes the following parameters:
//
//    - interfacename: interface name.
//
// The function returns the following values:
//
//    - ok: TRUE when factory implement the interface.
//
func (factory *ElementFactory) HasInterface(interfacename string) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(interfacename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_factory_has_interface(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(interfacename)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListIsType: check if factory is of the given types.
//
// The function takes the following parameters:
//
//    - typ: ElementFactoryListType.
//
// The function returns the following values:
//
//    - ok: TRUE if factory is of type.
//
func (factory *ElementFactory) ListIsType(typ ElementFactoryListType) bool {
	var _arg0 *C.GstElementFactory        // out
	var _arg1 C.GstElementFactoryListType // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = C.guint64(typ)
	type _ = ElementFactoryListType
	type _ = uint64

	_cret = C.gst_element_factory_list_is_type(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ElementFactoryFind: search for an element factory of the given name. Refs the
// returned element factory; caller is responsible for unreffing.
//
// The function takes the following parameters:
//
//    - name of factory to find.
//
// The function returns the following values:
//
//    - elementFactory (optional) if found, NULL otherwise.
//
func ElementFactoryFind(name string) *ElementFactory {
	var _arg1 *C.gchar             // out
	var _cret *C.GstElementFactory // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_factory_find(_arg1)
	runtime.KeepAlive(name)

	var _elementFactory *ElementFactory // out

	if _cret != nil {
		_elementFactory = wrapElementFactory(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _elementFactory
}

// ElementFactoryListFilter: filter out all the elementfactories in list that
// can handle caps in the given direction.
//
// If subsetonly is TRUE, then only the elements whose pads templates are a
// complete superset of caps will be returned. Else any element whose pad
// templates caps can intersect with caps will be returned.
//
// The function takes the following parameters:
//
//    - list of ElementFactory to filter.
//    - caps: Caps.
//    - direction to filter on.
//    - subsetonly: whether to filter on caps subsets or not.
//
// The function returns the following values:
//
//    - ret of ElementFactory elements that match the given requisites. Use
//      #gst_plugin_feature_list_free after usage.
//
func ElementFactoryListFilter(list []*ElementFactory, caps *Caps, direction PadDirection, subsetonly bool) []*ElementFactory {
	var _arg1 *C.GList          // out
	var _arg2 *C.GstCaps        // out
	var _arg3 C.GstPadDirection // out
	var _arg4 C.gboolean        // out
	var _cret *C.GList          // in

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstElementFactory // out
		dst = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = C.GstPadDirection(direction)
	if subsetonly {
		_arg4 = C.TRUE
	}

	_cret = C.gst_element_factory_list_filter(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(list)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(subsetonly)

	var _ret []*ElementFactory // out

	_ret = make([]*ElementFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstElementFactory)(v)
		var dst *ElementFactory // out
		dst = wrapElementFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_ret = append(_ret, dst)
	})

	return _ret
}

// ElementFactoryListGetElements: get a list of factories that match the given
// type. Only elements with a rank greater or equal to minrank will be returned.
// The list of factories is returned by decreasing rank.
//
// The function takes the following parameters:
//
//    - typ: ElementFactoryListType.
//    - minrank: minimum rank.
//
// The function returns the following values:
//
//    - list of ElementFactory elements. Use gst_plugin_feature_list_free() after
//      usage.
//
func ElementFactoryListGetElements(typ ElementFactoryListType, minrank Rank) []*ElementFactory {
	var _arg1 C.GstElementFactoryListType // out
	var _arg2 C.GstRank                   // out
	var _cret *C.GList                    // in

	_arg1 = C.guint64(typ)
	type _ = ElementFactoryListType
	type _ = uint64
	_arg2 = C.GstRank(minrank)

	_cret = C.gst_element_factory_list_get_elements(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(minrank)

	var _list []*ElementFactory // out

	_list = make([]*ElementFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstElementFactory)(v)
		var dst *ElementFactory // out
		dst = wrapElementFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ElementFactoryMake: create a new element of the type defined by the given
// element factory. If name is NULL, then the element will receive a guaranteed
// unique name, consisting of the element factory name and a number. If name is
// given, it will be given the name supplied.
//
// The function takes the following parameters:
//
//    - factoryname: named factory to instantiate.
//    - name (optional) of new element, or NULL to automatically create a unique
//      name.
//
// The function returns the following values:
//
//    - element (optional): new Element or NULL if unable to create element.
//
func ElementFactoryMake(factoryname, name string) Elementer {
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryname)))
	defer C.free(unsafe.Pointer(_arg1))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_element_factory_make(_arg1, _arg2)
	runtime.KeepAlive(factoryname)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}
