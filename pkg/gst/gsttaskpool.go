// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_TaskPoolFunction(gpointer);
// extern void _gotk4_gst1_TaskPoolClass_prepare(GstTaskPool*, GError**);
// extern void _gotk4_gst1_TaskPoolClass_join(GstTaskPool*, gpointer);
// extern void _gotk4_gst1_TaskPoolClass_dispose_handle(GstTaskPool*, gpointer);
// extern void _gotk4_gst1_TaskPoolClass_cleanup(GstTaskPool*);
// gpointer _gotk4_gst1_TaskPool_virtual_push(void* fnptr, GstTaskPool* arg0, GstTaskPoolFunction arg1, gpointer arg2, GError** arg3) {
//   return ((gpointer (*)(GstTaskPool*, GstTaskPoolFunction, gpointer, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gst1_TaskPool_virtual_cleanup(void* fnptr, GstTaskPool* arg0) {
//   ((void (*)(GstTaskPool*))(fnptr))(arg0);
// };
// void _gotk4_gst1_TaskPool_virtual_dispose_handle(void* fnptr, GstTaskPool* arg0, gpointer arg1) {
//   ((void (*)(GstTaskPool*, gpointer))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_TaskPool_virtual_join(void* fnptr, GstTaskPool* arg0, gpointer arg1) {
//   ((void (*)(GstTaskPool*, gpointer))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_TaskPool_virtual_prepare(void* fnptr, GstTaskPool* arg0, GError** arg1) {
//   ((void (*)(GstTaskPool*, GError**))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeTaskPool = coreglib.Type(C.gst_task_pool_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTaskPool, F: marshalTaskPool},
	})
}

// TaskPoolFunction: task function, see gst_task_pool_push().
type TaskPoolFunction func()

// TaskPoolOverrides contains methods that are overridable.
type TaskPoolOverrides struct {
	// Cleanup: wait for all tasks to be stopped. This is mainly used internally
	// to ensure proper cleanup of internal data structures in test suites.
	//
	// MT safe.
	Cleanup func()
	// DisposeHandle: dispose of the handle returned by gst_task_pool_push().
	// This does not need to be called with the default implementation as the
	// default TaskPoolClass::push implementation always returns NULL. This does
	// not need to be called either when calling gst_task_pool_join(), but
	// should be called when joining is not necessary, but gst_task_pool_push()
	// returned a non-NULL value.
	//
	// This method should only be called with the same pool instance that
	// provided id.
	//
	// The function takes the following parameters:
	//
	//    - id (optional): id.
	//
	DisposeHandle func(id unsafe.Pointer)
	// Join a task and/or return it to the pool. id is the id obtained from
	// gst_task_pool_push(). The default implementation does nothing, as the
	// default TaskPoolClass::push implementation always returns NULL.
	//
	// This method should only be called with the same pool instance that
	// provided id.
	//
	// The function takes the following parameters:
	//
	//    - id (optional): id.
	//
	Join func(id unsafe.Pointer)
	// Prepare the taskpool for accepting gst_task_pool_push() operations.
	//
	// MT safe.
	Prepare func() error
}

func defaultTaskPoolOverrides(v *TaskPool) TaskPoolOverrides {
	return TaskPoolOverrides{
		Cleanup:       v.cleanup,
		DisposeHandle: v.disposeHandle,
		Join:          v.join,
		Prepare:       v.prepare,
	}
}

// TaskPool: this object provides an abstraction for creating threads. The
// default implementation uses a regular GThreadPool to start tasks.
//
// Subclasses can be made to create custom threads.
type TaskPool struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*TaskPool)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TaskPool, *TaskPoolClass, TaskPoolOverrides](
		GTypeTaskPool,
		initTaskPoolClass,
		wrapTaskPool,
		defaultTaskPoolOverrides,
	)
}

func initTaskPoolClass(gclass unsafe.Pointer, overrides TaskPoolOverrides, classInitFunc func(*TaskPoolClass)) {
	pclass := (*C.GstTaskPoolClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTaskPool))))

	if overrides.Cleanup != nil {
		pclass.cleanup = (*[0]byte)(C._gotk4_gst1_TaskPoolClass_cleanup)
	}

	if overrides.DisposeHandle != nil {
		pclass.dispose_handle = (*[0]byte)(C._gotk4_gst1_TaskPoolClass_dispose_handle)
	}

	if overrides.Join != nil {
		pclass.join = (*[0]byte)(C._gotk4_gst1_TaskPoolClass_join)
	}

	if overrides.Prepare != nil {
		pclass.prepare = (*[0]byte)(C._gotk4_gst1_TaskPoolClass_prepare)
	}

	if classInitFunc != nil {
		class := (*TaskPoolClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTaskPool(obj *coreglib.Object) *TaskPool {
	return &TaskPool{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalTaskPool(p uintptr) (interface{}, error) {
	return wrapTaskPool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTaskPool: create a new default task pool. The default task pool will use a
// regular GThreadPool for threads.
//
// The function returns the following values:
//
//    - taskPool: new TaskPool. gst_object_unref() after usage.
//
func NewTaskPool() *TaskPool {
	var _cret *C.GstTaskPool // in

	_cret = C.gst_task_pool_new()

	var _taskPool *TaskPool // out

	_taskPool = wrapTaskPool(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _taskPool
}

// Cleanup: wait for all tasks to be stopped. This is mainly used internally to
// ensure proper cleanup of internal data structures in test suites.
//
// MT safe.
func (pool *TaskPool) Cleanup() {
	var _arg0 *C.GstTaskPool // out

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C.gst_task_pool_cleanup(_arg0)
	runtime.KeepAlive(pool)
}

// DisposeHandle: dispose of the handle returned by gst_task_pool_push(). This
// does not need to be called with the default implementation as the default
// TaskPoolClass::push implementation always returns NULL. This does not need to
// be called either when calling gst_task_pool_join(), but should be called when
// joining is not necessary, but gst_task_pool_push() returned a non-NULL value.
//
// This method should only be called with the same pool instance that provided
// id.
//
// The function takes the following parameters:
//
//    - id (optional): id.
//
func (pool *TaskPool) DisposeHandle(id unsafe.Pointer) {
	var _arg0 *C.GstTaskPool // out
	var _arg1 C.gpointer     // out

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))

	C.gst_task_pool_dispose_handle(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(id)
}

// Join a task and/or return it to the pool. id is the id obtained from
// gst_task_pool_push(). The default implementation does nothing, as the default
// TaskPoolClass::push implementation always returns NULL.
//
// This method should only be called with the same pool instance that provided
// id.
//
// The function takes the following parameters:
//
//    - id (optional): id.
//
func (pool *TaskPool) Join(id unsafe.Pointer) {
	var _arg0 *C.GstTaskPool // out
	var _arg1 C.gpointer     // out

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))

	C.gst_task_pool_join(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(id)
}

// Prepare the taskpool for accepting gst_task_pool_push() operations.
//
// MT safe.
func (pool *TaskPool) Prepare() error {
	var _arg0 *C.GstTaskPool // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C.gst_task_pool_prepare(_arg0, &_cerr)
	runtime.KeepAlive(pool)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Push: start the execution of a new thread from pool.
//
// The function takes the following parameters:
//
//    - fn: function to call.
//
// The function returns the following values:
//
//    - gpointer (optional): pointer that should be used for the
//      gst_task_pool_join function. This pointer can be NULL, you must check
//      error to detect errors. If the pointer is not NULL and
//      gst_task_pool_join() is not used, call gst_task_pool_dispose_handle()
//      instead.
//
func (pool *TaskPool) Push(fn TaskPoolFunction) (unsafe.Pointer, error) {
	var _arg0 *C.GstTaskPool        // out
	var _arg1 C.GstTaskPoolFunction // out
	var _arg2 C.gpointer
	var _cret C.gpointer // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_TaskPoolFunction)
	_arg2 = C.gpointer(gbox.AssignOnce(fn))

	_cret = C.gst_task_pool_push(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(fn)

	var _gpointer unsafe.Pointer // out
	var _goerr error             // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gpointer, _goerr
}

// Cleanup: wait for all tasks to be stopped. This is mainly used internally to
// ensure proper cleanup of internal data structures in test suites.
//
// MT safe.
func (pool *TaskPool) cleanup() {
	gclass := (*C.GstTaskPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.cleanup

	var _arg0 *C.GstTaskPool // out

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C._gotk4_gst1_TaskPool_virtual_cleanup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)
}

// disposeHandle: dispose of the handle returned by gst_task_pool_push(). This
// does not need to be called with the default implementation as the default
// TaskPoolClass::push implementation always returns NULL. This does not need to
// be called either when calling gst_task_pool_join(), but should be called when
// joining is not necessary, but gst_task_pool_push() returned a non-NULL value.
//
// This method should only be called with the same pool instance that provided
// id.
//
// The function takes the following parameters:
//
//    - id (optional): id.
//
func (pool *TaskPool) disposeHandle(id unsafe.Pointer) {
	gclass := (*C.GstTaskPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.dispose_handle

	var _arg0 *C.GstTaskPool // out
	var _arg1 C.gpointer     // out

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))

	C._gotk4_gst1_TaskPool_virtual_dispose_handle(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(id)
}

// Join: join a task and/or return it to the pool. id is the id obtained from
// gst_task_pool_push(). The default implementation does nothing, as the default
// TaskPoolClass::push implementation always returns NULL.
//
// This method should only be called with the same pool instance that provided
// id.
//
// The function takes the following parameters:
//
//    - id (optional): id.
//
func (pool *TaskPool) join(id unsafe.Pointer) {
	gclass := (*C.GstTaskPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.join

	var _arg0 *C.GstTaskPool // out
	var _arg1 C.gpointer     // out

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))

	C._gotk4_gst1_TaskPool_virtual_join(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(id)
}

// Prepare: prepare the taskpool for accepting gst_task_pool_push() operations.
//
// MT safe.
func (pool *TaskPool) prepare() error {
	gclass := (*C.GstTaskPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.prepare

	var _arg0 *C.GstTaskPool // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C._gotk4_gst1_TaskPool_virtual_prepare(unsafe.Pointer(fnarg), _arg0, &_cerr)
	runtime.KeepAlive(pool)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Push: start the execution of a new thread from pool.
//
// The function takes the following parameters:
//
//    - fn: function to call.
//
// The function returns the following values:
//
//    - gpointer (optional): pointer that should be used for the
//      gst_task_pool_join function. This pointer can be NULL, you must check
//      error to detect errors. If the pointer is not NULL and
//      gst_task_pool_join() is not used, call gst_task_pool_dispose_handle()
//      instead.
//
func (pool *TaskPool) push(fn TaskPoolFunction) (unsafe.Pointer, error) {
	gclass := (*C.GstTaskPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.push

	var _arg0 *C.GstTaskPool        // out
	var _arg1 C.GstTaskPoolFunction // out
	var _arg2 C.gpointer
	var _cret C.gpointer // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GstTaskPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_TaskPoolFunction)
	_arg2 = C.gpointer(gbox.AssignOnce(fn))

	_cret = C._gotk4_gst1_TaskPool_virtual_push(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(fn)

	var _gpointer unsafe.Pointer // out
	var _goerr error             // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gpointer, _goerr
}

// TaskPoolClass object.
//
// An instance of this type is always passed by reference.
type TaskPoolClass struct {
	*taskPoolClass
}

// taskPoolClass is the struct that's finalized.
type taskPoolClass struct {
	native *C.GstTaskPoolClass
}

// ParentClass: parent class structure.
func (t *TaskPoolClass) ParentClass() *ObjectClass {
	valptr := &t.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
