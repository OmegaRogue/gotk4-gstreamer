// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_Device_ConnectRemoved(gpointer, guintptr);
// extern gboolean _gotk4_gst1_DeviceClass_reconfigure_element(GstDevice*, GstElement*);
// extern GstElement* _gotk4_gst1_DeviceClass_create_element(GstDevice*, gchar*);
// GstElement* _gotk4_gst1_Device_virtual_create_element(void* fnptr, GstDevice* arg0, gchar* arg1) {
//   return ((GstElement* (*)(GstDevice*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Device_virtual_reconfigure_element(void* fnptr, GstDevice* arg0, GstElement* arg1) {
//   return ((gboolean (*)(GstDevice*, GstElement*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeDevice = coreglib.Type(C.gst_device_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDevice, F: marshalDevice},
	})
}

// DeviceOverrides contains methods that are overridable.
type DeviceOverrides struct {
	// CreateElement creates the element with all of the required parameters set
	// to use this device.
	//
	// The function takes the following parameters:
	//
	//    - name (optional) of new element, or NULL to automatically create a
	//      unique name.
	//
	// The function returns the following values:
	//
	//    - element (optional): new Element configured to use this device.
	//
	CreateElement func(name string) Elementer
	// ReconfigureElement tries to reconfigure an existing element to use the
	// device. If this function fails, then one must destroy the element and
	// create a new one using gst_device_create_element().
	//
	// Note: This should only be implemented for elements can change their
	// device in the PLAYING state.
	//
	// The function takes the following parameters:
	//
	//    - element: Element.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the element could be reconfigured to use this device,
	//      FALSE otherwise.
	//
	ReconfigureElement func(element Elementer) bool
}

func defaultDeviceOverrides(v *Device) DeviceOverrides {
	return DeviceOverrides{
		CreateElement:      v.createElement,
		ReconfigureElement: v.reconfigureElement,
	}
}

// Device are objects representing a device, they contain relevant metadata
// about the device, such as its class and the Caps representing the media types
// it can produce or handle.
//
// Device are created by DeviceProvider objects which can be aggregated by
// DeviceMonitor objects.
type Device struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Device)(nil)
)

// Devicer describes types inherited from class Device.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Devicer interface {
	coreglib.Objector
	baseDevice() *Device
}

var _ Devicer = (*Device)(nil)

func init() {
	coreglib.RegisterClassInfo[*Device, *DeviceClass, DeviceOverrides](
		GTypeDevice,
		initDeviceClass,
		wrapDevice,
		defaultDeviceOverrides,
	)
}

func initDeviceClass(gclass unsafe.Pointer, overrides DeviceOverrides, classInitFunc func(*DeviceClass)) {
	pclass := (*C.GstDeviceClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDevice))))

	if overrides.CreateElement != nil {
		pclass.create_element = (*[0]byte)(C._gotk4_gst1_DeviceClass_create_element)
	}

	if overrides.ReconfigureElement != nil {
		pclass.reconfigure_element = (*[0]byte)(C._gotk4_gst1_DeviceClass_reconfigure_element)
	}

	if classInitFunc != nil {
		class := (*DeviceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDevice(obj *coreglib.Object) *Device {
	return &Device{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	return wrapDevice(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (device *Device) baseDevice() *Device {
	return device
}

// BaseDevice returns the underlying base object.
func BaseDevice(obj Devicer) *Device {
	return obj.baseDevice()
}

func (device *Device) ConnectRemoved(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(device, "removed", false, unsafe.Pointer(C._gotk4_gst1_Device_ConnectRemoved), f)
}

// CreateElement creates the element with all of the required parameters set to
// use this device.
//
// The function takes the following parameters:
//
//    - name (optional) of new element, or NULL to automatically create a unique
//      name.
//
// The function returns the following values:
//
//    - element (optional): new Element configured to use this device.
//
func (device *Device) CreateElement(name string) Elementer {
	var _arg0 *C.GstDevice  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_device_create_element(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// Caps: getter for the Caps that this device supports.
//
// The function returns the following values:
//
//    - caps (optional) supported by this device. Unref with gst_caps_unref()
//      when done.
//
func (device *Device) Caps() *Caps {
	var _arg0 *C.GstDevice // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_caps(_arg0)
	runtime.KeepAlive(device)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// DeviceClass gets the "class" of a device. This is a "/" separated list of
// classes that represent this device. They are a subset of the classes of the
// DeviceProvider that produced this device.
//
// The function returns the following values:
//
//    - utf8: device class. Free with g_free() after use.
//
func (device *Device) DeviceClass() string {
	var _arg0 *C.GstDevice // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_device_class(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DisplayName gets the user-friendly name of the device.
//
// The function returns the following values:
//
//    - utf8: device name. Free with g_free() after use.
//
func (device *Device) DisplayName() string {
	var _arg0 *C.GstDevice // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_display_name(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Properties gets the extra properties of a device.
//
// The function returns the following values:
//
//    - structure (optional): extra properties or NULL when there are none. Free
//      with gst_structure_free() after use.
//
func (device *Device) Properties() *Structure {
	var _arg0 *C.GstDevice    // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_properties(_arg0)
	runtime.KeepAlive(device)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// HasClasses: check if device matches all of the given classes.
//
// The function takes the following parameters:
//
//    - classes: "/"-separated list of device classes to match, only match if all
//      classes are matched.
//
// The function returns the following values:
//
//    - ok: TRUE if device matches.
//
func (device *Device) HasClasses(classes string) bool {
	var _arg0 *C.GstDevice // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(classes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_has_classes(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(classes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasClassesv: check if factory matches all of the given classes.
//
// The function takes the following parameters:
//
//    - classes: NULL terminated array of classes to match, only match if all
//      classes are matched.
//
// The function returns the following values:
//
//    - ok: TRUE if device matches.
//
func (device *Device) HasClassesv(classes []string) bool {
	var _arg0 *C.GstDevice // out
	var _arg1 **C.gchar    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(classes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(classes)+1)
			var zero *C.gchar
			out[len(classes)] = zero
			for i := range classes {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(classes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_device_has_classesv(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(classes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReconfigureElement tries to reconfigure an existing element to use the
// device. If this function fails, then one must destroy the element and create
// a new one using gst_device_create_element().
//
// Note: This should only be implemented for elements can change their device in
// the PLAYING state.
//
// The function takes the following parameters:
//
//    - element: Element.
//
// The function returns the following values:
//
//    - ok: TRUE if the element could be reconfigured to use this device, FALSE
//      otherwise.
//
func (device *Device) ReconfigureElement(element Elementer) bool {
	var _arg0 *C.GstDevice  // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_device_reconfigure_element(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// createElement creates the element with all of the required parameters set to
// use this device.
//
// The function takes the following parameters:
//
//    - name (optional) of new element, or NULL to automatically create a unique
//      name.
//
// The function returns the following values:
//
//    - element (optional): new Element configured to use this device.
//
func (device *Device) createElement(name string) Elementer {
	gclass := (*C.GstDeviceClass)(coreglib.PeekParentClass(device))
	fnarg := gclass.create_element

	var _arg0 *C.GstDevice  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C._gotk4_gst1_Device_virtual_create_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// reconfigureElement tries to reconfigure an existing element to use the
// device. If this function fails, then one must destroy the element and create
// a new one using gst_device_create_element().
//
// Note: This should only be implemented for elements can change their device in
// the PLAYING state.
//
// The function takes the following parameters:
//
//    - element: Element.
//
// The function returns the following values:
//
//    - ok: TRUE if the element could be reconfigured to use this device, FALSE
//      otherwise.
//
func (device *Device) reconfigureElement(element Elementer) bool {
	gclass := (*C.GstDeviceClass)(coreglib.PeekParentClass(device))
	fnarg := gclass.reconfigure_element

	var _arg0 *C.GstDevice  // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Device_virtual_reconfigure_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceClass class structure for a Device object.
//
// An instance of this type is always passed by reference.
type DeviceClass struct {
	*deviceClass
}

// deviceClass is the struct that's finalized.
type deviceClass struct {
	native *C.GstDeviceClass
}

// ParentClass: parent ObjectClass structure.
func (d *DeviceClass) ParentClass() *ObjectClass {
	valptr := &d.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
