// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeObjectFlags = coreglib.Type(C.gst_object_flags_get_type())
	GTypeGstObject   = coreglib.Type(C.gst_object_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeObjectFlags, F: marshalObjectFlags},
		coreglib.TypeMarshaler{T: GTypeGstObject, F: marshalGstObject},
	})
}

// ObjectFlags: standard flags that an gstobject may have.
type ObjectFlags C.guint

const (
	// ObjectFlagMayBeLeaked: object is expected to stay alive even after
	// gst_deinit() has been called and so should be ignored by leak detection
	// tools. (Since: 1.10).
	ObjectFlagMayBeLeaked ObjectFlags = 0b1
	// ObjectFlagLast subclasses can add additional flags starting from this
	// flag.
	ObjectFlagLast ObjectFlags = 0b10000
)

func marshalObjectFlags(p uintptr) (interface{}, error) {
	return ObjectFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ObjectFlags.
func (o ObjectFlags) String() string {
	if o == 0 {
		return "ObjectFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(36)

	for o != 0 {
		next := o & (o - 1)
		bit := o - next

		switch bit {
		case ObjectFlagMayBeLeaked:
			builder.WriteString("MayBeLeaked|")
		case ObjectFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("ObjectFlags(0b%b)|", bit))
		}

		o = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if o contains other.
func (o ObjectFlags) Has(other ObjectFlags) bool {
	return (o & other) == other
}

// GstObjectOverrides contains methods that are overridable.
type GstObjectOverrides struct {
}

func defaultGstObjectOverrides(v *GstObject) GstObjectOverrides {
	return GstObjectOverrides{}
}

// GstObject provides a root for the object hierarchy tree filed in by the
// GStreamer library. It is currently a thin wrapper on top of Unowned. It is an
// abstract class that is not very usable on its own.
//
// Object gives us basic refcounting, parenting functionality and locking. Most
// of the functions are just extended for special GStreamer needs and can be
// found under the same name in the base class of Object which is #GObject (e.g.
// g_object_ref() becomes gst_object_ref()).
//
// Since Object derives from Unowned, it also inherits the floating reference.
// Be aware that functions such as gst_bin_add() and gst_element_add_pad() take
// ownership of the floating reference.
//
// In contrast to #GObject instances, Object adds a name property. The functions
// gst_object_set_name() and gst_object_get_name() are used to set/get the name
// of the object.
//
// controlled properties
//
// Controlled properties offers a lightweight way to adjust gobject properties
// over stream-time. It works by using time-stamped value pairs that are queued
// for element-properties. At run-time the elements continuously pull value
// changes for the current stream-time.
//
// What needs to be changed in a Element? Very little - it is just two steps to
// make a plugin controllable!
//
//    * mark gobject-properties paramspecs that make sense to be controlled,
//      by GST_PARAM_CONTROLLABLE.
//
//    * when processing data (get, chain, loop function) at the beginning call
//      gst_object_sync_values(element,timestamp).
//      This will make the controller update all GObject properties that are
//      under its control with the current values based on the timestamp.
//
// What needs to be done in applications? Again it's not a lot to change.
//
//    * create a ControlSource.
//      csource = gst_interpolation_control_source_new ();
//      g_object_set (csource, "mode", GST_INTERPOLATION_MODE_LINEAR, NULL);
//
//    * Attach the ControlSource on the controller to a property.
//      gst_object_add_control_binding (object, gst_direct_control_binding_new (object, "prop1", csource));
//
//    * Set the control values
//      gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,0 * GST_SECOND, value1);
//      gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,1 * GST_SECOND, value2);
//
//    * start your pipeline.
type GstObject struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

// GstObjector describes types inherited from class GstObject.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GstObjector interface {
	coreglib.Objector
	baseGstObject() *GstObject
}

var _ GstObjector = (*GstObject)(nil)

func init() {
	coreglib.RegisterClassInfo[*GstObject, *ObjectClass, GstObjectOverrides](
		GTypeGstObject,
		initObjectClass,
		wrapObject,
		defaultGstObjectOverrides,
	)
}

func initObjectClass(gclass unsafe.Pointer, overrides GstObjectOverrides, classInitFunc func(*ObjectClass)) {
	if classInitFunc != nil {
		class := (*ObjectClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapObject(obj *coreglib.Object) *GstObject {
	return &GstObject{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalGstObject(p uintptr) (interface{}, error) {
	return wrapObject(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (object *GstObject) baseGstObject() *GstObject {
	return object
}

// BaseGstObject returns the underlying base object.
func BaseGstObject(obj GstObjector) *GstObject {
	return obj.baseGstObject()
}

// AddControlBinding: attach the ControlBinding to the object. If there already
// was a ControlBinding for this property it will be replaced.
//
// The object's reference count will be incremented, and any floating reference
// will be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//    - binding that should be used.
//
// The function returns the following values:
//
//    - ok: FALSE if the given binding has not been setup for this object or has
//      been setup for a non suitable property, TRUE otherwise.
//
func (object *GstObject) AddControlBinding(binding ControlBindinger) bool {
	var _arg0 *C.GstObject         // out
	var _arg1 *C.GstControlBinding // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))

	_cret = C.gst_object_add_control_binding(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(binding)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultError: default error function that uses g_printerr() to display the
// error message and the optional debug string..
//
// The default handler will simply print the error string using g_print.
//
// The function takes the following parameters:
//
//    - err: GError.
//    - debug (optional): additional debug information string, or NULL.
//
func (source *GstObject) DefaultError(err error, debug string) {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GError    // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}
	if debug != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gst_object_default_error(_arg0, _arg1, _arg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
}

// ControlBinding gets the corresponding ControlBinding for the property. This
// should be unreferenced again after use.
//
// The function takes the following parameters:
//
//    - propertyName: name of the property.
//
// The function returns the following values:
//
//    - controlBinding (optional) for property_name or NULL if the property is
//      not controlled.
//
func (object *GstObject) ControlBinding(propertyName string) ControlBindinger {
	var _arg0 *C.GstObject         // out
	var _arg1 *C.gchar             // out
	var _cret *C.GstControlBinding // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_object_get_control_binding(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)

	var _controlBinding ControlBindinger // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(ControlBindinger)
				return ok
			})
			rv, ok := casted.(ControlBindinger)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.ControlBindinger")
			}
			_controlBinding = rv
		}
	}

	return _controlBinding
}

// ControlRate: obtain the control-rate for this object. Audio processing
// Element objects will use this rate to sub-divide their processing loop and
// call gst_object_sync_values() in between. The length of the processing
// segment should be up to control-rate nanoseconds.
//
// If the object is not under property control, this will return
// GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
//
// The control-rate is not expected to change if the element is in
// GST_STATE_PAUSED or GST_STATE_PLAYING.
//
// The function returns the following values:
//
//    - clockTime: control rate in nanoseconds.
//
func (object *GstObject) ControlRate() ClockTime {
	var _arg0 *C.GstObject   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_control_rate(_arg0)
	runtime.KeepAlive(object)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// GValueArray gets a number of #GValues for the given controlled property
// starting at the requested time. The array values need to hold enough space
// for n_values of #GValue.
//
// This function is useful if one wants to e.g. draw a graph of the control
// curve or apply a control curve sample by sample.
//
// The function takes the following parameters:
//
//    - propertyName: name of the property to get.
//    - timestamp: time that should be processed.
//    - interval: time spacing between subsequent values.
//    - values: array to put control-values in.
//
// The function returns the following values:
//
//    - ok: TRUE if the given array could be filled, FALSE otherwise.
//
func (object *GstObject) GValueArray(propertyName string, timestamp, interval ClockTime, values []coreglib.Value) bool {
	var _arg0 *C.GstObject   // out
	var _arg1 *C.gchar       // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg5 *C.GValue      // out
	var _arg4 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(interval)
	type _ = ClockTime
	type _ = uint64
	_arg4 = (C.guint)(len(values))
	_arg5 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice((*C.GValue)(_arg5), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_object_get_g_value_array(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name returns a copy of the name of object. Caller should g_free() the return
// value after usage. For a nameless object, this returns NULL, which you can
// safely g_free() as well.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//    - utf8 (optional): name of object. g_free() after usage.
//
//      MT safe. This function grabs and releases object's LOCK.
//
func (object *GstObject) Name() string {
	var _arg0 *C.GstObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_name(_arg0)
	runtime.KeepAlive(object)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Parent returns the parent of object. This function increases the refcount of
// the parent object so you should gst_object_unref() it after usage.
//
// The function returns the following values:
//
//    - ret (optional): parent of object, this can be NULL if object has no
//      parent. unref after usage.
//
//      MT safe. Grabs and releases object's LOCK.
//
func (object *GstObject) Parent() GstObjector {
	var _arg0 *C.GstObject // out
	var _cret *C.GstObject // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_parent(_arg0)
	runtime.KeepAlive(object)

	var _ret GstObjector // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GstObjector)
				return ok
			})
			rv, ok := casted.(GstObjector)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
			}
			_ret = rv
		}
	}

	return _ret
}

// PathString generates a string describing the path of object in the object
// hierarchy. Only useful (or used) for debugging.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//    - utf8: string describing the path of object. You must g_free() the string
//      after usage.
//
//      MT safe. Grabs and releases the Object's LOCK for all objects in the
//      hierarchy.
//
func (object *GstObject) PathString() string {
	var _arg0 *C.GstObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_path_string(_arg0)
	runtime.KeepAlive(object)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Value gets the value for the given controlled property at the requested time.
//
// The function takes the following parameters:
//
//    - propertyName: name of the property to get.
//    - timestamp: time the control-change should be read from.
//
// The function returns the following values:
//
//    - value (optional): GValue of the property at the given time, or NULL if
//      the property isn't controlled.
//
func (object *GstObject) Value(propertyName string, timestamp ClockTime) *coreglib.Value {
	var _arg0 *C.GstObject   // out
	var _arg1 *C.gchar       // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GValue      // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_object_get_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(timestamp)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
		runtime.SetFinalizer(_value, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
	}

	return _value
}

// HasActiveControlBindings: check if the object has active controlled
// properties.
//
// The function returns the following values:
//
//    - ok: TRUE if the object has active controlled properties.
//
func (object *GstObject) HasActiveControlBindings() bool {
	var _arg0 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_has_active_control_bindings(_arg0)
	runtime.KeepAlive(object)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasAncestor: check if object has an ancestor ancestor somewhere up in the
// hierarchy. One can e.g. check if a Element is inside a Pipeline.
//
// Deprecated: Use gst_object_has_as_ancestor() instead.
//
// MT safe. Grabs and releases object's locks.
//
// The function takes the following parameters:
//
//    - ancestor to check as ancestor.
//
// The function returns the following values:
//
//    - ok: TRUE if ancestor is an ancestor of object.
//
func (object *GstObject) HasAncestor(ancestor GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gst_object_has_ancestor(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasAsAncestor: check if object has an ancestor ancestor somewhere up in the
// hierarchy. One can e.g. check if a Element is inside a Pipeline.
//
// The function takes the following parameters:
//
//    - ancestor to check as ancestor.
//
// The function returns the following values:
//
//    - ok: TRUE if ancestor is an ancestor of object.
//
//      MT safe. Grabs and releases object's locks.
//
func (object *GstObject) HasAsAncestor(ancestor GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gst_object_has_as_ancestor(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasAsParent: check if parent is the parent of object. E.g. a Element can
// check if it owns a given Pad.
//
// The function takes the following parameters:
//
//    - parent to check as parent.
//
// The function returns the following values:
//
//    - ok: FALSE if either object or parent is NULL. TRUE if parent is the
//      parent of object. Otherwise FALSE.
//
//      MT safe. Grabs and releases object's locks.
//
func (object *GstObject) HasAsParent(parent GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C.gst_object_has_as_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveControlBinding removes the corresponding ControlBinding. If it was the
// last ref of the binding, it will be disposed.
//
// The function takes the following parameters:
//
//    - binding: binding.
//
// The function returns the following values:
//
//    - ok: TRUE if the binding could be removed.
//
func (object *GstObject) RemoveControlBinding(binding ControlBindinger) bool {
	var _arg0 *C.GstObject         // out
	var _arg1 *C.GstControlBinding // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))

	_cret = C.gst_object_remove_control_binding(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(binding)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetControlBindingDisabled: this function is used to disable the control
// bindings on a property for some time, i.e. gst_object_sync_values() will do
// nothing for the property.
//
// The function takes the following parameters:
//
//    - propertyName: property to disable.
//    - disabled: boolean that specifies whether to disable the controller or
//      not.
//
func (object *GstObject) SetControlBindingDisabled(propertyName string, disabled bool) {
	var _arg0 *C.GstObject // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	if disabled {
		_arg2 = C.TRUE
	}

	C.gst_object_set_control_binding_disabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(disabled)
}

// SetControlBindingsDisabled: this function is used to disable all controlled
// properties of the object for some time, i.e. gst_object_sync_values() will do
// nothing.
//
// The function takes the following parameters:
//
//    - disabled: boolean that specifies whether to disable the controller or
//      not.
//
func (object *GstObject) SetControlBindingsDisabled(disabled bool) {
	var _arg0 *C.GstObject // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	if disabled {
		_arg1 = C.TRUE
	}

	C.gst_object_set_control_bindings_disabled(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(disabled)
}

// SetControlRate: change the control-rate for this object. Audio processing
// Element objects will use this rate to sub-divide their processing loop and
// call gst_object_sync_values() in between. The length of the processing
// segment should be up to control-rate nanoseconds.
//
// The control-rate should not change if the element is in GST_STATE_PAUSED or
// GST_STATE_PLAYING.
//
// The function takes the following parameters:
//
//    - controlRate: new control-rate in nanoseconds.
//
func (object *GstObject) SetControlRate(controlRate ClockTime) {
	var _arg0 *C.GstObject   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = C.guint64(controlRate)
	type _ = ClockTime
	type _ = uint64

	C.gst_object_set_control_rate(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(controlRate)
}

// SetName sets the name of object, or gives object a guaranteed unique name (if
// name is NULL). This function makes a copy of the provided name, so the caller
// retains ownership of the name it sent.
//
// The function takes the following parameters:
//
//    - name (optional): new name of object.
//
// The function returns the following values:
//
//    - ok: TRUE if the name could be set. Since Objects that have a parent
//      cannot be renamed, this function returns FALSE in those cases.
//
//      MT safe. This function grabs and releases object's LOCK.
//
func (object *GstObject) SetName(name string) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_object_set_name(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetParent sets the parent of object to parent. The object's reference count
// will be incremented, and any floating reference will be removed (see
// gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//    - parent: new parent of object.
//
// The function returns the following values:
//
//    - ok: TRUE if parent could be set or FALSE when object already had a parent
//      or object and parent are the same.
//
//      MT safe. Grabs and releases object's LOCK.
//
func (object *GstObject) SetParent(parent GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C.gst_object_set_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SuggestNextSync returns a suggestion for timestamps where buffers should be
// split to get best controller results.
//
// The function returns the following values:
//
//    - clockTime returns the suggested timestamp or GST_CLOCK_TIME_NONE if no
//      control-rate was set.
//
func (object *GstObject) SuggestNextSync() ClockTime {
	var _arg0 *C.GstObject   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_suggest_next_sync(_arg0)
	runtime.KeepAlive(object)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// SyncValues sets the properties of the object, according to the ControlSources
// that (maybe) handle them and for the given timestamp.
//
// If this function fails, it is most likely the application developers fault.
// Most probably the control sources are not setup correctly.
//
// The function takes the following parameters:
//
//    - timestamp: time that should be processed.
//
// The function returns the following values:
//
//    - ok: TRUE if the controller values could be applied to the object
//      properties, FALSE otherwise.
//
func (object *GstObject) SyncValues(timestamp ClockTime) bool {
	var _arg0 *C.GstObject   // out
	var _arg1 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_object_sync_values(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(timestamp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unparent: clear the parent of object, removing the associated reference. This
// function decreases the refcount of object.
//
// MT safe. Grabs and releases object's lock.
func (object *GstObject) Unparent() {
	var _arg0 *C.GstObject // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C.gst_object_unparent(_arg0)
	runtime.KeepAlive(object)
}

// ObjectCheckUniqueness checks to see if there is any object named name in
// list. This function does not do any locking of any kind. You might want to
// protect the provided list with the lock of the owner of the list. This
// function will lock each Object in the list to compare the name, so be careful
// when passing a list with a locked object.
//
// The function takes the following parameters:
//
//    - list of Object to check through.
//    - name to search for.
//
// The function returns the following values:
//
//    - ok: TRUE if a Object named name does not appear in list, FALSE if it
//      does.
//
//      MT safe. Grabs and releases the LOCK of each object in the list.
//
func ObjectCheckUniqueness(list []GstObjector, name string) bool {
	var _arg1 *C.GList   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstObject // out
		dst = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_object_check_uniqueness(_arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObjectClass: GStreamer base object class.
//
// An instance of this type is always passed by reference.
type ObjectClass struct {
	*objectClass
}

// objectClass is the struct that's finalized.
type objectClass struct {
	native *C.GstObjectClass
}

// PathStringSeparator: separator used by gst_object_get_path_string().
func (o *ObjectClass) PathStringSeparator() string {
	valptr := &o.native.path_string_separator
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}
