// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_Bus_ConnectSyncMessage(gpointer, GstMessage*, guintptr);
// extern void _gotk4_gst1_Bus_ConnectMessage(gpointer, GstMessage*, guintptr);
// extern void _gotk4_gst1_BusClass_sync_message(GstBus*, GstMessage*);
// extern void _gotk4_gst1_BusClass_message(GstBus*, GstMessage*);
// extern gboolean _gotk4_gst1_BusFunc(GstBus*, GstMessage*, gpointer);
// extern GstBusSyncReply _gotk4_gst1_BusSyncHandler(GstBus*, GstMessage*, gpointer);
// void _gotk4_gst1_Bus_virtual_message(void* fnptr, GstBus* arg0, GstMessage* arg1) {
//   ((void (*)(GstBus*, GstMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bus_virtual_sync_message(void* fnptr, GstBus* arg0, GstMessage* arg1) {
//   ((void (*)(GstBus*, GstMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBusSyncReply = coreglib.Type(C.gst_bus_sync_reply_get_type())
	GTypeBusFlags     = coreglib.Type(C.gst_bus_flags_get_type())
	GTypeBus          = coreglib.Type(C.gst_bus_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBusSyncReply, F: marshalBusSyncReply},
		coreglib.TypeMarshaler{T: GTypeBusFlags, F: marshalBusFlags},
		coreglib.TypeMarshaler{T: GTypeBus, F: marshalBus},
	})
}

// BusSyncReply: result values for a GstBusSyncHandler.
type BusSyncReply C.gint

const (
	// BusDrop: drop the message.
	BusDrop BusSyncReply = iota
	// BusPass pass the message to the async queue.
	BusPass
	// BusAsync pass message to async queue, continue if message is handled.
	BusAsync
)

func marshalBusSyncReply(p uintptr) (interface{}, error) {
	return BusSyncReply(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BusSyncReply.
func (b BusSyncReply) String() string {
	switch b {
	case BusDrop:
		return "Drop"
	case BusPass:
		return "Pass"
	case BusAsync:
		return "Async"
	default:
		return fmt.Sprintf("BusSyncReply(%d)", b)
	}
}

// BusFlags: standard flags that a bus may have.
type BusFlags C.guint

const (
	// BusFlushing bus is currently dropping all messages.
	BusFlushing BusFlags = 0b10000
	// BusFlagLast: offset to define more flags.
	BusFlagLast BusFlags = 0b100000
)

func marshalBusFlags(p uintptr) (interface{}, error) {
	return BusFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusFlags.
func (b BusFlags) String() string {
	if b == 0 {
		return "BusFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusFlushing:
			builder.WriteString("Flushing|")
		case BusFlagLast:
			builder.WriteString("FlagLast|")
		default:
			builder.WriteString(fmt.Sprintf("BusFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusFlags) Has(other BusFlags) bool {
	return (b & other) == other
}

// BusFunc specifies the type of function passed to gst_bus_add_watch() or
// gst_bus_add_watch_full(), which is called from the mainloop when a message is
// available on the bus.
//
// The message passed to the function will be unreffed after execution of this
// function so it should not be freed in the function.
//
// Note that this function is used as a Func which means that returning FALSE
// will remove the #GSource from the mainloop.
type BusFunc func(bus *Bus, message *Message) (ok bool)

// BusSyncHandler: handler will be invoked synchronously, when a new message has
// been injected into the bus. This function is mostly used internally. Only one
// sync handler can be attached to a given bus.
//
// If the handler returns GST_BUS_DROP, it should unref the message, else the
// message should not be unreffed by the sync handler.
type BusSyncHandler func(bus *Bus, message *Message) (busSyncReply BusSyncReply)

// BusOverrides contains methods that are overridable.
type BusOverrides struct {
	// Message: message has been posted on the bus.
	//
	// The function takes the following parameters:
	//
	//    - message that has been posted asynchronously.
	//
	Message func(message *Message)
	// SyncMessage: message has been posted on the bus.
	//
	// The function takes the following parameters:
	//
	//    - message that has been posted synchronously.
	//
	SyncMessage func(message *Message)
}

func defaultBusOverrides(v *Bus) BusOverrides {
	return BusOverrides{
		Message:     v.message,
		SyncMessage: v.syncMessage,
	}
}

// Bus is an object responsible for delivering Message packets in a first-in
// first-out way from the streaming threads (see Task) to the application.
//
// Since the application typically only wants to deal with delivery of these
// messages from one thread, the GstBus will marshall the messages between
// different threads. This is important since the actual streaming of media is
// done in another thread than the application.
//
// The GstBus provides support for #GSource based notifications. This makes it
// possible to handle the delivery in the glib Loop.
//
// The #GSource callback function gst_bus_async_signal_func() can be used to
// convert all bus messages into signal emissions.
//
// A message is posted on the bus with the gst_bus_post() method. With the
// gst_bus_peek() and gst_bus_pop() methods one can look at or retrieve a
// previously posted message.
//
// The bus can be polled with the gst_bus_poll() method. This methods blocks up
// to the specified timeout value until one of the specified messages types is
// posted on the bus. The application can then gst_bus_pop() the messages from
// the bus to handle them. Alternatively the application can register an
// asynchronous bus function using gst_bus_add_watch_full() or
// gst_bus_add_watch(). This function will install a #GSource in the default
// glib main loop and will deliver messages a short while after they have been
// posted. Note that the main loop should be running for the asynchronous
// callbacks.
//
// It is also possible to get messages from the bus without any thread
// marshalling with the gst_bus_set_sync_handler() method. This makes it
// possible to react to a message in the same thread that posted the message on
// the bus. This should only be used if the application is able to deal with
// messages from different threads.
//
// Every Pipeline has one bus.
//
// Note that a Pipeline will set its bus into flushing state when changing from
// READY to NULL state.
type Bus struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Bus)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Bus, *BusClass, BusOverrides](
		GTypeBus,
		initBusClass,
		wrapBus,
		defaultBusOverrides,
	)
}

func initBusClass(gclass unsafe.Pointer, overrides BusOverrides, classInitFunc func(*BusClass)) {
	pclass := (*C.GstBusClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBus))))

	if overrides.Message != nil {
		pclass.message = (*[0]byte)(C._gotk4_gst1_BusClass_message)
	}

	if overrides.SyncMessage != nil {
		pclass.sync_message = (*[0]byte)(C._gotk4_gst1_BusClass_sync_message)
	}

	if classInitFunc != nil {
		class := (*BusClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBus(obj *coreglib.Object) *Bus {
	return &Bus{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalBus(p uintptr) (interface{}, error) {
	return wrapBus(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectMessage has been posted on the bus. This signal is emitted from a
// #GSource added to the mainloop. this signal will only be emitted when there
// is a Loop running.
func (bus *Bus) ConnectMessage(f func(message *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bus, "message", false, unsafe.Pointer(C._gotk4_gst1_Bus_ConnectMessage), f)
}

// ConnectSyncMessage: message has been posted on the bus. This signal is
// emitted from the thread that posted the message so one has to be careful with
// locking.
//
// This signal will not be emitted by default, you have to call
// gst_bus_enable_sync_message_emission() before.
func (bus *Bus) ConnectSyncMessage(f func(message *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bus, "sync-message", false, unsafe.Pointer(C._gotk4_gst1_Bus_ConnectSyncMessage), f)
}

// NewBus creates a new Bus instance.
//
// The function returns the following values:
//
//    - bus: new Bus instance.
//
func NewBus() *Bus {
	var _cret *C.GstBus // in

	_cret = C.gst_bus_new()

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// AddSignalWatch adds a bus signal watch to the default main context with the
// default priority ( G_PRIORITY_DEFAULT ). It is also possible to use a
// non-default main context set up using g_main_context_push_thread_default()
// (before one had to create a bus watch source and attach it to the desired
// main context 'manually').
//
// After calling this statement, the bus will emit the "message" signal for each
// message posted on the bus.
//
// This function may be called multiple times. To clean up, the caller is
// responsible for calling gst_bus_remove_signal_watch() as many times as this
// function is called.
func (bus *Bus) AddSignalWatch() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_add_signal_watch(_arg0)
	runtime.KeepAlive(bus)
}

// AddSignalWatchFull adds a bus signal watch to the default main context with
// the given priority (e.g. G_PRIORITY_DEFAULT). It is also possible to use a
// non-default main context set up using g_main_context_push_thread_default()
// (before one had to create a bus watch source and attach it to the desired
// main context 'manually').
//
// After calling this statement, the bus will emit the "message" signal for each
// message posted on the bus when the Loop is running.
//
// This function may be called multiple times. To clean up, the caller is
// responsible for calling gst_bus_remove_signal_watch() as many times as this
// function is called.
//
// There can only be a single bus watch per bus, you must remove any signal
// watch before you can set another type of watch.
//
// The function takes the following parameters:
//
//    - priority of the watch.
//
func (bus *Bus) AddSignalWatchFull(priority int) {
	var _arg0 *C.GstBus // out
	var _arg1 C.gint    // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.gint(priority)

	C.gst_bus_add_signal_watch_full(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(priority)
}

// AddWatch adds a bus watch to the default main context with the given priority
// (e.g. G_PRIORITY_DEFAULT). It is also possible to use a non-default main
// context set up using g_main_context_push_thread_default() (before one had to
// create a bus watch source and attach it to the desired main context
// 'manually').
//
// This function is used to receive asynchronous messages in the main loop.
// There can only be a single bus watch per bus, you must remove it before you
// can set a new one.
//
// The bus watch will only work if a Loop is being run.
//
// When func is called, the message belongs to the caller; if you want to keep a
// copy of it, call gst_message_ref() before leaving func.
//
// The watch can be removed using gst_bus_remove_watch() or by returning FALSE
// from func. If the watch was added to the default main context it is also
// possible to remove the watch using g_source_remove().
//
// The bus watch will take its own reference to the bus, so it is safe to unref
// bus using gst_object_unref() after setting the bus watch.
//
// The function takes the following parameters:
//
//    - priority of the watch.
//    - fn: function to call when a message is received.
//
// The function returns the following values:
//
//    - guint: event source id or 0 if bus already got an event source.
//
func (bus *Bus) AddWatch(priority int, fn BusFunc) uint {
	var _arg0 *C.GstBus    // out
	var _arg1 C.gint       // out
	var _arg2 C.GstBusFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.gint(priority)
	_arg2 = (*[0]byte)(C._gotk4_gst1_BusFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_bus_add_watch_full(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(fn)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// AsyncSignalFunc: helper BusFunc that can be used to convert all asynchronous
// messages into signals.
//
// The function takes the following parameters:
//
//    - message: Message received.
//    - data (optional): user data.
//
// The function returns the following values:
//
//    - ok: TRUE.
//
func (bus *Bus) AsyncSignalFunc(message *Message, data unsafe.Pointer) bool {
	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out
	var _arg2 C.gpointer    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg2 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_bus_async_signal_func(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateWatch: create watch for this bus. The #GSource will be dispatched
// whenever a message is on the bus. After the GSource is dispatched, the
// message is popped off the bus and unreffed.
//
// As with other watches, there can only be one watch on the bus, including any
// signal watch added with #gst_bus_add_signal_watch.
//
// The function returns the following values:
//
//    - source (optional) that can be added to a Loop.
//
func (bus *Bus) CreateWatch() *glib.Source {
	var _arg0 *C.GstBus  // out
	var _cret *C.GSource // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_create_watch(_arg0)
	runtime.KeepAlive(bus)

	var _source *glib.Source // out

	if _cret != nil {
		_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_source)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_source_unref((*C.GSource)(intern.C))
			},
		)
	}

	return _source
}

// DisableSyncMessageEmission instructs GStreamer to stop emitting the
// "sync-message" signal for this bus. See
// gst_bus_enable_sync_message_emission() for more information.
//
// In the event that multiple pieces of code have called
// gst_bus_enable_sync_message_emission(), the sync-message emissions will only
// be stopped after all calls to gst_bus_enable_sync_message_emission() were
// "cancelled" by calling this function. In this way the semantics are exactly
// the same as gst_object_ref() that which calls enable should also call
// disable.
func (bus *Bus) DisableSyncMessageEmission() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_disable_sync_message_emission(_arg0)
	runtime.KeepAlive(bus)
}

// EnableSyncMessageEmission instructs GStreamer to emit the "sync-message"
// signal after running the bus's sync handler. This function is here so that
// code can ensure that they can synchronously receive messages without having
// to affect what the bin's sync handler is.
//
// This function may be called multiple times. To clean up, the caller is
// responsible for calling gst_bus_disable_sync_message_emission() as many times
// as this function is called.
//
// While this function looks similar to gst_bus_add_signal_watch(), it is not
// exactly the same -- this function enables *synchronous* emission of signals
// when messages arrive; gst_bus_add_signal_watch() adds an idle callback to pop
// messages off the bus *asynchronously*. The sync-message signal comes from the
// thread of whatever object posted the message; the "message" signal is
// marshalled to the main thread via the Loop.
func (bus *Bus) EnableSyncMessageEmission() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_enable_sync_message_emission(_arg0)
	runtime.KeepAlive(bus)
}

// HavePending checks if there are pending messages on the bus that should be
// handled.
//
// The function returns the following values:
//
//    - ok: TRUE if there are messages on the bus to be handled, FALSE otherwise.
//
func (bus *Bus) HavePending() bool {
	var _arg0 *C.GstBus  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_have_pending(_arg0)
	runtime.KeepAlive(bus)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Peek peeks the message on the top of the bus' queue. The message will remain
// on the bus' message queue.
//
// The function returns the following values:
//
//    - message (optional) that is on the bus, or NULL if the bus is empty.
//
func (bus *Bus) Peek() *Message {
	var _arg0 *C.GstBus     // out
	var _cret *C.GstMessage // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_peek(_arg0)
	runtime.KeepAlive(bus)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Poll polls the bus for messages. Will block while waiting for messages to
// come. You can specify a maximum time to poll with the timeout parameter. If
// timeout is negative, this function will block indefinitely.
//
// All messages not in events will be popped off the bus and will be ignored. It
// is not possible to use message enums beyond T_MESSAGE_EXTENDED in the events
// mask
//
// Because poll is implemented using the "message" signal enabled by
// gst_bus_add_signal_watch(), calling gst_bus_poll() will cause the "message"
// signal to be emitted for every message that poll sees. Thus a "message"
// signal handler will see the same messages that this function sees -- neither
// will steal messages from the other.
//
// This function will run a Loop from the default main context when polling.
//
// You should never use this function, since it is pure evil. This is especially
// true for GUI applications based on Gtk+ or Qt, but also for any other
// non-trivial application that uses the GLib main loop. As this function runs a
// GLib main loop, any callback attached to the default GLib main context may be
// invoked. This could be timeouts, GUI events, I/O events etc.; even if
// gst_bus_poll() is called with a 0 timeout. Any of these callbacks may do
// things you do not expect, e.g. destroy the main application window or some
// other resource; change other application state; display a dialog and run
// another main loop until the user clicks it away. In short, using this
// function may add a lot of complexity to your code through unexpected
// re-entrancy and unexpected changes to your application's state.
//
// For 0 timeouts use gst_bus_pop_filtered() instead of this function; for other
// short timeouts use gst_bus_timed_pop_filtered(); everything else is better
// handled by setting up an asynchronous bus watch and doing things from there.
//
// The function takes the following parameters:
//
//    - events: mask of MessageType, representing the set of message types to
//      poll for (note special handling of extended message types below).
//    - timeout: poll timeout, as a ClockTime, or T_CLOCK_TIME_NONE to poll
//      indefinitely.
//
// The function returns the following values:
//
//    - message (optional) that was received, or NULL if the poll timed out.
//
func (bus *Bus) Poll(events MessageType, timeout ClockTime) *Message {
	var _arg0 *C.GstBus        // out
	var _arg1 C.GstMessageType // out
	var _arg2 C.GstClockTime   // out
	var _cret *C.GstMessage    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.GstMessageType(events)
	_arg2 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_bus_poll(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(events)
	runtime.KeepAlive(timeout)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Pop gets a message from the bus.
//
// The function returns the following values:
//
//    - message (optional) that is on the bus, or NULL if the bus is empty.
//
func (bus *Bus) Pop() *Message {
	var _arg0 *C.GstBus     // out
	var _cret *C.GstMessage // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_pop(_arg0)
	runtime.KeepAlive(bus)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// PopFiltered gets a message matching type from the bus. Will discard all
// messages on the bus that do not match type and that have been posted before
// the first message that does match type. If there is no message matching type
// on the bus, all messages will be discarded. It is not possible to use message
// enums beyond T_MESSAGE_EXTENDED in the events mask.
//
// The function takes the following parameters:
//
//    - types: message types to take into account.
//
// The function returns the following values:
//
//    - message (optional): next Message matching type that is on the bus, or
//      NULL if the bus is empty or there is no message matching type.
//
func (bus *Bus) PopFiltered(types MessageType) *Message {
	var _arg0 *C.GstBus        // out
	var _arg1 C.GstMessageType // out
	var _cret *C.GstMessage    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.GstMessageType(types)

	_cret = C.gst_bus_pop_filtered(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(types)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Post posts a message on the given bus. Ownership of the message is taken by
// the bus.
//
// The function takes the following parameters:
//
//    - message to post.
//
// The function returns the following values:
//
//    - ok: TRUE if the message could be posted, FALSE if the bus is flushing.
//
func (bus *Bus) Post(message *Message) bool {
	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	_cret = C.gst_bus_post(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveSignalWatch removes a signal watch previously added with
// gst_bus_add_signal_watch().
func (bus *Bus) RemoveSignalWatch() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_remove_signal_watch(_arg0)
	runtime.KeepAlive(bus)
}

// RemoveWatch removes an installed bus watch from bus.
//
// The function returns the following values:
//
//    - ok: TRUE on success or FALSE if bus has no event source.
//
func (bus *Bus) RemoveWatch() bool {
	var _arg0 *C.GstBus  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_remove_watch(_arg0)
	runtime.KeepAlive(bus)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlushing: if flushing, flushes out and unrefs any messages queued in the
// bus. Releases references to the message origin objects. Will flush future
// messages until gst_bus_set_flushing() sets flushing to FALSE.
//
// The function takes the following parameters:
//
//    - flushing: whether or not to flush the bus.
//
func (bus *Bus) SetFlushing(flushing bool) {
	var _arg0 *C.GstBus  // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	if flushing {
		_arg1 = C.TRUE
	}

	C.gst_bus_set_flushing(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(flushing)
}

// SetSyncHandler sets the synchronous handler on the bus. The function will be
// called every time a new message is posted on the bus. Note that the function
// will be called in the same thread context as the posting object. This
// function is usually only called by the creator of the bus. Applications
// should handle messages asynchronously using the gst_bus watch and poll
// functions.
//
// Before 1.16.3 it was not possible to replace an existing handler and clearing
// an existing handler with NULL was not thread-safe.
//
// The function takes the following parameters:
//
//    - fn (optional): handler function to install.
//
func (bus *Bus) SetSyncHandler(fn BusSyncHandler) {
	var _arg0 *C.GstBus           // out
	var _arg1 C.GstBusSyncHandler // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gst1_BusSyncHandler)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gst_bus_set_sync_handler(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(fn)
}

// SyncSignalHandler: helper BusSyncHandler that can be used to convert all
// synchronous messages into signals.
//
// The function takes the following parameters:
//
//    - message: Message received.
//    - data (optional): user data.
//
// The function returns the following values:
//
//    - busSyncReply: GST_BUS_PASS.
//
func (bus *Bus) SyncSignalHandler(message *Message, data unsafe.Pointer) BusSyncReply {
	var _arg0 *C.GstBus         // out
	var _arg1 *C.GstMessage     // out
	var _arg2 C.gpointer        // out
	var _cret C.GstBusSyncReply // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg2 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_bus_sync_signal_handler(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
	runtime.KeepAlive(data)

	var _busSyncReply BusSyncReply // out

	_busSyncReply = BusSyncReply(_cret)

	return _busSyncReply
}

// TimedPop gets a message from the bus, waiting up to the specified timeout.
//
// If timeout is 0, this function behaves like gst_bus_pop(). If timeout is
// T_CLOCK_TIME_NONE, this function will block forever until a message was
// posted on the bus.
//
// The function takes the following parameters:
//
//    - timeout: timeout.
//
// The function returns the following values:
//
//    - message (optional) that is on the bus after the specified timeout or NULL
//      if the bus is empty after the timeout expired.
//
func (bus *Bus) TimedPop(timeout ClockTime) *Message {
	var _arg0 *C.GstBus      // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstMessage  // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_bus_timed_pop(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(timeout)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// TimedPopFiltered gets a message from the bus whose type matches the message
// type mask types, waiting up to the specified timeout (and discarding any
// messages that do not match the mask provided).
//
// If timeout is 0, this function behaves like gst_bus_pop_filtered(). If
// timeout is T_CLOCK_TIME_NONE, this function will block forever until a
// matching message was posted on the bus.
//
// The function takes the following parameters:
//
//    - timeout in nanoseconds, or GST_CLOCK_TIME_NONE to wait forever.
//    - types: message types to take into account, GST_MESSAGE_ANY for any type.
//
// The function returns the following values:
//
//    - message (optional) matching the filter in types, or NULL if no matching
//      message was found on the bus until the timeout expired.
//
func (bus *Bus) TimedPopFiltered(timeout ClockTime, types MessageType) *Message {
	var _arg0 *C.GstBus        // out
	var _arg1 C.GstClockTime   // out
	var _arg2 C.GstMessageType // out
	var _cret *C.GstMessage    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64
	_arg2 = C.GstMessageType(types)

	_cret = C.gst_bus_timed_pop_filtered(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(types)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Message has been posted on the bus.
//
// The function takes the following parameters:
//
//    - message that has been posted asynchronously.
//
func (bus *Bus) message(message *Message) {
	gclass := (*C.GstBusClass)(coreglib.PeekParentClass(bus))
	fnarg := gclass.message

	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C._gotk4_gst1_Bus_virtual_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
}

// syncMessage: message has been posted on the bus.
//
// The function takes the following parameters:
//
//    - message that has been posted synchronously.
//
func (bus *Bus) syncMessage(message *Message) {
	gclass := (*C.GstBusClass)(coreglib.PeekParentClass(bus))
	fnarg := gclass.sync_message

	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C._gotk4_gst1_Bus_virtual_sync_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
}

// BusClass: GStreamer bus class.
//
// An instance of this type is always passed by reference.
type BusClass struct {
	*busClass
}

// busClass is the struct that's finalized.
type busClass struct {
	native *C.GstBusClass
}

// ParentClass: parent class structure.
func (b *BusClass) ParentClass() *ObjectClass {
	valptr := &b.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
