// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeBitmask       = coreglib.Type(C.gst_bitmask_get_type())
	GTypeDoubleRange   = coreglib.Type(C.gst_double_range_get_type())
	GTypeFlagSet       = coreglib.Type(C.gst_flagset_get_type())
	GTypeFraction      = coreglib.Type(C.gst_fraction_get_type())
	GTypeFractionRange = coreglib.Type(C.gst_fraction_range_get_type())
	GTypeInt64Range    = coreglib.Type(C.gst_int64_range_get_type())
	GTypeIntRange      = coreglib.Type(C.gst_int_range_get_type())
	GTypeValueArray    = coreglib.Type(C.gst_value_array_get_type())
	GTypeValueList     = coreglib.Type(C.gst_value_list_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBitmask, F: marshalBitmask},
		coreglib.TypeMarshaler{T: GTypeDoubleRange, F: marshalDoubleRange},
		coreglib.TypeMarshaler{T: GTypeFlagSet, F: marshalFlagSet},
		coreglib.TypeMarshaler{T: GTypeFraction, F: marshalFraction},
		coreglib.TypeMarshaler{T: GTypeFractionRange, F: marshalFractionRange},
		coreglib.TypeMarshaler{T: GTypeInt64Range, F: marshalInt64Range},
		coreglib.TypeMarshaler{T: GTypeIntRange, F: marshalIntRange},
		coreglib.TypeMarshaler{T: GTypeValueArray, F: marshalValueArray},
		coreglib.TypeMarshaler{T: GTypeValueList, F: marshalValueList},
	})
}

// FOURCC_FORMAT: can be used together with T_FOURCC_ARGS to properly output a
// #guint32 fourcc value in a printf\()-style text message.
//
//    printf ("fourcc: %" GST_FOURCC_FORMAT "\n", GST_FOURCC_ARGS (fcc));.
const FOURCC_FORMAT = "c%c%c%c"

// VALUE_EQUAL indicates that the first value provided to a comparison function
// (gst_value_compare()) is equal to the second one.
const VALUE_EQUAL = 0

// VALUE_GREATER_THAN indicates that the first value provided to a comparison
// function (gst_value_compare()) is greater than the second one.
const VALUE_GREATER_THAN = 1

// VALUE_LESS_THAN indicates that the first value provided to a comparison
// function (gst_value_compare()) is lesser than the second one.
const VALUE_LESS_THAN = -1

// VALUE_UNORDERED indicates that the comparison function (gst_value_compare())
// can not determine a order for the two provided values.
const VALUE_UNORDERED = 2

// ValueCanCompare determines if value1 and value2 can be compared.
//
// The function takes the following parameters:
//
//    - value1: value to compare.
//    - value2: another value to compare.
//
// The function returns the following values:
//
//    - ok: TRUE if the values can be compared.
//
func ValueCanCompare(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_can_compare(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCanIntersect determines if intersecting two values will produce a valid
// result. Two values will produce a valid intersection if they have the same
// type.
//
// The function takes the following parameters:
//
//    - value1: value to intersect.
//    - value2: another value to intersect.
//
// The function returns the following values:
//
//    - ok: TRUE if the values can intersect.
//
func ValueCanIntersect(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_can_intersect(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCanSubtract checks if it's possible to subtract subtrahend from minuend.
//
// The function takes the following parameters:
//
//    - minuend: value to subtract from.
//    - subtrahend: value to subtract.
//
// The function returns the following values:
//
//    - ok: TRUE if a subtraction is possible.
//
func ValueCanSubtract(minuend, subtrahend *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(minuend.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(subtrahend.Native()))

	_cret = C.gst_value_can_subtract(_arg1, _arg2)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCanUnion determines if value1 and value2 can be non-trivially unioned.
// Any two values can be trivially unioned by adding both of them to a
// GstValueList. However, certain types have the possibility to be unioned in a
// simpler way. For example, an integer range and an integer can be unioned if
// the integer is a subset of the integer range. If there is the possibility
// that two values can be unioned, this function returns TRUE.
//
// The function takes the following parameters:
//
//    - value1: value to union.
//    - value2: another value to union.
//
// The function returns the following values:
//
//    - ok: TRUE if there is a function allowing the two values to be unioned.
//
func ValueCanUnion(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_can_union(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCompare compares value1 and value2. If value1 and value2 cannot be
// compared, the function returns GST_VALUE_UNORDERED. Otherwise, if value1 is
// greater than value2, GST_VALUE_GREATER_THAN is returned. If value1 is less
// than value2, GST_VALUE_LESS_THAN is returned. If the values are equal,
// GST_VALUE_EQUAL is returned.
//
// The function takes the following parameters:
//
//    - value1: value to compare.
//    - value2: another value to compare.
//
// The function returns the following values:
//
//    - gint: comparison result.
//
func ValueCompare(value1, value2 *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_compare(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueDeserialize tries to deserialize a string into the type specified by the
// given GValue. If the operation succeeds, TRUE is returned, FALSE otherwise.
//
// The function takes the following parameters:
//
//    - src: string to deserialize.
//
// The function returns the following values:
//
//    - dest to fill with contents of deserialization.
//    - ok: TRUE on success.
//
func ValueDeserialize(src string) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_value_deserialize(&_arg1, _arg2)
	runtime.KeepAlive(src)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// ValueFixate: fixate src into a new value dest. For ranges, the first element
// is taken. For lists and arrays, the first item is fixated and returned. If
// src is already fixed, this function returns FALSE.
//
// The function takes the following parameters:
//
//    - dest: #GValue destination.
//    - src to fixate.
//
// The function returns the following values:
//
//    - ok: TRUE if dest contains a fixated version of src.
//
func ValueFixate(dest, src *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(dest.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(src.Native()))

	_cret = C.gst_value_fixate(_arg1, _arg2)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueFractionMultiply multiplies the two #GValue items containing a
// T_TYPE_FRACTION and sets product to the product of the two fractions.
//
// The function takes the following parameters:
//
//    - product: GValue initialized to T_TYPE_FRACTION.
//    - factor1: GValue initialized to T_TYPE_FRACTION.
//    - factor2: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//    - ok: FALSE in case of an error (like integer overflow), TRUE otherwise.
//
func ValueFractionMultiply(product, factor1, factor2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(product.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(factor1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(factor2.Native()))

	_cret = C.gst_value_fraction_multiply(_arg1, _arg2, _arg3)
	runtime.KeepAlive(product)
	runtime.KeepAlive(factor1)
	runtime.KeepAlive(factor2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueFractionSubtract subtracts the subtrahend from the minuend and sets dest
// to the result.
//
// The function takes the following parameters:
//
//    - dest: GValue initialized to T_TYPE_FRACTION.
//    - minuend: GValue initialized to T_TYPE_FRACTION.
//    - subtrahend: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//    - ok: FALSE in case of an error (like integer overflow), TRUE otherwise.
//
func ValueFractionSubtract(dest, minuend, subtrahend *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(dest.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(minuend.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(subtrahend.Native()))

	_cret = C.gst_value_fraction_subtract(_arg1, _arg2, _arg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueGetBitmask gets the bitmask specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to T_TYPE_BITMASK.
//
// The function returns the following values:
//
//    - guint64: bitmask.
//
func ValueGetBitmask(value *coreglib.Value) uint64 {
	var _arg1 *C.GValue // out
	var _cret C.guint64 // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_bitmask(_arg1)
	runtime.KeepAlive(value)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ValueGetCaps gets the contents of value. The reference count of the returned
// Caps will not be modified, therefore the caller must take one before getting
// rid of the value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_CAPS.
//
// The function returns the following values:
//
//    - caps contents of value.
//
func ValueGetCaps(value *coreglib.Value) *Caps {
	var _arg1 *C.GValue  // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_caps(_arg1)
	runtime.KeepAlive(value)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _caps
}

// ValueGetCapsFeatures gets the contents of value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_CAPS_FEATURES.
//
// The function returns the following values:
//
//    - capsFeatures contents of value.
//
func ValueGetCapsFeatures(value *coreglib.Value) *CapsFeatures {
	var _arg1 *C.GValue          // out
	var _cret *C.GstCapsFeatures // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_caps_features(_arg1)
	runtime.KeepAlive(value)

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _capsFeatures
}

// ValueGetDoubleRangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_DOUBLE_RANGE.
//
// The function returns the following values:
//
//    - gdouble: maximum of the range.
//
func ValueGetDoubleRangeMax(value *coreglib.Value) float64 {
	var _arg1 *C.GValue // out
	var _cret C.gdouble // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_double_range_max(_arg1)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ValueGetDoubleRangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_DOUBLE_RANGE.
//
// The function returns the following values:
//
//    - gdouble: minimum of the range.
//
func ValueGetDoubleRangeMin(value *coreglib.Value) float64 {
	var _arg1 *C.GValue // out
	var _cret C.gdouble // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_double_range_min(_arg1)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ValueGetFractionDenominator gets the denominator of the fraction specified by
// value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//    - gint: denominator of the fraction.
//
func ValueGetFractionDenominator(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_denominator(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetFractionNumerator gets the numerator of the fraction specified by
// value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//    - gint: numerator of the fraction.
//
func ValueGetFractionNumerator(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_numerator(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetFractionRangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//
// The function returns the following values:
//
//    - ret (optional): maximum of the range.
//
func ValueGetFractionRangeMax(value *coreglib.Value) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_range_max(_arg1)
	runtime.KeepAlive(value)

	var _ret *coreglib.Value // out

	if _cret != nil {
		_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _ret
}

// ValueGetFractionRangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//
// The function returns the following values:
//
//    - ret (optional): minimum of the range.
//
func ValueGetFractionRangeMin(value *coreglib.Value) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_range_min(_arg1)
	runtime.KeepAlive(value)

	var _ret *coreglib.Value // out

	if _cret != nil {
		_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _ret
}

// ValueGetInt64RangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT64_RANGE.
//
// The function returns the following values:
//
//    - gint64: maximum of the range.
//
func ValueGetInt64RangeMax(value *coreglib.Value) int64 {
	var _arg1 *C.GValue // out
	var _cret C.gint64  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int64_range_max(_arg1)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ValueGetInt64RangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT64_RANGE.
//
// The function returns the following values:
//
//    - gint64: minimum of the range.
//
func ValueGetInt64RangeMin(value *coreglib.Value) int64 {
	var _arg1 *C.GValue // out
	var _cret C.gint64  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int64_range_min(_arg1)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ValueGetInt64RangeStep gets the step of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT64_RANGE.
//
// The function returns the following values:
//
//    - gint64: step of the range.
//
func ValueGetInt64RangeStep(value *coreglib.Value) int64 {
	var _arg1 *C.GValue // out
	var _cret C.gint64  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int64_range_step(_arg1)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ValueGetIntRangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT_RANGE.
//
// The function returns the following values:
//
//    - gint: maximum of the range.
//
func ValueGetIntRangeMax(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int_range_max(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetIntRangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT_RANGE.
//
// The function returns the following values:
//
//    - gint: minimum of the range.
//
func ValueGetIntRangeMin(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int_range_min(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetIntRangeStep gets the step of the range specified by value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT_RANGE.
//
// The function returns the following values:
//
//    - gint: step of the range.
//
func ValueGetIntRangeStep(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int_range_step(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetStructure gets the contents of value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_STRUCTURE.
//
// The function returns the following values:
//
//    - structure contents of value.
//
func ValueGetStructure(value *coreglib.Value) *Structure {
	var _arg1 *C.GValue       // out
	var _cret *C.GstStructure // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_structure(_arg1)
	runtime.KeepAlive(value)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// ValueInitAndCopy initialises the target value to be of the same type as
// source and then copies the contents from source to target.
//
// The function takes the following parameters:
//
//    - src: source value.
//
// The function returns the following values:
//
//    - dest: target value.
//
func ValueInitAndCopy(src *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(src.Native()))

	C.gst_value_init_and_copy(&_arg1, _arg2)
	runtime.KeepAlive(src)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// ValueIntersect calculates the intersection of two values. If the values have
// a non-empty intersection, the value representing the intersection is placed
// in dest, unless NULL. If the intersection is non-empty, dest is not modified.
//
// The function takes the following parameters:
//
//    - value1: value to intersect.
//    - value2: another value to intersect.
//
// The function returns the following values:
//
//    - dest (optional): a uninitialized #GValue that will hold the calculated
//      intersection value. May be NULL if the resulting set if not needed.
//    - ok: TRUE if the intersection is non-empty.
//
func ValueIntersect(value1, value2 *coreglib.Value) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_intersect(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	runtime.SetFinalizer(_dest, func(v *coreglib.Value) {
		C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
	})
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// ValueIsFixed tests if the given GValue, if available in a GstStructure (or
// any other container) contains a "fixed" (which means: one value) or an
// "unfixed" (which means: multiple possible values, such as data lists or data
// ranges) value.
//
// The function takes the following parameters:
//
//    - value to check.
//
// The function returns the following values:
//
//    - ok: true if the value is "fixed".
//
func ValueIsFixed(value *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_is_fixed(_arg1)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueIsSubset: check that value1 is a subset of value2.
//
// The function takes the following parameters:
//
//    - value1: #GValue.
//    - value2: #GValue.
//
// The function returns the following values:
//
//    - ok: TRUE is value1 is a subset of value2.
//
func ValueIsSubset(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_is_subset(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueRegister registers functions to perform calculations on #GValue items of
// a given type. Each type can only be added once.
//
// The function takes the following parameters:
//
//    - table: structure containing functions to register.
//
func ValueRegister(table *ValueTable) {
	var _arg1 *C.GstValueTable // out

	_arg1 = (*C.GstValueTable)(gextras.StructNative(unsafe.Pointer(table)))

	C.gst_value_register(_arg1)
	runtime.KeepAlive(table)
}

// ValueSerialize tries to transform the given value into a string
// representation that allows getting back this string later on using
// gst_value_deserialize().
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//    - value to serialize.
//
// The function returns the following values:
//
//    - utf8 (optional): serialization for value or NULL if none exists.
//
func ValueSerialize(value *coreglib.Value) string {
	var _arg1 *C.GValue // out
	var _cret *C.gchar  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_serialize(_arg1)
	runtime.KeepAlive(value)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ValueSetBitmask sets value to the bitmask specified by bitmask.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to T_TYPE_BITMASK.
//    - bitmask: bitmask.
//
func ValueSetBitmask(value *coreglib.Value, bitmask uint64) {
	var _arg1 *C.GValue // out
	var _arg2 C.guint64 // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint64(bitmask)

	C.gst_value_set_bitmask(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(bitmask)
}

// ValueSetCaps sets the contents of value to caps. A reference to the provided
// caps will be taken by the value.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_CAPS.
//    - caps to set the value to.
//
func ValueSetCaps(value *coreglib.Value, caps *Caps) {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GstCaps // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_value_set_caps(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(caps)
}

// ValueSetCapsFeatures sets the contents of value to features.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_CAPS_FEATURES.
//    - features to set the value to.
//
func ValueSetCapsFeatures(value *coreglib.Value, features *CapsFeatures) {
	var _arg1 *C.GValue          // out
	var _arg2 *C.GstCapsFeatures // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	C.gst_value_set_caps_features(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(features)
}

// ValueSetDoubleRange sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_DOUBLE_RANGE.
//    - start of the range.
//    - end of the range.
//
func ValueSetDoubleRange(value *coreglib.Value, start, end float64) {
	var _arg1 *C.GValue // out
	var _arg2 C.gdouble // out
	var _arg3 C.gdouble // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gdouble(start)
	_arg3 = C.gdouble(end)

	C.gst_value_set_double_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetFraction sets value to the fraction specified by numerator over
// denominator. The fraction gets reduced to the smallest numerator and
// denominator, and if necessary the sign is moved to the numerator.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to T_TYPE_FRACTION.
//    - numerator of the fraction.
//    - denominator of the fraction.
//
func ValueSetFraction(value *coreglib.Value, numerator, denominator int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(numerator)
	_arg3 = C.gint(denominator)

	C.gst_value_set_fraction(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(numerator)
	runtime.KeepAlive(denominator)
}

// ValueSetFractionRange sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//    - start of the range (a GST_TYPE_FRACTION GValue).
//    - end of the range (a GST_TYPE_FRACTION GValue).
//
func ValueSetFractionRange(value, start, end *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out
	var _arg3 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(end.Native()))

	C.gst_value_set_fraction_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetFractionRangeFull sets value to the range specified by
// numerator_start/denominator_start and numerator_end/denominator_end.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//    - numeratorStart: numerator start of the range.
//    - denominatorStart: denominator start of the range.
//    - numeratorEnd: numerator end of the range.
//    - denominatorEnd: denominator end of the range.
//
func ValueSetFractionRangeFull(value *coreglib.Value, numeratorStart, denominatorStart, numeratorEnd, denominatorEnd int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _arg4 C.gint    // out
	var _arg5 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(numeratorStart)
	_arg3 = C.gint(denominatorStart)
	_arg4 = C.gint(numeratorEnd)
	_arg5 = C.gint(denominatorEnd)

	C.gst_value_set_fraction_range_full(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(value)
	runtime.KeepAlive(numeratorStart)
	runtime.KeepAlive(denominatorStart)
	runtime.KeepAlive(numeratorEnd)
	runtime.KeepAlive(denominatorEnd)
}

// ValueSetInt64Range sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT64_RANGE.
//    - start of the range.
//    - end of the range.
//
func ValueSetInt64Range(value *coreglib.Value, start, end int64) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint64  // out
	var _arg3 C.gint64  // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint64(start)
	_arg3 = C.gint64(end)

	C.gst_value_set_int64_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetInt64RangeStep sets value to the range specified by start, end and
// step.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT64_RANGE.
//    - start of the range.
//    - end of the range.
//    - step of the range.
//
func ValueSetInt64RangeStep(value *coreglib.Value, start, end, step int64) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint64  // out
	var _arg3 C.gint64  // out
	var _arg4 C.gint64  // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint64(start)
	_arg3 = C.gint64(end)
	_arg4 = C.gint64(step)

	C.gst_value_set_int64_range_step(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(step)
}

// ValueSetIntRange sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT_RANGE.
//    - start of the range.
//    - end of the range.
//
func ValueSetIntRange(value *coreglib.Value, start, end int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(start)
	_arg3 = C.gint(end)

	C.gst_value_set_int_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetIntRangeStep sets value to the range specified by start, end and
// step.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_INT_RANGE.
//    - start of the range.
//    - end of the range.
//    - step of the range.
//
func ValueSetIntRangeStep(value *coreglib.Value, start, end, step int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _arg4 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(start)
	_arg3 = C.gint(end)
	_arg4 = C.gint(step)

	C.gst_value_set_int_range_step(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(step)
}

// ValueSetStructure sets the contents of value to structure.
//
// The function takes the following parameters:
//
//    - value: GValue initialized to GST_TYPE_STRUCTURE.
//    - structure to set the value to.
//
func ValueSetStructure(value *coreglib.Value, structure *Structure) {
	var _arg1 *C.GValue       // out
	var _arg2 *C.GstStructure // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_value_set_structure(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(structure)
}

// ValueSubtract subtracts subtrahend from minuend and stores the result in
// dest. Note that this means subtraction as in sets, not as in mathematics.
//
// The function takes the following parameters:
//
//    - minuend: value to subtract from.
//    - subtrahend: value to subtract.
//
// The function returns the following values:
//
//    - dest (optional): destination value for the result if the subtraction is
//      not empty. May be NULL, in which case the resulting set will not be
//      computed, which can give a fair speedup.
//    - ok: TRUE if the subtraction is not empty.
//
func ValueSubtract(minuend, subtrahend *coreglib.Value) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg2 = (*C.GValue)(unsafe.Pointer(minuend.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(subtrahend.Native()))

	_cret = C.gst_value_subtract(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// ValueUnion creates a GValue corresponding to the union of value1 and value2.
//
// The function takes the following parameters:
//
//    - value1: value to union.
//    - value2: another value to union.
//
// The function returns the following values:
//
//    - dest: destination value.
//    - ok: TRUE if the union succeeded.
//
func ValueUnion(value1, value2 *coreglib.Value) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_union(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// Bitmask: fundamental type that describes a 64-bit bitmask.
type Bitmask struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Bitmask)(nil)
)

func wrapBitmask(obj *coreglib.Object) *Bitmask {
	return &Bitmask{
		Object: obj,
	}
}

func marshalBitmask(p uintptr) (interface{}, error) {
	return wrapBitmask(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DoubleRange: fundamental type that describes a #gdouble range.
type DoubleRange struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DoubleRange)(nil)
)

func wrapDoubleRange(obj *coreglib.Object) *DoubleRange {
	return &DoubleRange{
		Object: obj,
	}
}

func marshalDoubleRange(p uintptr) (interface{}, error) {
	return wrapDoubleRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FlagSet: fundamental type that describes a 32-bit flag bitfield, with 32-bit
// mask indicating which of the bits in the field are explicitly set.
type FlagSet struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FlagSet)(nil)
)

func wrapFlagSet(obj *coreglib.Object) *FlagSet {
	return &FlagSet{
		Object: obj,
	}
}

func marshalFlagSet(p uintptr) (interface{}, error) {
	return wrapFlagSet(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Fraction: fundamental type that describes a fraction of an integer numerator
// over an integer denominator.
type Fraction struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Fraction)(nil)
)

func wrapFraction(obj *coreglib.Object) *Fraction {
	return &Fraction{
		Object: obj,
	}
}

func marshalFraction(p uintptr) (interface{}, error) {
	return wrapFraction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FractionRange: fundamental type that describes a FractionRange range.
type FractionRange struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FractionRange)(nil)
)

func wrapFractionRange(obj *coreglib.Object) *FractionRange {
	return &FractionRange{
		Object: obj,
	}
}

func marshalFractionRange(p uintptr) (interface{}, error) {
	return wrapFractionRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Int64Range: fundamental type that describes a #gint64 range.
type Int64Range struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Int64Range)(nil)
)

func wrapInt64Range(obj *coreglib.Object) *Int64Range {
	return &Int64Range{
		Object: obj,
	}
}

func marshalInt64Range(p uintptr) (interface{}, error) {
	return wrapInt64Range(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IntRange: fundamental type that describes a #gint range.
type IntRange struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IntRange)(nil)
)

func wrapIntRange(obj *coreglib.Object) *IntRange {
	return &IntRange{
		Object: obj,
	}
}

func marshalIntRange(p uintptr) (interface{}, error) {
	return wrapIntRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ValueArray: fundamental type that describes an ordered list of #GValue.
type ValueArray struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ValueArray)(nil)
)

func wrapValueArray(obj *coreglib.Object) *ValueArray {
	return &ValueArray{
		Object: obj,
	}
}

func marshalValueArray(p uintptr) (interface{}, error) {
	return wrapValueArray(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ValueArrayAppendValue appends append_value to the GstValueArray in value.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_ARRAY.
//    - appendValue: value to append.
//
func ValueArrayAppendValue(value, appendValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(appendValue.Native()))

	C.gst_value_array_append_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(appendValue)
}

// ValueArrayGetSize gets the number of values contained in value.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_ARRAY.
//
// The function returns the following values:
//
//    - guint: number of values.
//
func ValueArrayGetSize(value *coreglib.Value) uint {
	var _arg1 *C.GValue // out
	var _cret C.guint   // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_array_get_size(_arg1)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ValueArrayGetValue gets the value that is a member of the array contained in
// value and has the index index.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_ARRAY.
//    - index of value to get from the array.
//
// The function returns the following values:
//
//    - ret: value at the given index.
//
func ValueArrayGetValue(value *coreglib.Value, index uint) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(index)

	_cret = C.gst_value_array_get_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)

	var _ret *coreglib.Value // out

	_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _ret
}

// ValueArrayPrependValue prepends prepend_value to the GstValueArray in value.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_ARRAY.
//    - prependValue: value to prepend.
//
func ValueArrayPrependValue(value, prependValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(prependValue.Native()))

	C.gst_value_array_prepend_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(prependValue)
}

// ValueList: fundamental type that describes an unordered list of #GValue.
type ValueList struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ValueList)(nil)
)

func wrapValueList(obj *coreglib.Object) *ValueList {
	return &ValueList{
		Object: obj,
	}
}

func marshalValueList(p uintptr) (interface{}, error) {
	return wrapValueList(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ValueListAppendValue appends append_value to the GstValueList in value.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_LIST.
//    - appendValue: value to append.
//
func ValueListAppendValue(value, appendValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(appendValue.Native()))

	C.gst_value_list_append_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(appendValue)
}

// ValueListConcat concatenates copies of value1 and value2 into a list. Values
// that are not of type T_TYPE_LIST are treated as if they were lists of length
// 1. dest will be initialized to the type T_TYPE_LIST.
//
// The function takes the following parameters:
//
//    - value1: #GValue.
//    - value2: #GValue.
//
// The function returns the following values:
//
//    - dest: uninitialized #GValue to take the result.
//
func ValueListConcat(value1, value2 *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out
	var _arg3 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	C.gst_value_list_concat(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// ValueListGetSize gets the number of values contained in value.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_LIST.
//
// The function returns the following values:
//
//    - guint: number of values.
//
func ValueListGetSize(value *coreglib.Value) uint {
	var _arg1 *C.GValue // out
	var _cret C.guint   // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_list_get_size(_arg1)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ValueListGetValue gets the value that is a member of the list contained in
// value and has the index index.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_LIST.
//    - index of value to get from the list.
//
// The function returns the following values:
//
//    - ret: value at the given index.
//
func ValueListGetValue(value *coreglib.Value, index uint) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(index)

	_cret = C.gst_value_list_get_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)

	var _ret *coreglib.Value // out

	_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _ret
}

// ValueListMerge merges copies of value1 and value2. Values that are not of
// type T_TYPE_LIST are treated as if they were lists of length 1.
//
// The result will be put into dest and will either be a list that will not
// contain any duplicates, or a non-list type (if value1 and value2 were equal).
//
// The function takes the following parameters:
//
//    - value1: #GValue.
//    - value2: #GValue.
//
// The function returns the following values:
//
//    - dest: uninitialized #GValue to take the result.
//
func ValueListMerge(value1, value2 *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out
	var _arg3 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	C.gst_value_list_merge(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// ValueListPrependValue prepends prepend_value to the GstValueList in value.
//
// The function takes the following parameters:
//
//    - value of type T_TYPE_LIST.
//    - prependValue: value to prepend.
//
func ValueListPrependValue(value, prependValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(prependValue.Native()))

	C.gst_value_list_prepend_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(prependValue)
}

// ValueTable: VTable for the #GValue type.
//
// An instance of this type is always passed by reference.
type ValueTable struct {
	*valueTable
}

// valueTable is the struct that's finalized.
type valueTable struct {
	native *C.GstValueTable
}
