// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern gboolean _gotk4_gst1_BufferForEachMetaFunc(GstBuffer*, GstMeta**, gpointer);
import "C"

// GType values.
var (
	GTypeBufferCopyFlags = coreglib.Type(C.gst_buffer_copy_flags_get_type())
	GTypeBufferFlags     = coreglib.Type(C.gst_buffer_flags_get_type())
	GTypeBuffer          = coreglib.Type(C.gst_buffer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBufferCopyFlags, F: marshalBufferCopyFlags},
		coreglib.TypeMarshaler{T: GTypeBufferFlags, F: marshalBufferFlags},
		coreglib.TypeMarshaler{T: GTypeBuffer, F: marshalBuffer},
	})
}

// BUFFER_OFFSET_NONE: constant for no-offset return results.
const BUFFER_OFFSET_NONE = 18446744073709551615

// BufferCopyFlags: set of flags that can be provided to the
// gst_buffer_copy_into() function to specify which items should be copied.
type BufferCopyFlags C.guint

const (
	// BufferCopyCopyNone: copy nothing.
	BufferCopyCopyNone BufferCopyFlags = 0b0
	// BufferCopyCopyFlags: flag indicating that buffer flags should be copied.
	BufferCopyCopyFlags BufferCopyFlags = 0b1
	// BufferCopyCopyTimestamps: flag indicating that buffer pts, dts, duration,
	// offset and offset_end should be copied.
	BufferCopyCopyTimestamps BufferCopyFlags = 0b10
	// BufferCopyCopyMeta: flag indicating that buffer meta should be copied.
	BufferCopyCopyMeta BufferCopyFlags = 0b100
	// BufferCopyCopyMemory: flag indicating that buffer memory should be reffed
	// and appended to already existing memory. Unless the memory is marked as
	// NO_SHARE, no actual copy of the memory is made but it is simply reffed.
	// Add GST_BUFFER_COPY_DEEP to force a real copy.
	BufferCopyCopyMemory BufferCopyFlags = 0b1000
	// BufferCopyCopyMerge: flag indicating that buffer memory should be merged.
	BufferCopyCopyMerge BufferCopyFlags = 0b10000
	// BufferCopyCopyDeep: flag indicating that memory should always be copied
	// instead of reffed.
	BufferCopyCopyDeep BufferCopyFlags = 0b100000
)

func marshalBufferCopyFlags(p uintptr) (interface{}, error) {
	return BufferCopyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BufferCopyFlags.
func (b BufferCopyFlags) String() string {
	if b == 0 {
		return "BufferCopyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(142)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BufferCopyCopyNone:
			builder.WriteString("None|")
		case BufferCopyCopyFlags:
			builder.WriteString("Flags|")
		case BufferCopyCopyTimestamps:
			builder.WriteString("Timestamps|")
		case BufferCopyCopyMeta:
			builder.WriteString("Meta|")
		case BufferCopyCopyMemory:
			builder.WriteString("Memory|")
		case BufferCopyCopyMerge:
			builder.WriteString("Merge|")
		case BufferCopyCopyDeep:
			builder.WriteString("Deep|")
		default:
			builder.WriteString(fmt.Sprintf("BufferCopyFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BufferCopyFlags) Has(other BufferCopyFlags) bool {
	return (b & other) == other
}

// BufferFlags: set of buffer flags used to describe properties of a Buffer.
type BufferFlags C.guint

const (
	// BufferFlagLive: buffer is live data and should be discarded in the PAUSED
	// state.
	BufferFlagLive BufferFlags = 0b10000
	// BufferFlagDecodeOnly: buffer contains data that should be dropped because
	// it will be clipped against the segment boundaries or because it does not
	// contain data that should be shown to the user.
	BufferFlagDecodeOnly BufferFlags = 0b100000
	// BufferFlagDiscont: buffer marks a data discontinuity in the stream. This
	// typically occurs after a seek or a dropped buffer from a live or network
	// source.
	BufferFlagDiscont BufferFlags = 0b1000000
	// BufferFlagResync: buffer timestamps might have a discontinuity and this
	// buffer is a good point to resynchronize.
	BufferFlagResync BufferFlags = 0b10000000
	// BufferFlagCorrupted: buffer data is corrupted.
	BufferFlagCorrupted BufferFlags = 0b100000000
	// BufferFlagMarker: buffer contains a media specific marker. for video this
	// is the end of a frame boundary, for audio this is the start of a
	// talkspurt.
	BufferFlagMarker BufferFlags = 0b1000000000
	// BufferFlagHeader: buffer contains header information that is needed to
	// decode the following data.
	BufferFlagHeader BufferFlags = 0b10000000000
	// BufferFlagGap: buffer has been created to fill a gap in the stream and
	// contains media neutral data (elements can switch to optimized code path
	// that ignores the buffer content).
	BufferFlagGap BufferFlags = 0b100000000000
	// BufferFlagDroppable: buffer can be dropped without breaking the stream,
	// for example to reduce bandwidth.
	BufferFlagDroppable BufferFlags = 0b1000000000000
	// BufferFlagDeltaUnit: unit cannot be decoded independently.
	BufferFlagDeltaUnit BufferFlags = 0b10000000000000
	// BufferFlagTagMemory: flag is set when memory of the buffer is
	// added/removed.
	BufferFlagTagMemory BufferFlags = 0b100000000000000
	// BufferFlagSyncAfter elements which write to disk or permanent storage
	// should ensure the data is synced after writing the contents of this
	// buffer.
	BufferFlagSyncAfter BufferFlags = 0b1000000000000000
	// BufferFlagNonDroppable: this buffer is important and should not be
	// dropped.
	//
	// This can be used to mark important buffers, e.g. to flag RTP packets
	// carrying keyframes or codec setup data for RTP Forward Error Correction
	// purposes, or to prevent still video frames from being dropped by elements
	// due to QoS.
	BufferFlagNonDroppable BufferFlags = 0b10000000000000000
	// BufferFlagLast: additional media specific flags can be added starting
	// from this flag.
	BufferFlagLast BufferFlags = 0b100000000000000000000
)

func marshalBufferFlags(p uintptr) (interface{}, error) {
	return BufferFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BufferFlags.
func (b BufferFlags) String() string {
	if b == 0 {
		return "BufferFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BufferFlagLive:
			builder.WriteString("Live|")
		case BufferFlagDecodeOnly:
			builder.WriteString("DecodeOnly|")
		case BufferFlagDiscont:
			builder.WriteString("Discont|")
		case BufferFlagResync:
			builder.WriteString("Resync|")
		case BufferFlagCorrupted:
			builder.WriteString("Corrupted|")
		case BufferFlagMarker:
			builder.WriteString("Marker|")
		case BufferFlagHeader:
			builder.WriteString("Header|")
		case BufferFlagGap:
			builder.WriteString("Gap|")
		case BufferFlagDroppable:
			builder.WriteString("Droppable|")
		case BufferFlagDeltaUnit:
			builder.WriteString("DeltaUnit|")
		case BufferFlagTagMemory:
			builder.WriteString("TagMemory|")
		case BufferFlagSyncAfter:
			builder.WriteString("SyncAfter|")
		case BufferFlagNonDroppable:
			builder.WriteString("NonDroppable|")
		case BufferFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BufferFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BufferFlags) Has(other BufferFlags) bool {
	return (b & other) == other
}

// BufferForEachMetaFunc: function that will be called from
// gst_buffer_foreach_meta(). The meta field will point to a the reference of
// the meta.
//
// buffer should not be modified from this callback.
//
// When this function returns TRUE, the next meta will be returned. When FALSE
// is returned, gst_buffer_foreach_meta() will return.
//
// When meta is set to NULL, the item will be removed from the buffer.
type BufferForEachMetaFunc func(buffer *Buffer) (meta *Meta, ok bool)

// The function returns the following values:
//
func ParentBufferMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_parent_buffer_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// The function returns the following values:
//
func ReferenceTimestampMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_reference_timestamp_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Buffer buffers are the basic unit of data transfer in GStreamer. They contain
// the timing and offset along with other arbitrary metadata that is associated
// with the Memory blocks that the buffer contains.
//
// Buffers are usually created with gst_buffer_new(). After a buffer has been
// created one will typically allocate memory for it and add it to the buffer.
// The following example creates a buffer that can hold a given video frame with
// a given width, height and bits per plane.
//
//    C   GstBuffer *buffer;   GstMemory *memory;   gint size, width, height, bpp;   ...   size = width * height * bpp;   buffer = gst_buffer_new ();   memory = gst_allocator_alloc (NULL, size, NULL);   gst_buffer_insert_memory (buffer, -1, memory);   ...
//
// Alternatively, use gst_buffer_new_allocate() to create a buffer with
// preallocated data of a given size.
//
// Buffers can contain a list of Memory objects. You can retrieve how many
// memory objects with gst_buffer_n_memory() and you can get a pointer to memory
// with gst_buffer_peek_memory()
//
// A buffer will usually have timestamps, and a duration, but neither of these
// are guaranteed (they may be set to T_CLOCK_TIME_NONE). Whenever a meaningful
// value can be given for these, they should be set. The timestamps and duration
// are measured in nanoseconds (they are ClockTime values).
//
// The buffer DTS refers to the timestamp when the buffer should be decoded and
// is usually monotonically increasing. The buffer PTS refers to the timestamp
// when the buffer content should be presented to the user and is not always
// monotonically increasing.
//
// A buffer can also have one or both of a start and an end offset. These are
// media-type specific. For video buffers, the start offset will generally be
// the frame number. For audio buffers, it will be the number of samples
// produced so far. For compressed data, it could be the byte offset in a source
// or destination file. Likewise, the end offset will be the offset of the end
// of the buffer. These can only be meaningfully interpreted if you know the
// media type of the buffer (the preceding CAPS event). Either or both can be
// set to T_BUFFER_OFFSET_NONE.
//
// gst_buffer_ref() is used to increase the refcount of a buffer. This must be
// done when you want to keep a handle to the buffer after pushing it to the
// next element. The buffer refcount determines the writability of the buffer, a
// buffer is only writable when the refcount is exactly 1, i.e. when the caller
// has the only reference to the buffer.
//
// To efficiently create a smaller buffer out of an existing one, you can use
// gst_buffer_copy_region(). This method tries to share the memory objects
// between the two buffers.
//
// If a plug-in wants to modify the buffer data or metadata in-place, it should
// first obtain a buffer that is safe to modify by using
// gst_buffer_make_writable(). This function is optimized so that a copy will
// only be made when it is necessary.
//
// Several flags of the buffer can be set and unset with the
// GST_BUFFER_FLAG_SET() and GST_BUFFER_FLAG_UNSET() macros. Use
// GST_BUFFER_FLAG_IS_SET() to test if a certain BufferFlags flag is set.
//
// Buffers can be efficiently merged into a larger buffer with
// gst_buffer_append(). Copying of memory will only be done when absolutely
// needed.
//
// Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
// Metadata can be retrieved with gst_buffer_get_meta(). See also Meta.
//
// An element should either unref the buffer or push it out on a src pad using
// gst_pad_push() (see Pad).
//
// Buffers are usually freed by unreffing them with gst_buffer_unref(). When the
// refcount drops to 0, any memory and metadata pointed to by the buffer is
// unreffed as well. Buffers allocated from a BufferPool will be returned to the
// pool when the refcount drops to 0.
//
// The ParentBufferMeta is a meta which can be attached to a Buffer to hold a
// reference to another buffer that is only released when the child Buffer is
// released.
//
// Typically, ParentBufferMeta is used when the child buffer is directly using
// the Memory of the parent buffer, and wants to prevent the parent buffer from
// being returned to a buffer pool until the Memory is available for re-use.
// (Since: 1.6)
//
// An instance of this type is always passed by reference.
type Buffer struct {
	*buffer
}

// buffer is the struct that's finalized.
type buffer struct {
	native *C.GstBuffer
}

func marshalBuffer(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Buffer{&buffer{(*C.GstBuffer)(b)}}, nil
}

// NewBuffer constructs a struct Buffer.
func NewBuffer() *Buffer {
	var _cret *C.GstBuffer // in

	_cret = C.gst_buffer_new()

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewBufferAllocate constructs a struct Buffer.
func NewBufferAllocate(allocator Allocatorrer, size uint, params *AllocationParams) *Buffer {
	var _arg1 *C.GstAllocator        // out
	var _arg2 C.gsize                // out
	var _arg3 *C.GstAllocationParams // out
	var _cret *C.GstBuffer           // in

	if allocator != nil {
		_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	_arg2 = C.gsize(size)
	if params != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_buffer_new_allocate(_arg1, _arg2, _arg3)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(size)
	runtime.KeepAlive(params)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// NewBufferMemdup constructs a struct Buffer.
func NewBufferMemdup(data []byte) *Buffer {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gsize
	var _cret *C.GstBuffer // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_buffer_new_memdup(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewBufferWrapped constructs a struct Buffer.
func NewBufferWrapped(data []byte) *Buffer {
	var _arg1 C.gpointer // out
	var _arg2 C.gsize
	var _cret *C.GstBuffer // in

	_arg2 = (C.gsize)(len(data))
	_arg1 = (C.gpointer)(C.calloc(C.size_t(len(data)), C.size_t(C.sizeof_guint8)))
	copy(unsafe.Slice((*byte)(_arg1), len(data)), data)

	_cret = C.gst_buffer_new_wrapped(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewBufferWrappedBytes constructs a struct Buffer.
func NewBufferWrappedBytes(bytes *glib.Bytes) *Buffer {
	var _arg1 *C.GBytes    // out
	var _cret *C.GstBuffer // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.gst_buffer_new_wrapped_bytes(_arg1)
	runtime.KeepAlive(bytes)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// MiniObject: parent structure.
func (b *Buffer) MiniObject() *MiniObject {
	valptr := &b.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Pool: pointer to the pool owner of the buffer.
func (b *Buffer) Pool() *BufferPool {
	valptr := &b.native.pool
	var _v *BufferPool // out
	_v = wrapBufferPool(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// Pts: presentation timestamp of the buffer, can be T_CLOCK_TIME_NONE when the
// pts is not known or relevant. The pts contains the timestamp when the media
// should be presented to the user.
func (b *Buffer) Pts() ClockTime {
	valptr := &b.native.pts
	var _v ClockTime // out
	_v = uint64(*valptr)
	type _ = ClockTime
	type _ = uint64
	return _v
}

// Dts: decoding timestamp of the buffer, can be T_CLOCK_TIME_NONE when the dts
// is not known or relevant. The dts contains the timestamp when the media
// should be processed.
func (b *Buffer) Dts() ClockTime {
	valptr := &b.native.dts
	var _v ClockTime // out
	_v = uint64(*valptr)
	type _ = ClockTime
	type _ = uint64
	return _v
}

// Duration: duration in time of the buffer data, can be T_CLOCK_TIME_NONE when
// the duration is not known or relevant.
func (b *Buffer) Duration() ClockTime {
	valptr := &b.native.duration
	var _v ClockTime // out
	_v = uint64(*valptr)
	type _ = ClockTime
	type _ = uint64
	return _v
}

// Offset: media specific offset for the buffer data. For video frames, this is
// the frame number of this buffer. For audio samples, this is the offset of the
// first sample in this buffer. For file data or compressed data this is the
// byte offset of the first byte in this buffer.
func (b *Buffer) Offset() uint64 {
	valptr := &b.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// OffsetEnd: last offset contained in this buffer. It has the same format as
// offset.
func (b *Buffer) OffsetEnd() uint64 {
	valptr := &b.native.offset_end
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Offset: media specific offset for the buffer data. For video frames, this is
// the frame number of this buffer. For audio samples, this is the offset of the
// first sample in this buffer. For file data or compressed data this is the
// byte offset of the first byte in this buffer.
func (b *Buffer) SetOffset(offset uint64) {
	valptr := &b.native.offset
	*valptr = C.guint64(offset)
}

// OffsetEnd: last offset contained in this buffer. It has the same format as
// offset.
func (b *Buffer) SetOffsetEnd(offsetEnd uint64) {
	valptr := &b.native.offset_end
	*valptr = C.guint64(offsetEnd)
}

// AddCustomMeta creates and adds a CustomMeta for the desired name. name must
// have been successfully registered with gst_meta_register_custom().
//
// The function takes the following parameters:
//
//    - name: registered name of the desired custom meta.
//
// The function returns the following values:
//
//    - customMeta (optional) that was added to the buffer.
//
func (buffer *Buffer) AddCustomMeta(name string) *CustomMeta {
	var _arg0 *C.GstBuffer     // out
	var _arg1 *C.gchar         // out
	var _cret *C.GstCustomMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_buffer_add_custom_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _customMeta *CustomMeta // out

	if _cret != nil {
		_customMeta = (*CustomMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _customMeta
}

// AddMeta adds metadata for info to buffer using the parameters in params.
//
// The function takes the following parameters:
//
//    - info: MetaInfo.
//    - params (optional) for info.
//
// The function returns the following values:
//
//    - meta (optional): metadata for the api in info on buffer.
//
func (buffer *Buffer) AddMeta(info *MetaInfo, params unsafe.Pointer) *Meta {
	var _arg0 *C.GstBuffer   // out
	var _arg1 *C.GstMetaInfo // out
	var _arg2 C.gpointer     // out
	var _cret *C.GstMeta     // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMetaInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (C.gpointer)(unsafe.Pointer(params))

	_cret = C.gst_buffer_add_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)
	runtime.KeepAlive(params)

	var _meta *Meta // out

	if _cret != nil {
		_meta = (*Meta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _meta
}

// AddParentBufferMeta adds a ParentBufferMeta to buffer that holds a reference
// on ref until the buffer is freed.
//
// The function takes the following parameters:
//
//    - ref to ref.
//
// The function returns the following values:
//
//    - parentBufferMeta (optional) that was added to the buffer.
//
func (buffer *Buffer) AddParentBufferMeta(ref *Buffer) *ParentBufferMeta {
	var _arg0 *C.GstBuffer           // out
	var _arg1 *C.GstBuffer           // out
	var _cret *C.GstParentBufferMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(ref)))

	_cret = C.gst_buffer_add_parent_buffer_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ref)

	var _parentBufferMeta *ParentBufferMeta // out

	if _cret != nil {
		_parentBufferMeta = (*ParentBufferMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _parentBufferMeta
}

// AddProtectionMeta attaches protection metadata to a Buffer.
//
// The function takes the following parameters:
//
//    - info holding cryptographic information relating to the sample contained
//      in buffer. This function takes ownership of info.
//
// The function returns the following values:
//
//    - protectionMeta: pointer to the added ProtectionMeta if successful.
//
func (buffer *Buffer) AddProtectionMeta(info *Structure) *ProtectionMeta {
	var _arg0 *C.GstBuffer         // out
	var _arg1 *C.GstStructure      // out
	var _cret *C.GstProtectionMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(info)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(info)), nil)

	_cret = C.gst_buffer_add_protection_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)

	var _protectionMeta *ProtectionMeta // out

	_protectionMeta = (*ProtectionMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _protectionMeta
}

// AddReferenceTimestampMeta adds a ReferenceTimestampMeta to buffer that holds
// a timestamp and optionally duration based on a specific timestamp reference.
// See the documentation of ReferenceTimestampMeta for details.
//
// The function takes the following parameters:
//
//    - reference: identifier for the timestamp reference.
//    - timestamp: timestamp.
//    - duration: duration, or GST_CLOCK_TIME_NONE.
//
// The function returns the following values:
//
//    - referenceTimestampMeta (optional) that was added to the buffer.
//
func (buffer *Buffer) AddReferenceTimestampMeta(reference *Caps, timestamp ClockTime, duration ClockTime) *ReferenceTimestampMeta {
	var _arg0 *C.GstBuffer                 // out
	var _arg1 *C.GstCaps                   // out
	var _arg2 C.GstClockTime               // out
	var _arg3 C.GstClockTime               // out
	var _cret *C.GstReferenceTimestampMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(reference)))
	_arg2 = C.guint64(timestamp)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(duration)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_buffer_add_reference_timestamp_meta(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(reference)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _referenceTimestampMeta *ReferenceTimestampMeta // out

	if _cret != nil {
		_referenceTimestampMeta = (*ReferenceTimestampMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _referenceTimestampMeta
}

// Append appends all the memory from buf2 to buf1. The result buffer will
// contain a concatenation of the memory of buf1 and buf2.
//
// The function takes the following parameters:
//
//    - buf2: second source Buffer to append.
//
// The function returns the following values:
//
//    - buffer: new Buffer that contains the memory of the two source buffers.
//
func (buf1 *Buffer) Append(buf2 *Buffer) *Buffer {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstBuffer // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf1)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf1)), nil)
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf2)), nil)

	_cret = C.gst_buffer_append(_arg0, _arg1)
	runtime.KeepAlive(buf1)
	runtime.KeepAlive(buf2)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// AppendMemory appends the memory block mem to buffer. This function takes
// ownership of mem and thus doesn't increase its refcount.
//
// This function is identical to gst_buffer_insert_memory() with an index of -1.
// See gst_buffer_insert_memory() for more details.
//
// The function takes the following parameters:
//
//    - mem: Memory.
//
func (buffer *Buffer) AppendMemory(mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_append_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mem)
}

// AppendRegion appends size bytes at offset from buf2 to buf1. The result
// buffer will contain a concatenation of the memory of buf1 and the requested
// region of buf2.
//
// The function takes the following parameters:
//
//    - buf2: second source Buffer to append.
//    - offset in buf2.
//    - size or -1 of buf2.
//
// The function returns the following values:
//
//    - buffer: new Buffer that contains the memory of the two source buffers.
//
func (buf1 *Buffer) AppendRegion(buf2 *Buffer, offset int, size int) *Buffer {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstBuffer // out
	var _arg2 C.gssize     // out
	var _arg3 C.gssize     // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf1)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf1)), nil)
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf2)), nil)
	_arg2 = C.gssize(offset)
	_arg3 = C.gssize(size)

	_cret = C.gst_buffer_append_region(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buf1)
	runtime.KeepAlive(buf2)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// CopyDeep creates a copy of the given buffer. This will make a newly allocated
// copy of the data the source buffer contains.
//
// The function returns the following values:
//
//    - buffer: new copy of buf.
//
func (buf *Buffer) CopyDeep() *Buffer {
	var _arg0 *C.GstBuffer // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C.gst_buffer_copy_deep(_arg0)
	runtime.KeepAlive(buf)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// CopyInto copies the information from src into dest.
//
// If dest already contains memory and flags contains GST_BUFFER_COPY_MEMORY,
// the memory from src will be appended to dest.
//
// flags indicate which fields will be copied.
//
// The function takes the following parameters:
//
//    - src: source Buffer.
//    - flags indicating what metadata fields should be copied.
//    - offset to copy from.
//    - size: total size to copy. If -1, all data is copied.
//
// The function returns the following values:
//
//    - ok: TRUE if the copying succeeded, FALSE otherwise.
//
func (dest *Buffer) CopyInto(src *Buffer, flags BufferCopyFlags, offset uint, size uint) bool {
	var _arg0 *C.GstBuffer         // out
	var _arg1 *C.GstBuffer         // out
	var _arg2 C.GstBufferCopyFlags // out
	var _arg3 C.gsize              // out
	var _arg4 C.gsize              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
	_arg2 = C.GstBufferCopyFlags(flags)
	_arg3 = C.gsize(offset)
	_arg4 = C.gsize(size)

	_cret = C.gst_buffer_copy_into(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyRegion creates a sub-buffer from parent at offset and size. This
// sub-buffer uses the actual memory space of the parent buffer. This function
// will copy the offset and timestamp fields when the offset is 0. If not, they
// will be set to T_CLOCK_TIME_NONE and T_BUFFER_OFFSET_NONE. If offset equals 0
// and size equals the total size of buffer, the duration and offset end fields
// are also copied. If not they will be set to T_CLOCK_TIME_NONE and
// T_BUFFER_OFFSET_NONE.
//
// The function takes the following parameters:
//
//    - flags: BufferCopyFlags.
//    - offset into parent Buffer at which the new sub-buffer begins.
//    - size of the new Buffer sub-buffer, in bytes. If -1, all data is copied.
//
// The function returns the following values:
//
//    - buffer: new Buffer or NULL if the arguments were invalid.
//
func (parent *Buffer) CopyRegion(flags BufferCopyFlags, offset uint, size uint) *Buffer {
	var _arg0 *C.GstBuffer         // out
	var _arg1 C.GstBufferCopyFlags // out
	var _arg2 C.gsize              // out
	var _arg3 C.gsize              // out
	var _cret *C.GstBuffer         // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(parent)))
	_arg1 = C.GstBufferCopyFlags(flags)
	_arg2 = C.gsize(offset)
	_arg3 = C.gsize(size)

	_cret = C.gst_buffer_copy_region(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// Extract copies size bytes starting from offset in buffer to dest.
//
// The function takes the following parameters:
//
//    - offset to extract.
//    - dest: the destination address.
//
// The function returns the following values:
//
//    - gsize: amount of bytes extracted. This value can be lower than size when
//      buffer did not contain enough data.
//
func (buffer *Buffer) Extract(offset uint, dest []byte) uint {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.gpointer   // out
	var _arg3 C.gsize
	var _cret C.gsize // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg3 = (C.gsize)(len(dest))
	if len(dest) > 0 {
		_arg2 = (C.gpointer)(unsafe.Pointer(&dest[0]))
	}

	_cret = C.gst_buffer_extract(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(dest)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// ExtractDup extracts a copy of at most size bytes the data at offset into
// newly-allocated memory. dest must be freed using g_free() when done.
//
// The function takes the following parameters:
//
//    - offset to extract.
//    - size to extract.
//
// The function returns the following values:
//
//    - dest: pointer where the destination array will be written. Might be NULL
//      if the size is 0.
//
func (buffer *Buffer) ExtractDup(offset uint, size uint) []byte {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.gsize      // out
	var _arg3 C.gpointer   // in
	var _arg4 C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg2 = C.gsize(size)

	C.gst_buffer_extract_dup(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _dest []byte // out

	defer C.free(unsafe.Pointer(_arg3))
	_dest = make([]byte, _arg4)
	copy(_dest, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg4))

	return _dest
}

// Fill copies size bytes from src to buffer at offset.
//
// The function takes the following parameters:
//
//    - offset to fill.
//    - src: source address.
//
// The function returns the following values:
//
//    - gsize: amount of bytes copied. This value can be lower than size when
//      buffer did not contain enough data.
//
func (buffer *Buffer) Fill(offset uint, src []byte) uint {
	var _arg0 *C.GstBuffer    // out
	var _arg1 C.gsize         // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize
	var _cret C.gsize // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg3 = (C.gsize)(len(src))
	if len(src) > 0 {
		_arg2 = (C.gconstpointer)(unsafe.Pointer(&src[0]))
	}

	_cret = C.gst_buffer_fill(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(src)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// FindMemory finds the memory blocks that span size bytes starting from offset
// in buffer.
//
// When this function returns TRUE, idx will contain the index of the first
// memory block where the byte for offset can be found and length contains the
// number of memory blocks containing the size remaining bytes. skip contains
// the number of bytes to skip in the memory block at idx to get to the byte for
// offset.
//
// size can be -1 to get all the memory blocks after idx.
//
// The function takes the following parameters:
//
//    - offset: offset.
//    - size: size.
//
// The function returns the following values:
//
//    - idx: pointer to index.
//    - length: pointer to length.
//    - skip: pointer to skip.
//    - ok: TRUE when size bytes starting from offset could be found in buffer
//      and idx, length and skip will be filled.
//
func (buffer *Buffer) FindMemory(offset uint, size uint) (idx uint, length uint, skip uint, ok bool) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.gsize      // out
	var _arg3 C.guint      // in
	var _arg4 C.guint      // in
	var _arg5 C.gsize      // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg2 = C.gsize(size)

	_cret = C.gst_buffer_find_memory(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _idx uint    // out
	var _length uint // out
	var _skip uint   // out
	var _ok bool     // out

	_idx = uint(_arg3)
	_length = uint(_arg4)
	_skip = uint(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _idx, _length, _skip, _ok
}

// ForEachMeta calls func with user_data for each meta in buffer.
//
// func can modify the passed meta pointer or its contents. The return value of
// func defines if this function returns or if the remaining metadata items in
// the buffer should be skipped.
//
// The function takes the following parameters:
//
//    - fn to call.
//
// The function returns the following values:
//
//    - ok: FALSE when func returned FALSE for one of the metadata.
//
func (buffer *Buffer) ForEachMeta(fn BufferForEachMetaFunc) bool {
	var _arg0 *C.GstBuffer               // out
	var _arg1 C.GstBufferForeachMetaFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_BufferForEachMetaFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_buffer_foreach_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AllMemory gets all the memory blocks in buffer. The memory blocks will be
// merged into one large Memory.
//
// The function returns the following values:
//
//    - memory (optional) that contains the merged memory.
//
func (buffer *Buffer) AllMemory() *Memory {
	var _arg0 *C.GstBuffer // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_all_memory(_arg0)
	runtime.KeepAlive(buffer)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// CustomMeta finds the first CustomMeta on buffer for the desired name.
//
// The function takes the following parameters:
//
//    - name: registered name of the custom meta to retrieve.
//
// The function returns the following values:
//
//    - customMeta (optional): CustomMeta.
//
func (buffer *Buffer) CustomMeta(name string) *CustomMeta {
	var _arg0 *C.GstBuffer     // out
	var _arg1 *C.gchar         // out
	var _cret *C.GstCustomMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_buffer_get_custom_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _customMeta *CustomMeta // out

	if _cret != nil {
		_customMeta = (*CustomMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _customMeta
}

// Flags gets the BufferFlags flags set on this buffer.
//
// The function returns the following values:
//
//    - bufferFlags flags set on this buffer.
//
func (buffer *Buffer) Flags() BufferFlags {
	var _arg0 *C.GstBuffer     // out
	var _cret C.GstBufferFlags // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_flags(_arg0)
	runtime.KeepAlive(buffer)

	var _bufferFlags BufferFlags // out

	_bufferFlags = BufferFlags(_cret)

	return _bufferFlags
}

// Memory gets the memory block at index idx in buffer.
//
// The function takes the following parameters:
//
//    - idx: index.
//
// The function returns the following values:
//
//    - memory (optional) that contains the data of the memory block at idx.
//
func (buffer *Buffer) Memory(idx uint) *Memory {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_get_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// MemoryRange gets length memory blocks in buffer starting at idx. The memory
// blocks will be merged into one large Memory.
//
// If length is -1, all memory starting from idx is merged.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length.
//
// The function returns the following values:
//
//    - memory (optional) that contains the merged data of length blocks starting
//      at idx.
//
func (buffer *Buffer) MemoryRange(idx uint, length int) *Memory {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	_cret = C.gst_buffer_get_memory_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// Meta gets the metadata for api on buffer. When there is no such metadata,
// NULL is returned. If multiple metadata with the given api are attached to
// this buffer only the first one is returned. To handle multiple metadata with
// a given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta()
// instead and check the meta->info.api member for the API type.
//
// The function takes the following parameters:
//
//    - api of an API.
//
// The function returns the following values:
//
//    - meta (optional): metadata for api on buffer.
//
func (buffer *Buffer) Meta(api coreglib.Type) *Meta {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.GType      // out
	var _cret *C.GstMeta   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GType(api)

	_cret = C.gst_buffer_get_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(api)

	var _meta *Meta // out

	if _cret != nil {
		_meta = (*Meta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _meta
}

// The function takes the following parameters:
//
//    - apiType of an API.
//
// The function returns the following values:
//
//    - guint: number of metas of type api_type on buffer.
//
func (buffer *Buffer) NMeta(apiType coreglib.Type) uint {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.GType      // out
	var _cret C.guint      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GType(apiType)

	_cret = C.gst_buffer_get_n_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(apiType)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ReferenceTimestampMeta finds the first ReferenceTimestampMeta on buffer that
// conforms to reference. Conformance is tested by checking if the meta's
// reference is a subset of reference.
//
// Buffers can contain multiple ReferenceTimestampMeta metadata items.
//
// The function takes the following parameters:
//
//    - reference (optional) Caps.
//
// The function returns the following values:
//
//    - referenceTimestampMeta (optional) or NULL when there is no such metadata
//      on buffer.
//
func (buffer *Buffer) ReferenceTimestampMeta(reference *Caps) *ReferenceTimestampMeta {
	var _arg0 *C.GstBuffer                 // out
	var _arg1 *C.GstCaps                   // out
	var _cret *C.GstReferenceTimestampMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	if reference != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gst_buffer_get_reference_timestamp_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(reference)

	var _referenceTimestampMeta *ReferenceTimestampMeta // out

	if _cret != nil {
		_referenceTimestampMeta = (*ReferenceTimestampMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _referenceTimestampMeta
}

// Size gets the total size of the memory blocks in buffer.
//
// The function returns the following values:
//
//    - gsize: total size of the memory blocks in buffer.
//
func (buffer *Buffer) Size() uint {
	var _arg0 *C.GstBuffer // out
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_size(_arg0)
	runtime.KeepAlive(buffer)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Sizes gets the total size of the memory blocks in buffer.
//
// When not NULL, offset will contain the offset of the data in the first memory
// block in buffer and maxsize will contain the sum of the size and offset and
// the amount of extra padding on the last memory block. offset and maxsize can
// be used to resize the buffer memory blocks with gst_buffer_resize().
//
// The function returns the following values:
//
//    - offset (optional): pointer to the offset.
//    - maxsize (optional): pointer to the maxsize.
//    - gsize: total size of the memory blocks in buffer.
//
func (buffer *Buffer) Sizes() (offset uint, maxsize uint, gsize uint) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // in
	var _arg2 C.gsize      // in
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_sizes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _offset uint  // out
	var _maxsize uint // out
	var _gsize uint   // out

	_offset = uint(_arg1)
	_maxsize = uint(_arg2)
	_gsize = uint(_cret)

	return _offset, _maxsize, _gsize
}

// SizesRange gets the total size of length memory blocks stating from idx in
// buffer.
//
// When not NULL, offset will contain the offset of the data in the memory block
// in buffer at idx and maxsize will contain the sum of the size and offset and
// the amount of extra padding on the memory block at idx + length -1. offset
// and maxsize can be used to resize the buffer memory blocks with
// gst_buffer_resize_range().
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length.
//
// The function returns the following values:
//
//    - offset (optional): pointer to the offset.
//    - maxsize (optional): pointer to the maxsize.
//    - gsize: total size of length memory blocks starting at idx in buffer.
//
func (buffer *Buffer) SizesRange(idx uint, length int) (offset uint, maxsize uint, gsize uint) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _arg3 C.gsize      // in
	var _arg4 C.gsize      // in
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	_cret = C.gst_buffer_get_sizes_range(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)

	var _offset uint  // out
	var _maxsize uint // out
	var _gsize uint   // out

	_offset = uint(_arg3)
	_maxsize = uint(_arg4)
	_gsize = uint(_cret)

	return _offset, _maxsize, _gsize
}

// HasFlags gives the status of a specific flag on a buffer.
//
// The function takes the following parameters:
//
//    - flags flag to check.
//
// The function returns the following values:
//
//    - ok: TRUE if all flags in flags are found on buffer.
//
func (buffer *Buffer) HasFlags(flags BufferFlags) bool {
	var _arg0 *C.GstBuffer     // out
	var _arg1 C.GstBufferFlags // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GstBufferFlags(flags)

	_cret = C.gst_buffer_has_flags(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMemory inserts the memory block mem into buffer at idx. This function
// takes ownership of mem and thus doesn't increase its refcount.
//
// Only gst_buffer_get_max_memory() can be added to a buffer. If more memory is
// added, existing memory blocks will automatically be merged to make room for
// the new memory.
//
// The function takes the following parameters:
//
//    - idx: index to add the memory at, or -1 to append it to the end.
//    - mem: Memory.
//
func (buffer *Buffer) InsertMemory(idx int, mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gint       // out
	var _arg2 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gint(idx)
	_arg2 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_insert_memory(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(mem)
}

// IsAllMemoryWritable checks if all memory blocks in buffer are writable.
//
// Note that this function does not check if buffer is writable, use
// gst_buffer_is_writable() to check that if needed.
//
// The function returns the following values:
//
//    - ok: TRUE if all memory blocks in buffer are writable.
//
func (buffer *Buffer) IsAllMemoryWritable() bool {
	var _arg0 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_is_all_memory_writable(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMemoryRangeWritable checks if length memory blocks in buffer starting from
// idx are writable.
//
// length can be -1 to check all the memory blocks after idx.
//
// Note that this function does not check if buffer is writable, use
// gst_buffer_is_writable() to check that if needed.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length, should not be 0.
//
// The function returns the following values:
//
//    - ok: TRUE if the memory range is writable.
//
func (buffer *Buffer) IsMemoryRangeWritable(idx uint, length int) bool {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	_cret = C.gst_buffer_is_memory_range_writable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Map fills info with the MapInfo of all merged memory blocks in buffer.
//
// flags describe the desired access of the memory. When flags is T_MAP_WRITE,
// buffer should be writable (as returned from gst_buffer_is_writable()).
//
// When buffer is writable but the memory isn't, a writable copy will
// automatically be created and returned. The readonly copy of the buffer memory
// will then also be replaced with this writable copy.
//
// The memory in info should be unmapped with gst_buffer_unmap() after usage.
//
// The function takes the following parameters:
//
//    - flags for the mapping.
//
// The function returns the following values:
//
//    - info about the mapping.
//    - ok: TRUE if the map succeeded and info contains valid data.
//
func (buffer *Buffer) Map(flags MapFlags) (*MapInfo, bool) {
	var _arg0 *C.GstBuffer  // out
	var _arg1 C.GstMapInfo  // in
	var _arg2 C.GstMapFlags // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_buffer_map(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _info *MapInfo // out
	var _ok bool       // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// MapRange fills info with the MapInfo of length merged memory blocks starting
// at idx in buffer. When length is -1, all memory blocks starting from idx are
// merged and mapped.
//
// flags describe the desired access of the memory. When flags is T_MAP_WRITE,
// buffer should be writable (as returned from gst_buffer_is_writable()).
//
// When buffer is writable but the memory isn't, a writable copy will
// automatically be created and returned. The readonly copy of the buffer memory
// will then also be replaced with this writable copy.
//
// The memory in info should be unmapped with gst_buffer_unmap() after usage.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length.
//    - flags for the mapping.
//
// The function returns the following values:
//
//    - info about the mapping.
//    - ok: TRUE if the map succeeded and info contains valid data.
//
func (buffer *Buffer) MapRange(idx uint, length int, flags MapFlags) (*MapInfo, bool) {
	var _arg0 *C.GstBuffer  // out
	var _arg1 C.guint       // out
	var _arg2 C.gint        // out
	var _arg3 C.GstMapInfo  // in
	var _arg4 C.GstMapFlags // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)
	_arg4 = C.GstMapFlags(flags)

	_cret = C.gst_buffer_map_range(_arg0, _arg1, _arg2, &_arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
	runtime.KeepAlive(flags)

	var _info *MapInfo // out
	var _ok bool       // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// Memcmp compares size bytes starting from offset in buffer with the memory in
// mem.
//
// The function takes the following parameters:
//
//    - offset in buffer.
//    - mem: memory to compare.
//
// The function returns the following values:
//
//    - gint: 0 if the memory is equal.
//
func (buffer *Buffer) Memcmp(offset uint, mem []byte) int {
	var _arg0 *C.GstBuffer    // out
	var _arg1 C.gsize         // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize
	var _cret C.gint // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg3 = (C.gsize)(len(mem))
	if len(mem) > 0 {
		_arg2 = (C.gconstpointer)(unsafe.Pointer(&mem[0]))
	}

	_cret = C.gst_buffer_memcmp(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(mem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Memset fills buf with size bytes with val starting from offset.
//
// The function takes the following parameters:
//
//    - offset in buffer.
//    - val: value to set.
//    - size to set.
//
// The function returns the following values:
//
//    - gsize: amount of bytes filled. This value can be lower than size when
//      buffer did not contain enough data.
//
func (buffer *Buffer) Memset(offset uint, val byte, size uint) uint {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.guint8     // out
	var _arg3 C.gsize      // out
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg2 = C.guint8(val)
	_arg3 = C.gsize(size)

	_cret = C.gst_buffer_memset(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(val)
	runtime.KeepAlive(size)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// NMemory gets the amount of memory blocks that this buffer has. This amount is
// never larger than what gst_buffer_get_max_memory() returns.
//
// The function returns the following values:
//
//    - guint: number of memory blocks this buffer is made of.
//
func (buffer *Buffer) NMemory() uint {
	var _arg0 *C.GstBuffer // out
	var _cret C.guint      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_n_memory(_arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PeekMemory gets the memory block at idx in buffer. The memory block stays
// valid until the memory block in buffer is removed, replaced or merged,
// typically with any call that modifies the memory in buffer.
//
// The function takes the following parameters:
//
//    - idx: index.
//
// The function returns the following values:
//
//    - memory (optional) at idx.
//
func (buffer *Buffer) PeekMemory(idx uint) *Memory {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_peek_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _memory
}

// PrependMemory prepends the memory block mem to buffer. This function takes
// ownership of mem and thus doesn't increase its refcount.
//
// This function is identical to gst_buffer_insert_memory() with an index of 0.
// See gst_buffer_insert_memory() for more details.
//
// The function takes the following parameters:
//
//    - mem: Memory.
//
func (buffer *Buffer) PrependMemory(mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_prepend_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mem)
}

// RemoveAllMemory removes all the memory blocks in buffer.
func (buffer *Buffer) RemoveAllMemory() {
	var _arg0 *C.GstBuffer // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C.gst_buffer_remove_all_memory(_arg0)
	runtime.KeepAlive(buffer)
}

// RemoveMemory removes the memory block in b at index i.
//
// The function takes the following parameters:
//
//    - idx: index.
//
func (buffer *Buffer) RemoveMemory(idx uint) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)

	C.gst_buffer_remove_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
}

// RemoveMemoryRange removes length memory blocks in buffer starting from idx.
//
// length can be -1, in which case all memory starting from idx is removed.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length.
//
func (buffer *Buffer) RemoveMemoryRange(idx uint, length int) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	C.gst_buffer_remove_memory_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
}

// RemoveMeta removes the metadata for meta on buffer.
//
// The function takes the following parameters:
//
//    - meta: Meta.
//
// The function returns the following values:
//
//    - ok: TRUE if the metadata existed and was removed, FALSE if no such
//      metadata was on buffer.
//
func (buffer *Buffer) RemoveMeta(meta *Meta) bool {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMeta   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_buffer_remove_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(meta)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReplaceAllMemory replaces all memory in buffer with mem.
//
// The function takes the following parameters:
//
//    - mem: Memory.
//
func (buffer *Buffer) ReplaceAllMemory(mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_replace_all_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mem)
}

// ReplaceMemory replaces the memory block at index idx in buffer with mem.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - mem: Memory.
//
func (buffer *Buffer) ReplaceMemory(idx uint, mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_replace_memory(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(mem)
}

// ReplaceMemoryRange replaces length memory blocks in buffer starting at idx
// with mem.
//
// If length is -1, all memory starting from idx will be removed and replaced
// with mem.
//
// buffer should be writable.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length, should not be 0.
//    - mem: Memory.
//
func (buffer *Buffer) ReplaceMemoryRange(idx uint, length int, mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _arg3 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)
	_arg3 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_replace_memory_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
	runtime.KeepAlive(mem)
}

// Resize sets the offset and total size of the memory blocks in buffer.
//
// The function takes the following parameters:
//
//    - offset adjustment.
//    - size: new size or -1 to just adjust the offset.
//
func (buffer *Buffer) Resize(offset int, size int) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gssize     // out
	var _arg2 C.gssize     // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gssize(size)

	C.gst_buffer_resize(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)
}

// ResizeRange sets the total size of the length memory blocks starting at idx
// in buffer.
//
// The function takes the following parameters:
//
//    - idx: index.
//    - length: length.
//    - offset adjustment.
//    - size: new size or -1 to just adjust the offset.
//
// The function returns the following values:
//
//    - ok: TRUE if resizing succeeded, FALSE otherwise.
//
func (buffer *Buffer) ResizeRange(idx uint, length int, offset int, size int) bool {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _arg3 C.gssize     // out
	var _arg4 C.gssize     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)
	_arg3 = C.gssize(offset)
	_arg4 = C.gssize(size)

	_cret = C.gst_buffer_resize_range(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlags sets one or more buffer flags on a buffer.
//
// The function takes the following parameters:
//
//    - flags to set.
//
// The function returns the following values:
//
//    - ok: TRUE if flags were successfully set on buffer.
//
func (buffer *Buffer) SetFlags(flags BufferFlags) bool {
	var _arg0 *C.GstBuffer     // out
	var _arg1 C.GstBufferFlags // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GstBufferFlags(flags)

	_cret = C.gst_buffer_set_flags(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSize sets the total size of the memory blocks in buffer.
//
// The function takes the following parameters:
//
//    - size: new size.
//
func (buffer *Buffer) SetSize(size int) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gssize     // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gssize(size)

	C.gst_buffer_set_size(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(size)
}

// Unmap releases the memory previously mapped with gst_buffer_map().
//
// The function takes the following parameters:
//
//    - info: MapInfo.
//
func (buffer *Buffer) Unmap(info *MapInfo) {
	var _arg0 *C.GstBuffer  // out
	var _arg1 *C.GstMapInfo // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMapInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.gst_buffer_unmap(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)
}

// UnsetFlags clears one or more buffer flags.
//
// The function takes the following parameters:
//
//    - flags to clear.
//
// The function returns the following values:
//
//    - ok: true if flags is successfully cleared from buffer.
//
func (buffer *Buffer) UnsetFlags(flags BufferFlags) bool {
	var _arg0 *C.GstBuffer     // out
	var _arg1 C.GstBufferFlags // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GstBufferFlags(flags)

	_cret = C.gst_buffer_unset_flags(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (b *Buffer) SetPts(dur ClockTime) {
	b.native.pts = C.ulong(dur)
}
