// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_IteratorForEachFunction(GValue*, gpointer);
// extern gboolean _gotk4_gst1_IteratorFoldFunction(GValue*, GValue*, gpointer);
import "C"

// GType values.
var (
	GTypeIteratorItem   = coreglib.Type(C.gst_iterator_item_get_type())
	GTypeIteratorResult = coreglib.Type(C.gst_iterator_result_get_type())
	GTypeIterator       = coreglib.Type(C.gst_iterator_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIteratorItem, F: marshalIteratorItem},
		coreglib.TypeMarshaler{T: GTypeIteratorResult, F: marshalIteratorResult},
		coreglib.TypeMarshaler{T: GTypeIterator, F: marshalIterator},
	})
}

// IteratorItem: result of a IteratorItemFunction.
type IteratorItem C.gint

const (
	// IteratorItemSkip: skip this item.
	IteratorItemSkip IteratorItem = iota
	// IteratorItemPass: return item.
	IteratorItemPass
	// IteratorItemEnd: stop after this item.
	IteratorItemEnd
)

func marshalIteratorItem(p uintptr) (interface{}, error) {
	return IteratorItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IteratorItem.
func (i IteratorItem) String() string {
	switch i {
	case IteratorItemSkip:
		return "Skip"
	case IteratorItemPass:
		return "Pass"
	case IteratorItemEnd:
		return "End"
	default:
		return fmt.Sprintf("IteratorItem(%d)", i)
	}
}

// IteratorResult: result of gst_iterator_next().
type IteratorResult C.gint

const (
	// IteratorDone: no more items in the iterator.
	IteratorDone IteratorResult = iota
	// IteratorOK: item was retrieved.
	IteratorOK
	// IteratorResync: datastructure changed while iterating.
	IteratorResync
	// IteratorError: error happened.
	IteratorError
)

func marshalIteratorResult(p uintptr) (interface{}, error) {
	return IteratorResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IteratorResult.
func (i IteratorResult) String() string {
	switch i {
	case IteratorDone:
		return "Done"
	case IteratorOK:
		return "OK"
	case IteratorResync:
		return "Resync"
	case IteratorError:
		return "Error"
	default:
		return fmt.Sprintf("IteratorResult(%d)", i)
	}
}

// IteratorFoldFunction: function to be passed to gst_iterator_fold().
type IteratorFoldFunction func(item, ret *coreglib.Value) (ok bool)

// IteratorForEachFunction: function that is called by gst_iterator_foreach()
// for every element.
type IteratorForEachFunction func(item *coreglib.Value)

// Iterator is used to retrieve multiple objects from another object in a
// threadsafe way.
//
// Various GStreamer objects provide access to their internal structures using
// an iterator.
//
// Note that if calling a GstIterator function results in your code receiving a
// refcounted object (with, say, g_value_get_object()), the refcount for that
// object will not be increased. Your code is responsible for taking a reference
// if it wants to continue using it later.
//
// The basic use pattern of an iterator is as follows:
//
//    GstIterator *it = _get_iterator(object);
//    GValue item = G_VALUE_INIT;
//    done = FALSE;
//    while (!done) {
//      switch (gst_iterator_next (it, &item)) {
//        case GST_ITERATOR_OK:
//          ...get/use/change item here...
//          g_value_reset (&item);
//          break;
//        case GST_ITERATOR_RESYNC:
//          ...rollback changes to items...
//          gst_iterator_resync (it);
//          break;
//        case GST_ITERATOR_ERROR:
//          ...wrong parameters were given...
//          done = TRUE;
//          break;
//        case GST_ITERATOR_DONE:
//          done = TRUE;
//          break;
//      }
//    }
//    g_value_unset (&item);
//    gst_iterator_free (it);
//
// An instance of this type is always passed by reference.
type Iterator struct {
	*iterator
}

// iterator is the struct that's finalized.
type iterator struct {
	native *C.GstIterator
}

func marshalIterator(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Iterator{&iterator{(*C.GstIterator)(b)}}, nil
}

// NewIteratorSingle constructs a struct Iterator.
func NewIteratorSingle(typ coreglib.Type, object *coreglib.Value) *Iterator {
	var _arg1 C.GType        // out
	var _arg2 *C.GValue      // out
	var _cret *C.GstIterator // in

	_arg1 = C.GType(typ)
	_arg2 = (*C.GValue)(unsafe.Pointer(object.Native()))

	_cret = C.gst_iterator_new_single(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(object)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// Copy the iterator and its state.
//
// The function returns the following values:
//
//    - iterator: new copy of it.
//
func (it *Iterator) Copy() *Iterator {
	var _arg0 *C.GstIterator // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))

	_cret = C.gst_iterator_copy(_arg0)
	runtime.KeepAlive(it)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// Fold folds func over the elements of iter. That is to say, func will be
// called as func (object, ret, user_data) for each object in it. The normal use
// of this procedure is to accumulate the results of operating on the objects in
// ret.
//
// This procedure can be used (and is used internally) to implement the
// gst_iterator_foreach() and gst_iterator_find_custom() operations.
//
// The fold will proceed as long as func returns TRUE. When the iterator has no
// more arguments, GST_ITERATOR_DONE will be returned. If func returns FALSE,
// the fold will stop, and GST_ITERATOR_OK will be returned. Errors or resyncs
// will cause fold to return GST_ITERATOR_ERROR or GST_ITERATOR_RESYNC as
// appropriate.
//
// The iterator will not be freed.
//
// The function takes the following parameters:
//
//    - fn: fold function.
//    - ret: seed value passed to the fold function.
//
// The function returns the following values:
//
//    - iteratorResult as described above.
//
//      MT safe.
//
func (it *Iterator) Fold(fn IteratorFoldFunction, ret *coreglib.Value) IteratorResult {
	var _arg0 *C.GstIterator            // out
	var _arg1 C.GstIteratorFoldFunction // out
	var _arg3 C.gpointer
	var _arg2 *C.GValue           // out
	var _cret C.GstIteratorResult // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_IteratorFoldFunction)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))
	_arg2 = (*C.GValue)(unsafe.Pointer(ret.Native()))

	_cret = C.gst_iterator_fold(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(it)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(ret)

	var _iteratorResult IteratorResult // out

	_iteratorResult = IteratorResult(_cret)

	return _iteratorResult
}

// ForEach: iterate over all element of it and call the given function func for
// each element.
//
// The function takes the following parameters:
//
//    - fn: function to call for each element.
//
// The function returns the following values:
//
//    - iteratorResult: result call to gst_iterator_fold(). The iterator will not
//      be freed.
//
//      MT safe.
//
func (it *Iterator) ForEach(fn IteratorForEachFunction) IteratorResult {
	var _arg0 *C.GstIterator               // out
	var _arg1 C.GstIteratorForeachFunction // out
	var _arg2 C.gpointer
	var _cret C.GstIteratorResult // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_IteratorForEachFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_iterator_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(it)
	runtime.KeepAlive(fn)

	var _iteratorResult IteratorResult // out

	_iteratorResult = IteratorResult(_cret)

	return _iteratorResult
}

// Next: get the next item from the iterator in elem.
//
// Only when this function returns GST_ITERATOR_OK, elem will contain a valid
// value. elem must have been initialized to the type of the iterator or
// initialized to zeroes with g_value_unset(). The caller is responsible for
// unsetting or resetting elem with g_value_unset() or g_value_reset() after
// usage.
//
// When this function returns GST_ITERATOR_DONE, no more elements can be
// retrieved from it.
//
// A return value of GST_ITERATOR_RESYNC indicates that the element list was
// concurrently updated. The user of it should call gst_iterator_resync() to get
// the newly updated list.
//
// A return value of GST_ITERATOR_ERROR indicates an unrecoverable fatal error.
//
// The function returns the following values:
//
//    - elem: pointer to hold next element.
//    - iteratorResult: result of the iteration. Unset elem after usage.
//
//      MT safe.
//
func (it *Iterator) Next() (coreglib.Value, IteratorResult) {
	var _arg0 *C.GstIterator      // out
	var _arg1 C.GValue            // in
	var _cret C.GstIteratorResult // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))

	_cret = C.gst_iterator_next(_arg0, &_arg1)
	runtime.KeepAlive(it)

	var _elem coreglib.Value           // out
	var _iteratorResult IteratorResult // out

	_elem = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	_iteratorResult = IteratorResult(_cret)

	return _elem, _iteratorResult
}

// Push pushes other iterator onto it. All calls performed on it are forwarded
// to other. If other returns GST_ITERATOR_DONE, it is popped again and calls
// are handled by it again.
//
// This function is mainly used by objects implementing the iterator next
// function to recurse into substructures.
//
// When gst_iterator_resync() is called on it, other will automatically be
// popped.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - other to push.
//
func (it *Iterator) Push(other *Iterator) {
	var _arg0 *C.GstIterator // out
	var _arg1 *C.GstIterator // out

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))
	_arg1 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(other)))

	C.gst_iterator_push(_arg0, _arg1)
	runtime.KeepAlive(it)
	runtime.KeepAlive(other)
}

// Resync the iterator. this function is mostly called after gst_iterator_next()
// returned GST_ITERATOR_RESYNC.
//
// When an iterator was pushed on it, it will automatically be popped again with
// this function.
//
// MT safe.
func (it *Iterator) Resync() {
	var _arg0 *C.GstIterator // out

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))

	C.gst_iterator_resync(_arg0)
	runtime.KeepAlive(it)
}
