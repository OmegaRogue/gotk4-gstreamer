// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_Element_ConnectPadRemoved(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_Element_ConnectPadAdded(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_Element_ConnectNoMorePads(gpointer, guintptr);
// extern void _gotk4_gst1_ElementClass_state_changed(GstElement*, GstState, GstState, GstState);
// extern void _gotk4_gst1_ElementClass_set_context(GstElement*, GstContext*);
// extern void _gotk4_gst1_ElementClass_set_bus(GstElement*, GstBus*);
// extern void _gotk4_gst1_ElementClass_release_pad(GstElement*, GstPad*);
// extern void _gotk4_gst1_ElementClass_pad_removed(GstElement*, GstPad*);
// extern void _gotk4_gst1_ElementClass_pad_added(GstElement*, GstPad*);
// extern void _gotk4_gst1_ElementClass_no_more_pads(GstElement*);
// extern void _gotk4_gst1_ElementCallAsyncFunc(GstElement*, gpointer);
// extern gboolean _gotk4_gst1_ElementForEachPadFunc(GstElement*, GstPad*, gpointer);
// extern gboolean _gotk4_gst1_ElementClass_set_clock(GstElement*, GstClock*);
// extern gboolean _gotk4_gst1_ElementClass_send_event(GstElement*, GstEvent*);
// extern gboolean _gotk4_gst1_ElementClass_query(GstElement*, GstQuery*);
// extern gboolean _gotk4_gst1_ElementClass_post_message(GstElement*, GstMessage*);
// extern GstStateChangeReturn _gotk4_gst1_ElementClass_set_state(GstElement*, GstState);
// extern GstStateChangeReturn _gotk4_gst1_ElementClass_get_state(GstElement*, GstState*, GstState*, GstClockTime);
// extern GstStateChangeReturn _gotk4_gst1_ElementClass_change_state(GstElement*, GstStateChange);
// extern GstClock* _gotk4_gst1_ElementClass_provide_clock(GstElement*);
// GstClock* _gotk4_gst1_Element_virtual_provide_clock(void* fnptr, GstElement* arg0) {
//   return ((GstClock* (*)(GstElement*))(fnptr))(arg0);
// };
// GstPad* _gotk4_gst1_Element_virtual_request_new_pad(void* fnptr, GstElement* arg0, GstPadTemplate* arg1, gchar* arg2, GstCaps* arg3) {
//   return ((GstPad* (*)(GstElement*, GstPadTemplate*, gchar*, GstCaps*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstStateChangeReturn _gotk4_gst1_Element_virtual_change_state(void* fnptr, GstElement* arg0, GstStateChange arg1) {
//   return ((GstStateChangeReturn (*)(GstElement*, GstStateChange))(fnptr))(arg0, arg1);
// };
// GstStateChangeReturn _gotk4_gst1_Element_virtual_get_state(void* fnptr, GstElement* arg0, GstState* arg1, GstState* arg2, GstClockTime arg3) {
//   return ((GstStateChangeReturn (*)(GstElement*, GstState*, GstState*, GstClockTime))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstStateChangeReturn _gotk4_gst1_Element_virtual_set_state(void* fnptr, GstElement* arg0, GstState arg1) {
//   return ((GstStateChangeReturn (*)(GstElement*, GstState))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_post_message(void* fnptr, GstElement* arg0, GstMessage* arg1) {
//   return ((gboolean (*)(GstElement*, GstMessage*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_query(void* fnptr, GstElement* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstElement*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_send_event(void* fnptr, GstElement* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstElement*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_set_clock(void* fnptr, GstElement* arg0, GstClock* arg1) {
//   return ((gboolean (*)(GstElement*, GstClock*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_no_more_pads(void* fnptr, GstElement* arg0) {
//   ((void (*)(GstElement*))(fnptr))(arg0);
// };
// void _gotk4_gst1_Element_virtual_pad_added(void* fnptr, GstElement* arg0, GstPad* arg1) {
//   ((void (*)(GstElement*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_pad_removed(void* fnptr, GstElement* arg0, GstPad* arg1) {
//   ((void (*)(GstElement*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_release_pad(void* fnptr, GstElement* arg0, GstPad* arg1) {
//   ((void (*)(GstElement*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_set_bus(void* fnptr, GstElement* arg0, GstBus* arg1) {
//   ((void (*)(GstElement*, GstBus*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_set_context(void* fnptr, GstElement* arg0, GstContext* arg1) {
//   ((void (*)(GstElement*, GstContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_state_changed(void* fnptr, GstElement* arg0, GstState arg1, GstState arg2, GstState arg3) {
//   ((void (*)(GstElement*, GstState, GstState, GstState))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeState             = coreglib.Type(C.gst_state_get_type())
	GTypeStateChange       = coreglib.Type(C.gst_state_change_get_type())
	GTypeStateChangeReturn = coreglib.Type(C.gst_state_change_return_get_type())
	GTypeElementFlags      = coreglib.Type(C.gst_element_flags_get_type())
	GTypeElement           = coreglib.Type(C.gst_element_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeState, F: marshalState},
		coreglib.TypeMarshaler{T: GTypeStateChange, F: marshalStateChange},
		coreglib.TypeMarshaler{T: GTypeStateChangeReturn, F: marshalStateChangeReturn},
		coreglib.TypeMarshaler{T: GTypeElementFlags, F: marshalElementFlags},
		coreglib.TypeMarshaler{T: GTypeElement, F: marshalElement},
	})
}

// State: possible states an element can be in. States can be changed using
// gst_element_set_state() and checked using gst_element_get_state().
type State C.gint

const (
	// StateVoidPending: no pending state.
	StateVoidPending State = iota
	// StateNull: NULL state or initial state of an element.
	StateNull
	// StateReady: element is ready to go to PAUSED.
	StateReady
	// StatePaused: element is PAUSED, it is ready to accept and process data.
	// Sink elements however only accept one buffer and then block.
	StatePaused
	// StatePlaying: element is PLAYING, the Clock is running and the data is
	// flowing.
	StatePlaying
)

func marshalState(p uintptr) (interface{}, error) {
	return State(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for State.
func (s State) String() string {
	switch s {
	case StateVoidPending:
		return "VoidPending"
	case StateNull:
		return "Null"
	case StateReady:
		return "Ready"
	case StatePaused:
		return "Paused"
	case StatePlaying:
		return "Playing"
	default:
		return fmt.Sprintf("State(%d)", s)
	}
}

// StateChange: these are the different state changes an element goes through.
// GST_STATE_NULL &rArr; GST_STATE_PLAYING is called an upwards state change and
// GST_STATE_PLAYING &rArr; GST_STATE_NULL a downwards state change.
type StateChange C.gint

const (
	// StateChangeNullToReady: state change from NULL to READY. * The element
	// must check if the resources it needs are available. Device sinks and
	// -sources typically try to probe the device to constrain their caps. * The
	// element opens the device (in case feature need to be probed).
	StateChangeNullToReady StateChange = 10
	// StateChangeReadyToPaused: state change from READY to PAUSED. * The
	// element pads are activated in order to receive data in PAUSED. Streaming
	// threads are started. * Some elements might need to return
	// GST_STATE_CHANGE_ASYNC and complete the state change when they have
	// enough information. It is a requirement for sinks to return
	// GST_STATE_CHANGE_ASYNC and complete the state change when they receive
	// the first buffer or GST_EVENT_EOS (preroll). Sinks also block the
	// dataflow when in PAUSED. * A pipeline resets the running_time to 0. *
	// Live sources return GST_STATE_CHANGE_NO_PREROLL and don't generate data.
	StateChangeReadyToPaused StateChange = 19
	// StateChangePausedToPlaying: state change from PAUSED to PLAYING. * Most
	// elements ignore this state change. * The pipeline selects a Clock and
	// distributes this to all the children before setting them to PLAYING. This
	// means that it is only allowed to synchronize on the Clock in the PLAYING
	// state. * The pipeline uses the Clock and the running_time to calculate
	// the base_time. The base_time is distributed to all children when
	// performing the state change. * Sink elements stop blocking on the preroll
	// buffer or event and start rendering the data. * Sinks can post
	// GST_MESSAGE_EOS in the PLAYING state. It is not allowed to post
	// GST_MESSAGE_EOS when not in the PLAYING state. * While streaming in
	// PAUSED or PLAYING elements can create and remove sometimes pads. * Live
	// sources start generating data and return GST_STATE_CHANGE_SUCCESS.
	StateChangePausedToPlaying StateChange = 28
	// StateChangePlayingToPaused: state change from PLAYING to PAUSED. * Most
	// elements ignore this state change. * The pipeline calculates the
	// running_time based on the last selected Clock and the base_time. It
	// stores this information to continue playback when going back to the
	// PLAYING state. * Sinks unblock any Clock wait calls. * When a sink does
	// not have a pending buffer to play, it returns T_STATE_CHANGE_ASYNC from
	// this state change and completes the state change when it receives a new
	// buffer or an GST_EVENT_EOS. * Any queued GST_MESSAGE_EOS items are
	// removed since they will be reposted when going back to the PLAYING state.
	// The EOS messages are queued in Bin containers. * Live sources stop
	// generating data and return GST_STATE_CHANGE_NO_PREROLL.
	StateChangePlayingToPaused StateChange = 35
	// StateChangePausedToReady: state change from PAUSED to READY. * Sinks
	// unblock any waits in the preroll. * Elements unblock any waits on devices
	// * Chain or get_range functions return GST_FLOW_FLUSHING. * The element
	// pads are deactivated so that streaming becomes impossible and all
	// streaming threads are stopped. * The sink forgets all negotiated formats
	// * Elements remove all sometimes pads.
	StateChangePausedToReady StateChange = 26
	// StateChangeReadyToNull: state change from READY to NULL. * Elements close
	// devices * Elements reset any internal state.
	StateChangeReadyToNull StateChange = 17
	// StateChangeNullToNull: state change from NULL to NULL. (Since: 1.14).
	StateChangeNullToNull StateChange = 9
	// StateChangeReadyToReady: state change from READY to READY, This might
	// happen when going to PAUSED asynchronously failed, in that case elements
	// should make sure they are in a proper, coherent READY state. (Since:
	// 1.14).
	StateChangeReadyToReady StateChange = 18
	// StateChangePausedToPaused: state change from PAUSED to PAUSED. This might
	// happen when elements were in PLAYING state and 'lost state', they should
	// make sure to go back to real 'PAUSED' state (prerolling for example).
	// (Since: 1.14).
	StateChangePausedToPaused StateChange = 27
	// StateChangePlayingToPlaying: state change from PLAYING to PLAYING.
	// (Since: 1.14).
	StateChangePlayingToPlaying StateChange = 36
)

func marshalStateChange(p uintptr) (interface{}, error) {
	return StateChange(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StateChange.
func (s StateChange) String() string {
	switch s {
	case StateChangeNullToReady:
		return "NullToReady"
	case StateChangeReadyToPaused:
		return "ReadyToPaused"
	case StateChangePausedToPlaying:
		return "PausedToPlaying"
	case StateChangePlayingToPaused:
		return "PlayingToPaused"
	case StateChangePausedToReady:
		return "PausedToReady"
	case StateChangeReadyToNull:
		return "ReadyToNull"
	case StateChangeNullToNull:
		return "NullToNull"
	case StateChangeReadyToReady:
		return "ReadyToReady"
	case StateChangePausedToPaused:
		return "PausedToPaused"
	case StateChangePlayingToPlaying:
		return "PlayingToPlaying"
	default:
		return fmt.Sprintf("StateChange(%d)", s)
	}
}

// StateChangeReturn: possible return values from a state change function such
// as gst_element_set_state(). Only GST_STATE_CHANGE_FAILURE is a real failure.
type StateChangeReturn C.gint

const (
	// StateChangeFailure: state change failed.
	StateChangeFailure StateChangeReturn = iota
	// StateChangeSuccess: state change succeeded.
	StateChangeSuccess
	// StateChangeAsync: state change will happen asynchronously.
	StateChangeAsync
	// StateChangeNoPreroll: state change succeeded but the element cannot
	// produce data in GST_STATE_PAUSED. This typically happens with live
	// sources.
	StateChangeNoPreroll
)

func marshalStateChangeReturn(p uintptr) (interface{}, error) {
	return StateChangeReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StateChangeReturn.
func (s StateChangeReturn) String() string {
	switch s {
	case StateChangeFailure:
		return "Failure"
	case StateChangeSuccess:
		return "Success"
	case StateChangeAsync:
		return "Async"
	case StateChangeNoPreroll:
		return "NoPreroll"
	default:
		return fmt.Sprintf("StateChangeReturn(%d)", s)
	}
}

// ElementFlags: standard flags that an element may have.
type ElementFlags C.guint

const (
	// ElementFlagLockedState: ignore state changes from parent.
	ElementFlagLockedState ElementFlags = 0b10000
	// ElementFlagSink: element is a sink.
	ElementFlagSink ElementFlags = 0b100000
	// ElementFlagSource: element is a source.
	ElementFlagSource ElementFlags = 0b1000000
	// ElementFlagProvideClock: element can provide a clock.
	ElementFlagProvideClock ElementFlags = 0b10000000
	// ElementFlagRequireClock: element requires a clock.
	ElementFlagRequireClock ElementFlags = 0b100000000
	// ElementFlagIndexable: element can use an index.
	ElementFlagIndexable ElementFlags = 0b1000000000
	// ElementFlagLast: offset to define more flags.
	ElementFlagLast ElementFlags = 0b100000000000000
)

func marshalElementFlags(p uintptr) (interface{}, error) {
	return ElementFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ElementFlags.
func (e ElementFlags) String() string {
	if e == 0 {
		return "ElementFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(141)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case ElementFlagLockedState:
			builder.WriteString("LockedState|")
		case ElementFlagSink:
			builder.WriteString("Sink|")
		case ElementFlagSource:
			builder.WriteString("Source|")
		case ElementFlagProvideClock:
			builder.WriteString("ProvideClock|")
		case ElementFlagRequireClock:
			builder.WriteString("RequireClock|")
		case ElementFlagIndexable:
			builder.WriteString("Indexable|")
		case ElementFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("ElementFlags(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e ElementFlags) Has(other ElementFlags) bool {
	return (e & other) == other
}

// ElementCallAsyncFunc: callback prototype used in #gst_element_call_async.
type ElementCallAsyncFunc func(element Elementer)

// ElementOverrides contains methods that are overridable.
type ElementOverrides struct {
	// ChangeState: perform transition on element.
	//
	// This function must be called with STATE_LOCK held and is mainly used
	// internally.
	//
	// The function takes the following parameters:
	//
	//    - transition: requested transition.
	//
	// The function returns the following values:
	//
	//    - stateChangeReturn of the state transition.
	//
	ChangeState func(transition StateChange) StateChangeReturn
	// State gets the state of the element.
	//
	// For elements that performed an ASYNC state change, as reported by
	// gst_element_set_state(), this function will block up to the specified
	// timeout value for the state change to complete. If the element completes
	// the state change or goes into an error, this function returns immediately
	// with a return value of GST_STATE_CHANGE_SUCCESS or
	// GST_STATE_CHANGE_FAILURE respectively.
	//
	// For elements that did not return GST_STATE_CHANGE_ASYNC, this function
	// returns the current and pending state immediately.
	//
	// This function returns GST_STATE_CHANGE_NO_PREROLL if the element
	// successfully changed its state but is not able to provide data yet. This
	// mostly happens for live sources that only produce data in
	// GST_STATE_PLAYING. While the state change return is equivalent to
	// GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal
	// that some sink elements might not be able to complete their state change
	// because an element is not producing data to complete the preroll. When
	// setting the element to playing, the preroll will complete and playback
	// will start.
	//
	// The function takes the following parameters:
	//
	//    - timeout to specify the timeout for an async state change or
	//      GST_CLOCK_TIME_NONE for infinite timeout.
	//
	// The function returns the following values:
	//
	//    - state (optional): pointer to State to hold the state. Can be NULL.
	//    - pending (optional): pointer to State to hold the pending state. Can
	//      be NULL.
	//    - stateChangeReturn: GST_STATE_CHANGE_SUCCESS if the element has no
	//      more pending state and the last state change succeeded,
	//      GST_STATE_CHANGE_ASYNC if the element is still performing a state
	//      change or GST_STATE_CHANGE_FAILURE if the last state change failed.
	//
	//      MT safe.
	//
	State func(timeout ClockTime) (state, pending State, stateChangeReturn StateChangeReturn)
	// NoMorePads: use this function to signal that the element does not expect
	// any more pads to show up in the current pipeline. This function should be
	// called whenever pads have been added by the element itself. Elements with
	// T_PAD_SOMETIMES pad templates use this in combination with autopluggers
	// to figure out that the element is done initializing its pads.
	//
	// This function emits the Element::no-more-pads signal.
	//
	// MT safe.
	NoMorePads func()
	// The function takes the following parameters:
	//
	PadAdded func(pad *Pad)
	// The function takes the following parameters:
	//
	PadRemoved func(pad *Pad)
	// PostMessage: post a message on the element's Bus. This function takes
	// ownership of the message; if you want to access the message after this
	// call, you should add an additional reference before calling.
	//
	// The function takes the following parameters:
	//
	//    - message to post.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the message was successfully posted. The function returns
	//      FALSE if the element did not have a bus.
	//
	//      MT safe.
	//
	PostMessage func(message *Message) bool
	// ProvideClock: get the clock provided by the given element. > An element
	// is only required to provide a clock in the PAUSED > state. Some elements
	// can provide a clock in other states.
	//
	// The function returns the following values:
	//
	//    - clock (optional): gstClock provided by the element or NULL if no
	//      clock could be provided. Unref after usage.
	//
	//      MT safe.
	//
	ProvideClock func() Clocker
	// Query performs a query on the given element.
	//
	// For elements that don't implement a query handler, this function forwards
	// the query to a random srcpad or to the peer of a random linked sinkpad of
	// this element.
	//
	// Please note that some queries might need a running pipeline to work.
	//
	// The function takes the following parameters:
	//
	//    - query: Query.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the query could be performed.
	//
	//      MT safe.
	//
	Query func(query *Query) bool
	// The function takes the following parameters:
	//
	ReleasePad func(pad *Pad)
	// SendEvent sends an event to an element. If the element doesn't implement
	// an event handler, the event will be pushed on a random linked sink pad
	// for downstream events or a random linked source pad for upstream events.
	//
	// This function takes ownership of the provided event so you should
	// gst_event_ref() it if you want to reuse the event after this call.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//    - event to send to the element.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the event was handled. Events that trigger a preroll
	//      (such as flushing seeks and steps) will emit GST_MESSAGE_ASYNC_DONE.
	//
	SendEvent func(event *Event) bool
	// SetBus sets the bus of the element. Increases the refcount on the bus.
	// For internal use only, unless you're testing elements.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//    - bus (optional) to set.
	//
	SetBus func(bus *Bus)
	// SetClock sets the clock for the element. This function increases the
	// refcount on the clock. Any previously set clock on the object is
	// unreffed.
	//
	// The function takes the following parameters:
	//
	//    - clock (optional) to set for the element.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the element accepted the clock. An element can refuse a
	//      clock when it, for example, is not able to slave its internal clock
	//      to the clock or when it requires a specific clock to operate.
	//
	//      MT safe.
	//
	SetClock func(clock Clocker) bool
	// SetContext sets the context of the element. Increases the refcount of the
	// context.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//    - context to set.
	//
	SetContext func(context *Context)
	// SetState sets the state of the element. This function will try to set the
	// requested state by going through all the intermediary states and calling
	// the class's state change function for each.
	//
	// This function can return T_STATE_CHANGE_ASYNC, in which case the element
	// will perform the remainder of the state change asynchronously in another
	// thread. An application can use gst_element_get_state() to wait for the
	// completion of the state change or it can wait for a
	// GST_MESSAGE_ASYNC_DONE or GST_MESSAGE_STATE_CHANGED on the bus.
	//
	// State changes to GST_STATE_READY or GST_STATE_NULL never return
	// T_STATE_CHANGE_ASYNC.
	//
	// The function takes the following parameters:
	//
	//    - state element's new State.
	//
	// The function returns the following values:
	//
	//    - stateChangeReturn: result of the state change using
	//      StateChangeReturn.
	//
	//      MT safe.
	//
	SetState func(state State) StateChangeReturn
	// The function takes the following parameters:
	//
	//    - oldstate
	//    - newstate
	//    - pending
	//
	StateChanged func(oldstate, newstate, pending State)
}

func defaultElementOverrides(v *Element) ElementOverrides {
	return ElementOverrides{
		ChangeState:  v.changeState,
		State:        v.state,
		NoMorePads:   v.noMorePads,
		PadAdded:     v.padAdded,
		PadRemoved:   v.padRemoved,
		PostMessage:  v.postMessage,
		ProvideClock: v.provideClock,
		Query:        v.query,
		ReleasePad:   v.releasePad,
		SendEvent:    v.sendEvent,
		SetBus:       v.setBus,
		SetClock:     v.setClock,
		SetContext:   v.setContext,
		SetState:     v.setState,
		StateChanged: v.stateChanged,
	}
}

// Element is the abstract base class needed to construct an element that can be
// used in a GStreamer pipeline. Please refer to the plugin writers guide for
// more information on creating Element subclasses.
//
// The name of a Element can be get with gst_element_get_name() and set with
// gst_element_set_name(). For speed, GST_ELEMENT_NAME() can be used in the core
// when using the appropriate locking. Do not use this in plug-ins or
// applications in order to retain ABI compatibility.
//
// Elements can have pads (of the type Pad). These pads link to pads on other
// elements. Buffer flow between these linked pads. A Element has a #GList of
// Pad structures for all their input (or sink) and output (or source) pads.
// Core and plug-in writers can add and remove pads with gst_element_add_pad()
// and gst_element_remove_pad().
//
// An existing pad of an element can be retrieved by name with
// gst_element_get_static_pad(). A new dynamic pad can be created using
// gst_element_request_pad() with a PadTemplate. An iterator of all pads can be
// retrieved with gst_element_iterate_pads().
//
// Elements can be linked through their pads. If the link is straightforward,
// use the gst_element_link() convenience function to link two elements, or
// gst_element_link_many() for more elements in a row. Use
// gst_element_link_filtered() to link two elements constrained by a specified
// set of Caps. For finer control, use gst_element_link_pads() and
// gst_element_link_pads_filtered() to specify the pads to link on each element
// by name.
//
// Each element has a state (see State). You can get and set the state of an
// element with gst_element_get_state() and gst_element_set_state(). Setting a
// state triggers a StateChange. To get a string representation of a State, use
// gst_element_state_get_name().
//
// You can get and set a Clock on an element using gst_element_get_clock() and
// gst_element_set_clock(). Some elements can provide a clock for the pipeline
// if the T_ELEMENT_FLAG_PROVIDE_CLOCK flag is set. With the
// gst_element_provide_clock() method one can retrieve the clock provided by
// such an element. Not all elements require a clock to operate correctly. If
// the T_ELEMENT_FLAG_REQUIRE_CLOCK() flag is set, a clock should be set on the
// element with gst_element_set_clock().
//
// Note that clock selection and distribution is normally handled by the
// toplevel Pipeline so the clock functions are only to be used in very specific
// situations.
type Element struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Element)(nil)
)

// Elementer describes types inherited from class Element.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Elementer interface {
	coreglib.Objector
	baseElement() *Element
}

var _ Elementer = (*Element)(nil)

func init() {
	coreglib.RegisterClassInfo[*Element, *ElementClass, ElementOverrides](
		GTypeElement,
		initElementClass,
		wrapElement,
		defaultElementOverrides,
	)
}

func initElementClass(gclass unsafe.Pointer, overrides ElementOverrides, classInitFunc func(*ElementClass)) {
	pclass := (*C.GstElementClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeElement))))

	if overrides.ChangeState != nil {
		pclass.change_state = (*[0]byte)(C._gotk4_gst1_ElementClass_change_state)
	}

	if overrides.State != nil {
		pclass.get_state = (*[0]byte)(C._gotk4_gst1_ElementClass_get_state)
	}

	if overrides.NoMorePads != nil {
		pclass.no_more_pads = (*[0]byte)(C._gotk4_gst1_ElementClass_no_more_pads)
	}

	if overrides.PadAdded != nil {
		pclass.pad_added = (*[0]byte)(C._gotk4_gst1_ElementClass_pad_added)
	}

	if overrides.PadRemoved != nil {
		pclass.pad_removed = (*[0]byte)(C._gotk4_gst1_ElementClass_pad_removed)
	}

	if overrides.PostMessage != nil {
		pclass.post_message = (*[0]byte)(C._gotk4_gst1_ElementClass_post_message)
	}

	if overrides.ProvideClock != nil {
		pclass.provide_clock = (*[0]byte)(C._gotk4_gst1_ElementClass_provide_clock)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gst1_ElementClass_query)
	}

	if overrides.ReleasePad != nil {
		pclass.release_pad = (*[0]byte)(C._gotk4_gst1_ElementClass_release_pad)
	}

	if overrides.SendEvent != nil {
		pclass.send_event = (*[0]byte)(C._gotk4_gst1_ElementClass_send_event)
	}

	if overrides.SetBus != nil {
		pclass.set_bus = (*[0]byte)(C._gotk4_gst1_ElementClass_set_bus)
	}

	if overrides.SetClock != nil {
		pclass.set_clock = (*[0]byte)(C._gotk4_gst1_ElementClass_set_clock)
	}

	if overrides.SetContext != nil {
		pclass.set_context = (*[0]byte)(C._gotk4_gst1_ElementClass_set_context)
	}

	if overrides.SetState != nil {
		pclass.set_state = (*[0]byte)(C._gotk4_gst1_ElementClass_set_state)
	}

	if overrides.StateChanged != nil {
		pclass.state_changed = (*[0]byte)(C._gotk4_gst1_ElementClass_state_changed)
	}

	if classInitFunc != nil {
		class := (*ElementClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapElement(obj *coreglib.Object) *Element {
	return &Element{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalElement(p uintptr) (interface{}, error) {
	return wrapElement(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (element *Element) baseElement() *Element {
	return element
}

// BaseElement returns the underlying base object.
func BaseElement(obj Elementer) *Element {
	return obj.baseElement()
}

// ConnectNoMorePads: this signals that the element will not generate more
// dynamic pads. Note that this signal will usually be emitted from the context
// of the streaming thread.
func (element *Element) ConnectNoMorePads(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(element, "no-more-pads", false, unsafe.Pointer(C._gotk4_gst1_Element_ConnectNoMorePads), f)
}

// ConnectPadAdded: new Pad has been added to the element. Note that this signal
// will usually be emitted from the context of the streaming thread. Also keep
// in mind that if you add new elements to the pipeline in the signal handler
// you will need to set them to the desired target state with
// gst_element_set_state() or gst_element_sync_state_with_parent().
func (element *Element) ConnectPadAdded(f func(newPad *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(element, "pad-added", false, unsafe.Pointer(C._gotk4_gst1_Element_ConnectPadAdded), f)
}

// ConnectPadRemoved has been removed from the element.
func (element *Element) ConnectPadRemoved(f func(oldPad *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(element, "pad-removed", false, unsafe.Pointer(C._gotk4_gst1_Element_ConnectPadRemoved), f)
}

// AbortState: abort the state change of the element. This function is used by
// elements that do asynchronous state changes and find out something is wrong.
//
// This function should be called with the STATE_LOCK held.
//
// MT safe.
func (element *Element) AbortState() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_abort_state(_arg0)
	runtime.KeepAlive(element)
}

// AddPad adds a pad (link point) to element. pad's parent will be set to
// element; see gst_object_set_parent() for refcounting information.
//
// Pads are automatically activated when added in the PAUSED or PLAYING state.
//
// The pad and the element should be unlocked when calling this function.
//
// This function will emit the Element::pad-added signal on the element.
//
// The function takes the following parameters:
//
//    - pad to add to the element.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad could be added. This function can fail when a pad
//      with the same name already existed or the pad already had another parent.
//
//      MT safe.
//
func (element *Element) AddPad(pad *Pad) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_element_add_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - propertyName (optional): name of property to watch for changes, or NULL
//      to watch all properties.
//    - includeValue: whether to include the new property value in the message.
//
// The function returns the following values:
//
//    - gulong: watch id, which can be used in connection with
//      gst_element_remove_property_notify_watch() to remove the watch again.
//
func (element *Element) AddPropertyDeepNotifyWatch(propertyName string, includeValue bool) uint32 {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret C.gulong      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if propertyName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if includeValue {
		_arg2 = C.TRUE
	}

	_cret = C.gst_element_add_property_deep_notify_watch(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(includeValue)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// The function takes the following parameters:
//
//    - propertyName (optional): name of property to watch for changes, or NULL
//      to watch all properties.
//    - includeValue: whether to include the new property value in the message.
//
// The function returns the following values:
//
//    - gulong: watch id, which can be used in connection with
//      gst_element_remove_property_notify_watch() to remove the watch again.
//
func (element *Element) AddPropertyNotifyWatch(propertyName string, includeValue bool) uint32 {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret C.gulong      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if propertyName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if includeValue {
		_arg2 = C.TRUE
	}

	_cret = C.gst_element_add_property_notify_watch(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(includeValue)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// CallAsync calls func from another thread and passes user_data to it. This is
// to be used for cases when a state change has to be performed from a streaming
// thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
// events.
//
// Calling those functions directly from the streaming thread will cause
// deadlocks in many situations, as they might involve waiting for the streaming
// thread to shut down from this very streaming thread.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - fn: function to call asynchronously from another thread.
//
func (element *Element) CallAsync(fn ElementCallAsyncFunc) {
	var _arg0 *C.GstElement             // out
	var _arg1 C.GstElementCallAsyncFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementCallAsyncFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gst_element_call_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)
}

// ChangeState: perform transition on element.
//
// This function must be called with STATE_LOCK held and is mainly used
// internally.
//
// The function takes the following parameters:
//
//    - transition: requested transition.
//
// The function returns the following values:
//
//    - stateChangeReturn of the state transition.
//
func (element *Element) ChangeState(transition StateChange) StateChangeReturn {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstStateChange       // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstStateChange(transition)

	_cret = C.gst_element_change_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(transition)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// ContinueState: commit the state change of the element and proceed to the next
// pending state if any. This function is used by elements that do asynchronous
// state changes. The core will normally call this method automatically when an
// element returned GST_STATE_CHANGE_SUCCESS from the state change function.
//
// If after calling this method the element still has not reached the pending
// state, the next state change is performed.
//
// This method is used internally and should normally not be called by plugins
// or applications.
//
// This function must be called with STATE_LOCK held.
//
// The function takes the following parameters:
//
//    - ret previous state return value.
//
// The function returns the following values:
//
//    - stateChangeReturn: result of the commit state change.
//
//      MT safe.
//
func (element *Element) ContinueState(ret StateChangeReturn) StateChangeReturn {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstStateChangeReturn // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstStateChangeReturn(ret)

	_cret = C.gst_element_continue_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(ret)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// CreateAllPads creates a pad for each pad template that is always available.
// This function is only useful during object initialization of subclasses of
// Element.
func (element *Element) CreateAllPads() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_create_all_pads(_arg0)
	runtime.KeepAlive(element)
}

// ForEachPad: call func with user_data for each of element's pads. func will be
// called exactly once for each pad that exists at the time of this call, unless
// one of the calls to func returns FALSE in which case we will stop iterating
// pads and return early. If new pads are added or pads are removed while pads
// are being iterated, this will not be taken into account until next time this
// function is used.
//
// The function takes the following parameters:
//
//    - fn: function to call for each pad.
//
// The function returns the following values:
//
//    - ok: FALSE if element had no pads or if one of the calls to func returned
//      FALSE.
//
func (element *Element) ForEachPad(fn ElementForEachPadFunc) bool {
	var _arg0 *C.GstElement              // out
	var _arg1 C.GstElementForeachPadFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementForEachPadFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_element_foreach_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEachSinkPad: call func with user_data for each of element's sink pads.
// func will be called exactly once for each sink pad that exists at the time of
// this call, unless one of the calls to func returns FALSE in which case we
// will stop iterating pads and return early. If new sink pads are added or sink
// pads are removed while the sink pads are being iterated, this will not be
// taken into account until next time this function is used.
//
// The function takes the following parameters:
//
//    - fn: function to call for each sink pad.
//
// The function returns the following values:
//
//    - ok: FALSE if element had no sink pads or if one of the calls to func
//      returned FALSE.
//
func (element *Element) ForEachSinkPad(fn ElementForEachPadFunc) bool {
	var _arg0 *C.GstElement              // out
	var _arg1 C.GstElementForeachPadFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementForEachPadFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_element_foreach_sink_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEachSrcPad: call func with user_data for each of element's source pads.
// func will be called exactly once for each source pad that exists at the time
// of this call, unless one of the calls to func returns FALSE in which case we
// will stop iterating pads and return early. If new source pads are added or
// source pads are removed while the source pads are being iterated, this will
// not be taken into account until next time this function is used.
//
// The function takes the following parameters:
//
//    - fn: function to call for each source pad.
//
// The function returns the following values:
//
//    - ok: FALSE if element had no source pads or if one of the calls to func
//      returned FALSE.
//
func (element *Element) ForEachSrcPad(fn ElementForEachPadFunc) bool {
	var _arg0 *C.GstElement              // out
	var _arg1 C.GstElementForeachPadFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementForEachPadFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_element_foreach_src_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BaseTime returns the base time of the element. The base time is the absolute
// time of the clock when this element was last put to PLAYING. Subtracting the
// base time from the clock time gives the running time of the element.
//
// The function returns the following values:
//
//    - clockTime: base time of the element.
//
//      MT safe.
//
func (element *Element) BaseTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_base_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Bus returns the bus of the element. Note that only a Pipeline will provide a
// bus for the application.
//
// The function returns the following values:
//
//    - bus (optional) element's Bus. unref after usage.
//
//      MT safe.
//
func (element *Element) Bus() *Bus {
	var _arg0 *C.GstElement // out
	var _cret *C.GstBus     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_bus(_arg0)
	runtime.KeepAlive(element)

	var _bus *Bus // out

	if _cret != nil {
		_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _bus
}

// Clock gets the currently configured clock of the element. This is the clock
// as was last set with gst_element_set_clock().
//
// Elements in a pipeline will only have their clock set when the pipeline is in
// the PLAYING state.
//
// The function returns the following values:
//
//    - clock (optional) of the element. unref after usage.
//
//      MT safe.
//
func (element *Element) Clock() Clocker {
	var _arg0 *C.GstElement // out
	var _cret *C.GstClock   // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_clock(_arg0)
	runtime.KeepAlive(element)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// CompatiblePad looks for an unlinked pad to which the given pad can link. It
// is not guaranteed that linking the pads will work, though it should work in
// most cases.
//
// This function will first attempt to find a compatible unlinked ALWAYS pad,
// and if none can be found, it will request a compatible REQUEST pad by looking
// at the templates of element.
//
// The function takes the following parameters:
//
//    - pad to find a compatible one for.
//    - caps (optional) to use as a filter.
//
// The function returns the following values:
//
//    - ret (optional) to which a link can be made, or NULL if one cannot be
//      found. gst_object_unref() after usage.
//
func (element *Element) CompatiblePad(pad *Pad, caps *Caps) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out
	var _arg2 *C.GstCaps    // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C.gst_element_get_compatible_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)

	var _ret *Pad // out

	if _cret != nil {
		_ret = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// CompatiblePadTemplate retrieves a pad template from element that is
// compatible with compattempl. Pads from compatible templates can be linked
// together.
//
// The function takes the following parameters:
//
//    - compattempl to find a compatible template for.
//
// The function returns the following values:
//
//    - padTemplate (optional): compatible PadTemplate, or NULL if none was
//      found. No unreferencing is necessary.
//
func (element *Element) CompatiblePadTemplate(compattempl *PadTemplate) *PadTemplate {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.GstPadTemplate // out
	var _cret *C.GstPadTemplate // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(compattempl).Native()))

	_cret = C.gst_element_get_compatible_pad_template(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(compattempl)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// Context gets the context with context_type set on the element or NULL.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - contextType: name of a context to retrieve.
//
// The function returns the following values:
//
//    - context (optional) or NULL.
//
func (element *Element) Context(contextType string) *Context {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstContext // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_context(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(contextType)

	var _context *Context // out

	if _cret != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_context)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _context
}

// ContextUnlocked gets the context with context_type set on the element or
// NULL.
//
// The function takes the following parameters:
//
//    - contextType: name of a context to retrieve.
//
// The function returns the following values:
//
//    - context (optional) or NULL.
//
func (element *Element) ContextUnlocked(contextType string) *Context {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstContext // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_context_unlocked(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(contextType)

	var _context *Context // out

	if _cret != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_context)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _context
}

// Contexts gets the contexts set on the element.
//
// MT safe.
//
// The function returns the following values:
//
//    - list: list of Context.
//
func (element *Element) Contexts() []*Context {
	var _arg0 *C.GstElement // out
	var _cret *C.GList      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_contexts(_arg0)
	runtime.KeepAlive(element)

	var _list []*Context // out

	_list = make([]*Context, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstContext)(v)
		var dst *Context // out
		dst = (*Context)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// CurrentClockTime returns the current clock time of the element, as in, the
// time of the element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
//
// The function returns the following values:
//
//    - clockTime: clock time of the element, or GST_CLOCK_TIME_NONE if there is
//      no clock.
//
func (element *Element) CurrentClockTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_current_clock_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// CurrentRunningTime returns the running time of the element. The running time
// is the element's clock time minus its base time. Will return
// GST_CLOCK_TIME_NONE if the element has no clock, or if its base time has not
// been set.
//
// The function returns the following values:
//
//    - clockTime: running time of the element, or GST_CLOCK_TIME_NONE if the
//      element has no clock or its base time has not been set.
//
func (element *Element) CurrentRunningTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_current_running_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// Factory retrieves the factory that was used to create this element.
//
// The function returns the following values:
//
//    - elementFactory (optional) used for creating this element or NULL if
//      element has not been registered (static element). no refcounting is
//      needed.
//
func (element *Element) Factory() *ElementFactory {
	var _arg0 *C.GstElement        // out
	var _cret *C.GstElementFactory // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_factory(_arg0)
	runtime.KeepAlive(element)

	var _elementFactory *ElementFactory // out

	if _cret != nil {
		_elementFactory = wrapElementFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _elementFactory
}

// Metadata: get metadata with key in klass.
//
// The function takes the following parameters:
//
//    - key to get.
//
// The function returns the following values:
//
//    - utf8: metadata for key.
//
func (element *Element) Metadata(key string) string {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadTemplate retrieves a padtemplate from element with the given name.
//
// The function takes the following parameters:
//
//    - name of the PadTemplate to get.
//
// The function returns the following values:
//
//    - padTemplate (optional) with the given name, or NULL if none was found. No
//      unreferencing is necessary.
//
func (element *Element) PadTemplate(name string) *PadTemplate {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.gchar          // out
	var _cret *C.GstPadTemplate // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_pad_template(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// PadTemplateList retrieves a list of the pad templates associated with
// element. The list must not be modified by the calling code.
//
// The function returns the following values:
//
//    - list of pad templates.
//
func (element *Element) PadTemplateList() []*PadTemplate {
	var _arg0 *C.GstElement // out
	var _cret *C.GList      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_pad_template_list(_arg0)
	runtime.KeepAlive(element)

	var _list []*PadTemplate // out

	_list = make([]*PadTemplate, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPadTemplate)(v)
		var dst *PadTemplate // out
		dst = wrapPadTemplate(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// GetRequestPad: name of this function is confusing to people learning
// GStreamer. gst_element_request_pad_simple() aims at making it more explicit
// it is a simplified gst_element_request_pad().
//
// Deprecated: Prefer using gst_element_request_pad_simple() which provides the
// exact same functionality.
//
// The function takes the following parameters:
//
//    - name of the request Pad to retrieve.
//
// The function returns the following values:
//
//    - pad (optional): requested Pad if found, otherwise NULL. Release after
//      usage.
//
func (element *Element) GetRequestPad(name string) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_request_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// StartTime returns the start time of the element. The start time is the
// running time of the clock when this element was last put to PAUSED.
//
// Usually the start_time is managed by a toplevel element such as Pipeline.
//
// MT safe.
//
// The function returns the following values:
//
//    - clockTime: start time of the element.
//
func (element *Element) StartTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_start_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = uint64(_cret)
	type _ = ClockTime
	type _ = uint64

	return _clockTime
}

// State gets the state of the element.
//
// For elements that performed an ASYNC state change, as reported by
// gst_element_set_state(), this function will block up to the specified timeout
// value for the state change to complete. If the element completes the state
// change or goes into an error, this function returns immediately with a return
// value of GST_STATE_CHANGE_SUCCESS or GST_STATE_CHANGE_FAILURE respectively.
//
// For elements that did not return GST_STATE_CHANGE_ASYNC, this function
// returns the current and pending state immediately.
//
// This function returns GST_STATE_CHANGE_NO_PREROLL if the element successfully
// changed its state but is not able to provide data yet. This mostly happens
// for live sources that only produce data in GST_STATE_PLAYING. While the state
// change return is equivalent to GST_STATE_CHANGE_SUCCESS, it is returned to
// the application to signal that some sink elements might not be able to
// complete their state change because an element is not producing data to
// complete the preroll. When setting the element to playing, the preroll will
// complete and playback will start.
//
// The function takes the following parameters:
//
//    - timeout to specify the timeout for an async state change or
//      GST_CLOCK_TIME_NONE for infinite timeout.
//
// The function returns the following values:
//
//    - state (optional): pointer to State to hold the state. Can be NULL.
//    - pending (optional): pointer to State to hold the pending state. Can be
//      NULL.
//    - stateChangeReturn: GST_STATE_CHANGE_SUCCESS if the element has no more
//      pending state and the last state change succeeded, GST_STATE_CHANGE_ASYNC
//      if the element is still performing a state change or
//      GST_STATE_CHANGE_FAILURE if the last state change failed.
//
//      MT safe.
//
func (element *Element) State(timeout ClockTime) (state, pending State, stateChangeReturn StateChangeReturn) {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // in
	var _arg2 C.GstState             // in
	var _arg3 C.GstClockTime         // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg3 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64

	_cret = C.gst_element_get_state(_arg0, &_arg1, &_arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(timeout)

	var _state State                         // out
	var _pending State                       // out
	var _stateChangeReturn StateChangeReturn // out

	_state = State(_arg1)
	_pending = State(_arg2)
	_stateChangeReturn = StateChangeReturn(_cret)

	return _state, _pending, _stateChangeReturn
}

// StaticPad retrieves a pad from element by name. This version only retrieves
// already-existing (i.e. 'static') pads.
//
// The function takes the following parameters:
//
//    - name of the static Pad to retrieve.
//
// The function returns the following values:
//
//    - pad (optional): requested Pad if found, otherwise NULL. unref after
//      usage.
//
//      MT safe.
//
func (element *Element) StaticPad(name string) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_static_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// IsLockedState checks if the state of an element is locked. If the state of an
// element is locked, state changes of the parent don't affect the element. This
// way you can leave currently unused elements inside bins. Just lock their
// state before changing the state from T_STATE_NULL.
//
// MT safe.
//
// The function returns the following values:
//
//    - ok: TRUE, if the element's state is locked.
//
func (element *Element) IsLockedState() bool {
	var _arg0 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_is_locked_state(_arg0)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IteratePads retrieves an iterator of element's pads. The iterator should be
// freed after usage. Also more specialized iterators exists such as
// gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
//
// The order of pads returned by the iterator will be the order in which the
// pads were added to the element.
//
// The function returns the following values:
//
//    - iterator of Pad.
//
//      MT safe.
//
func (element *Element) IteratePads() *Iterator {
	var _arg0 *C.GstElement  // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_iterate_pads(_arg0)
	runtime.KeepAlive(element)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// IterateSinkPads retrieves an iterator of element's sink pads.
//
// The order of pads returned by the iterator will be the order in which the
// pads were added to the element.
//
// The function returns the following values:
//
//    - iterator of Pad.
//
//      MT safe.
//
func (element *Element) IterateSinkPads() *Iterator {
	var _arg0 *C.GstElement  // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_iterate_sink_pads(_arg0)
	runtime.KeepAlive(element)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// IterateSrcPads retrieves an iterator of element's source pads.
//
// The order of pads returned by the iterator will be the order in which the
// pads were added to the element.
//
// The function returns the following values:
//
//    - iterator of Pad.
//
//      MT safe.
//
func (element *Element) IterateSrcPads() *Iterator {
	var _arg0 *C.GstElement  // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_iterate_src_pads(_arg0)
	runtime.KeepAlive(element)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// Link links src to dest. The link must be from source to destination; the
// other direction will not be tried. The function looks for existing pads that
// aren't linked yet. It will request new pads if necessary. Such pads need to
// be released manually when unlinking. If multiple links are possible, only one
// is established.
//
// Make sure you have added your elements to a bin or pipeline with
// gst_bin_add() before trying to link them.
//
// The function takes the following parameters:
//
//    - dest containing the destination pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the elements could be linked, FALSE otherwise.
//
func (src *Element) Link(dest Elementer) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))

	_cret = C.gst_element_link(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkFiltered links src to dest using the given caps as filtercaps. The link
// must be from source to destination; the other direction will not be tried.
// The function looks for existing pads that aren't linked yet. It will request
// new pads if necessary. If multiple links are possible, only one is
// established.
//
// Make sure you have added your elements to a bin or pipeline with
// gst_bin_add() before trying to link them.
//
// The function takes the following parameters:
//
//    - dest containing the destination pad.
//    - filter (optional) to filter the link, or NULL for no filter.
//
// The function returns the following values:
//
//    - ok: TRUE if the pads could be linked, FALSE otherwise.
//
func (src *Element) LinkFiltered(dest Elementer, filter *Caps) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if filter != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_element_link_filtered(_arg0, _arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkPads links the two named pads of the source and destination elements.
// Side effect is that if one of the pads has no parent, it becomes a child of
// the parent of the other element. If they have different parents, the link
// fails.
//
// The function takes the following parameters:
//
//    - srcpadname (optional): name of the Pad in source element or NULL for any
//      pad.
//    - dest containing the destination pad.
//    - destpadname (optional): name of the Pad in destination element, or NULL
//      for any pad.
//
// The function returns the following values:
//
//    - ok: TRUE if the pads could be linked, FALSE otherwise.
//
func (src *Element) LinkPads(srcpadname string, dest Elementer, destpadname string) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if srcpadname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if destpadname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_element_link_pads(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkPadsFiltered links the two named pads of the source and destination
// elements. Side effect is that if one of the pads has no parent, it becomes a
// child of the parent of the other element. If they have different parents, the
// link fails. If caps is not NULL, makes sure that the caps of the link is a
// subset of caps.
//
// The function takes the following parameters:
//
//    - srcpadname (optional): name of the Pad in source element or NULL for any
//      pad.
//    - dest containing the destination pad.
//    - destpadname (optional): name of the Pad in destination element or NULL
//      for any pad.
//    - filter (optional) to filter the link, or NULL for no filter.
//
// The function returns the following values:
//
//    - ok: TRUE if the pads could be linked, FALSE otherwise.
//
func (src *Element) LinkPadsFiltered(srcpadname string, dest Elementer, destpadname string, filter *Caps) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.gchar      // out
	var _arg4 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if srcpadname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if destpadname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if filter != nil {
		_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_element_link_pads_filtered(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkPadsFull links the two named pads of the source and destination elements.
// Side effect is that if one of the pads has no parent, it becomes a child of
// the parent of the other element. If they have different parents, the link
// fails.
//
// Calling gst_element_link_pads_full() with flags == GST_PAD_LINK_CHECK_DEFAULT
// is the same as calling gst_element_link_pads() and the recommended way of
// linking pads with safety checks applied.
//
// This is a convenience function for gst_pad_link_full().
//
// The function takes the following parameters:
//
//    - srcpadname (optional): name of the Pad in source element or NULL for any
//      pad.
//    - dest containing the destination pad.
//    - destpadname (optional): name of the Pad in destination element, or NULL
//      for any pad.
//    - flags to be performed when linking pads.
//
// The function returns the following values:
//
//    - ok: TRUE if the pads could be linked, FALSE otherwise.
//
func (src *Element) LinkPadsFull(srcpadname string, dest Elementer, destpadname string, flags PadLinkCheck) bool {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GstElement     // out
	var _arg3 *C.gchar          // out
	var _arg4 C.GstPadLinkCheck // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if srcpadname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if destpadname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.GstPadLinkCheck(flags)

	_cret = C.gst_element_link_pads_full(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LostState brings the element to the lost state. The current state of the
// element is copied to the pending state so that any call to
// gst_element_get_state() will return GST_STATE_CHANGE_ASYNC.
//
// An ASYNC_START message is posted. If the element was PLAYING, it will go to
// PAUSED. The element will be restored to its PLAYING state by the parent
// pipeline when it prerolls again.
//
// This is mostly used for elements that lost their preroll buffer in the
// GST_STATE_PAUSED or GST_STATE_PLAYING state after a flush, they will go to
// their pending state again when a new preroll buffer is queued. This function
// can only be called when the element is currently not in error or an async
// state change.
//
// This function is used internally and should normally not be called from
// plugins or applications.
func (element *Element) LostState() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_lost_state(_arg0)
	runtime.KeepAlive(element)
}

// MessageFull: post an error, warning or info message on the bus from inside an
// element.
//
// type must be of T_MESSAGE_ERROR, T_MESSAGE_WARNING or T_MESSAGE_INFO.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - typ: MessageType.
//    - domain: GStreamer GError domain this message belongs to.
//    - code: GError code belonging to the domain.
//    - text (optional): allocated text string to be used as a replacement for
//      the default message connected to code, or NULL.
//    - debug (optional): allocated debug message to be used as a replacement for
//      the default debugging information, or NULL.
//    - file: source code file where the error was generated.
//    - function: source code function where the error was generated.
//    - line: source code line where the error was generated.
//
func (element *Element) MessageFull(typ MessageType, domain glib.Quark, code int, text, debug, file, function string, line int) {
	var _arg0 *C.GstElement    // out
	var _arg1 C.GstMessageType // out
	var _arg2 C.GQuark         // out
	var _arg3 C.gint           // out
	var _arg4 *C.gchar         // out
	var _arg5 *C.gchar         // out
	var _arg6 *C.gchar         // out
	var _arg7 *C.gchar         // out
	var _arg8 C.gint           // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstMessageType(typ)
	_arg2 = C.guint32(domain)
	type _ = glib.Quark
	type _ = uint32
	_arg3 = C.gint(code)
	if text != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	}
	if debug != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	}
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(function)))
	defer C.free(unsafe.Pointer(_arg7))
	_arg8 = C.gint(line)

	C.gst_element_message_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(element)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(text)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(file)
	runtime.KeepAlive(function)
	runtime.KeepAlive(line)
}

// MessageFullWithDetails: post an error, warning or info message on the bus
// from inside an element.
//
// type must be of T_MESSAGE_ERROR, T_MESSAGE_WARNING or T_MESSAGE_INFO.
//
// The function takes the following parameters:
//
//    - typ: MessageType.
//    - domain: GStreamer GError domain this message belongs to.
//    - code: GError code belonging to the domain.
//    - text (optional): allocated text string to be used as a replacement for
//      the default message connected to code, or NULL.
//    - debug (optional): allocated debug message to be used as a replacement for
//      the default debugging information, or NULL.
//    - file: source code file where the error was generated.
//    - function: source code function where the error was generated.
//    - line: source code line where the error was generated.
//    - structure: optional details structure.
//
func (element *Element) MessageFullWithDetails(typ MessageType, domain glib.Quark, code int, text, debug, file, function string, line int, structure *Structure) {
	var _arg0 *C.GstElement    // out
	var _arg1 C.GstMessageType // out
	var _arg2 C.GQuark         // out
	var _arg3 C.gint           // out
	var _arg4 *C.gchar         // out
	var _arg5 *C.gchar         // out
	var _arg6 *C.gchar         // out
	var _arg7 *C.gchar         // out
	var _arg8 C.gint           // out
	var _arg9 *C.GstStructure  // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstMessageType(typ)
	_arg2 = C.guint32(domain)
	type _ = glib.Quark
	type _ = uint32
	_arg3 = C.gint(code)
	if text != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	}
	if debug != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	}
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(function)))
	defer C.free(unsafe.Pointer(_arg7))
	_arg8 = C.gint(line)
	_arg9 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	C.gst_element_message_full_with_details(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(element)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(text)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(file)
	runtime.KeepAlive(function)
	runtime.KeepAlive(line)
	runtime.KeepAlive(structure)
}

// NoMorePads: use this function to signal that the element does not expect any
// more pads to show up in the current pipeline. This function should be called
// whenever pads have been added by the element itself. Elements with
// T_PAD_SOMETIMES pad templates use this in combination with autopluggers to
// figure out that the element is done initializing its pads.
//
// This function emits the Element::no-more-pads signal.
//
// MT safe.
func (element *Element) NoMorePads() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_no_more_pads(_arg0)
	runtime.KeepAlive(element)
}

// PostMessage: post a message on the element's Bus. This function takes
// ownership of the message; if you want to access the message after this call,
// you should add an additional reference before calling.
//
// The function takes the following parameters:
//
//    - message to post.
//
// The function returns the following values:
//
//    - ok: TRUE if the message was successfully posted. The function returns
//      FALSE if the element did not have a bus.
//
//      MT safe.
//
func (element *Element) PostMessage(message *Message) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	_cret = C.gst_element_post_message(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProvideClock: get the clock provided by the given element. > An element is
// only required to provide a clock in the PAUSED > state. Some elements can
// provide a clock in other states.
//
// The function returns the following values:
//
//    - clock (optional): gstClock provided by the element or NULL if no clock
//      could be provided. Unref after usage.
//
//      MT safe.
//
func (element *Element) ProvideClock() Clocker {
	var _arg0 *C.GstElement // out
	var _cret *C.GstClock   // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_provide_clock(_arg0)
	runtime.KeepAlive(element)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// Query performs a query on the given element.
//
// For elements that don't implement a query handler, this function forwards the
// query to a random srcpad or to the peer of a random linked sinkpad of this
// element.
//
// Please note that some queries might need a running pipeline to work.
//
// The function takes the following parameters:
//
//    - query: Query.
//
// The function returns the following values:
//
//    - ok: TRUE if the query could be performed.
//
//      MT safe.
//
func (element *Element) Query(query *Query) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstQuery   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_element_query(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryConvert queries an element to convert src_val in src_format to
// dest_format.
//
// The function takes the following parameters:
//
//    - srcFormat to convert from.
//    - srcVal: value to convert.
//    - destFormat to convert to.
//
// The function returns the following values:
//
//    - destVal: pointer to the result.
//    - ok: TRUE if the query could be performed.
//
func (element *Element) QueryConvert(srcFormat Format, srcVal int64, destFormat Format) (int64, bool) {
	var _arg0 *C.GstElement // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // out
	var _arg3 C.GstFormat   // out
	var _arg4 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_element_query_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(element)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFormat)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// QueryDuration queries an element (usually top-level pipeline or playbin
// element) for the total stream duration in nanoseconds. This query will only
// work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING state).
// The application will receive an ASYNC_DONE message on the pipeline bus when
// that is the case.
//
// If the duration changes for some reason, you will get a DURATION_CHANGED
// message on the pipeline bus, in which case you should re-query the duration
// using this function.
//
// The function takes the following parameters:
//
//    - format: Format requested.
//
// The function returns the following values:
//
//    - duration (optional): location in which to store the total duration, or
//      NULL.
//    - ok: TRUE if the query could be performed.
//
func (element *Element) QueryDuration(format Format) (int64, bool) {
	var _arg0 *C.GstElement // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_element_query_duration(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(format)

	var _duration int64 // out
	var _ok bool        // out

	_duration = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _duration, _ok
}

// QueryPosition queries an element (usually top-level pipeline or playbin
// element) for the stream position in nanoseconds. This will be a value between
// 0 and the stream duration (if the stream duration is known). This query will
// usually only work once the pipeline is prerolled (i.e. reached PAUSED or
// PLAYING state). The application will receive an ASYNC_DONE message on the
// pipeline bus when that is the case.
//
// If one repeatedly calls this function one can also create a query and reuse
// it in gst_element_query().
//
// The function takes the following parameters:
//
//    - format: Format requested.
//
// The function returns the following values:
//
//    - cur (optional): location in which to store the current position, or NULL.
//    - ok: TRUE if the query could be performed.
//
func (element *Element) QueryPosition(format Format) (int64, bool) {
	var _arg0 *C.GstElement // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_element_query_position(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(format)

	var _cur int64 // out
	var _ok bool   // out

	_cur = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _cur, _ok
}

// ReleaseRequestPad makes the element free the previously requested pad as
// obtained with gst_element_request_pad().
//
// This does not unref the pad. If the pad was created by using
// gst_element_request_pad(), gst_element_release_request_pad() needs to be
// followed by gst_object_unref() to free the pad.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - pad to release.
//
func (element *Element) ReleaseRequestPad(pad *Pad) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_element_release_request_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// RemovePad removes pad from element. pad will be destroyed if it has not been
// referenced elsewhere using gst_object_unparent().
//
// This function is used by plugin developers and should not be used by
// applications. Pads that were dynamically requested from elements with
// gst_element_request_pad() should be released with the
// gst_element_release_request_pad() function instead.
//
// Pads are not automatically deactivated so elements should perform the needed
// steps to deactivate the pad in case this pad is removed in the PAUSED or
// PLAYING state. See gst_pad_set_active() for more information about
// deactivating pads.
//
// The pad and the element should be unlocked when calling this function.
//
// This function will emit the Element::pad-removed signal on the element.
//
// The function takes the following parameters:
//
//    - pad to remove from the element.
//
// The function returns the following values:
//
//    - ok: TRUE if the pad could be removed. Can return FALSE if the pad does
//      not belong to the provided element.
//
//      MT safe.
//
func (element *Element) RemovePad(pad *Pad) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_element_remove_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - watchId: watch id to remove.
//
func (element *Element) RemovePropertyNotifyWatch(watchId uint32) {
	var _arg0 *C.GstElement // out
	var _arg1 C.gulong      // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.gulong(watchId)

	C.gst_element_remove_property_notify_watch(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(watchId)
}

// RequestPad retrieves a request pad from the element according to the provided
// template. Pad templates can be looked up using
// gst_element_factory_get_static_pad_templates().
//
// The pad should be released with gst_element_release_request_pad().
//
// The function takes the following parameters:
//
//    - templ of which we want a pad of.
//    - name (optional) of the request Pad to retrieve. Can be NULL.
//    - caps (optional) of the pad we want to request. Can be NULL.
//
// The function returns the following values:
//
//    - pad (optional): requested Pad if found, otherwise NULL. Release after
//      usage.
//
func (element *Element) RequestPad(templ *PadTemplate, name string, caps *Caps) *Pad {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.GstPadTemplate // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstPad         // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C.gst_element_request_pad(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)
	runtime.KeepAlive(caps)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// RequestPadSimple retrieves a pad from the element by name (e.g. "src_\d").
// This version only retrieves request pads. The pad should be released with
// gst_element_release_request_pad().
//
// This method is slower than manually getting the pad template and calling
// gst_element_request_pad() if the pads should have a specific name (e.g. name
// is "src_1" instead of "src_\u").
//
// Note that this function was introduced in GStreamer 1.20 in order to provide
// a better name to gst_element_get_request_pad(). Prior to 1.20, users should
// use gst_element_get_request_pad() which provides the same functionality.
//
// The function takes the following parameters:
//
//    - name of the request Pad to retrieve.
//
// The function returns the following values:
//
//    - pad (optional): requested Pad if found, otherwise NULL. Release after
//      usage.
//
func (element *Element) RequestPadSimple(name string) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_request_pad_simple(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// Seek sends a seek event to an element. See gst_event_new_seek() for the
// details of the parameters. The seek event is sent to the element using
// gst_element_send_event().
//
// MT safe.
//
// The function takes the following parameters:
//
//    - rate: new playback rate.
//    - format of the seek values.
//    - flags: optional seek flags.
//    - startType: type and flags for the new start position.
//    - start: value of the new start position.
//    - stopType: type and flags for the new stop position.
//    - stop: value of the new stop position.
//
// The function returns the following values:
//
//    - ok: TRUE if the event was handled. Flushing seeks will trigger a preroll,
//      which will emit GST_MESSAGE_ASYNC_DONE.
//
func (element *Element) Seek(rate float64, format Format, flags SeekFlags, startType SeekType, start int64, stopType SeekType, stop int64) bool {
	var _arg0 *C.GstElement  // out
	var _arg1 C.gdouble      // out
	var _arg2 C.GstFormat    // out
	var _arg3 C.GstSeekFlags // out
	var _arg4 C.GstSeekType  // out
	var _arg5 C.gint64       // out
	var _arg6 C.GstSeekType  // out
	var _arg7 C.gint64       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.GstSeekFlags(flags)
	_arg4 = C.GstSeekType(startType)
	_arg5 = C.gint64(start)
	_arg6 = C.GstSeekType(stopType)
	_arg7 = C.gint64(stop)

	_cret = C.gst_element_seek(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(element)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stopType)
	runtime.KeepAlive(stop)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SeekSimple: simple API to perform a seek on the given element, meaning it
// just seeks to the given position relative to the start of the stream. For
// more complex operations like segment seeks (e.g. for looping) or changing the
// playback rate or seeking relative to the last configured playback segment you
// should use gst_element_seek().
//
// In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
// guaranteed to return TRUE on a seekable media type or FALSE when the media
// type is certainly not seekable (such as a live stream).
//
// Some elements allow for seeking in the READY state, in this case they will
// store the seek event and execute it when they are put to PAUSED. If the
// element supports seek in READY, it will always return TRUE when it receives
// the event in the READY state.
//
// The function takes the following parameters:
//
//    - format to execute the seek in, such as T_FORMAT_TIME.
//    - seekFlags: seek options; playback applications will usually want to use
//      GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here.
//    - seekPos: position to seek to (relative to the start); if you are doing a
//      seek in T_FORMAT_TIME this value is in nanoseconds - multiply with
//      T_SECOND to convert seconds to nanoseconds or with T_MSECOND to convert
//      milliseconds to nanoseconds.
//
// The function returns the following values:
//
//    - ok: TRUE if the seek operation succeeded. Flushing seeks will trigger a
//      preroll, which will emit GST_MESSAGE_ASYNC_DONE.
//
func (element *Element) SeekSimple(format Format, seekFlags SeekFlags, seekPos int64) bool {
	var _arg0 *C.GstElement  // out
	var _arg1 C.GstFormat    // out
	var _arg2 C.GstSeekFlags // out
	var _arg3 C.gint64       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(format)
	_arg2 = C.GstSeekFlags(seekFlags)
	_arg3 = C.gint64(seekPos)

	_cret = C.gst_element_seek_simple(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(format)
	runtime.KeepAlive(seekFlags)
	runtime.KeepAlive(seekPos)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SendEvent sends an event to an element. If the element doesn't implement an
// event handler, the event will be pushed on a random linked sink pad for
// downstream events or a random linked source pad for upstream events.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - event to send to the element.
//
// The function returns the following values:
//
//    - ok: TRUE if the event was handled. Events that trigger a preroll (such as
//      flushing seeks and steps) will emit GST_MESSAGE_ASYNC_DONE.
//
func (element *Element) SendEvent(event *Event) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_element_send_event(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetBaseTime: set the base time of an element. See
// gst_element_get_base_time().
//
// MT safe.
//
// The function takes the following parameters:
//
//    - time: base time to set.
//
func (element *Element) SetBaseTime(time ClockTime) {
	var _arg0 *C.GstElement  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.guint64(time)
	type _ = ClockTime
	type _ = uint64

	C.gst_element_set_base_time(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(time)
}

// SetBus sets the bus of the element. Increases the refcount on the bus. For
// internal use only, unless you're testing elements.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - bus (optional) to set.
//
func (element *Element) SetBus(bus *Bus) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstBus     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if bus != nil {
		_arg1 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	}

	C.gst_element_set_bus(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(bus)
}

// SetClock sets the clock for the element. This function increases the refcount
// on the clock. Any previously set clock on the object is unreffed.
//
// The function takes the following parameters:
//
//    - clock (optional) to set for the element.
//
// The function returns the following values:
//
//    - ok: TRUE if the element accepted the clock. An element can refuse a clock
//      when it, for example, is not able to slave its internal clock to the
//      clock or when it requires a specific clock to operate.
//
//      MT safe.
//
func (element *Element) SetClock(clock Clocker) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstClock   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if clock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}

	_cret = C.gst_element_set_clock(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetContext sets the context of the element. Increases the refcount of the
// context.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - context to set.
//
func (element *Element) SetContext(context *Context) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstContext // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.gst_element_set_context(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(context)
}

// SetLockedState locks the state of an element, so state changes of the parent
// don't affect this element anymore.
//
// Note that this is racy if the state lock of the parent bin is not taken. The
// parent bin might've just checked the flag in another thread and as the next
// step proceed to change the child element's state.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - lockedState: TRUE to lock the element's state.
//
// The function returns the following values:
//
//    - ok: TRUE if the state was changed, FALSE if bad parameters were given or
//      the elements state-locking needed no change.
//
func (element *Element) SetLockedState(lockedState bool) bool {
	var _arg0 *C.GstElement // out
	var _arg1 C.gboolean    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if lockedState {
		_arg1 = C.TRUE
	}

	_cret = C.gst_element_set_locked_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(lockedState)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetStartTime: set the start time of an element. The start time of the element
// is the running time of the element when it last went to the PAUSED state. In
// READY or after a flushing seek, it is set to 0.
//
// Toplevel elements like Pipeline will manage the start_time and base_time on
// its children. Setting the start_time to T_CLOCK_TIME_NONE on such a toplevel
// element will disable the distribution of the base_time to the children and
// can be useful if the application manages the base_time itself, for example if
// you want to synchronize capture from multiple pipelines, and you can also
// ensure that the pipelines have the same clock.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - time: base time to set.
//
func (element *Element) SetStartTime(time ClockTime) {
	var _arg0 *C.GstElement  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.guint64(time)
	type _ = ClockTime
	type _ = uint64

	C.gst_element_set_start_time(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(time)
}

// SetState sets the state of the element. This function will try to set the
// requested state by going through all the intermediary states and calling the
// class's state change function for each.
//
// This function can return T_STATE_CHANGE_ASYNC, in which case the element will
// perform the remainder of the state change asynchronously in another thread.
// An application can use gst_element_get_state() to wait for the completion of
// the state change or it can wait for a GST_MESSAGE_ASYNC_DONE or
// GST_MESSAGE_STATE_CHANGED on the bus.
//
// State changes to GST_STATE_READY or GST_STATE_NULL never return
// T_STATE_CHANGE_ASYNC.
//
// The function takes the following parameters:
//
//    - state element's new State.
//
// The function returns the following values:
//
//    - stateChangeReturn: result of the state change using StateChangeReturn.
//
//      MT safe.
//
func (element *Element) SetState(state State) StateChangeReturn {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstState(state)

	_cret = C.gst_element_set_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(state)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// SyncStateWithParent tries to change the state of the element to the same as
// its parent. If this function returns FALSE, the state of element is
// undefined.
//
// The function returns the following values:
//
//    - ok: TRUE, if the element's state could be synced to the parent's state.
//
//      MT safe.
//
func (element *Element) SyncStateWithParent() bool {
	var _arg0 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_sync_state_with_parent(_arg0)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unlink unlinks all source pads of the source element with all sink pads of
// the sink element to which they are linked.
//
// If the link has been made using gst_element_link(), it could have created an
// requestpad, which has to be released using gst_element_release_request_pad().
//
// The function takes the following parameters:
//
//    - dest: sink Element to unlink.
//
func (src *Element) Unlink(dest Elementer) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))

	C.gst_element_unlink(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// UnlinkPads unlinks the two named pads of the source and destination elements.
//
// This is a convenience function for gst_pad_unlink().
//
// The function takes the following parameters:
//
//    - srcpadname: name of the Pad in source element.
//    - dest containing the destination pad.
//    - destpadname: name of the Pad in destination element.
//
func (src *Element) UnlinkPads(srcpadname string, dest Elementer, destpadname string) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.gchar      // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_element_unlink_pads(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)
}

// changeState: perform transition on element.
//
// This function must be called with STATE_LOCK held and is mainly used
// internally.
//
// The function takes the following parameters:
//
//    - transition: requested transition.
//
// The function returns the following values:
//
//    - stateChangeReturn of the state transition.
//
func (element *Element) changeState(transition StateChange) StateChangeReturn {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.change_state

	var _arg0 *C.GstElement          // out
	var _arg1 C.GstStateChange       // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstStateChange(transition)

	_cret = C._gotk4_gst1_Element_virtual_change_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(transition)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// State gets the state of the element.
//
// For elements that performed an ASYNC state change, as reported by
// gst_element_set_state(), this function will block up to the specified timeout
// value for the state change to complete. If the element completes the state
// change or goes into an error, this function returns immediately with a return
// value of GST_STATE_CHANGE_SUCCESS or GST_STATE_CHANGE_FAILURE respectively.
//
// For elements that did not return GST_STATE_CHANGE_ASYNC, this function
// returns the current and pending state immediately.
//
// This function returns GST_STATE_CHANGE_NO_PREROLL if the element successfully
// changed its state but is not able to provide data yet. This mostly happens
// for live sources that only produce data in GST_STATE_PLAYING. While the state
// change return is equivalent to GST_STATE_CHANGE_SUCCESS, it is returned to
// the application to signal that some sink elements might not be able to
// complete their state change because an element is not producing data to
// complete the preroll. When setting the element to playing, the preroll will
// complete and playback will start.
//
// The function takes the following parameters:
//
//    - timeout to specify the timeout for an async state change or
//      GST_CLOCK_TIME_NONE for infinite timeout.
//
// The function returns the following values:
//
//    - state (optional): pointer to State to hold the state. Can be NULL.
//    - pending (optional): pointer to State to hold the pending state. Can be
//      NULL.
//    - stateChangeReturn: GST_STATE_CHANGE_SUCCESS if the element has no more
//      pending state and the last state change succeeded, GST_STATE_CHANGE_ASYNC
//      if the element is still performing a state change or
//      GST_STATE_CHANGE_FAILURE if the last state change failed.
//
//      MT safe.
//
func (element *Element) state(timeout ClockTime) (state, pending State, stateChangeReturn StateChangeReturn) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.get_state

	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // in
	var _arg2 C.GstState             // in
	var _arg3 C.GstClockTime         // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg3 = C.guint64(timeout)
	type _ = ClockTime
	type _ = uint64

	_cret = C._gotk4_gst1_Element_virtual_get_state(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(timeout)

	var _state State                         // out
	var _pending State                       // out
	var _stateChangeReturn StateChangeReturn // out

	_state = State(_arg1)
	_pending = State(_arg2)
	_stateChangeReturn = StateChangeReturn(_cret)

	return _state, _pending, _stateChangeReturn
}

// noMorePads: use this function to signal that the element does not expect any
// more pads to show up in the current pipeline. This function should be called
// whenever pads have been added by the element itself. Elements with
// T_PAD_SOMETIMES pad templates use this in combination with autopluggers to
// figure out that the element is done initializing its pads.
//
// This function emits the Element::no-more-pads signal.
//
// MT safe.
func (element *Element) noMorePads() {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.no_more_pads

	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C._gotk4_gst1_Element_virtual_no_more_pads(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(element)
}

// The function takes the following parameters:
//
func (element *Element) padAdded(pad *Pad) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.pad_added

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_Element_virtual_pad_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// The function takes the following parameters:
//
func (element *Element) padRemoved(pad *Pad) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.pad_removed

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_Element_virtual_pad_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// postMessage: post a message on the element's Bus. This function takes
// ownership of the message; if you want to access the message after this call,
// you should add an additional reference before calling.
//
// The function takes the following parameters:
//
//    - message to post.
//
// The function returns the following values:
//
//    - ok: TRUE if the message was successfully posted. The function returns
//      FALSE if the element did not have a bus.
//
//      MT safe.
//
func (element *Element) postMessage(message *Message) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.post_message

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	_cret = C._gotk4_gst1_Element_virtual_post_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// provideClock: get the clock provided by the given element. > An element is
// only required to provide a clock in the PAUSED > state. Some elements can
// provide a clock in other states.
//
// The function returns the following values:
//
//    - clock (optional): gstClock provided by the element or NULL if no clock
//      could be provided. Unref after usage.
//
//      MT safe.
//
func (element *Element) provideClock() Clocker {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.provide_clock

	var _arg0 *C.GstElement // out
	var _cret *C.GstClock   // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Element_virtual_provide_clock(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(element)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// Query performs a query on the given element.
//
// For elements that don't implement a query handler, this function forwards the
// query to a random srcpad or to the peer of a random linked sinkpad of this
// element.
//
// Please note that some queries might need a running pipeline to work.
//
// The function takes the following parameters:
//
//    - query: Query.
//
// The function returns the following values:
//
//    - ok: TRUE if the query could be performed.
//
//      MT safe.
//
func (element *Element) query(query *Query) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.query

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstQuery   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gst1_Element_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (element *Element) releasePad(pad *Pad) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.release_pad

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_Element_virtual_release_pad(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// requestNewPad retrieves a request pad from the element according to the
// provided template. Pad templates can be looked up using
// gst_element_factory_get_static_pad_templates().
//
// The pad should be released with gst_element_release_request_pad().
//
// The function takes the following parameters:
//
//    - templ of which we want a pad of.
//    - name (optional) of the request Pad to retrieve. Can be NULL.
//    - caps (optional) of the pad we want to request. Can be NULL.
//
// The function returns the following values:
//
//    - pad (optional): requested Pad if found, otherwise NULL. Release after
//      usage.
//
func (element *Element) requestNewPad(templ *PadTemplate, name string, caps *Caps) *Pad {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.request_new_pad

	var _arg0 *C.GstElement     // out
	var _arg1 *C.GstPadTemplate // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstPad         // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C._gotk4_gst1_Element_virtual_request_new_pad(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)
	runtime.KeepAlive(caps)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// sendEvent sends an event to an element. If the element doesn't implement an
// event handler, the event will be pushed on a random linked sink pad for
// downstream events or a random linked source pad for upstream events.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - event to send to the element.
//
// The function returns the following values:
//
//    - ok: TRUE if the event was handled. Events that trigger a preroll (such as
//      flushing seeks and steps) will emit GST_MESSAGE_ASYNC_DONE.
//
func (element *Element) sendEvent(event *Event) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.send_event

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C._gotk4_gst1_Element_virtual_send_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setBus sets the bus of the element. Increases the refcount on the bus. For
// internal use only, unless you're testing elements.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - bus (optional) to set.
//
func (element *Element) setBus(bus *Bus) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_bus

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstBus     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if bus != nil {
		_arg1 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	}

	C._gotk4_gst1_Element_virtual_set_bus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(bus)
}

// setClock sets the clock for the element. This function increases the refcount
// on the clock. Any previously set clock on the object is unreffed.
//
// The function takes the following parameters:
//
//    - clock (optional) to set for the element.
//
// The function returns the following values:
//
//    - ok: TRUE if the element accepted the clock. An element can refuse a clock
//      when it, for example, is not able to slave its internal clock to the
//      clock or when it requires a specific clock to operate.
//
//      MT safe.
//
func (element *Element) setClock(clock Clocker) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_clock

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstClock   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if clock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}

	_cret = C._gotk4_gst1_Element_virtual_set_clock(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setContext sets the context of the element. Increases the refcount of the
// context.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - context to set.
//
func (element *Element) setContext(context *Context) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_context

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstContext // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	C._gotk4_gst1_Element_virtual_set_context(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(context)
}

// setState sets the state of the element. This function will try to set the
// requested state by going through all the intermediary states and calling the
// class's state change function for each.
//
// This function can return T_STATE_CHANGE_ASYNC, in which case the element will
// perform the remainder of the state change asynchronously in another thread.
// An application can use gst_element_get_state() to wait for the completion of
// the state change or it can wait for a GST_MESSAGE_ASYNC_DONE or
// GST_MESSAGE_STATE_CHANGED on the bus.
//
// State changes to GST_STATE_READY or GST_STATE_NULL never return
// T_STATE_CHANGE_ASYNC.
//
// The function takes the following parameters:
//
//    - state element's new State.
//
// The function returns the following values:
//
//    - stateChangeReturn: result of the state change using StateChangeReturn.
//
//      MT safe.
//
func (element *Element) setState(state State) StateChangeReturn {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_state

	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstState(state)

	_cret = C._gotk4_gst1_Element_virtual_set_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(state)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// The function takes the following parameters:
//
//    - oldstate
//    - newstate
//    - pending
//
func (element *Element) stateChanged(oldstate, newstate, pending State) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.state_changed

	var _arg0 *C.GstElement // out
	var _arg1 C.GstState    // out
	var _arg2 C.GstState    // out
	var _arg3 C.GstState    // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstState(oldstate)
	_arg2 = C.GstState(newstate)
	_arg3 = C.GstState(pending)

	C._gotk4_gst1_Element_virtual_state_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(oldstate)
	runtime.KeepAlive(newstate)
	runtime.KeepAlive(pending)
}

// ElementClass: GStreamer element class. Override the vmethods to implement the
// element functionality.
//
// An instance of this type is always passed by reference.
type ElementClass struct {
	*elementClass
}

// elementClass is the struct that's finalized.
type elementClass struct {
	native *C.GstElementClass
}

// ParentClass: parent class structure.
func (e *ElementClass) ParentClass() *ObjectClass {
	valptr := &e.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Elementfactory that creates these elements.
func (e *ElementClass) Elementfactory() *ElementFactory {
	valptr := &e.native.elementfactory
	var _v *ElementFactory // out
	_v = wrapElementFactory(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// Numpadtemplates: number of padtemplates.
func (e *ElementClass) Numpadtemplates() int {
	valptr := &e.native.numpadtemplates
	var _v int // out
	_v = int(*valptr)
	return _v
}

// PadTemplCookie: changed whenever the padtemplates change.
func (e *ElementClass) PadTemplCookie() uint32 {
	valptr := &e.native.pad_templ_cookie
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// AddMetadata: set key with value as metadata in klass.
//
// The function takes the following parameters:
//
//    - key to set.
//    - value to set.
//
func (klass *ElementClass) AddMetadata(key string, value string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_element_class_add_metadata(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// AddPadTemplate adds a padtemplate to an element class. This is mainly used in
// the _class_init functions of classes. If a pad template with the same name as
// an already existing one is added the old one is replaced by the new one.
//
// templ's reference count will be incremented, and any floating reference will
// be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//    - templ to add to the element class.
//
func (klass *ElementClass) AddPadTemplate(templ *PadTemplate) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.GstPadTemplate  // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	C.gst_element_class_add_pad_template(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(templ)
}

// AddStaticMetadata: set key with value as metadata in klass.
//
// Same as gst_element_class_add_metadata(), but value must be a static string
// or an inlined string, as it will not be copied. (GStreamer plugins will be
// made resident once loaded, so this function can be used even from dynamically
// loaded plugins.).
//
// The function takes the following parameters:
//
//    - key to set.
//    - value to set.
//
func (klass *ElementClass) AddStaticMetadata(key string, value string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_element_class_add_static_metadata(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// AddStaticPadTemplate adds a pad template to an element class based on the
// static pad template templ. This is mainly used in the _class_init functions
// of element implementations. If a pad template with the same name already
// exists, the old one is replaced by the new one.
//
// The function takes the following parameters:
//
//    - staticTempl to add as pad template to the element class.
//
func (klass *ElementClass) AddStaticPadTemplate(staticTempl *StaticPadTemplate) {
	var _arg0 *C.GstElementClass      // out
	var _arg1 *C.GstStaticPadTemplate // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(staticTempl)))

	C.gst_element_class_add_static_pad_template(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(staticTempl)
}

// AddStaticPadTemplateWithGType adds a pad template to an element class based
// on the static pad template templ. This is mainly used in the _class_init
// functions of element implementations. If a pad template with the same name
// already exists, the old one is replaced by the new one.
//
// The function takes the following parameters:
//
//    - staticTempl to add as pad template to the element class.
//    - padType of the pad to create.
//
func (klass *ElementClass) AddStaticPadTemplateWithGType(staticTempl *StaticPadTemplate, padType coreglib.Type) {
	var _arg0 *C.GstElementClass      // out
	var _arg1 *C.GstStaticPadTemplate // out
	var _arg2 C.GType                 // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(staticTempl)))
	_arg2 = C.GType(padType)

	C.gst_element_class_add_static_pad_template_with_gtype(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(staticTempl)
	runtime.KeepAlive(padType)
}

// Metadata: get metadata with key in klass.
//
// The function takes the following parameters:
//
//    - key to get.
//
// The function returns the following values:
//
//    - utf8: metadata for key.
//
func (klass *ElementClass) Metadata(key string) string {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_class_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadTemplate retrieves a padtemplate from element_class with the given name. >
// If you use this function in the InitFunc of an object class > that has
// subclasses, make sure to pass the g_class parameter of the > InitFunc here.
//
// The function takes the following parameters:
//
//    - name of the PadTemplate to get.
//
// The function returns the following values:
//
//    - padTemplate (optional) with the given name, or NULL if none was found. No
//      unreferencing is necessary.
//
func (elementClass *ElementClass) PadTemplate(name string) *PadTemplate {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _cret *C.GstPadTemplate  // in

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(elementClass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_class_get_pad_template(_arg0, _arg1)
	runtime.KeepAlive(elementClass)
	runtime.KeepAlive(name)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// PadTemplateList retrieves a list of the pad templates associated with
// element_class. The list must not be modified by the calling code. > If you
// use this function in the InitFunc of an object class > that has subclasses,
// make sure to pass the g_class parameter of the > InitFunc here.
//
// The function returns the following values:
//
//    - list of pad templates.
//
func (elementClass *ElementClass) PadTemplateList() []*PadTemplate {
	var _arg0 *C.GstElementClass // out
	var _cret *C.GList           // in

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(elementClass)))

	_cret = C.gst_element_class_get_pad_template_list(_arg0)
	runtime.KeepAlive(elementClass)

	var _list []*PadTemplate // out

	_list = make([]*PadTemplate, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPadTemplate)(v)
		var dst *PadTemplate // out
		dst = wrapPadTemplate(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// SetMetadata sets the detailed information for a ElementClass. > This function
// is for use in _class_init functions only.
//
// The function takes the following parameters:
//
//    - longname: long English name of the element. E.g. "File Sink".
//    - classification: string describing the type of element, as an unordered
//      list separated with slashes ('/'). See draft-klass.txt of the design docs
//      for more details and common types. E.g: "Sink/File".
//    - description: sentence describing the purpose of the element. E.g: "Write
//      stream to a file".
//    - author: name and contact details of the author(s). Use \n to separate
//      multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;".
//
func (klass *ElementClass) SetMetadata(longname string, classification string, description string, author string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(longname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(classification)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(author)))
	defer C.free(unsafe.Pointer(_arg4))

	C.gst_element_class_set_metadata(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(longname)
	runtime.KeepAlive(classification)
	runtime.KeepAlive(description)
	runtime.KeepAlive(author)
}

// SetStaticMetadata sets the detailed information for a ElementClass.
//
// > This function is for use in _class_init functions only.
//
// Same as gst_element_class_set_metadata(), but longname, classification,
// description, and author must be static strings or inlined strings, as they
// will not be copied. (GStreamer plugins will be made resident once loaded, so
// this function can be used even from dynamically loaded plugins.).
//
// The function takes the following parameters:
//
//    - longname: long English name of the element. E.g. "File Sink".
//    - classification: string describing the type of element, as an unordered
//      list separated with slashes ('/'). See draft-klass.txt of the design docs
//      for more details and common types. E.g: "Sink/File".
//    - description: sentence describing the purpose of the element. E.g: "Write
//      stream to a file".
//    - author: name and contact details of the author(s). Use \n to separate
//      multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;".
//
func (klass *ElementClass) SetStaticMetadata(longname string, classification string, description string, author string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(longname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(classification)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(author)))
	defer C.free(unsafe.Pointer(_arg4))

	C.gst_element_class_set_static_metadata(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(longname)
	runtime.KeepAlive(classification)
	runtime.KeepAlive(description)
	runtime.KeepAlive(author)
}
