// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeMapFlags    = coreglib.Type(C.gst_map_flags_get_type())
	GTypeMemoryFlags = coreglib.Type(C.gst_memory_flags_get_type())
	GTypeMemory      = coreglib.Type(C.gst_memory_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMapFlags, F: marshalMapFlags},
		coreglib.TypeMarshaler{T: GTypeMemoryFlags, F: marshalMemoryFlags},
		coreglib.TypeMarshaler{T: GTypeMemory, F: marshalMemory},
	})
}

// MapFlags flags used when mapping memory.
type MapFlags C.guint

const (
	// MapRead: map for read access.
	MapRead MapFlags = 0b1
	// MapWrite: map for write access.
	MapWrite MapFlags = 0b10
	// MapFlagLast: first flag that can be used for custom purposes.
	MapFlagLast MapFlags = 0b10000000000000000
)

func marshalMapFlags(p uintptr) (interface{}, error) {
	return MapFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MapFlags.
func (m MapFlags) String() string {
	if m == 0 {
		return "MapFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(28)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MapRead:
			builder.WriteString("Read|")
		case MapWrite:
			builder.WriteString("Write|")
		case MapFlagLast:
			builder.WriteString("FlagLast|")
		default:
			builder.WriteString(fmt.Sprintf("MapFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MapFlags) Has(other MapFlags) bool {
	return (m & other) == other
}

// MemoryFlags flags for wrapped memory.
type MemoryFlags C.guint

const (
	// MemoryFlagReadonly: memory is readonly. It is not allowed to map the
	// memory with T_MAP_WRITE.
	MemoryFlagReadonly MemoryFlags = 0b10
	// MemoryFlagNoShare: memory must not be shared. Copies will have to be made
	// when this memory needs to be shared between buffers. (DEPRECATED: do not
	// use in new code, instead you should create a custom GstAllocator for
	// memory pooling instead of relying on the GstBuffer they were originally
	// attached to.).
	MemoryFlagNoShare MemoryFlags = 0b10000
	// MemoryFlagZeroPrefixed: memory prefix is filled with 0 bytes.
	MemoryFlagZeroPrefixed MemoryFlags = 0b100000
	// MemoryFlagZeroPadded: memory padding is filled with 0 bytes.
	MemoryFlagZeroPadded MemoryFlags = 0b1000000
	// MemoryFlagPhysicallyContiguous: memory is physically contiguous. (Since:
	// 1.2).
	MemoryFlagPhysicallyContiguous MemoryFlags = 0b10000000
	// MemoryFlagNotMappable: memory can't be mapped via gst_memory_map()
	// without any preconditions. (Since: 1.2).
	MemoryFlagNotMappable MemoryFlags = 0b100000000
	// MemoryFlagLast: first flag that can be used for custom purposes.
	MemoryFlagLast MemoryFlags = 0b100000000000000000000
)

func marshalMemoryFlags(p uintptr) (interface{}, error) {
	return MemoryFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MemoryFlags.
func (m MemoryFlags) String() string {
	if m == 0 {
		return "MemoryFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(148)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MemoryFlagReadonly:
			builder.WriteString("Readonly|")
		case MemoryFlagNoShare:
			builder.WriteString("NoShare|")
		case MemoryFlagZeroPrefixed:
			builder.WriteString("ZeroPrefixed|")
		case MemoryFlagZeroPadded:
			builder.WriteString("ZeroPadded|")
		case MemoryFlagPhysicallyContiguous:
			builder.WriteString("PhysicallyContiguous|")
		case MemoryFlagNotMappable:
			builder.WriteString("NotMappable|")
		case MemoryFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("MemoryFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MemoryFlags) Has(other MemoryFlags) bool {
	return (m & other) == other
}

// MapInfo: structure containing the result of a map operation such as
// gst_memory_map(). It contains the data and size.
//
// An instance of this type is always passed by reference.
type MapInfo struct {
	*mapInfo
}

// mapInfo is the struct that's finalized.
type mapInfo struct {
	native *C.GstMapInfo
}

// Memory is a lightweight refcounted object that wraps a region of memory. They
// are typically used to manage the data of a Buffer.
//
// A GstMemory object has an allocated region of memory of maxsize. The maximum
// size does not change during the lifetime of the memory object. The memory
// also has an offset and size property that specifies the valid range of memory
// in the allocated region.
//
// Memory is usually created by allocators with a gst_allocator_alloc() method
// call. When NULL is used as the allocator, the default allocator will be used.
//
// New allocators can be registered with gst_allocator_register(). Allocators
// are identified by name and can be retrieved with gst_allocator_find().
// gst_allocator_set_default() can be used to change the default allocator.
//
// New memory can be created with gst_memory_new_wrapped() that wraps the memory
// allocated elsewhere.
//
// Refcounting of the memory block is performed with gst_memory_ref() and
// gst_memory_unref().
//
// The size of the memory can be retrieved and changed with
// gst_memory_get_sizes() and gst_memory_resize() respectively.
//
// Getting access to the data of the memory is performed with gst_memory_map().
// The call will return a pointer to offset bytes into the region of memory.
// After the memory access is completed, gst_memory_unmap() should be called.
//
// Memory can be copied with gst_memory_copy(), which will return a writable
// copy. gst_memory_share() will create a new memory block that shares the
// memory with an existing memory block at a custom offset and with a custom
// size.
//
// Memory can be efficiently merged when gst_memory_is_span() returns TRUE.
//
// An instance of this type is always passed by reference.
type Memory struct {
	*memory
}

// memory is the struct that's finalized.
type memory struct {
	native *C.GstMemory
}

func marshalMemory(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Memory{&memory{(*C.GstMemory)(b)}}, nil
}

// MiniObject: parent structure.
func (m *Memory) MiniObject() *MiniObject {
	valptr := &m.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Allocator: pointer to the Allocator.
func (m *Memory) Allocator() Allocatorrer {
	valptr := &m.native.allocator
	var _v Allocatorrer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gst.Allocatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Allocatorrer)
			return ok
		})
		rv, ok := casted.(Allocatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
		}
		_v = rv
	}
	return _v
}

// Parent: parent memory block.
func (m *Memory) Parent() *Memory {
	valptr := &m.native.parent
	var _v *Memory // out
	_v = (*Memory)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Maxsize: maximum size allocated.
func (m *Memory) Maxsize() uint {
	valptr := &m.native.maxsize
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Align: alignment of the memory.
func (m *Memory) Align() uint {
	valptr := &m.native.align
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: offset where valid data starts.
func (m *Memory) Offset() uint {
	valptr := &m.native.offset
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Size: size of valid data.
func (m *Memory) Size() uint {
	valptr := &m.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Maxsize: maximum size allocated.
func (m *Memory) SetMaxsize(maxsize uint) {
	valptr := &m.native.maxsize
	*valptr = C.gsize(maxsize)
}

// Align: alignment of the memory.
func (m *Memory) SetAlign(align uint) {
	valptr := &m.native.align
	*valptr = C.gsize(align)
}

// Offset: offset where valid data starts.
func (m *Memory) SetOffset(offset uint) {
	valptr := &m.native.offset
	*valptr = C.gsize(offset)
}

// Size: size of valid data.
func (m *Memory) SetSize(size uint) {
	valptr := &m.native.size
	*valptr = C.gsize(size)
}

// Copy: return a copy of size bytes from mem starting from offset. This copy is
// guaranteed to be writable. size can be set to -1 to return a copy from offset
// to the end of the memory region.
//
// The function takes the following parameters:
//
//    - offset to copy from.
//    - size to copy, or -1 to copy to the end of the memory region.
//
// The function returns the following values:
//
//    - memory: new Memory.
//
func (mem *Memory) Copy(offset int, size int) *Memory {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gssize     // out
	var _arg2 C.gssize     // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gssize(size)

	_cret = C.gst_memory_copy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _memory *Memory // out

	_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_memory)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _memory
}

// Sizes: get the current size, offset and maxsize of mem.
//
// The function returns the following values:
//
//    - offset (optional): pointer to offset.
//    - maxsize (optional): pointer to maxsize.
//    - gsize: current size of mem.
//
func (mem *Memory) Sizes() (offset uint, maxsize uint, gsize uint) {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gsize      // in
	var _arg2 C.gsize      // in
	var _cret C.gsize      // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_memory_get_sizes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(mem)

	var _offset uint  // out
	var _maxsize uint // out
	var _gsize uint   // out

	_offset = uint(_arg1)
	_maxsize = uint(_arg2)
	_gsize = uint(_cret)

	return _offset, _maxsize, _gsize
}

// IsSpan: check if mem1 and mem2 share the memory with a common parent memory
// object and that the memory is contiguous.
//
// If this is the case, the memory of mem1 and mem2 can be merged efficiently by
// performing gst_memory_share() on the parent object from the returned offset.
//
// The function takes the following parameters:
//
//    - mem2: Memory.
//
// The function returns the following values:
//
//    - offset: pointer to a result offset.
//    - ok: TRUE if the memory is contiguous and of a common parent.
//
func (mem1 *Memory) IsSpan(mem2 *Memory) (uint, bool) {
	var _arg0 *C.GstMemory // out
	var _arg1 *C.GstMemory // out
	var _arg2 C.gsize      // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem1)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem2)))

	_cret = C.gst_memory_is_span(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(mem1)
	runtime.KeepAlive(mem2)

	var _offset uint // out
	var _ok bool     // out

	_offset = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _offset, _ok
}

// IsType: check if mem if allocated with an allocator for mem_type.
//
// The function takes the following parameters:
//
//    - memType: memory type.
//
// The function returns the following values:
//
//    - ok: TRUE if mem was allocated from an allocator for mem_type.
//
func (mem *Memory) IsType(memType string) bool {
	var _arg0 *C.GstMemory // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(memType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_memory_is_type(_arg0, _arg1)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(memType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MakeMapped: create a Memory object that is mapped with flags. If mem is
// mappable with flags, this function returns the mapped mem directly. Otherwise
// a mapped copy of mem is returned.
//
// This function takes ownership of old mem and returns a reference to a new
// Memory.
//
// The function takes the following parameters:
//
//    - flags: mapping flags.
//
// The function returns the following values:
//
//    - info: pointer for info.
//    - memory (optional) object mapped with flags or NULL when a mapping is not
//      possible.
//
func (mem *Memory) MakeMapped(flags MapFlags) (*MapInfo, *Memory) {
	var _arg0 *C.GstMemory  // out
	var _arg1 C.GstMapInfo  // in
	var _arg2 C.GstMapFlags // out
	var _cret *C.GstMemory  // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_memory_make_mapped(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(flags)

	var _info *MapInfo  // out
	var _memory *Memory // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _info, _memory
}

// Map: fill info with the pointer and sizes of the memory in mem that can be
// accessed according to flags.
//
// This function can return FALSE for various reasons:
//
// - the memory backed by mem is not accessible with the given flags.
//
// - the memory was already mapped with a different mapping.
//
// info and its contents remain valid for as long as mem is valid and until
// gst_memory_unmap() is called.
//
// For each gst_memory_map() call, a corresponding gst_memory_unmap() call
// should be done.
//
// The function takes the following parameters:
//
//    - flags: mapping flags.
//
// The function returns the following values:
//
//    - info: pointer for info.
//    - ok: TRUE if the map operation was successful.
//
func (mem *Memory) Map(flags MapFlags) (*MapInfo, bool) {
	var _arg0 *C.GstMemory  // out
	var _arg1 C.GstMapInfo  // in
	var _arg2 C.GstMapFlags // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_memory_map(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(flags)

	var _info *MapInfo // out
	var _ok bool       // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// Resize the memory region. mem should be writable and offset + size should be
// less than the maxsize of mem.
//
// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED will be cleared
// when offset or padding is increased respectively.
//
// The function takes the following parameters:
//
//    - offset: new offset.
//    - size: new size.
//
func (mem *Memory) Resize(offset int, size uint) {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gssize     // out
	var _arg2 C.gsize      // out

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gsize(size)

	C.gst_memory_resize(_arg0, _arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)
}

// Share: return a shared copy of size bytes from mem starting from offset. No
// memory copy is performed and the memory region is simply shared. The result
// is guaranteed to be non-writable. size can be set to -1 to return a shared
// copy from offset to the end of the memory region.
//
// The function takes the following parameters:
//
//    - offset to share from.
//    - size to share, or -1 to share to the end of the memory region.
//
// The function returns the following values:
//
//    - memory: new Memory.
//
func (mem *Memory) Share(offset int, size int) *Memory {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gssize     // out
	var _arg2 C.gssize     // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gssize(size)

	_cret = C.gst_memory_share(_arg0, _arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _memory *Memory // out

	_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_memory)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _memory
}

// Unmap: release the memory obtained with gst_memory_map().
//
// The function takes the following parameters:
//
//    - info: MapInfo.
//
func (mem *Memory) Unmap(info *MapInfo) {
	var _arg0 *C.GstMemory  // out
	var _arg1 *C.GstMapInfo // out

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = (*C.GstMapInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.gst_memory_unmap(_arg0, _arg1)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(info)
}
