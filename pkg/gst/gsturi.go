// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// gboolean _gotk4_gst1_URIHandler_virtual_set_uri(void* fnptr, GstURIHandler* arg0, gchar* arg1, GError** arg2) {
//   return ((gboolean (*)(GstURIHandler*, gchar*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gchar* _gotk4_gst1_URIHandler_virtual_get_uri(void* fnptr, GstURIHandler* arg0) {
//   return ((gchar* (*)(GstURIHandler*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeURIError   = coreglib.Type(C.gst_uri_error_get_type())
	GTypeURIType    = coreglib.Type(C.gst_uri_type_get_type())
	GTypeURIHandler = coreglib.Type(C.gst_uri_handler_get_type())
	GTypeURI        = coreglib.Type(C.gst_uri_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeURIError, F: marshalURIError},
		coreglib.TypeMarshaler{T: GTypeURIType, F: marshalURIType},
		coreglib.TypeMarshaler{T: GTypeURIHandler, F: marshalURIHandler},
		coreglib.TypeMarshaler{T: GTypeURI, F: marshalURI},
	})
}

// URI_NO_PORT: value for Uri<!-- -->.port to indicate no port number.
const URI_NO_PORT = 0

// URIError: different URI-related errors that can occur.
type URIError C.gint

const (
	// URIErrorUnsupportedProtocol: protocol is not supported.
	URIErrorUnsupportedProtocol URIError = iota
	// URIErrorBadURI: there was a problem with the URI.
	URIErrorBadURI
	// URIErrorBadState: could not set or change the URI because the URI handler
	// was in a state where that is not possible or not permitted.
	URIErrorBadState
	// URIErrorBadReference: there was a problem with the entity that the URI
	// references.
	URIErrorBadReference
)

func marshalURIError(p uintptr) (interface{}, error) {
	return URIError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for URIError.
func (u URIError) String() string {
	switch u {
	case URIErrorUnsupportedProtocol:
		return "UnsupportedProtocol"
	case URIErrorBadURI:
		return "BadURI"
	case URIErrorBadState:
		return "BadState"
	case URIErrorBadReference:
		return "BadReference"
	default:
		return fmt.Sprintf("URIError(%d)", u)
	}
}

// URIType: different types of URI direction.
type URIType C.gint

const (
	// URIUnknown: URI direction is unknown.
	URIUnknown URIType = iota
	// URISink: URI is a consumer.
	URISink
	// URISrc: URI is a producer.
	URISrc
)

func marshalURIType(p uintptr) (interface{}, error) {
	return URIType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for URIType.
func (u URIType) String() string {
	switch u {
	case URIUnknown:
		return "Unknown"
	case URISink:
		return "Sink"
	case URISrc:
		return "Src"
	default:
		return fmt.Sprintf("URIType(%d)", u)
	}
}

// FilenameToURI: similar to g_filename_to_uri(), but attempts to handle
// relative file paths as well. Before converting filename into an URI, it will
// be prefixed by the current working directory if it is a relative path, and
// then the path will be canonicalised so that it doesn't contain any './' or
// '../' segments.
//
// On Windows filename should be in UTF-8 encoding.
//
// The function takes the following parameters:
//
//    - filename: absolute or relative file name path.
//
// The function returns the following values:
//
//    - utf8: newly-allocated URI string, or NULL on error. The caller must free
//      the URI string with g_free() when no longer needed.
//
func FilenameToURI(filename string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_filename_to_uri(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// URIHandler is an interface that is implemented by Source and Sink Element to
// unify handling of URI.
//
// An application can use the following functions to quickly get an element that
// handles the given URI for reading or writing (gst_element_make_from_uri()).
//
// Source and Sink plugins should implement this interface when possible.
//
// URIHandler wraps an interface. This means the user can get the
// underlying type by calling Cast().
type URIHandler struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*URIHandler)(nil)
)

// URIHandlerer describes URIHandler's interface methods.
type URIHandlerer interface {
	coreglib.Objector

	// Protocols gets the list of protocols supported by handler.
	Protocols() []string
	// URI gets the currently handled URI.
	URI() string
	// URIType gets the type of the given URI handler.
	URIType() URIType
	// SetURI tries to set the URI of the given handler.
	SetURI(uri string) error
}

var _ URIHandlerer = (*URIHandler)(nil)

func wrapURIHandler(obj *coreglib.Object) *URIHandler {
	return &URIHandler{
		Object: obj,
	}
}

func marshalURIHandler(p uintptr) (interface{}, error) {
	return wrapURIHandler(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Protocols gets the list of protocols supported by handler. This list may not
// be modified.
//
// The function returns the following values:
//
//    - utf8s (optional): the supported protocols. Returns NULL if the handler
//      isn't implemented properly, or the handler doesn't support any protocols.
//
func (handler *URIHandler) Protocols() []string {
	var _arg0 *C.GstURIHandler // out
	var _cret **C.gchar        // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C.gst_uri_handler_get_protocols(_arg0)
	runtime.KeepAlive(handler)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// URI gets the currently handled URI.
//
// The function returns the following values:
//
//    - utf8 (optional): URI currently handled by the handler. Returns NULL if
//      there are no URI currently handled. The returned string must be freed
//      with g_free() when no longer needed.
//
func (handler *URIHandler) URI() string {
	var _arg0 *C.GstURIHandler // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C.gst_uri_handler_get_uri(_arg0)
	runtime.KeepAlive(handler)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIType gets the type of the given URI handler.
//
// The function returns the following values:
//
//    - uriType of the URI handler. Returns T_URI_UNKNOWN if the handler isn't
//      implemented correctly.
//
func (handler *URIHandler) URIType() URIType {
	var _arg0 *C.GstURIHandler // out
	var _cret C.GstURIType     // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C.gst_uri_handler_get_uri_type(_arg0)
	runtime.KeepAlive(handler)

	var _uriType URIType // out

	_uriType = URIType(_cret)

	return _uriType
}

// SetURI tries to set the URI of the given handler.
//
// The function takes the following parameters:
//
//    - uri: URI to set.
//
func (handler *URIHandler) SetURI(uri string) error {
	var _arg0 *C.GstURIHandler // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_uri_handler_set_uri(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// urI gets the currently handled URI.
//
// The function returns the following values:
//
//    - utf8 (optional): URI currently handled by the handler. Returns NULL if
//      there are no URI currently handled. The returned string must be freed
//      with g_free() when no longer needed.
//
func (handler *URIHandler) urI() string {
	gclass := (*C.GstURIHandlerInterface)(coreglib.PeekParentClass(handler))
	fnarg := gclass.get_uri

	var _arg0 *C.GstURIHandler // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C._gotk4_gst1_URIHandler_virtual_get_uri(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(handler)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// setURI tries to set the URI of the given handler.
//
// The function takes the following parameters:
//
//    - uri: URI to set.
//
func (handler *URIHandler) setURI(uri string) error {
	gclass := (*C.GstURIHandlerInterface)(coreglib.PeekParentClass(handler))
	fnarg := gclass.set_uri

	var _arg0 *C.GstURIHandler // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gst1_URIHandler_virtual_set_uri(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ElementMakeFromURI creates an element for handling the given URI.
//
// The function takes the following parameters:
//
//    - typ: whether to create a source or a sink.
//    - uri: URI to create an element for.
//    - elementname (optional): name of created element, can be NULL.
//
// The function returns the following values:
//
//    - element: new element or NULL if none could be created.
//
func ElementMakeFromURI(typ URIType, uri, elementname string) (Elementer, error) {
	var _arg1 C.GstURIType  // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	_arg1 = C.GstURIType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg2))
	if elementname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(elementname)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_element_make_from_uri(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(elementname)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// URIHandlerInterface: any Element using this interface should implement these
// methods.
//
// An instance of this type is always passed by reference.
type URIHandlerInterface struct {
	*uriHandlerInterface
}

// uriHandlerInterface is the struct that's finalized.
type uriHandlerInterface struct {
	native *C.GstURIHandlerInterface
}

// URI object can be used to parse and split a URI string into its constituent
// parts. Two Uri objects can be joined to make a new Uri using the algorithm
// described in RFC3986.
//
// An instance of this type is always passed by reference.
type URI struct {
	*urI
}

// urI is the struct that's finalized.
type urI struct {
	native *C.GstUri
}

func marshalURI(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &URI{&urI{(*C.GstUri)(b)}}, nil
}

// NewURI constructs a struct URI.
func NewURI(scheme string, userinfo string, host string, port uint, path string, query string, fragment string) *URI {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _arg3 *C.gchar  // out
	var _arg4 C.guint   // out
	var _arg5 *C.gchar  // out
	var _arg6 *C.gchar  // out
	var _arg7 *C.gchar  // out
	var _cret *C.GstUri // in

	if scheme != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if userinfo != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if host != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.guint(port)
	if path != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if query != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if fragment != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg7))
	}

	_cret = C.gst_uri_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// AppendPath: append a path onto the end of the path in the URI. The path is
// not normalized, call #gst_uri_normalize() to normalize the path.
//
// The function takes the following parameters:
//
//    - relativePath: relative path to append to the end of the current path.
//
// The function returns the following values:
//
//    - ok: TRUE if the path was appended successfully.
//
func (uri *URI) AppendPath(relativePath string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(relativePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_append_path(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(relativePath)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppendPathSegment: append a single path segment onto the end of the URI path.
//
// The function takes the following parameters:
//
//    - pathSegment: path segment string to append to the URI path.
//
// The function returns the following values:
//
//    - ok: TRUE if the path was appended successfully.
//
func (uri *URI) AppendPathSegment(pathSegment string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pathSegment)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_append_path_segment(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(pathSegment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal compares two Uri objects to see if they represent the same normalized
// URI.
//
// The function takes the following parameters:
//
//    - second: second Uri to compare.
//
// The function returns the following values:
//
//    - ok: TRUE if the normalized versions of the two URI's would be equal.
//
func (first *URI) Equal(second *URI) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(second)))

	_cret = C.gst_uri_equal(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FromStringWithBase: like gst_uri_from_string() but also joins with a base
// URI.
//
// The function takes the following parameters:
//
//    - uri: URI string to parse.
//
// The function returns the following values:
//
//    - ret: new Uri object.
//
func (base *URI) FromStringWithBase(uri string) *URI {
	var _arg0 *C.GstUri // out
	var _arg1 *C.gchar  // out
	var _cret *C.GstUri // in

	if base != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(base)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_from_string_with_base(_arg0, _arg1)
	runtime.KeepAlive(base)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// Fragment: get the fragment name from the URI or NULL if it doesn't exist. If
// uri is NULL then returns NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): host name from the Uri object or NULL.
//
func (uri *URI) Fragment() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_fragment(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Host: get the host name from the URI or NULL if it doesn't exist. If uri is
// NULL then returns NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): host name from the Uri object or NULL.
//
func (uri *URI) Host() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_host(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MediaFragmentTable: get the media fragment table from the URI, as defined by
// "Media Fragments URI 1.0". Hash table returned by this API is a list of
// "key-value" pairs, and the each pair is generated by splitting "URI fragment"
// per "&" sub-delims, then "key" and "value" are split by "=" sub-delims. The
// "key" returned by this API may be undefined keyword by standard. A value may
// be NULL to indicate that the key should appear in the fragment string in the
// URI, but does not have a value. Free the returned Table with
// #g_hash_table_unref() when it is no longer required. Modifying this hash
// table does not affect the fragment in the URI.
//
// See more about Media Fragments URI 1.0 (W3C) at
// https://www.w3.org/TR/media-frags/.
//
// The function returns the following values:
//
//    - hashTable (optional): the fragment hash table from the URI.
//
func (uri *URI) MediaFragmentTable() map[string]string {
	var _arg0 *C.GstUri     // out
	var _cret *C.GHashTable // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_media_fragment_table(_arg0)
	runtime.KeepAlive(uri)

	var _hashTable map[string]string // out

	if _cret != nil {
		_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
		gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gchar)(k)
			vsrc := *(**C.gchar)(v)
			var kdst string // out
			var vdst string // out
			kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
			defer C.free(unsafe.Pointer(ksrc))
			vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
			defer C.free(unsafe.Pointer(vsrc))
			_hashTable[kdst] = vdst
		})
	}

	return _hashTable
}

// Path: extract the path string from the URI object.
//
// The function returns the following values:
//
//    - utf8 (optional): path from the URI. Once finished with the string should
//      be g_free()'d.
//
func (uri *URI) Path() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_get_path(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// PathSegments: get a list of path segments from the URI.
//
// The function returns the following values:
//
//    - list of path segment strings or NULL if no path segments are available.
//      Free the list when no longer needed with g_list_free_full(list, g_free).
//
func (uri *URI) PathSegments() []string {
	var _arg0 *C.GstUri // out
	var _cret *C.GList  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_path_segments(_arg0)
	runtime.KeepAlive(uri)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// PathString: extract the path string from the URI object as a percent encoded
// URI path.
//
// The function returns the following values:
//
//    - utf8 (optional): path from the URI. Once finished with the string should
//      be g_free()'d.
//
func (uri *URI) PathString() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_get_path_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Port: get the port number from the URI or GST_URI_NO_PORT if it doesn't
// exist. If uri is NULL then returns GST_URI_NO_PORT.
//
// The function returns the following values:
//
//    - guint: port number from the Uri object or GST_URI_NO_PORT.
//
func (uri *URI) Port() uint {
	var _arg0 *C.GstUri // out
	var _cret C.guint   // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_port(_arg0)
	runtime.KeepAlive(uri)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// QueryKeys: get a list of the query keys from the URI.
//
// The function returns the following values:
//
//    - list of keys from the URI query. Free the list with g_list_free().
//
func (uri *URI) QueryKeys() []string {
	var _arg0 *C.GstUri // out
	var _cret *C.GList  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_query_keys(_arg0)
	runtime.KeepAlive(uri)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// QueryString: get a percent encoded URI query string from the uri.
//
// The function returns the following values:
//
//    - utf8 (optional): percent encoded query string. Use g_free() when no
//      longer needed.
//
func (uri *URI) QueryString() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_query_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// QueryTable: get the query table from the URI. Keys and values in the table
// are freed with g_free when they are deleted. A value may be NULL to indicate
// that the key should appear in the query string in the URI, but does not have
// a value. Free the returned Table with #g_hash_table_unref() when it is no
// longer required. Modifying this hash table will modify the query in the URI.
//
// The function returns the following values:
//
//    - hashTable (optional): query hash table from the URI.
//
func (uri *URI) QueryTable() map[string]string {
	var _arg0 *C.GstUri     // out
	var _cret *C.GHashTable // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_query_table(_arg0)
	runtime.KeepAlive(uri)

	var _hashTable map[string]string // out

	if _cret != nil {
		_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
		gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gchar)(k)
			vsrc := *(**C.gchar)(v)
			var kdst string // out
			var vdst string // out
			kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
			defer C.free(unsafe.Pointer(ksrc))
			vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
			defer C.free(unsafe.Pointer(vsrc))
			_hashTable[kdst] = vdst
		})
	}

	return _hashTable
}

// QueryValue: get the value associated with the query_key key. Will return NULL
// if the key has no value or if the key does not exist in the URI query table.
// Because NULL is returned for both missing keys and keys with no value, you
// should use gst_uri_query_has_key() to determine if a key is present in the
// URI query.
//
// The function takes the following parameters:
//
//    - queryKey: key to lookup.
//
// The function returns the following values:
//
//    - utf8 (optional): value for the given key, or NULL if not found.
//
func (uri *URI) QueryValue(queryKey string) string {
	var _arg0 *C.GstUri // out
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_get_query_value(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Scheme: get the scheme name from the URI or NULL if it doesn't exist. If uri
// is NULL then returns NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): scheme from the Uri object or NULL.
//
func (uri *URI) Scheme() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_scheme(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Userinfo: get the userinfo (usually in the form "username:password") from the
// URI or NULL if it doesn't exist. If uri is NULL then returns NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): userinfo from the Uri object or NULL.
//
func (uri *URI) Userinfo() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_userinfo(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IsNormalized tests the uri to see if it is normalized. A NULL uri is
// considered to be normalized.
//
// The function returns the following values:
//
//    - ok: TRUE if the URI is normalized or is NULL.
//
func (uri *URI) IsNormalized() bool {
	var _arg0 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_is_normalized(_arg0)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsWritable: check if it is safe to write to this Uri.
//
// Check if the refcount of uri is exactly 1, meaning that no other reference
// exists to the Uri and that the Uri is therefore writable.
//
// Modification of a Uri should only be done after verifying that it is
// writable.
//
// The function returns the following values:
//
//    - ok: TRUE if it is safe to write to the object.
//
func (uri *URI) IsWritable() bool {
	var _arg0 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_is_writable(_arg0)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Join a reference URI onto a base URI using the method from RFC 3986. If
// either URI is NULL then the other URI will be returned with the ref count
// increased.
//
// The function takes the following parameters:
//
//    - refUri (optional): reference URI to join onto the base URI.
//
// The function returns the following values:
//
//    - uri (optional) which represents the base with the reference URI joined
//      on.
//
func (baseUri *URI) Join(refUri *URI) *URI {
	var _arg0 *C.GstUri // out
	var _arg1 *C.GstUri // out
	var _cret *C.GstUri // in

	if baseUri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(baseUri)))
	}
	if refUri != nil {
		_arg1 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(refUri)))
	}

	_cret = C.gst_uri_join(_arg0, _arg1)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(refUri)

	var _uri *URI // out

	if _cret != nil {
		_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_uri)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _uri
}

// MakeWritable: make the Uri writable.
//
// Checks if uri is writable, and if so the original object is returned. If not,
// then a writable copy is made and returned. This gives away the reference to
// uri and returns a reference to the new Uri. If uri is NULL then NULL is
// returned.
//
// The function returns the following values:
//
//    - ret: writable version of uri.
//
func (uri *URI) MakeWritable() *URI {
	var _arg0 *C.GstUri // out
	var _cret *C.GstUri // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(uri)), nil)

	_cret = C.gst_uri_make_writable(_arg0)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// NewWithBase: like gst_uri_new(), but joins the new URI onto a base URI.
//
// The function takes the following parameters:
//
//    - scheme (optional) for the new URI.
//    - userinfo (optional): user-info for the new URI.
//    - host (optional) name for the new URI.
//    - port number for the new URI or GST_URI_NO_PORT.
//    - path (optional) for the new URI with '/' separating path elements.
//    - query (optional) string for the new URI with '&' separating query
//      elements. Elements containing '&' characters should encode them as
//      "&percnt;26".
//    - fragment (optional) name for the new URI.
//
// The function returns the following values:
//
//    - uri: new URI joined onto base.
//
func (base *URI) NewWithBase(scheme string, userinfo string, host string, port uint, path string, query string, fragment string) *URI {
	var _arg0 *C.GstUri // out
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _arg3 *C.gchar  // out
	var _arg4 C.guint   // out
	var _arg5 *C.gchar  // out
	var _arg6 *C.gchar  // out
	var _arg7 *C.gchar  // out
	var _cret *C.GstUri // in

	if base != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(base)))
	}
	if scheme != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if userinfo != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if host != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.guint(port)
	if path != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if query != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if fragment != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg7))
	}

	_cret = C.gst_uri_new_with_base(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(base)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// Normalize: normalization will remove extra path segments ("." and "..") from
// the URI. It will also convert the scheme and host name to lower case and any
// percent-encoded values to uppercase.
//
// The Uri object must be writable. Check with gst_uri_is_writable() or use
// gst_uri_make_writable() first.
//
// The function returns the following values:
//
//    - ok: TRUE if the URI was modified.
//
func (uri *URI) Normalize() bool {
	var _arg0 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_normalize(_arg0)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryHasKey: check if there is a query table entry for the query_key key.
//
// The function takes the following parameters:
//
//    - queryKey: key to lookup.
//
// The function returns the following values:
//
//    - ok: TRUE if query_key exists in the URI query table.
//
func (uri *URI) QueryHasKey(queryKey string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_query_has_key(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveQueryKey: remove an entry from the query table by key.
//
// The function takes the following parameters:
//
//    - queryKey: key to remove.
//
// The function returns the following values:
//
//    - ok: TRUE if the key existed in the table and was removed.
//
func (uri *URI) RemoveQueryKey(queryKey string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_remove_query_key(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFragment sets the fragment string in the URI. Use a value of NULL in
// fragment to unset the fragment string.
//
// The function takes the following parameters:
//
//    - fragment (optional) string to set.
//
// The function returns the following values:
//
//    - ok: TRUE if the fragment was set/unset successfully.
//
func (uri *URI) SetFragment(fragment string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if fragment != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_uri_set_fragment(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(fragment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetHost: set or unset the host for the URI.
//
// The function takes the following parameters:
//
//    - host: new host string to set or NULL to unset.
//
// The function returns the following values:
//
//    - ok: TRUE if the host was set/unset successfully.
//
func (uri *URI) SetHost(host string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_host(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(host)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPath sets or unsets the path in the URI.
//
// The function takes the following parameters:
//
//    - path: new path to set with path segments separated by '/', or use NULL to
//      unset the path.
//
// The function returns the following values:
//
//    - ok: TRUE if the path was set successfully.
//
func (uri *URI) SetPath(path string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_path(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPathSegments: replace the path segments list in the URI.
//
// The function takes the following parameters:
//
//    - pathSegments (optional): new path list to set.
//
// The function returns the following values:
//
//    - ok: TRUE if the path segments were set successfully.
//
func (uri *URI) SetPathSegments(pathSegments []string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.GList   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if pathSegments != nil {
		for i := len(pathSegments) - 1; i >= 0; i-- {
			src := pathSegments[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
	}

	_cret = C.gst_uri_set_path_segments(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(pathSegments)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPathString sets or unsets the path in the URI.
//
// The function takes the following parameters:
//
//    - path: new percent encoded path to set with path segments separated by
//      '/', or use NULL to unset the path.
//
// The function returns the following values:
//
//    - ok: TRUE if the path was set successfully.
//
func (uri *URI) SetPathString(path string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_path_string(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPort: set or unset the port number for the URI.
//
// The function takes the following parameters:
//
//    - port: new port number to set or GST_URI_NO_PORT to unset.
//
// The function returns the following values:
//
//    - ok: TRUE if the port number was set/unset successfully.
//
func (uri *URI) SetPort(port uint) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = C.guint(port)

	_cret = C.gst_uri_set_port(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(port)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetQueryString sets or unsets the query table in the URI.
//
// The function takes the following parameters:
//
//    - query: new percent encoded query string to use to populate the query
//      table, or use NULL to unset the query table.
//
// The function returns the following values:
//
//    - ok: TRUE if the query table was set successfully.
//
func (uri *URI) SetQueryString(query string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_query_string(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetQueryTable: set the query table to use in the URI. The old table is
// unreferenced and a reference to the new one is used instead. A value if NULL
// for query_table will remove the query string from the URI.
//
// The function takes the following parameters:
//
//    - queryTable (optional): new query table to use.
//
// The function returns the following values:
//
//    - ok: TRUE if the new table was successfully used for the query table.
//
func (uri *URI) SetQueryTable(queryTable map[string]string) bool {
	var _arg0 *C.GstUri     // out
	var _arg1 *C.GHashTable // out
	var _cret C.gboolean    // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if queryTable != nil {
		_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
		for ksrc, vsrc := range queryTable {
			var kdst *C.gchar // out
			var vdst *C.gchar // out
			kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
			defer C.free(unsafe.Pointer(kdst))
			vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
			defer C.free(unsafe.Pointer(vdst))
			C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
		}
		defer C.g_hash_table_unref(_arg1)
	}

	_cret = C.gst_uri_set_query_table(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryTable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetQueryValue: this inserts or replaces a key in the query table. A
// query_value of NULL indicates that the key has no associated value, but will
// still be present in the query string.
//
// The function takes the following parameters:
//
//    - queryKey: key for the query entry.
//    - queryValue (optional): value for the key.
//
// The function returns the following values:
//
//    - ok: TRUE if the query table was successfully updated.
//
func (uri *URI) SetQueryValue(queryKey string, queryValue string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))
	if queryValue != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(queryValue)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_uri_set_query_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)
	runtime.KeepAlive(queryValue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetScheme: set or unset the scheme for the URI.
//
// The function takes the following parameters:
//
//    - scheme: new scheme to set or NULL to unset the scheme.
//
// The function returns the following values:
//
//    - ok: TRUE if the scheme was set/unset successfully.
//
func (uri *URI) SetScheme(scheme string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_scheme(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(scheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUserinfo: set or unset the user information for the URI.
//
// The function takes the following parameters:
//
//    - userinfo: new user-information string to set or NULL to unset.
//
// The function returns the following values:
//
//    - ok: TRUE if the user information was set/unset successfully.
//
func (uri *URI) SetUserinfo(userinfo string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_userinfo(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(userinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String: convert the URI to a string.
//
// Returns the URI as held in this object as a #gchar* nul-terminated string.
// The caller should g_free() the string once they are finished with it. The
// string is put together as described in RFC 3986.
//
// The function returns the following values:
//
//    - utf8: string version of the URI.
//
func (uri *URI) String() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_to_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIConstruct constructs a URI for a given valid protocol and location.
//
// Free-function: g_free
//
// Deprecated: Use GstURI instead.
//
// The function takes the following parameters:
//
//    - protocol: protocol for URI.
//    - location: location for URI.
//
// The function returns the following values:
//
//    - utf8: new string for this URI. Returns NULL if the given URI protocol is
//      not valid, or the given location is NULL.
//
func URIConstruct(protocol, location string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(location)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_construct(_arg1, _arg2)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(location)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIGetLocation extracts the location out of a given valid URI, ie. the
// protocol and "://" are stripped from the URI, which means that the location
// returned includes the hostname if one is specified. The returned string must
// be freed using g_free().
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//    - uri: URI string.
//
// The function returns the following values:
//
//    - utf8 (optional): location for this URI. Returns NULL if the URI isn't
//      valid. If the URI does not contain a location, an empty string is
//      returned.
//
func URIGetLocation(uri string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_get_location(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIGetProtocol extracts the protocol out of a given valid URI. The returned
// string must be freed using g_free().
//
// The function takes the following parameters:
//
//    - uri: URI string.
//
// The function returns the following values:
//
//    - utf8 (optional): protocol for this URI.
//
func URIGetProtocol(uri string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_get_protocol(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIHasProtocol checks if the protocol of a given valid URI matches protocol.
//
// The function takes the following parameters:
//
//    - uri: URI string.
//    - protocol string (e.g. "http").
//
// The function returns the following values:
//
//    - ok: TRUE if the protocol matches.
//
func URIHasProtocol(uri, protocol string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_has_protocol(_arg1, _arg2)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(protocol)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIIsValid tests if the given string is a valid URI identifier. URIs start
// with a valid scheme followed by ":" and maybe a string identifying the
// location.
//
// The function takes the following parameters:
//
//    - uri: URI string.
//
// The function returns the following values:
//
//    - ok: TRUE if the string is a valid URI.
//
func URIIsValid(uri string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_is_valid(_arg1)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIProtocolIsSupported checks if an element exists that supports the given
// URI protocol. Note that a positive return value does not imply that a
// subsequent call to gst_element_make_from_uri() is guaranteed to work.
//
// The function takes the following parameters:
//
//    - typ: whether to check for a source or a sink.
//    - protocol: protocol that should be checked for (e.g. "http" or "smb").
//
// The function returns the following values:
//
//    - ok: TRUE.
//
func URIProtocolIsSupported(typ URIType, protocol string) bool {
	var _arg1 C.GstURIType // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg1 = C.GstURIType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_protocol_is_supported(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIProtocolIsValid tests if the given string is a valid protocol identifier.
// Protocols must consist of alphanumeric characters, '+', '-' and '.' and must
// start with a alphabetic character. See RFC 3986 Section 3.1.
//
// The function takes the following parameters:
//
//    - protocol: string.
//
// The function returns the following values:
//
//    - ok: TRUE if the string is a valid protocol identifier, FALSE otherwise.
//
func URIProtocolIsValid(protocol string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_protocol_is_valid(_arg1)
	runtime.KeepAlive(protocol)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
