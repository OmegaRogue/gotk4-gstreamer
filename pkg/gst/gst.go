// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gstreamer-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeDebugColorMode  = coreglib.Type(C.gst_debug_color_mode_get_type())
	GTypePluginAPIFlags  = coreglib.Type(C.gst_plugin_api_flags_get_type())
	GTypeSerializeFlags  = coreglib.Type(C.gst_serialize_flags_get_type())
	GTypeStackTraceFlags = coreglib.Type(C.gst_stack_trace_flags_get_type())
	GTypeStreamFlags     = coreglib.Type(C.gst_stream_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDebugColorMode, F: marshalDebugColorMode},
		coreglib.TypeMarshaler{T: GTypePluginAPIFlags, F: marshalPluginAPIFlags},
		coreglib.TypeMarshaler{T: GTypeSerializeFlags, F: marshalSerializeFlags},
		coreglib.TypeMarshaler{T: GTypeStackTraceFlags, F: marshalStackTraceFlags},
		coreglib.TypeMarshaler{T: GTypeStreamFlags, F: marshalStreamFlags},
	})
}

// The function returns the following values:
//
func CoreErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_core_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

type DebugColorMode C.gint

const (
	// DebugColorModeOff: do not use colors in logs.
	DebugColorModeOff DebugColorMode = iota
	// DebugColorModeOn: paint logs in a platform-specific way.
	DebugColorModeOn
	// DebugColorModeUnix: paint logs with UNIX terminal color codes no matter
	// what platform GStreamer is running on.
	DebugColorModeUnix
)

func marshalDebugColorMode(p uintptr) (interface{}, error) {
	return DebugColorMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DebugColorMode.
func (d DebugColorMode) String() string {
	switch d {
	case DebugColorModeOff:
		return "Off"
	case DebugColorModeOn:
		return "On"
	case DebugColorModeUnix:
		return "Unix"
	default:
		return fmt.Sprintf("DebugColorMode(%d)", d)
	}
}

// The function returns the following values:
//
func LibraryErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_library_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// The function returns the following values:
//
func ResourceErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_resource_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// The function returns the following values:
//
func StreamErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_stream_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// The function returns the following values:
//
func URIErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_uri_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

type PluginAPIFlags C.guint

const (
	// PluginApiFlagIgnoreEnumMembers: ignore enum members when generating the
	// plugins cache. This is useful if the members of the enum are generated
	// dynamically, in order not to expose incorrect documentation to the end
	// user.
	PluginApiFlagIgnoreEnumMembers PluginAPIFlags = 0b1
)

func marshalPluginAPIFlags(p uintptr) (interface{}, error) {
	return PluginAPIFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PluginAPIFlags.
func (p PluginAPIFlags) String() string {
	if p == 0 {
		return "PluginAPIFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(30)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PluginApiFlagIgnoreEnumMembers:
			builder.WriteString("Members|")
		default:
			builder.WriteString(fmt.Sprintf("PluginAPIFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PluginAPIFlags) Has(other PluginAPIFlags) bool {
	return (p & other) == other
}

type SerializeFlags C.guint

const (
	// SerializeFlagNone: no special flags specified.
	SerializeFlagNone SerializeFlags = 0b0
	// SerializeFlagBackwardCompat: serialize using the old format for nested
	// structures.
	SerializeFlagBackwardCompat SerializeFlags = 0b1
)

func marshalSerializeFlags(p uintptr) (interface{}, error) {
	return SerializeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SerializeFlags.
func (s SerializeFlags) String() string {
	if s == 0 {
		return "SerializeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(45)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SerializeFlagNone:
			builder.WriteString("None|")
		case SerializeFlagBackwardCompat:
			builder.WriteString("BackwardCompat|")
		default:
			builder.WriteString(fmt.Sprintf("SerializeFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SerializeFlags) Has(other SerializeFlags) bool {
	return (s & other) == other
}

type StackTraceFlags C.guint

const (
	// StackTraceShowNone: try to retrieve the minimum information available,
	// which may be none on some platforms (Since: 1.18).
	StackTraceShowNone StackTraceFlags = 0b0
	// StackTraceShowFull: try to retrieve as much information as possible,
	// including source information when getting the stack trace.
	StackTraceShowFull StackTraceFlags = 0b1
)

func marshalStackTraceFlags(p uintptr) (interface{}, error) {
	return StackTraceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StackTraceFlags.
func (s StackTraceFlags) String() string {
	if s == 0 {
		return "StackTraceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(37)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StackTraceShowNone:
			builder.WriteString("None|")
		case StackTraceShowFull:
			builder.WriteString("Full|")
		default:
			builder.WriteString(fmt.Sprintf("StackTraceFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StackTraceFlags) Has(other StackTraceFlags) bool {
	return (s & other) == other
}

type StreamFlags C.guint

const (
	// StreamFlagNone: this stream has no special attributes.
	StreamFlagNone StreamFlags = 0b0
	// StreamFlagSparse: this stream is a sparse stream (e.g. a subtitle
	// stream), data may flow only in irregular intervals with large gaps in
	// between.
	StreamFlagSparse StreamFlags = 0b1
	// StreamFlagSelect: this stream should be selected by default. This flag
	// may be used by demuxers to signal that a stream should be selected by
	// default in a playback scenario.
	StreamFlagSelect StreamFlags = 0b10
	// StreamFlagUnselect: this stream should not be selected by default. This
	// flag may be used by demuxers to signal that a stream should not be
	// selected by default in a playback scenario, but only if explicitly
	// selected by the user (e.g. an audio track for the hard of hearing or a
	// director's commentary track).
	StreamFlagUnselect StreamFlags = 0b100
)

func marshalStreamFlags(p uintptr) (interface{}, error) {
	return StreamFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StreamFlags.
func (s StreamFlags) String() string {
	if s == 0 {
		return "StreamFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(67)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StreamFlagNone:
			builder.WriteString("None|")
		case StreamFlagSparse:
			builder.WriteString("Sparse|")
		case StreamFlagSelect:
			builder.WriteString("Select|")
		case StreamFlagUnselect:
			builder.WriteString("Unselect|")
		default:
			builder.WriteString(fmt.Sprintf("StreamFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StreamFlags) Has(other StreamFlags) bool {
	return (s & other) == other
}

// Deinit: clean up any resources created by GStreamer in gst_init().
//
// It is normally not needed to call this function in a normal application as
// the resources will automatically be freed when the program terminates. This
// function is therefore mostly used by testsuites and other memory profiling
// tools.
//
// After this call GStreamer (including this method) should not be used anymore.
func Deinit() {
	C.gst_deinit()
}

// IsInitialized: use this function to check if GStreamer has been initialized
// with gst_init() or gst_init_check().
//
// The function returns the following values:
//
//    - ok: TRUE if initialization has been done, FALSE otherwise.
//
func IsInitialized() bool {
	var _cret C.gboolean // in

	_cret = C.gst_is_initialized()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SegtrapIsEnabled: some functions in the GStreamer core might install a custom
// SIGSEGV handler to better catch and report errors to the application.
// Currently this feature is enabled by default when loading plugins.
//
// Applications might want to disable this behaviour with the
// gst_segtrap_set_enabled() function. This is typically done if the application
// wants to install its own handler without GStreamer interfering.
//
// The function returns the following values:
//
//    - ok: TRUE if GStreamer is allowed to install a custom SIGSEGV handler.
//
func SegtrapIsEnabled() bool {
	var _cret C.gboolean // in

	_cret = C.gst_segtrap_is_enabled()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SegtrapSetEnabled applications might want to disable/enable the SIGSEGV
// handling of the GStreamer core. See gst_segtrap_is_enabled() for more
// information.
//
// The function takes the following parameters:
//
//    - enabled: whether a custom SIGSEGV handler should be installed.
//
func SegtrapSetEnabled(enabled bool) {
	var _arg1 C.gboolean // out

	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_segtrap_set_enabled(_arg1)
	runtime.KeepAlive(enabled)
}

// UpdateRegistry forces GStreamer to re-scan its plugin paths and update the
// default plugin registry.
//
// Applications will almost never need to call this function, it is only useful
// if the application knows new plugins have been installed (or old ones
// removed) since the start of the application (or, to be precise, the first
// call to gst_init()) and the application wants to make use of any
// newly-installed plugins without restarting the application.
//
// Applications should assume that the registry update is neither atomic nor
// thread-safe and should therefore not have any dynamic pipelines running
// (including the playbin and decodebin elements) and should also not create any
// elements or access the GStreamer registry while the update is in progress.
//
// Note that this function may block for a significant amount of time.
//
// The function returns the following values:
//
//    - ok: TRUE if the registry has been updated successfully (does not imply
//      that there were changes), otherwise FALSE.
//
func UpdateRegistry() bool {
	var _cret C.gboolean // in

	_cret = C.gst_update_registry()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Version gets the version number of the GStreamer library.
//
// The function returns the following values:
//
//    - major: pointer to a guint to store the major version number.
//    - minor: pointer to a guint to store the minor version number.
//    - micro: pointer to a guint to store the micro version number.
//    - nano: pointer to a guint to store the nano version number.
//
func Version() (major, minor, micro, nano uint) {
	var _arg1 C.guint // in
	var _arg2 C.guint // in
	var _arg3 C.guint // in
	var _arg4 C.guint // in

	C.gst_version(&_arg1, &_arg2, &_arg3, &_arg4)

	var _major uint // out
	var _minor uint // out
	var _micro uint // out
	var _nano uint  // out

	_major = uint(_arg1)
	_minor = uint(_arg2)
	_micro = uint(_arg3)
	_nano = uint(_arg4)

	return _major, _minor, _micro, _nano
}

// VersionString: this function returns a string that is useful for describing
// this version of GStreamer to the outside world: user agent strings, logging,
// ...
//
// The function returns the following values:
//
//    - utf8: newly allocated string describing this version of GStreamer.
//
func VersionString() string {
	var _cret *C.gchar // in

	_cret = C.gst_version_string()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RegistryForkIsEnabled: by default GStreamer will perform scanning and
// rebuilding of the registry file using a helper child process.
//
// Applications might want to disable this behaviour with the
// gst_registry_fork_set_enabled() function, in which case new plugins are
// scanned (and loaded) into the application process.
//
// The function returns the following values:
//
//    - ok: TRUE if GStreamer will use the child helper process when rebuilding
//      the registry.
//
func RegistryForkIsEnabled() bool {
	var _cret C.gboolean // in

	_cret = C.gst_registry_fork_is_enabled()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegistryForkSetEnabled applications might want to disable/enable spawning of
// a child helper process when rebuilding the registry. See
// gst_registry_fork_is_enabled() for more information.
//
// The function takes the following parameters:
//
//    - enabled: whether rebuilding the registry can use a temporary child helper
//      process.
//
func RegistryForkSetEnabled(enabled bool) {
	var _arg1 C.gboolean // out

	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_registry_fork_set_enabled(_arg1)
	runtime.KeepAlive(enabled)
}

// Init binds to the gst_init() function. Argument parsing is not
// supported.
func Init() {
	C.gst_init(nil, nil)
}
