// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeDeviceMonitor = coreglib.Type(C.gst_device_monitor_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDeviceMonitor, F: marshalDeviceMonitor},
	})
}

// DeviceMonitorOverrides contains methods that are overridable.
type DeviceMonitorOverrides struct {
}

func defaultDeviceMonitorOverrides(v *DeviceMonitor) DeviceMonitorOverrides {
	return DeviceMonitorOverrides{}
}

// DeviceMonitor applications should create a DeviceMonitor when they want to
// probe, list and monitor devices of a specific type. The DeviceMonitor will
// create the appropriate DeviceProvider objects and manage them. It will then
// post messages on its Bus for devices that have been added and removed.
//
// The device monitor will monitor all devices matching the filters that the
// application has set.
//
// The basic use pattern of a device monitor is as follows:
//
//      static gboolean
//      my_bus_func (GstBus * bus, GstMessage * message, gpointer user_data)
//      {
//         GstDevice *device;
//         gchar *name;
//
//         switch (GST_MESSAGE_TYPE (message)) {
//           case GST_MESSAGE_DEVICE_ADDED:
//             gst_message_parse_device_added (message, &device);
//             name = gst_device_get_display_name (device);
//             g_print("Device added: s\n", name);
//             g_free (name);
//             gst_object_unref (device);
//             break;
//           case GST_MESSAGE_DEVICE_REMOVED:
//             gst_message_parse_device_removed (message, &device);
//             name = gst_device_get_display_name (device);
//             g_print("Device removed: s\n", name);
//             g_free (name);
//             gst_object_unref (device);
//             break;
//           default:
//             break;
//         }
//
//         return G_SOURCE_CONTINUE;
//      }
//
//      GstDeviceMonitor *
//      setup_raw_video_source_device_monitor (void) {
//         GstDeviceMonitor *monitor;
//         GstBus *bus;
//         GstCaps *caps;
//
//         monitor = gst_device_monitor_new ();
//
//         bus = gst_device_monitor_get_bus (monitor);
//         gst_bus_add_watch (bus, my_bus_func, NULL);
//         gst_object_unref (bus);
//
//         caps = gst_caps_new_empty_simple ("video/x-raw");
//         gst_device_monitor_add_filter (monitor, "Video/Source", caps);
//         gst_caps_unref (caps);
//
//         gst_device_monitor_start (monitor);
//
//         return monitor;
//      }.
type DeviceMonitor struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*DeviceMonitor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DeviceMonitor, *DeviceMonitorClass, DeviceMonitorOverrides](
		GTypeDeviceMonitor,
		initDeviceMonitorClass,
		wrapDeviceMonitor,
		defaultDeviceMonitorOverrides,
	)
}

func initDeviceMonitorClass(gclass unsafe.Pointer, overrides DeviceMonitorOverrides, classInitFunc func(*DeviceMonitorClass)) {
	if classInitFunc != nil {
		class := (*DeviceMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDeviceMonitor(obj *coreglib.Object) *DeviceMonitor {
	return &DeviceMonitor{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalDeviceMonitor(p uintptr) (interface{}, error) {
	return wrapDeviceMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDeviceMonitor: create a new DeviceMonitor.
//
// The function returns the following values:
//
//    - deviceMonitor: new device monitor.
//
func NewDeviceMonitor() *DeviceMonitor {
	var _cret *C.GstDeviceMonitor // in

	_cret = C.gst_device_monitor_new()

	var _deviceMonitor *DeviceMonitor // out

	_deviceMonitor = wrapDeviceMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _deviceMonitor
}

// AddFilter adds a filter for which Device will be monitored, any device that
// matches all these classes and the Caps will be returned.
//
// If this function is called multiple times to add more filters, each will be
// matched independently. That is, adding more filters will not further restrict
// what devices are matched.
//
// The Caps supported by the device as returned by gst_device_get_caps() are not
// intersected with caps filters added using this function.
//
// Filters must be added before the DeviceMonitor is started.
//
// The function takes the following parameters:
//
//    - classes (optional): device classes to use as filter or NULL for any
//      class.
//    - caps (optional) to filter or NULL for ANY.
//
// The function returns the following values:
//
//    - guint: id of the new filter or 0 if no provider matched the filter's
//      classes.
//
func (monitor *DeviceMonitor) AddFilter(classes string, caps *Caps) uint {
	var _arg0 *C.GstDeviceMonitor // out
	var _arg1 *C.gchar            // out
	var _arg2 *C.GstCaps          // out
	var _cret C.guint             // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	if classes != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(classes)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C.gst_device_monitor_add_filter(_arg0, _arg1, _arg2)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(classes)
	runtime.KeepAlive(caps)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Bus gets the Bus of this DeviceMonitor.
//
// The function returns the following values:
//
//    - bus: Bus.
//
func (monitor *DeviceMonitor) Bus() *Bus {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret *C.GstBus           // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_bus(_arg0)
	runtime.KeepAlive(monitor)

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// Devices gets a list of devices from all of the relevant monitors. This may
// actually probe the hardware if the monitor is not currently started.
//
// The function returns the following values:
//
//    - list (optional) of Device.
//
func (monitor *DeviceMonitor) Devices() []Devicer {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret *C.GList            // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_devices(_arg0)
	runtime.KeepAlive(monitor)

	var _list []Devicer // out

	if _cret != nil {
		_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.GstDevice)(v)
			var dst Devicer // out
			{
				objptr := unsafe.Pointer(src)
				if objptr == nil {
					panic("object of type gst.Devicer is nil")
				}

				object := coreglib.AssumeOwnership(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Devicer)
					return ok
				})
				rv, ok := casted.(Devicer)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
				}
				dst = rv
			}
			_list = append(_list, dst)
		})
	}

	return _list
}

// Providers: get a list of the currently selected device provider factories.
//
// This.
//
// The function returns the following values:
//
//    - utf8s: A list of device provider factory names that are currently being
//      monitored by monitor or NULL when nothing is being monitored.
//
func (monitor *DeviceMonitor) Providers() []string {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret **C.gchar           // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_providers(_arg0)
	runtime.KeepAlive(monitor)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ShowAllDevices: get if monitor is currently showing all devices, even those
// from hidden providers.
//
// The function returns the following values:
//
//    - ok: TRUE when all devices will be shown.
//
func (monitor *DeviceMonitor) ShowAllDevices() bool {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_show_all_devices(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFilter removes a filter from the DeviceMonitor using the id that was
// returned by gst_device_monitor_add_filter().
//
// The function takes the following parameters:
//
//    - filterId: id of the filter.
//
// The function returns the following values:
//
//    - ok: TRUE of the filter id was valid, FALSE otherwise.
//
func (monitor *DeviceMonitor) RemoveFilter(filterId uint) bool {
	var _arg0 *C.GstDeviceMonitor // out
	var _arg1 C.guint             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.guint(filterId)

	_cret = C.gst_device_monitor_remove_filter(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(filterId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetShowAllDevices: set if all devices should be visible, even those devices
// from hidden providers. Setting show_all to true might show some devices
// multiple times.
//
// The function takes the following parameters:
//
//    - showAll: show all devices.
//
func (monitor *DeviceMonitor) SetShowAllDevices(showAll bool) {
	var _arg0 *C.GstDeviceMonitor // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	if showAll {
		_arg1 = C.TRUE
	}

	C.gst_device_monitor_set_show_all_devices(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(showAll)
}

// Start starts monitoring the devices, one this has succeeded, the
// GST_MESSAGE_DEVICE_ADDED and GST_MESSAGE_DEVICE_REMOVED messages will be
// emitted on the bus when the list of devices changes.
//
// The function returns the following values:
//
//    - ok: TRUE if the device monitoring could be started, i.e. at least a
//      single device provider was started successfully.
//
func (monitor *DeviceMonitor) Start() bool {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_start(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop stops monitoring the devices.
func (monitor *DeviceMonitor) Stop() {
	var _arg0 *C.GstDeviceMonitor // out

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	C.gst_device_monitor_stop(_arg0)
	runtime.KeepAlive(monitor)
}

// DeviceMonitorClass: opaque device monitor class structure.
//
// An instance of this type is always passed by reference.
type DeviceMonitorClass struct {
	*deviceMonitorClass
}

// deviceMonitorClass is the struct that's finalized.
type deviceMonitorClass struct {
	native *C.GstDeviceMonitorClass
}

// ParentClass: parent ObjectClass structure.
func (d *DeviceMonitorClass) ParentClass() *ObjectClass {
	valptr := &d.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
