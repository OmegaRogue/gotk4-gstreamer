// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeLockFlags       = coreglib.Type(C.gst_lock_flags_get_type())
	GTypeMiniObjectFlags = coreglib.Type(C.gst_mini_object_flags_get_type())
	GTypeMiniObject      = coreglib.Type(C.gst_mini_object_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeLockFlags, F: marshalLockFlags},
		coreglib.TypeMarshaler{T: GTypeMiniObjectFlags, F: marshalMiniObjectFlags},
		coreglib.TypeMarshaler{T: GTypeMiniObject, F: marshalMiniObject},
	})
}

// LockFlags flags used when locking miniobjects.
type LockFlags C.guint

const (
	// LockFlagRead: lock for read access.
	LockFlagRead LockFlags = 0b1
	// LockFlagWrite: lock for write access.
	LockFlagWrite LockFlags = 0b10
	// LockFlagExclusive: lock for exclusive access.
	LockFlagExclusive LockFlags = 0b100
	// LockFlagLast: first flag that can be used for custom purposes.
	LockFlagLast LockFlags = 0b100000000
)

func marshalLockFlags(p uintptr) (interface{}, error) {
	return LockFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for LockFlags.
func (l LockFlags) String() string {
	if l == 0 {
		return "LockFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(57)

	for l != 0 {
		next := l & (l - 1)
		bit := l - next

		switch bit {
		case LockFlagRead:
			builder.WriteString("Read|")
		case LockFlagWrite:
			builder.WriteString("Write|")
		case LockFlagExclusive:
			builder.WriteString("Exclusive|")
		case LockFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("LockFlags(0b%b)|", bit))
		}

		l = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if l contains other.
func (l LockFlags) Has(other LockFlags) bool {
	return (l & other) == other
}

// MiniObjectFlags flags for the mini object.
type MiniObjectFlags C.guint

const (
	// MiniObjectFlagLockable: object can be locked and unlocked with
	// gst_mini_object_lock() and gst_mini_object_unlock().
	MiniObjectFlagLockable MiniObjectFlags = 0b1
	// MiniObjectFlagLockReadonly: object is permanently locked in READONLY
	// mode. Only read locks can be performed on the object.
	MiniObjectFlagLockReadonly MiniObjectFlags = 0b10
	// MiniObjectFlagMayBeLeaked: object is expected to stay alive even after
	// gst_deinit() has been called and so should be ignored by leak detection
	// tools. (Since: 1.10).
	MiniObjectFlagMayBeLeaked MiniObjectFlags = 0b100
	// MiniObjectFlagLast: first flag that can be used by subclasses.
	MiniObjectFlagLast MiniObjectFlags = 0b10000
)

func marshalMiniObjectFlags(p uintptr) (interface{}, error) {
	return MiniObjectFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MiniObjectFlags.
func (m MiniObjectFlags) String() string {
	if m == 0 {
		return "MiniObjectFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MiniObjectFlagLockable:
			builder.WriteString("Lockable|")
		case MiniObjectFlagLockReadonly:
			builder.WriteString("LockReadonly|")
		case MiniObjectFlagMayBeLeaked:
			builder.WriteString("MayBeLeaked|")
		case MiniObjectFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("MiniObjectFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MiniObjectFlags) Has(other MiniObjectFlags) bool {
	return (m & other) == other
}

// MiniObjectNotify function can be added to a mini object as a callback that
// gets triggered when gst_mini_object_unref() drops the last ref and obj is
// about to be freed.
type MiniObjectNotify func(obj *MiniObject)

// MiniObject is a simple structure that can be used to implement refcounted
// types.
//
// Subclasses will include MiniObject as the first member in their structure and
// then call gst_mini_object_init() to initialize the MiniObject fields.
//
// gst_mini_object_ref() and gst_mini_object_unref() increment and decrement the
// refcount respectively. When the refcount of a mini-object reaches 0, the
// dispose function is called first and when this returns TRUE, the free
// function of the miniobject is called.
//
// A copy can be made with gst_mini_object_copy().
//
// gst_mini_object_is_writable() will return TRUE when the refcount of the
// object is exactly 1 and there is no parent or a single parent exists and is
// writable itself, meaning the current caller has the only reference to the
// object. gst_mini_object_make_writable() will return a writable version of the
// object, which might be a new copy when the refcount was not 1.
//
// Opaque data can be associated with a MiniObject with
// gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
// meant to be specific to the particular object and is not automatically copied
// with gst_mini_object_copy() or similar methods.
//
// A weak reference can be added and remove with gst_mini_object_weak_ref() and
// gst_mini_object_weak_unref() respectively.
//
// An instance of this type is always passed by reference.
type MiniObject struct {
	*miniObject
}

// miniObject is the struct that's finalized.
type miniObject struct {
	native *C.GstMiniObject
}

func marshalMiniObject(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MiniObject{&miniObject{(*C.GstMiniObject)(b)}}, nil
}

// AddParent: this adds parent as a parent for object. Having one ore more
// parents affects the writability of object: if a parent is not writable,
// object is also not writable, regardless of its refcount. object is only
// writable if all the parents are writable and its own refcount is exactly 1.
//
// Note: This function does not take ownership of parent and also does not take
// an additional reference. It is the responsibility of the caller to remove the
// parent again at a later time.
//
// The function takes the following parameters:
//
//    - parent MiniObject.
//
func (object *MiniObject) AddParent(parent *MiniObject) {
	var _arg0 *C.GstMiniObject // out
	var _arg1 *C.GstMiniObject // out

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(parent)))

	C.gst_mini_object_add_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)
}

// Qdata: this function gets back user data pointers stored via
// gst_mini_object_set_qdata().
//
// The function takes the following parameters:
//
//    - quark naming the user data pointer.
//
// The function returns the following values:
//
//    - gpointer (optional): user data pointer set, or NULL.
//
func (object *MiniObject) Qdata(quark glib.Quark) unsafe.Pointer {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GQuark         // out
	var _cret C.gpointer       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.guint32(quark)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_mini_object_get_qdata(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(quark)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// IsWritable: if mini_object has the LOCKABLE flag set, check if the current
// EXCLUSIVE lock on object is the only one, this means that changes to the
// object will not be visible to any other object.
//
// If the LOCKABLE flag is not set, check if the refcount of mini_object is
// exactly 1, meaning that no other reference exists to the object and that the
// object is therefore writable.
//
// Modification of a mini-object should only be done after verifying that it is
// writable.
//
// The function returns the following values:
//
//    - ok: TRUE if the object is writable.
//
func (miniObject *MiniObject) IsWritable() bool {
	var _arg0 *C.GstMiniObject // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(miniObject)))

	_cret = C.gst_mini_object_is_writable(_arg0)
	runtime.KeepAlive(miniObject)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lock the mini-object with the specified access mode in flags.
//
// The function takes the following parameters:
//
//    - flags: LockFlags.
//
// The function returns the following values:
//
//    - ok: TRUE if object could be locked.
//
func (object *MiniObject) Lock(flags LockFlags) bool {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GstLockFlags   // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.GstLockFlags(flags)

	_cret = C.gst_mini_object_lock(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveParent: this removes parent as a parent for object. See
// gst_mini_object_add_parent().
//
// The function takes the following parameters:
//
//    - parent MiniObject.
//
func (object *MiniObject) RemoveParent(parent *MiniObject) {
	var _arg0 *C.GstMiniObject // out
	var _arg1 *C.GstMiniObject // out

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(parent)))

	C.gst_mini_object_remove_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)
}

// StealQdata: this function gets back user data pointers stored via
// gst_mini_object_set_qdata() and removes the data from object without invoking
// its destroy() function (if any was set).
//
// The function takes the following parameters:
//
//    - quark naming the user data pointer.
//
// The function returns the following values:
//
//    - gpointer (optional): user data pointer set, or NULL.
//
func (object *MiniObject) StealQdata(quark glib.Quark) unsafe.Pointer {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GQuark         // out
	var _cret C.gpointer       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.guint32(quark)
	type _ = glib.Quark
	type _ = uint32

	_cret = C.gst_mini_object_steal_qdata(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(quark)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Unlock the mini-object with the specified access mode in flags.
//
// The function takes the following parameters:
//
//    - flags: LockFlags.
//
func (object *MiniObject) Unlock(flags LockFlags) {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GstLockFlags   // out

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.GstLockFlags(flags)

	C.gst_mini_object_unlock(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(flags)
}
