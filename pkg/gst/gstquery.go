// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeBufferingMode   = coreglib.Type(C.gst_buffering_mode_get_type())
	GTypeQueryType       = coreglib.Type(C.gst_query_type_get_type())
	GTypeQueryTypeFlags  = coreglib.Type(C.gst_query_type_flags_get_type())
	GTypeSchedulingFlags = coreglib.Type(C.gst_scheduling_flags_get_type())
	GTypeQuery           = coreglib.Type(C.gst_query_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBufferingMode, F: marshalBufferingMode},
		coreglib.TypeMarshaler{T: GTypeQueryType, F: marshalQueryType},
		coreglib.TypeMarshaler{T: GTypeQueryTypeFlags, F: marshalQueryTypeFlags},
		coreglib.TypeMarshaler{T: GTypeSchedulingFlags, F: marshalSchedulingFlags},
		coreglib.TypeMarshaler{T: GTypeQuery, F: marshalQuery},
	})
}

const QUERY_NUM_SHIFT = 8

// BufferingMode: different types of buffering methods.
type BufferingMode C.gint

const (
	// BufferingStream: small amount of data is buffered.
	BufferingStream BufferingMode = iota
	// BufferingDownload: stream is being downloaded.
	BufferingDownload
	// BufferingTimeshift: stream is being downloaded in a ringbuffer.
	BufferingTimeshift
	// BufferingLive: stream is a live stream.
	BufferingLive
)

func marshalBufferingMode(p uintptr) (interface{}, error) {
	return BufferingMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BufferingMode.
func (b BufferingMode) String() string {
	switch b {
	case BufferingStream:
		return "Stream"
	case BufferingDownload:
		return "Download"
	case BufferingTimeshift:
		return "Timeshift"
	case BufferingLive:
		return "Live"
	default:
		return fmt.Sprintf("BufferingMode(%d)", b)
	}
}

// QueryType: standard predefined Query types.
type QueryType C.gint

const (
	// QueryUnknown: unknown query type.
	QueryUnknown QueryType = 0
	// QueryPosition: current position in stream.
	QueryPosition QueryType = 2563
	// QueryDuration: total duration of the stream.
	QueryDuration QueryType = 5123
	// QueryLatency: latency of stream.
	QueryLatency QueryType = 7683
	// QueryJitter: current jitter of stream.
	QueryJitter QueryType = 10243
	// QueryRate: current rate of the stream.
	QueryRate QueryType = 12803
	// QuerySeeking: seeking capabilities.
	QuerySeeking QueryType = 15363
	// QuerySegment: segment start/stop positions.
	QuerySegment QueryType = 17923
	// QueryConvert: convert values between formats.
	QueryConvert QueryType = 20483
	// QueryFormats: query supported formats for convert.
	QueryFormats QueryType = 23043
	// QueryBuffering: query available media for efficient seeking.
	QueryBuffering QueryType = 28163
	// QueryCustom: custom application or element defined query.
	QueryCustom QueryType = 30723
	// QueryURI: query the URI of the source or sink.
	QueryURI QueryType = 33283
	// QueryAllocation: buffer allocation properties.
	QueryAllocation QueryType = 35846
	// QueryScheduling: scheduling properties.
	QueryScheduling QueryType = 38401
	// QueryAcceptCaps: accept caps query.
	QueryAcceptCaps QueryType = 40963
	// QueryCaps caps query.
	QueryCaps QueryType = 43523
	// QueryDrain: wait till all serialized data is consumed downstream.
	QueryDrain QueryType = 46086
	// QueryContext: query the pipeline-local context from downstream or
	// upstream (since 1.2).
	QueryContext QueryType = 48643
	// QueryBitrate: bitrate query (since 1.16).
	QueryBitrate QueryType = 51202
)

func marshalQueryType(p uintptr) (interface{}, error) {
	return QueryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for QueryType.
func (q QueryType) String() string {
	switch q {
	case QueryUnknown:
		return "Unknown"
	case QueryPosition:
		return "Position"
	case QueryDuration:
		return "Duration"
	case QueryLatency:
		return "Latency"
	case QueryJitter:
		return "Jitter"
	case QueryRate:
		return "Rate"
	case QuerySeeking:
		return "Seeking"
	case QuerySegment:
		return "Segment"
	case QueryConvert:
		return "Convert"
	case QueryFormats:
		return "Formats"
	case QueryBuffering:
		return "Buffering"
	case QueryCustom:
		return "Custom"
	case QueryURI:
		return "URI"
	case QueryAllocation:
		return "Allocation"
	case QueryScheduling:
		return "Scheduling"
	case QueryAcceptCaps:
		return "AcceptCaps"
	case QueryCaps:
		return "Caps"
	case QueryDrain:
		return "Drain"
	case QueryContext:
		return "Context"
	case QueryBitrate:
		return "Bitrate"
	default:
		return fmt.Sprintf("QueryType(%d)", q)
	}
}

// QueryTypeGetFlags gets the QueryTypeFlags associated with type.
//
// The function takes the following parameters:
//
//    - typ: QueryType.
//
// The function returns the following values:
//
//    - queryTypeFlags: QueryTypeFlags.
//
func QueryTypeGetFlags(typ QueryType) QueryTypeFlags {
	var _arg1 C.GstQueryType      // out
	var _cret C.GstQueryTypeFlags // in

	_arg1 = C.GstQueryType(typ)

	_cret = C.gst_query_type_get_flags(_arg1)
	runtime.KeepAlive(typ)

	var _queryTypeFlags QueryTypeFlags // out

	_queryTypeFlags = QueryTypeFlags(_cret)

	return _queryTypeFlags
}

// QueryTypeGetName: get a printable name for the given query type. Do not
// modify or free.
//
// The function takes the following parameters:
//
//    - typ: query type.
//
// The function returns the following values:
//
//    - utf8: reference to the static name of the query.
//
func QueryTypeGetName(typ QueryType) string {
	var _arg1 C.GstQueryType // out
	var _cret *C.gchar       // in

	_arg1 = C.GstQueryType(typ)

	_cret = C.gst_query_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// QueryTypeToQuark: get the unique quark for the given query type.
//
// The function takes the following parameters:
//
//    - typ: query type.
//
// The function returns the following values:
//
//    - quark associated with the query type.
//
func QueryTypeToQuark(typ QueryType) glib.Quark {
	var _arg1 C.GstQueryType // out
	var _cret C.GQuark       // in

	_arg1 = C.GstQueryType(typ)

	_cret = C.gst_query_type_to_quark(_arg1)
	runtime.KeepAlive(typ)

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// QueryTypeFlags indicate the aspects of the different QueryType values. You
// can get the type flags of a QueryType with the gst_query_type_get_flags()
// function.
type QueryTypeFlags C.guint

const (
	// QueryTypeUpstream: set if the query can travel upstream.
	QueryTypeUpstream QueryTypeFlags = 0b1
	// QueryTypeDownstream: set if the query can travel downstream.
	QueryTypeDownstream QueryTypeFlags = 0b10
	// QueryTypeSerialized: set if the query should be serialized with data
	// flow.
	QueryTypeSerialized QueryTypeFlags = 0b100
)

func marshalQueryTypeFlags(p uintptr) (interface{}, error) {
	return QueryTypeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for QueryTypeFlags.
func (q QueryTypeFlags) String() string {
	if q == 0 {
		return "QueryTypeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(57)

	for q != 0 {
		next := q & (q - 1)
		bit := q - next

		switch bit {
		case QueryTypeUpstream:
			builder.WriteString("Upstream|")
		case QueryTypeDownstream:
			builder.WriteString("Downstream|")
		case QueryTypeSerialized:
			builder.WriteString("Serialized|")
		default:
			builder.WriteString(fmt.Sprintf("QueryTypeFlags(0b%b)|", bit))
		}

		q = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if q contains other.
func (q QueryTypeFlags) Has(other QueryTypeFlags) bool {
	return (q & other) == other
}

// SchedulingFlags: different scheduling flags.
type SchedulingFlags C.guint

const (
	// SchedulingFlagSeekable: if seeking is possible.
	SchedulingFlagSeekable SchedulingFlags = 0b1
	// SchedulingFlagSequential: if sequential access is recommended.
	SchedulingFlagSequential SchedulingFlags = 0b10
	// SchedulingFlagBandwidthLimited: if bandwidth is limited and buffering
	// possible (since 1.2).
	SchedulingFlagBandwidthLimited SchedulingFlags = 0b100
)

func marshalSchedulingFlags(p uintptr) (interface{}, error) {
	return SchedulingFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SchedulingFlags.
func (s SchedulingFlags) String() string {
	if s == 0 {
		return "SchedulingFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(78)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SchedulingFlagSeekable:
			builder.WriteString("Seekable|")
		case SchedulingFlagSequential:
			builder.WriteString("Sequential|")
		case SchedulingFlagBandwidthLimited:
			builder.WriteString("BandwidthLimited|")
		default:
			builder.WriteString(fmt.Sprintf("SchedulingFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SchedulingFlags) Has(other SchedulingFlags) bool {
	return (s & other) == other
}

// Query queries can be performed on pads (gst_pad_query()) and elements
// (gst_element_query()). Please note that some queries might need a running
// pipeline to work.
//
// Queries can be created using the gst_query_new_*() functions. Query values
// can be set using gst_query_set_*(), and parsed using gst_query_parse_*()
// helpers.
//
// The following example shows how to query the duration of a pipeline:
//
//    GstQuery *query;
//    gboolean res;
//    query = gst_query_new_duration (GST_FORMAT_TIME);
//    res = gst_element_query (pipeline, query);
//    if (res) {
//      gint64 duration;
//      gst_query_parse_duration (query, NULL, &duration);
//      g_print ("duration = %"GST_TIME_FORMAT, GST_TIME_ARGS (duration));
//    } else {
//      g_print ("duration query failed...");
//    }
//    gst_query_unref (query);
//
// An instance of this type is always passed by reference.
type Query struct {
	*query
}

// query is the struct that's finalized.
type query struct {
	native *C.GstQuery
}

func marshalQuery(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Query{&query{(*C.GstQuery)(b)}}, nil
}

// NewQueryAcceptCaps constructs a struct Query.
func NewQueryAcceptCaps(caps *Caps) *Query {
	var _arg1 *C.GstCaps  // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_query_new_accept_caps(_arg1)
	runtime.KeepAlive(caps)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryAllocation constructs a struct Query.
func NewQueryAllocation(caps *Caps, needPool bool) *Query {
	var _arg1 *C.GstCaps  // out
	var _arg2 C.gboolean  // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	if needPool {
		_arg2 = C.TRUE
	}

	_cret = C.gst_query_new_allocation(_arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(needPool)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryBitrate constructs a struct Query.
func NewQueryBitrate() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_bitrate()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryBuffering constructs a struct Query.
func NewQueryBuffering(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_buffering(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryCaps constructs a struct Query.
func NewQueryCaps(filter *Caps) *Query {
	var _arg1 *C.GstCaps  // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C.gst_query_new_caps(_arg1)
	runtime.KeepAlive(filter)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryContext constructs a struct Query.
func NewQueryContext(contextType string) *Query {
	var _arg1 *C.gchar    // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_query_new_context(_arg1)
	runtime.KeepAlive(contextType)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryConvert constructs a struct Query.
func NewQueryConvert(srcFormat Format, value int64, destFormat Format) *Query {
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(value)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_query_new_convert(_arg1, _arg2, _arg3)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(value)
	runtime.KeepAlive(destFormat)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryCustom constructs a struct Query.
func NewQueryCustom(typ QueryType, structure *Structure) *Query {
	var _arg1 C.GstQueryType  // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstQuery     // in

	_arg1 = C.GstQueryType(typ)
	if structure != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	}

	_cret = C.gst_query_new_custom(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(structure)

	var _query *Query // out

	if _cret != nil {
		_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_query)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _query
}

// NewQueryDrain constructs a struct Query.
func NewQueryDrain() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_drain()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryDuration constructs a struct Query.
func NewQueryDuration(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_duration(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryFormats constructs a struct Query.
func NewQueryFormats() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_formats()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryLatency constructs a struct Query.
func NewQueryLatency() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_latency()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryPosition constructs a struct Query.
func NewQueryPosition(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_position(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryScheduling constructs a struct Query.
func NewQueryScheduling() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_scheduling()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQuerySeeking constructs a struct Query.
func NewQuerySeeking(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_seeking(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQuerySegment constructs a struct Query.
func NewQuerySegment(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_segment(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryURI constructs a struct Query.
func NewQueryURI() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_uri()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// MiniObject: parent MiniObject type.
func (q *Query) MiniObject() *MiniObject {
	valptr := &q.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Type: QueryType.
func (q *Query) Type() QueryType {
	valptr := &q.native._type
	var _v QueryType // out
	_v = QueryType(*valptr)
	return _v
}

// AddAllocationMeta: add api with params as one of the supported metadata API
// to query.
//
// The function takes the following parameters:
//
//    - api: metadata API.
//    - params (optional): API specific parameters.
//
func (query *Query) AddAllocationMeta(api coreglib.Type, params *Structure) {
	var _arg0 *C.GstQuery     // out
	var _arg1 C.GType         // out
	var _arg2 *C.GstStructure // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GType(api)
	if params != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_query_add_allocation_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(api)
	runtime.KeepAlive(params)
}

// AddAllocationParam: add allocator and its params as a supported memory
// allocator.
//
// The function takes the following parameters:
//
//    - allocator (optional): memory allocator.
//    - params (optional): AllocationParams.
//
func (query *Query) AddAllocationParam(allocator Allocatorrer, params *AllocationParams) {
	var _arg0 *C.GstQuery            // out
	var _arg1 *C.GstAllocator        // out
	var _arg2 *C.GstAllocationParams // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if allocator != nil {
		_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_query_add_allocation_param(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// AddAllocationPool: set the pool parameters in query.
//
// The function takes the following parameters:
//
//    - pool (optional): BufferPool.
//    - size: buffer size.
//    - minBuffers: min buffers.
//    - maxBuffers: max buffers.
//
func (query *Query) AddAllocationPool(pool *BufferPool, size uint, minBuffers uint, maxBuffers uint) {
	var _arg0 *C.GstQuery      // out
	var _arg1 *C.GstBufferPool // out
	var _arg2 C.guint          // out
	var _arg3 C.guint          // out
	var _arg4 C.guint          // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if pool != nil {
		_arg1 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	}
	_arg2 = C.guint(size)
	_arg3 = C.guint(minBuffers)
	_arg4 = C.guint(maxBuffers)

	C.gst_query_add_allocation_pool(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)
}

// AddBufferingRange: set the buffering-ranges array field in query. The current
// last start position of the array should be inferior to start.
//
// The function takes the following parameters:
//
//    - start position of the range.
//    - stop position of the range.
//
// The function returns the following values:
//
//    - ok indicating if the range was added or not.
//
func (query *Query) AddBufferingRange(start int64, stop int64) bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gint64    // out
	var _arg2 C.gint64    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.gint64(start)
	_arg2 = C.gint64(stop)

	_cret = C.gst_query_add_buffering_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddSchedulingMode: add mode as one of the supported scheduling modes to
// query.
//
// The function takes the following parameters:
//
//    - mode: PadMode.
//
func (query *Query) AddSchedulingMode(mode PadMode) {
	var _arg0 *C.GstQuery  // out
	var _arg1 C.GstPadMode // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstPadMode(mode)

	C.gst_query_add_scheduling_mode(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)
}

// FindAllocationMeta: check if query has metadata api set. When this function
// returns TRUE, index will contain the index where the requested API and the
// parameters can be found.
//
// The function takes the following parameters:
//
//    - api: metadata API.
//
// The function returns the following values:
//
//    - index (optional): index.
//    - ok: TRUE when api is in the list of metadata.
//
func (query *Query) FindAllocationMeta(api coreglib.Type) (uint, bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GType     // out
	var _arg2 C.guint     // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GType(api)

	_cret = C.gst_query_find_allocation_meta(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(api)

	var _index uint // out
	var _ok bool    // out

	_index = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _index, _ok
}

// NAllocationMetas: retrieve the number of values currently stored in the meta
// API array of the query's structure.
//
// The function returns the following values:
//
//    - guint: metadata API array size as a #guint.
//
func (query *Query) NAllocationMetas() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_allocation_metas(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NAllocationParams: retrieve the number of values currently stored in the
// allocator params array of the query's structure.
//
// If no memory allocator is specified, the downstream element can handle the
// default memory allocator. The first memory allocator in the query should be
// generic and allow mapping to system memory, all following allocators should
// be ordered by preference with the preferred one first.
//
// The function returns the following values:
//
//    - guint: allocator array size as a #guint.
//
func (query *Query) NAllocationParams() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_allocation_params(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NAllocationPools: retrieve the number of values currently stored in the pool
// array of the query's structure.
//
// The function returns the following values:
//
//    - guint: pool array size as a #guint.
//
func (query *Query) NAllocationPools() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_allocation_pools(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NBufferingRanges: retrieve the number of values currently stored in the
// buffered-ranges array of the query's structure.
//
// The function returns the following values:
//
//    - guint: range array size as a #guint.
//
func (query *Query) NBufferingRanges() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_buffering_ranges(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NSchedulingModes: retrieve the number of values currently stored in the
// scheduling mode array of the query's structure.
//
// The function returns the following values:
//
//    - guint: scheduling mode array size as a #guint.
//
func (query *Query) NSchedulingModes() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_scheduling_modes(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Structure: get the structure of a query.
//
// The function returns the following values:
//
//    - structure (optional) of the query. The structure is still owned by the
//      query and will therefore be freed when the query is unreffed.
//
func (query *Query) Structure() *Structure {
	var _arg0 *C.GstQuery     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_structure(_arg0)
	runtime.KeepAlive(query)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// HasSchedulingMode: check if query has scheduling mode set.
//
// > When checking if upstream supports pull mode, it is usually not > enough to
// just check for GST_PAD_MODE_PULL with this function, you > also want to check
// whether the scheduling flags returned by > gst_query_parse_scheduling() have
// the seeking flag set (meaning > random access is supported, not only
// sequential pulls).
//
// The function takes the following parameters:
//
//    - mode: scheduling mode.
//
// The function returns the following values:
//
//    - ok: TRUE when mode is in the list of scheduling modes.
//
func (query *Query) HasSchedulingMode(mode PadMode) bool {
	var _arg0 *C.GstQuery  // out
	var _arg1 C.GstPadMode // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstPadMode(mode)

	_cret = C.gst_query_has_scheduling_mode(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasSchedulingModeWithFlags: check if query has scheduling mode set and flags
// is set in query scheduling flags.
//
// The function takes the following parameters:
//
//    - mode: scheduling mode.
//    - flags: SchedulingFlags.
//
// The function returns the following values:
//
//    - ok: TRUE when mode is in the list of scheduling modes and flags are
//      compatible with query flags.
//
func (query *Query) HasSchedulingModeWithFlags(mode PadMode, flags SchedulingFlags) bool {
	var _arg0 *C.GstQuery          // out
	var _arg1 C.GstPadMode         // out
	var _arg2 C.GstSchedulingFlags // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstPadMode(mode)
	_arg2 = C.GstSchedulingFlags(flags)

	_cret = C.gst_query_has_scheduling_mode_with_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseAcceptCaps: get the caps from query. The caps remains valid as long as
// query remains valid.
//
// The function returns the following values:
//
//    - caps: pointer to the caps.
//
func (query *Query) ParseAcceptCaps() *Caps {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_accept_caps(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _caps
}

// ParseAcceptCapsResult: parse the result from query and store in result.
//
// The function returns the following values:
//
//    - result (optional): location for the result.
//
func (query *Query) ParseAcceptCapsResult() bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_accept_caps_result(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _result bool // out

	if _arg1 != 0 {
		_result = true
	}

	return _result
}

// ParseAllocation: parse an allocation query, writing the requested caps in
// caps and whether a pool is needed in need_pool, if the respective parameters
// are non-NULL.
//
// Pool details can be retrieved using gst_query_get_n_allocation_pools() and
// gst_query_parse_nth_allocation_pool().
//
// The function returns the following values:
//
//    - caps (optional): Caps.
//    - needPool (optional): whether a BufferPool is needed.
//
func (query *Query) ParseAllocation() (*Caps, bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in
	var _arg2 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_allocation(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _caps *Caps    // out
	var _needPool bool // out

	if _arg1 != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}
	if _arg2 != 0 {
		_needPool = true
	}

	return _caps, _needPool
}

// ParseBitrate: get the results of a bitrate query. See also
// gst_query_set_bitrate().
//
// The function returns the following values:
//
//    - nominalBitrate (optional): resulting bitrate in bits per second.
//
func (query *Query) ParseBitrate() uint {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_bitrate(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _nominalBitrate uint // out

	_nominalBitrate = uint(_arg1)

	return _nominalBitrate
}

// ParseBufferingPercent: get the percentage of buffered data. This is a value
// between 0 and 100. The busy indicator is TRUE when the buffering is in
// progress.
//
// The function returns the following values:
//
//    - busy (optional): if buffering is busy, or NULL.
//    - percent (optional): buffering percent, or NULL.
//
func (query *Query) ParseBufferingPercent() (bool, int) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_buffering_percent(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _busy bool   // out
	var _percent int // out

	if _arg1 != 0 {
		_busy = true
	}
	_percent = int(_arg2)

	return _busy, _percent
}

// ParseBufferingRange: parse an available query, writing the format into
// format, and other results into the passed parameters, if the respective
// parameters are non-NULL.
//
// The function returns the following values:
//
//    - format (optional) to set for the segment_start and segment_end values, or
//      NULL.
//    - start (optional) to set, or NULL.
//    - stop (optional) to set, or NULL.
//    - estimatedTotal (optional): estimated total amount of download time
//      remaining in milliseconds, or NULL.
//
func (query *Query) ParseBufferingRange() (format Format, start int64, stop int64, estimatedTotal int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in
	var _arg3 C.gint64    // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_buffering_range(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _format Format        // out
	var _start int64          // out
	var _stop int64           // out
	var _estimatedTotal int64 // out

	_format = Format(_arg1)
	_start = int64(_arg2)
	_stop = int64(_arg3)
	_estimatedTotal = int64(_arg4)

	return _format, _start, _stop, _estimatedTotal
}

// ParseBufferingStats extracts the buffering stats values from query.
//
// The function returns the following values:
//
//    - mode (optional): buffering mode, or NULL.
//    - avgIn (optional): average input rate, or NULL.
//    - avgOut (optional): average output rat, or NULL.
//    - bufferingLeft (optional): amount of buffering time left in milliseconds,
//      or NULL.
//
func (query *Query) ParseBufferingStats() (mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstQuery        // out
	var _arg1 C.GstBufferingMode // in
	var _arg2 C.gint             // in
	var _arg3 C.gint             // in
	var _arg4 C.gint64           // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_buffering_stats(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _mode BufferingMode  // out
	var _avgIn int           // out
	var _avgOut int          // out
	var _bufferingLeft int64 // out

	_mode = BufferingMode(_arg1)
	_avgIn = int(_arg2)
	_avgOut = int(_arg3)
	_bufferingLeft = int64(_arg4)

	return _mode, _avgIn, _avgOut, _bufferingLeft
}

// ParseCaps: get the filter from the caps query. The caps remains valid as long
// as query remains valid.
//
// The function returns the following values:
//
//    - filter: pointer to the caps filter.
//
func (query *Query) ParseCaps() *Caps {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_caps(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _filter *Caps // out

	_filter = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _filter
}

// ParseCapsResult: get the caps result from query. The caps remains valid as
// long as query remains valid.
//
// The function returns the following values:
//
//    - caps: pointer to the caps.
//
func (query *Query) ParseCapsResult() *Caps {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_caps_result(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _caps
}

// ParseContext: get the context from the context query. The context remains
// valid as long as query remains valid.
//
// The function returns the following values:
//
//    - context: pointer to store the Context.
//
func (query *Query) ParseContext() *Context {
	var _arg0 *C.GstQuery   // out
	var _arg1 *C.GstContext // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_context(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _context *Context // out

	_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _context
}

// ParseContextType: parse a context type from an existing GST_QUERY_CONTEXT
// query.
//
// The function returns the following values:
//
//    - contextType (optional): context type, or NULL.
//    - ok indicating if the parsing succeeded.
//
func (query *Query) ParseContextType() (string, bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_parse_context_type(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _contextType string // out
	var _ok bool            // out

	if _arg1 != nil {
		_contextType = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _contextType, _ok
}

// ParseConvert: parse a convert query answer. Any of src_format, src_value,
// dest_format, and dest_value may be NULL, in which case that value is omitted.
//
// The function returns the following values:
//
//    - srcFormat (optional): storage for the Format of the source value, or
//      NULL.
//    - srcValue (optional): storage for the source value, or NULL.
//    - destFormat (optional): storage for the Format of the destination value,
//      or NULL.
//    - destValue (optional): storage for the destination value, or NULL.
//
func (query *Query) ParseConvert() (srcFormat Format, srcValue int64, destFormat Format, destValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in
	var _arg3 C.GstFormat // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_convert(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _srcFormat Format  // out
	var _srcValue int64    // out
	var _destFormat Format // out
	var _destValue int64   // out

	_srcFormat = Format(_arg1)
	_srcValue = int64(_arg2)
	_destFormat = Format(_arg3)
	_destValue = int64(_arg4)

	return _srcFormat, _srcValue, _destFormat, _destValue
}

// ParseDuration: parse a duration query answer. Write the format of the
// duration into format, and the value into duration, if the respective
// variables are non-NULL.
//
// The function returns the following values:
//
//    - format (optional): storage for the Format of the duration value, or NULL.
//    - duration (optional): storage for the total duration, or NULL.
//
func (query *Query) ParseDuration() (Format, int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_duration(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _format Format  // out
	var _duration int64 // out

	_format = Format(_arg1)
	_duration = int64(_arg2)

	return _format, _duration
}

// ParseLatency: parse a latency query answer.
//
// The function returns the following values:
//
//    - live (optional): storage for live or NULL.
//    - minLatency (optional): storage for the min latency or NULL.
//    - maxLatency (optional): storage for the max latency or NULL.
//
func (query *Query) ParseLatency() (live bool, minLatency ClockTime, maxLatency ClockTime) {
	var _arg0 *C.GstQuery    // out
	var _arg1 C.gboolean     // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_latency(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)

	var _live bool            // out
	var _minLatency ClockTime // out
	var _maxLatency ClockTime // out

	if _arg1 != 0 {
		_live = true
	}
	_minLatency = uint64(_arg2)
	type _ = ClockTime
	type _ = uint64
	_maxLatency = uint64(_arg3)
	type _ = ClockTime
	type _ = uint64

	return _live, _minLatency, _maxLatency
}

// ParseNFormats: parse the number of formats in the formats query.
//
// The function returns the following values:
//
//    - nFormats (optional): number of formats in this query.
//
func (query *Query) ParseNFormats() uint {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_n_formats(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _nFormats uint // out

	_nFormats = uint(_arg1)

	return _nFormats
}

// ParseNthAllocationMeta: parse an available query and get the metadata API at
// index of the metadata API array.
//
// The function takes the following parameters:
//
//    - index: position in the metadata API array to read.
//
// The function returns the following values:
//
//    - params (optional): API specific parameters.
//    - gType of the metadata API at index.
//
func (query *Query) ParseNthAllocationMeta(index uint) (*Structure, coreglib.Type) {
	var _arg0 *C.GstQuery     // out
	var _arg1 C.guint         // out
	var _arg2 *C.GstStructure // in
	var _cret C.GType         // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	_cret = C.gst_query_parse_nth_allocation_meta(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _params *Structure   // out
	var _gType coreglib.Type // out

	if _arg2 != nil {
		_params = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	}
	_gType = coreglib.Type(_cret)

	return _params, _gType
}

// ParseNthAllocationParam: parse an available query and get the allocator and
// its params at index of the allocator array.
//
// The function takes the following parameters:
//
//    - index: position in the allocator array to read.
//
// The function returns the following values:
//
//    - allocator (optional): variable to hold the result.
//    - params (optional) parameters for the allocator.
//
func (query *Query) ParseNthAllocationParam(index uint) (Allocatorrer, *AllocationParams) {
	var _arg0 *C.GstQuery           // out
	var _arg1 C.guint               // out
	var _arg2 *C.GstAllocator       // in
	var _arg3 C.GstAllocationParams // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_parse_nth_allocation_param(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _allocator Allocatorrer   // out
	var _params *AllocationParams // out

	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Allocatorrer)
				return ok
			})
			rv, ok := casted.(Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _allocator, _params
}

// ParseNthAllocationPool: get the pool parameters in query.
//
// Unref pool with gst_object_unref() when it's not needed any more.
//
// The function takes the following parameters:
//
//    - index to parse.
//
// The function returns the following values:
//
//    - pool (optional): BufferPool.
//    - size (optional): buffer size.
//    - minBuffers (optional): min buffers.
//    - maxBuffers (optional): max buffers.
//
func (query *Query) ParseNthAllocationPool(index uint) (pool *BufferPool, size uint, minBuffers uint, maxBuffers uint) {
	var _arg0 *C.GstQuery      // out
	var _arg1 C.guint          // out
	var _arg2 *C.GstBufferPool // in
	var _arg3 C.guint          // in
	var _arg4 C.guint          // in
	var _arg5 C.guint          // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_parse_nth_allocation_pool(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _pool *BufferPool // out
	var _size uint        // out
	var _minBuffers uint  // out
	var _maxBuffers uint  // out

	if _arg2 != nil {
		_pool = wrapBufferPool(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	}
	_size = uint(_arg3)
	_minBuffers = uint(_arg4)
	_maxBuffers = uint(_arg5)

	return _pool, _size, _minBuffers, _maxBuffers
}

// ParseNthBufferingRange: parse an available query and get the start and stop
// values stored at the index of the buffered ranges array.
//
// The function takes the following parameters:
//
//    - index: position in the buffered-ranges array to read.
//
// The function returns the following values:
//
//    - start (optional) position to set, or NULL.
//    - stop (optional) position to set, or NULL.
//    - ok indicating if the parsing succeeded.
//
func (query *Query) ParseNthBufferingRange(index uint) (start int64, stop int64, ok bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out
	var _arg2 C.gint64    // in
	var _arg3 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	_cret = C.gst_query_parse_nth_buffering_range(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _start int64 // out
	var _stop int64  // out
	var _ok bool     // out

	_start = int64(_arg2)
	_stop = int64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _start, _stop, _ok
}

// ParseNthFormat: parse the format query and retrieve the nth format from it
// into format. If the list contains less elements than nth, format will be set
// to GST_FORMAT_UNDEFINED.
//
// The function takes the following parameters:
//
//    - nth format to retrieve.
//
// The function returns the following values:
//
//    - format (optional): pointer to store the nth format.
//
func (query *Query) ParseNthFormat(nth uint) Format {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out
	var _arg2 C.GstFormat // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(nth)

	C.gst_query_parse_nth_format(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(nth)

	var _format Format // out

	_format = Format(_arg2)

	return _format
}

// ParseNthSchedulingMode: parse an available query and get the scheduling mode
// at index of the scheduling modes array.
//
// The function takes the following parameters:
//
//    - index: position in the scheduling modes array to read.
//
// The function returns the following values:
//
//    - padMode of the scheduling mode at index.
//
func (query *Query) ParseNthSchedulingMode(index uint) PadMode {
	var _arg0 *C.GstQuery  // out
	var _arg1 C.guint      // out
	var _cret C.GstPadMode // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	_cret = C.gst_query_parse_nth_scheduling_mode(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _padMode PadMode // out

	_padMode = PadMode(_cret)

	return _padMode
}

// ParsePosition: parse a position query, writing the format into format, and
// the position into cur, if the respective parameters are non-NULL.
//
// The function returns the following values:
//
//    - format (optional): storage for the Format of the position values (may be
//      NULL).
//    - cur (optional): storage for the current position (may be NULL).
//
func (query *Query) ParsePosition() (Format, int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _format Format // out
	var _cur int64     // out

	_format = Format(_arg1)
	_cur = int64(_arg2)

	return _format, _cur
}

// ParseScheduling: set the scheduling properties.
//
// The function returns the following values:
//
//    - flags (optional): SchedulingFlags.
//    - minsize (optional): suggested minimum size of pull requests.
//    - maxsize (optional): suggested maximum size of pull requests:.
//    - align (optional): suggested alignment of pull requests.
//
func (query *Query) ParseScheduling() (flags SchedulingFlags, minsize int, maxsize int, align int) {
	var _arg0 *C.GstQuery          // out
	var _arg1 C.GstSchedulingFlags // in
	var _arg2 C.gint               // in
	var _arg3 C.gint               // in
	var _arg4 C.gint               // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_scheduling(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _flags SchedulingFlags // out
	var _minsize int           // out
	var _maxsize int           // out
	var _align int             // out

	_flags = SchedulingFlags(_arg1)
	_minsize = int(_arg2)
	_maxsize = int(_arg3)
	_align = int(_arg4)

	return _flags, _minsize, _maxsize, _align
}

// ParseSeeking: parse a seeking query, writing the format into format, and
// other results into the passed parameters, if the respective parameters are
// non-NULL.
//
// The function returns the following values:
//
//    - format (optional) to set for the segment_start and segment_end values, or
//      NULL.
//    - seekable (optional) flag to set, or NULL.
//    - segmentStart (optional): segment_start to set, or NULL.
//    - segmentEnd (optional): segment_end to set, or NULL.
//
func (query *Query) ParseSeeking() (format Format, seekable bool, segmentStart int64, segmentEnd int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gboolean  // in
	var _arg3 C.gint64    // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_seeking(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _format Format      // out
	var _seekable bool      // out
	var _segmentStart int64 // out
	var _segmentEnd int64   // out

	_format = Format(_arg1)
	if _arg2 != 0 {
		_seekable = true
	}
	_segmentStart = int64(_arg3)
	_segmentEnd = int64(_arg4)

	return _format, _seekable, _segmentStart, _segmentEnd
}

// ParseSegment: parse a segment query answer. Any of rate, format, start_value,
// and stop_value may be NULL, which will cause this value to be omitted.
//
// See gst_query_set_segment() for an explanation of the function arguments.
//
// The function returns the following values:
//
//    - rate (optional): storage for the rate of the segment, or NULL.
//    - format (optional): storage for the Format of the values, or NULL.
//    - startValue (optional): storage for the start value, or NULL.
//    - stopValue (optional): storage for the stop value, or NULL.
//
func (query *Query) ParseSegment() (rate float64, format Format, startValue int64, stopValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gdouble   // in
	var _arg2 C.GstFormat // in
	var _arg3 C.gint64    // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_segment(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _rate float64     // out
	var _format Format    // out
	var _startValue int64 // out
	var _stopValue int64  // out

	_rate = float64(_arg1)
	_format = Format(_arg2)
	_startValue = int64(_arg3)
	_stopValue = int64(_arg4)

	return _rate, _format, _startValue, _stopValue
}

// ParseURI: parse an URI query, writing the URI into uri as a newly allocated
// string, if the respective parameters are non-NULL. Free the string with
// g_free() after usage.
//
// The function returns the following values:
//
//    - uri (optional): storage for the current URI (may be NULL).
//
func (query *Query) ParseURI() string {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_uri(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _uri string // out

	if _arg1 != nil {
		_uri = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	return _uri
}

// ParseURIRedirection: parse an URI query, writing the URI into uri as a newly
// allocated string, if the respective parameters are non-NULL. Free the string
// with g_free() after usage.
//
// The function returns the following values:
//
//    - uri (optional): storage for the redirect URI (may be NULL).
//
func (query *Query) ParseURIRedirection() string {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_uri_redirection(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _uri string // out

	if _arg1 != nil {
		_uri = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	return _uri
}

// ParseURIRedirectionPermanent: parse an URI query, and set permanent to TRUE
// if there is a redirection and it should be considered permanent. If a
// redirection is permanent, applications should update their internal storage
// of the URI, otherwise they should make all future requests to the original
// URI.
//
// The function returns the following values:
//
//    - permanent (optional): if the URI redirection is permanent (may be NULL).
//
func (query *Query) ParseURIRedirectionPermanent() bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_uri_redirection_permanent(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _permanent bool // out

	if _arg1 != 0 {
		_permanent = true
	}

	return _permanent
}

// RemoveNthAllocationMeta: remove the metadata API at index of the metadata API
// array.
//
// The function takes the following parameters:
//
//    - index: position in the metadata API array to remove.
//
func (query *Query) RemoveNthAllocationMeta(index uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_remove_nth_allocation_meta(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
}

// RemoveNthAllocationParam: remove the allocation param at index of the
// allocation param array.
//
// The function takes the following parameters:
//
//    - index: position in the allocation param array to remove.
//
func (query *Query) RemoveNthAllocationParam(index uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_remove_nth_allocation_param(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
}

// RemoveNthAllocationPool: remove the allocation pool at index of the
// allocation pool array.
//
// The function takes the following parameters:
//
//    - index: position in the allocation pool array to remove.
//
func (query *Query) RemoveNthAllocationPool(index uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_remove_nth_allocation_pool(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
}

// SetAcceptCapsResult: set result as the result for the query.
//
// The function takes the following parameters:
//
//    - result to set.
//
func (query *Query) SetAcceptCapsResult(result bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if result {
		_arg1 = C.TRUE
	}

	C.gst_query_set_accept_caps_result(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(result)
}

// SetBitrate: set the results of a bitrate query. The nominal bitrate is the
// average bitrate expected over the length of the stream as advertised in file
// headers (or similar).
//
// The function takes the following parameters:
//
//    - nominalBitrate: nominal bitrate in bits per second.
//
func (query *Query) SetBitrate(nominalBitrate uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(nominalBitrate)

	C.gst_query_set_bitrate(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(nominalBitrate)
}

// SetBufferingPercent: set the percentage of buffered data. This is a value
// between 0 and 100. The busy indicator is TRUE when the buffering is in
// progress.
//
// The function takes the following parameters:
//
//    - busy: if buffering is busy.
//    - percent: buffering percent.
//
func (query *Query) SetBufferingPercent(busy bool, percent int) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out
	var _arg2 C.gint      // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if busy {
		_arg1 = C.TRUE
	}
	_arg2 = C.gint(percent)

	C.gst_query_set_buffering_percent(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(busy)
	runtime.KeepAlive(percent)
}

// SetBufferingRange: set the available query result fields in query.
//
// The function takes the following parameters:
//
//    - format to set for the start and stop values.
//    - start to set.
//    - stop to set.
//    - estimatedTotal: estimated total amount of download time remaining in
//      milliseconds.
//
func (query *Query) SetBufferingRange(format Format, start int64, stop int64, estimatedTotal int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.gint64    // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(start)
	_arg3 = C.gint64(stop)
	_arg4 = C.gint64(estimatedTotal)

	C.gst_query_set_buffering_range(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)
	runtime.KeepAlive(estimatedTotal)
}

// SetBufferingStats configures the buffering stats values in query.
//
// The function takes the following parameters:
//
//    - mode: buffering mode.
//    - avgIn: average input rate.
//    - avgOut: average output rate.
//    - bufferingLeft: amount of buffering time left in milliseconds.
//
func (query *Query) SetBufferingStats(mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstQuery        // out
	var _arg1 C.GstBufferingMode // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // out
	var _arg4 C.gint64           // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstBufferingMode(mode)
	_arg2 = C.gint(avgIn)
	_arg3 = C.gint(avgOut)
	_arg4 = C.gint64(bufferingLeft)

	C.gst_query_set_buffering_stats(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(avgIn)
	runtime.KeepAlive(avgOut)
	runtime.KeepAlive(bufferingLeft)
}

// SetCapsResult: set the caps result in query.
//
// The function takes the following parameters:
//
//    - caps: pointer to the caps.
//
func (query *Query) SetCapsResult(caps *Caps) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_query_set_caps_result(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(caps)
}

// SetContext: answer a context query by setting the requested context.
//
// The function takes the following parameters:
//
//    - context: requested Context.
//
func (query *Query) SetContext(context *Context) {
	var _arg0 *C.GstQuery   // out
	var _arg1 *C.GstContext // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.gst_query_set_context(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(context)
}

// SetConvert: answer a convert query by setting the requested values.
//
// The function takes the following parameters:
//
//    - srcFormat: source Format.
//    - srcValue: source value.
//    - destFormat: destination Format.
//    - destValue: destination value.
//
func (query *Query) SetConvert(srcFormat Format, srcValue int64, destFormat Format, destValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcValue)
	_arg3 = C.GstFormat(destFormat)
	_arg4 = C.gint64(destValue)

	C.gst_query_set_convert(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcValue)
	runtime.KeepAlive(destFormat)
	runtime.KeepAlive(destValue)
}

// SetDuration: answer a duration query by setting the requested value in the
// given format.
//
// The function takes the following parameters:
//
//    - format for the duration.
//    - duration of the stream.
//
func (query *Query) SetDuration(format Format, duration int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(duration)

	C.gst_query_set_duration(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(duration)
}

// SetFormatsv: set the formats query result fields in query. The number of
// formats passed in the formats array must be equal to n_formats.
//
// The function takes the following parameters:
//
//    - formats: array containing n_formats GstFormat values.
//
func (query *Query) SetFormatsv(formats []Format) {
	var _arg0 *C.GstQuery  // out
	var _arg2 *C.GstFormat // out
	var _arg1 C.gint

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (C.gint)(len(formats))
	if len(formats) > 0 {
		_arg2 = (*C.GstFormat)(unsafe.Pointer(&formats[0]))
	}

	C.gst_query_set_formatsv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(formats)
}

// SetLatency: answer a latency query by setting the requested values in the
// given format.
//
// The function takes the following parameters:
//
//    - live: if there is a live element upstream.
//    - minLatency: minimal latency of the upstream elements.
//    - maxLatency: maximal latency of the upstream elements.
//
func (query *Query) SetLatency(live bool, minLatency ClockTime, maxLatency ClockTime) {
	var _arg0 *C.GstQuery    // out
	var _arg1 C.gboolean     // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if live {
		_arg1 = C.TRUE
	}
	_arg2 = C.guint64(minLatency)
	type _ = ClockTime
	type _ = uint64
	_arg3 = C.guint64(maxLatency)
	type _ = ClockTime
	type _ = uint64

	C.gst_query_set_latency(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(live)
	runtime.KeepAlive(minLatency)
	runtime.KeepAlive(maxLatency)
}

// SetNthAllocationParam: parse an available query and get the allocator and its
// params at index of the allocator array.
//
// The function takes the following parameters:
//
//    - index: position in the allocator array to set.
//    - allocator (optional): new allocator to set.
//    - params (optional) parameters for the allocator.
//
func (query *Query) SetNthAllocationParam(index uint, allocator Allocatorrer, params *AllocationParams) {
	var _arg0 *C.GstQuery            // out
	var _arg1 C.guint                // out
	var _arg2 *C.GstAllocator        // out
	var _arg3 *C.GstAllocationParams // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)
	if allocator != nil {
		_arg2 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_query_set_nth_allocation_param(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// SetNthAllocationPool: set the pool parameters in query.
//
// The function takes the following parameters:
//
//    - index to modify.
//    - pool (optional): BufferPool.
//    - size: buffer size.
//    - minBuffers: min buffers.
//    - maxBuffers: max buffers.
//
func (query *Query) SetNthAllocationPool(index uint, pool *BufferPool, size uint, minBuffers uint, maxBuffers uint) {
	var _arg0 *C.GstQuery      // out
	var _arg1 C.guint          // out
	var _arg2 *C.GstBufferPool // out
	var _arg3 C.guint          // out
	var _arg4 C.guint          // out
	var _arg5 C.guint          // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)
	if pool != nil {
		_arg2 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	}
	_arg3 = C.guint(size)
	_arg4 = C.guint(minBuffers)
	_arg5 = C.guint(maxBuffers)

	C.gst_query_set_nth_allocation_pool(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)
}

// SetPosition: answer a position query by setting the requested value in the
// given format.
//
// The function takes the following parameters:
//
//    - format: requested Format.
//    - cur: position to set.
//
func (query *Query) SetPosition(format Format, cur int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(cur)

	C.gst_query_set_position(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(cur)
}

// SetScheduling: set the scheduling properties.
//
// The function takes the following parameters:
//
//    - flags: SchedulingFlags.
//    - minsize: suggested minimum size of pull requests.
//    - maxsize: suggested maximum size of pull requests.
//    - align: suggested alignment of pull requests.
//
func (query *Query) SetScheduling(flags SchedulingFlags, minsize int, maxsize int, align int) {
	var _arg0 *C.GstQuery          // out
	var _arg1 C.GstSchedulingFlags // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.gint               // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstSchedulingFlags(flags)
	_arg2 = C.gint(minsize)
	_arg3 = C.gint(maxsize)
	_arg4 = C.gint(align)

	C.gst_query_set_scheduling(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(minsize)
	runtime.KeepAlive(maxsize)
	runtime.KeepAlive(align)
}

// SetSeeking: set the seeking query result fields in query.
//
// The function takes the following parameters:
//
//    - format to set for the segment_start and segment_end values.
//    - seekable flag to set.
//    - segmentStart: segment_start to set.
//    - segmentEnd: segment_end to set.
//
func (query *Query) SetSeeking(format Format, seekable bool, segmentStart int64, segmentEnd int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gboolean  // out
	var _arg3 C.gint64    // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	if seekable {
		_arg2 = C.TRUE
	}
	_arg3 = C.gint64(segmentStart)
	_arg4 = C.gint64(segmentEnd)

	C.gst_query_set_seeking(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(segmentStart)
	runtime.KeepAlive(segmentEnd)
}

// SetSegment: answer a segment query by setting the requested values. The
// normal playback segment of a pipeline is 0 to duration at the default rate of
// 1.0. If a seek was performed on the pipeline to play a different segment,
// this query will return the range specified in the last seek.
//
// start_value and stop_value will respectively contain the configured playback
// range start and stop values expressed in format. The values are always
// between 0 and the duration of the media and start_value <= stop_value. rate
// will contain the playback rate. For negative rates, playback will actually
// happen from stop_value to start_value.
//
// The function takes the following parameters:
//
//    - rate of the segment.
//    - format of the segment values (start_value and stop_value).
//    - startValue: start value.
//    - stopValue: stop value.
//
func (query *Query) SetSegment(rate float64, format Format, startValue int64, stopValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gdouble   // out
	var _arg2 C.GstFormat // out
	var _arg3 C.gint64    // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.gint64(startValue)
	_arg4 = C.gint64(stopValue)

	C.gst_query_set_segment(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(startValue)
	runtime.KeepAlive(stopValue)
}

// SetURI: answer a URI query by setting the requested URI.
//
// The function takes the following parameters:
//
//    - uri: URI to set.
//
func (query *Query) SetURI(uri string) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_query_set_uri(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(uri)
}

// SetURIRedirection: answer a URI query by setting the requested URI
// redirection.
//
// The function takes the following parameters:
//
//    - uri: URI to set.
//
func (query *Query) SetURIRedirection(uri string) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_query_set_uri_redirection(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(uri)
}

// SetURIRedirectionPermanent: answer a URI query by setting the requested URI
// redirection to permanent or not.
//
// The function takes the following parameters:
//
//    - permanent: whether the redirect is permanent or not.
//
func (query *Query) SetURIRedirectionPermanent(permanent bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if permanent {
		_arg1 = C.TRUE
	}

	C.gst_query_set_uri_redirection_permanent(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(permanent)
}

// WritableStructure: get the structure of a query. This method should be called
// with a writable query so that the returned structure is guaranteed to be
// writable.
//
// The function returns the following values:
//
//    - structure of the query. The structure is still owned by the query and
//      will therefore be freed when the query is unreffed.
//
func (query *Query) WritableStructure() *Structure {
	var _arg0 *C.GstQuery     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_writable_structure(_arg0)
	runtime.KeepAlive(query)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}
