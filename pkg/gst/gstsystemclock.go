// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeClockType   = coreglib.Type(C.gst_clock_type_get_type())
	GTypeSystemClock = coreglib.Type(C.gst_system_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeClockType, F: marshalClockType},
		coreglib.TypeMarshaler{T: GTypeSystemClock, F: marshalSystemClock},
	})
}

// ClockType: different kind of clocks.
type ClockType C.gint

const (
	// ClockTypeRealtime: time since Epoch.
	ClockTypeRealtime ClockType = iota
	// ClockTypeMonotonic: monotonic time since some unspecified starting point.
	ClockTypeMonotonic
	// ClockTypeOther: some other time source is used (Since: 1.0.5).
	ClockTypeOther
	// ClockTypeTai: time since Epoch, but using International Atomic Time as
	// reference (Since: 1.18).
	ClockTypeTai
)

func marshalClockType(p uintptr) (interface{}, error) {
	return ClockType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ClockType.
func (c ClockType) String() string {
	switch c {
	case ClockTypeRealtime:
		return "Realtime"
	case ClockTypeMonotonic:
		return "Monotonic"
	case ClockTypeOther:
		return "Other"
	case ClockTypeTai:
		return "Tai"
	default:
		return fmt.Sprintf("ClockType(%d)", c)
	}
}

// SystemClockOverrides contains methods that are overridable.
type SystemClockOverrides struct {
}

func defaultSystemClockOverrides(v *SystemClock) SystemClockOverrides {
	return SystemClockOverrides{}
}

// SystemClock: GStreamer core provides a GstSystemClock based on the system
// time. Asynchronous callbacks are scheduled from an internal thread.
//
// Clock implementors are encouraged to subclass this systemclock as it
// implements the async notification.
//
// Subclasses can however override all of the important methods for sync and
// async notifications to implement their own callback methods or blocking wait
// operations.
type SystemClock struct {
	_ [0]func() // equal guard
	Clock
}

var (
	_ Clocker = (*SystemClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SystemClock, *SystemClockClass, SystemClockOverrides](
		GTypeSystemClock,
		initSystemClockClass,
		wrapSystemClock,
		defaultSystemClockOverrides,
	)
}

func initSystemClockClass(gclass unsafe.Pointer, overrides SystemClockOverrides, classInitFunc func(*SystemClockClass)) {
	if classInitFunc != nil {
		class := (*SystemClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSystemClock(obj *coreglib.Object) *SystemClock {
	return &SystemClock{
		Clock: Clock{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalSystemClock(p uintptr) (interface{}, error) {
	return wrapSystemClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SystemClockObtain: get a handle to the default system clock. The refcount of
// the clock will be increased so you need to unref the clock after usage.
//
// The function returns the following values:
//
//    - clock: default clock.
//
//      MT safe.
//
func SystemClockObtain() Clocker {
	var _cret *C.GstClock // in

	_cret = C.gst_system_clock_obtain()

	var _clock Clocker // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Clocker is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Clocker)
			return ok
		})
		rv, ok := casted.(Clocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
		}
		_clock = rv
	}

	return _clock
}

// SystemClockClass: instance of this type is always passed by reference.
type SystemClockClass struct {
	*systemClockClass
}

// systemClockClass is the struct that's finalized.
type systemClockClass struct {
	native *C.GstSystemClockClass
}

func (s *SystemClockClass) ParentClass() *ClockClass {
	valptr := &s.native.parent_class
	var _v *ClockClass // out
	_v = (*ClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
