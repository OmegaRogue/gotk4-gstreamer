// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeDebugLevel      = coreglib.Type(C.gst_debug_level_get_type())
	GTypeDebugColorFlags = coreglib.Type(C.gst_debug_color_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDebugLevel, F: marshalDebugLevel},
		coreglib.TypeMarshaler{T: GTypeDebugColorFlags, F: marshalDebugColorFlags},
	})
}

const DEBUG_BG_MASK = 240
const DEBUG_FG_MASK = 15
const DEBUG_FORMAT_MASK = 65280

// PTR_FORMAT: printf format type used to debug GStreamer types. You can use
// this in combination with GStreamer's debug logging system as well as the
// functions gst_info_vasprintf(), gst_info_strdup_vprintf() and
// gst_info_strdup_printf() to pretty-print the following types: Caps,
// Structure, CapsFeatures, TagList, DateTime, Buffer, BufferList, Message,
// Event, Query, Context, Pad, Object. All #GObject types will be printed as
// typename plus pointer, and everything else will simply be printed as pointer
// address.
//
// This can only be used on types whose size is >= sizeof(gpointer).
const PTR_FORMAT = "paA"

// SEGMENT_FORMAT: printf format type used to debug GStreamer segments. You can
// use this in combination with GStreamer's debug logging system as well as the
// functions gst_info_vasprintf(), gst_info_strdup_vprintf() and
// gst_info_strdup_printf() to pretty-print Segment structures. This can only be
// used on pointers to GstSegment structures.
const SEGMENT_FORMAT = "paB"

// DebugLevel: level defines the importance of a debugging message. The more
// important a message is, the greater the probability that the debugging system
// outputs it.
type DebugLevel C.gint

const (
	// LevelNone: no debugging level specified or desired. Used to deactivate
	// debugging output.
	LevelNone DebugLevel = 0
	// LevelError: error messages are to be used only when an error occurred
	// that stops the application from keeping working correctly. An examples is
	// gst_element_error, which outputs a message with this priority. It does
	// not mean that the application is terminating as with g_error.
	LevelError DebugLevel = 1
	// LevelWarning: warning messages are to inform about abnormal behaviour
	// that could lead to problems or weird behaviour later on. An example of
	// this would be clocking issues ("your computer is pretty slow") or broken
	// input data ("Can't synchronize to stream.").
	LevelWarning DebugLevel = 2
	// LevelFixme: fixme messages are messages that indicate that something in
	// the executed code path is not fully implemented or handled yet. Note that
	// this does not replace proper error handling in any way, the purpose of
	// this message is to make it easier to spot incomplete/unfinished pieces of
	// code when reading the debug log.
	LevelFixme DebugLevel = 3
	// LevelInfo: informational messages should be used to keep the developer
	// updated about what is happening. Examples where this should be used are
	// when a typefind function has successfully determined the type of the
	// stream or when an mp3 plugin detects the format to be used. ("This file
	// has mono sound.").
	LevelInfo DebugLevel = 4
	// LevelDebug: debugging messages should be used when something common
	// happens that is not the expected default behavior, or something that's
	// useful to know but doesn't happen all the time (ie. per loop iteration or
	// buffer processed or event handled). An example would be notifications
	// about state changes or receiving/sending of events.
	LevelDebug DebugLevel = 5
	// LevelLog: log messages are messages that are very common but might be
	// useful to know. As a rule of thumb a pipeline that is running as expected
	// should never output anything else but LOG messages whilst processing
	// data. Use this log level to log recurring information in chain functions
	// and loop functions, for example.
	LevelLog DebugLevel = 6
	// LevelTrace: tracing-related messages. Examples for this are
	// referencing/dereferencing of objects.
	LevelTrace DebugLevel = 7
	// LevelMemdump: memory dump messages are used to log (small) chunks of data
	// as memory dumps in the log. They will be displayed as hexdump with ASCII
	// characters.
	LevelMemdump DebugLevel = 9
	// LevelCount: number of defined debugging levels.
	LevelCount DebugLevel = 10
)

func marshalDebugLevel(p uintptr) (interface{}, error) {
	return DebugLevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DebugLevel.
func (d DebugLevel) String() string {
	switch d {
	case LevelNone:
		return "None"
	case LevelError:
		return "Error"
	case LevelWarning:
		return "Warning"
	case LevelFixme:
		return "Fixme"
	case LevelInfo:
		return "Info"
	case LevelDebug:
		return "Debug"
	case LevelLog:
		return "Log"
	case LevelTrace:
		return "Trace"
	case LevelMemdump:
		return "Memdump"
	case LevelCount:
		return "Count"
	default:
		return fmt.Sprintf("DebugLevel(%d)", d)
	}
}

// DebugLevelGetName: get the string representation of a debugging level.
//
// The function takes the following parameters:
//
//    - level to get the name for.
//
// The function returns the following values:
//
//    - utf8: name.
//
func DebugLevelGetName(level DebugLevel) string {
	var _arg1 C.GstDebugLevel // out
	var _cret *C.gchar        // in

	_arg1 = C.GstDebugLevel(level)

	_cret = C.gst_debug_level_get_name(_arg1)
	runtime.KeepAlive(level)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DebugColorFlags: these are some terminal style flags you can use when
// creating your debugging categories to make them stand out in debugging
// output.
type DebugColorFlags C.guint

const (
	// DebugFgBlack: use black as foreground color.
	DebugFgBlack DebugColorFlags = 0b0
	// DebugFgRed: use red as foreground color.
	DebugFgRed DebugColorFlags = 0b1
	// DebugFgGreen: use green as foreground color.
	DebugFgGreen DebugColorFlags = 0b10
	// DebugFgYellow: use yellow as foreground color.
	DebugFgYellow DebugColorFlags = 0b11
	// DebugFgBlue: use blue as foreground color.
	DebugFgBlue DebugColorFlags = 0b100
	// DebugFgMagenta: use magenta as foreground color.
	DebugFgMagenta DebugColorFlags = 0b101
	// DebugFgCyan: use cyan as foreground color.
	DebugFgCyan DebugColorFlags = 0b110
	// DebugFgWhite: use white as foreground color.
	DebugFgWhite DebugColorFlags = 0b111
	// DebugBgBlack: use black as background color.
	DebugBgBlack DebugColorFlags = 0b0
	// DebugBgRed: use red as background color.
	DebugBgRed DebugColorFlags = 0b10000
	// DebugBgGreen: use green as background color.
	DebugBgGreen DebugColorFlags = 0b100000
	// DebugBgYellow: use yellow as background color.
	DebugBgYellow DebugColorFlags = 0b110000
	// DebugBgBlue: use blue as background color.
	DebugBgBlue DebugColorFlags = 0b1000000
	// DebugBgMagenta: use magenta as background color.
	DebugBgMagenta DebugColorFlags = 0b1010000
	// DebugBgCyan: use cyan as background color.
	DebugBgCyan DebugColorFlags = 0b1100000
	// DebugBgWhite: use white as background color.
	DebugBgWhite DebugColorFlags = 0b1110000
	// DebugBold: make the output bold.
	DebugBold DebugColorFlags = 0b100000000
	// DebugUnderline: underline the output.
	DebugUnderline DebugColorFlags = 0b1000000000
)

func marshalDebugColorFlags(p uintptr) (interface{}, error) {
	return DebugColorFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DebugColorFlags.
func (d DebugColorFlags) String() string {
	if d == 0 {
		return "DebugColorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(230)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DebugFgBlack:
			builder.WriteString("FgBlack|")
		case DebugFgRed:
			builder.WriteString("FgRed|")
		case DebugFgGreen:
			builder.WriteString("FgGreen|")
		case DebugFgYellow:
			builder.WriteString("FgYellow|")
		case DebugFgBlue:
			builder.WriteString("FgBlue|")
		case DebugFgMagenta:
			builder.WriteString("FgMagenta|")
		case DebugFgCyan:
			builder.WriteString("FgCyan|")
		case DebugFgWhite:
			builder.WriteString("FgWhite|")
		case DebugBgRed:
			builder.WriteString("BgRed|")
		case DebugBgGreen:
			builder.WriteString("BgGreen|")
		case DebugBgYellow:
			builder.WriteString("BgYellow|")
		case DebugBgBlue:
			builder.WriteString("BgBlue|")
		case DebugBgMagenta:
			builder.WriteString("BgMagenta|")
		case DebugBgCyan:
			builder.WriteString("BgCyan|")
		case DebugBgWhite:
			builder.WriteString("BgWhite|")
		case DebugBold:
			builder.WriteString("Bold|")
		case DebugUnderline:
			builder.WriteString("Underline|")
		default:
			builder.WriteString(fmt.Sprintf("DebugColorFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DebugColorFlags) Has(other DebugColorFlags) bool {
	return (d & other) == other
}

// DebugConstructTermColor constructs a string that can be used for getting the
// desired color in color terminals. You need to free the string after use.
//
// The function takes the following parameters:
//
//    - colorinfo: color info.
//
// The function returns the following values:
//
//    - utf8: string containing the color definition.
//
func DebugConstructTermColor(colorinfo uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(colorinfo)

	_cret = C.gst_debug_construct_term_color(_arg1)
	runtime.KeepAlive(colorinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DebugConstructWinColor constructs an integer that can be used for getting the
// desired color in windows' terminals (cmd.exe). As there is no mean to
// underline, we simply ignore this attribute.
//
// This function returns 0 on non-windows machines.
//
// The function takes the following parameters:
//
//    - colorinfo: color info.
//
// The function returns the following values:
//
//    - gint: integer containing the color definition.
//
func DebugConstructWinColor(colorinfo uint) int {
	var _arg1 C.guint // out
	var _cret C.gint  // in

	_arg1 = C.guint(colorinfo)

	_cret = C.gst_debug_construct_win_color(_arg1)
	runtime.KeepAlive(colorinfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DebugGetAllCategories returns a snapshot of a all categories that are
// currently in use . This list may change anytime. The caller has to free the
// list after use.
//
// The function returns the following values:
//
//    - sList: list of debug categories.
//
func DebugGetAllCategories() []*DebugCategory {
	var _cret *C.GSList // in

	_cret = C.gst_debug_get_all_categories()

	var _sList []*DebugCategory // out

	_sList = make([]*DebugCategory, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDebugCategory)(v)
		var dst *DebugCategory // out
		dst = (*DebugCategory)(gextras.NewStructNative(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// DebugGetDefaultThreshold returns the default threshold that is used for new
// categories.
//
// The function returns the following values:
//
//    - debugLevel: default threshold level.
//
func DebugGetDefaultThreshold() DebugLevel {
	var _cret C.GstDebugLevel // in

	_cret = C.gst_debug_get_default_threshold()

	var _debugLevel DebugLevel // out

	_debugLevel = DebugLevel(_cret)

	return _debugLevel
}

// DebugIsActive checks if debugging output is activated.
//
// The function returns the following values:
//
//    - ok: TRUE, if debugging is activated.
//
func DebugIsActive() bool {
	var _cret C.gboolean // in

	_cret = C.gst_debug_is_active()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DebugIsColored checks if the debugging output should be colored.
//
// The function returns the following values:
//
//    - ok: TRUE, if the debug output should be colored.
//
func DebugIsColored() bool {
	var _cret C.gboolean // in

	_cret = C.gst_debug_is_colored()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DebugPrintStackTrace: if libunwind, glibc backtrace or DbgHelp are present a
// stack trace is printed.
func DebugPrintStackTrace() {
	C.gst_debug_print_stack_trace()
}

// DebugRemoveLogFunctionByData removes all registered instances of log
// functions with the given user data.
//
// The function takes the following parameters:
//
//    - data (optional): user data of the log function to remove.
//
// The function returns the following values:
//
//    - guint: how many instances of the function were removed.
//
func DebugRemoveLogFunctionByData(data unsafe.Pointer) uint {
	var _arg1 C.gpointer // out
	var _cret C.guint    // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_debug_remove_log_function_by_data(_arg1)
	runtime.KeepAlive(data)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DebugSetActive: if activated, debugging messages are sent to the debugging
// handlers. It makes sense to deactivate it for speed issues. > This function
// is not threadsafe. It makes sense to only call it during initialization.
//
// The function takes the following parameters:
//
//    - active: whether to use debugging output or not.
//
func DebugSetActive(active bool) {
	var _arg1 C.gboolean // out

	if active {
		_arg1 = C.TRUE
	}

	C.gst_debug_set_active(_arg1)
	runtime.KeepAlive(active)
}

// DebugSetColored sets or unsets the use of coloured debugging output. Same as
// gst_debug_set_color_mode () with the argument being being
// GST_DEBUG_COLOR_MODE_ON or GST_DEBUG_COLOR_MODE_OFF.
//
// This function may be called before gst_init().
//
// The function takes the following parameters:
//
//    - colored: whether to use colored output or not.
//
func DebugSetColored(colored bool) {
	var _arg1 C.gboolean // out

	if colored {
		_arg1 = C.TRUE
	}

	C.gst_debug_set_colored(_arg1)
	runtime.KeepAlive(colored)
}

// DebugSetDefaultThreshold sets the default threshold to the given level and
// updates all categories to use this threshold.
//
// This function may be called before gst_init().
//
// The function takes the following parameters:
//
//    - level to set.
//
func DebugSetDefaultThreshold(level DebugLevel) {
	var _arg1 C.GstDebugLevel // out

	_arg1 = C.GstDebugLevel(level)

	C.gst_debug_set_default_threshold(_arg1)
	runtime.KeepAlive(level)
}

// DebugSetThresholdForName sets all categories which match the given glob style
// pattern to the given level.
//
// The function takes the following parameters:
//
//    - name of the categories to set.
//    - level to set them to.
//
func DebugSetThresholdForName(name string, level DebugLevel) {
	var _arg1 *C.gchar        // out
	var _arg2 C.GstDebugLevel // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstDebugLevel(level)

	C.gst_debug_set_threshold_for_name(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(level)
}

// DebugUnsetThresholdForName resets all categories with the given name back to
// the default level.
//
// The function takes the following parameters:
//
//    - name of the categories to set.
//
func DebugUnsetThresholdForName(name string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_debug_unset_threshold_for_name(_arg1)
	runtime.KeepAlive(name)
}

// DebugCategory: this is the struct that describes the categories. Once
// initialized with T_DEBUG_CATEGORY_INIT, its values can't be changed anymore.
//
// An instance of this type is always passed by reference.
type DebugCategory struct {
	*debugCategory
}

// debugCategory is the struct that's finalized.
type debugCategory struct {
	native *C.GstDebugCategory
}

// Color returns the color of a debug category used when printing output in this
// category.
//
// The function returns the following values:
//
//    - guint: color of the category.
//
func (category *DebugCategory) Color() uint {
	var _arg0 *C.GstDebugCategory // out
	var _cret C.guint             // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_color(_arg0)
	runtime.KeepAlive(category)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Description returns the description of a debug category.
//
// The function returns the following values:
//
//    - utf8: description of the category.
//
func (category *DebugCategory) Description() string {
	var _arg0 *C.GstDebugCategory // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_description(_arg0)
	runtime.KeepAlive(category)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name returns the name of a debug category.
//
// The function returns the following values:
//
//    - utf8: name of the category.
//
func (category *DebugCategory) Name() string {
	var _arg0 *C.GstDebugCategory // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_name(_arg0)
	runtime.KeepAlive(category)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Threshold returns the threshold of a DebugCategory.
//
// The function returns the following values:
//
//    - debugLevel that is used as threshold.
//
func (category *DebugCategory) Threshold() DebugLevel {
	var _arg0 *C.GstDebugCategory // out
	var _cret C.GstDebugLevel     // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_threshold(_arg0)
	runtime.KeepAlive(category)

	var _debugLevel DebugLevel // out

	_debugLevel = DebugLevel(_cret)

	return _debugLevel
}

// ResetThreshold resets the threshold of the category to the default level.
// Debug information will only be output if the threshold is lower or equal to
// the level of the debugging message. Use this function to set the threshold
// back to where it was after using gst_debug_category_set_threshold().
func (category *DebugCategory) ResetThreshold() {
	var _arg0 *C.GstDebugCategory // out

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	C.gst_debug_category_reset_threshold(_arg0)
	runtime.KeepAlive(category)
}

// SetThreshold sets the threshold of the category to the given level. Debug
// information will only be output if the threshold is lower or equal to the
// level of the debugging message. > Do not use this function in production
// code, because other functions may > change the threshold of categories as
// side effect. It is however a nice > function to use when debugging (even from
// gdb).
//
// The function takes the following parameters:
//
//    - level threshold to set.
//
func (category *DebugCategory) SetThreshold(level DebugLevel) {
	var _arg0 *C.GstDebugCategory // out
	var _arg1 C.GstDebugLevel     // out

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))
	_arg1 = C.GstDebugLevel(level)

	C.gst_debug_category_set_threshold(_arg0, _arg1)
	runtime.KeepAlive(category)
	runtime.KeepAlive(level)
}
