// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeParseError   = coreglib.Type(C.gst_parse_error_get_type())
	GTypeParseFlags   = coreglib.Type(C.gst_parse_flags_get_type())
	GTypeParseContext = coreglib.Type(C.gst_parse_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeParseError, F: marshalParseError},
		coreglib.TypeMarshaler{T: GTypeParseFlags, F: marshalParseFlags},
		coreglib.TypeMarshaler{T: GTypeParseContext, F: marshalParseContext},
	})
}

// ParseError: different parsing errors that can occur.
type ParseError C.gint

const (
	// ParseErrorSyntax: syntax error occurred.
	ParseErrorSyntax ParseError = iota
	// ParseErrorNoSuchElement: description contained an unknown element.
	ParseErrorNoSuchElement
	// ParseErrorNoSuchProperty: element did not have a specified property.
	ParseErrorNoSuchProperty
	// ParseErrorLink: there was an error linking two pads.
	ParseErrorLink
	// ParseErrorCouldNotSetProperty: there was an error setting a property.
	ParseErrorCouldNotSetProperty
	// ParseErrorEmptyBin: empty bin was specified.
	ParseErrorEmptyBin
	// ParseErrorEmpty: empty description was specified.
	ParseErrorEmpty
	// ParseErrorDelayedLink: delayed link did not get resolved.
	ParseErrorDelayedLink
)

func marshalParseError(p uintptr) (interface{}, error) {
	return ParseError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ParseError.
func (p ParseError) String() string {
	switch p {
	case ParseErrorSyntax:
		return "Syntax"
	case ParseErrorNoSuchElement:
		return "NoSuchElement"
	case ParseErrorNoSuchProperty:
		return "NoSuchProperty"
	case ParseErrorLink:
		return "Link"
	case ParseErrorCouldNotSetProperty:
		return "CouldNotSetProperty"
	case ParseErrorEmptyBin:
		return "EmptyBin"
	case ParseErrorEmpty:
		return "Empty"
	case ParseErrorDelayedLink:
		return "DelayedLink"
	default:
		return fmt.Sprintf("ParseError(%d)", p)
	}
}

// ParseErrorQuark: get the error quark used by the parsing subsystem.
//
// The function returns the following values:
//
//    - quark of the parse errors.
//
func ParseErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_parse_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

// ParseFlags: parsing options.
type ParseFlags C.guint

const (
	// ParseFlagNone: do not use any special parsing options.
	ParseFlagNone ParseFlags = 0b0
	// ParseFlagFatalErrors always return NULL when an error occurs (default
	// behaviour is to return partially constructed bins or elements in some
	// cases).
	ParseFlagFatalErrors ParseFlags = 0b1
	// ParseFlagNoSingleElementBins: if a bin only has a single element, just
	// return the element.
	ParseFlagNoSingleElementBins ParseFlags = 0b10
	// ParseFlagPlaceInBin: if more than one toplevel element is described by
	// the pipeline description string, put them in a Bin instead of a Pipeline.
	// (Since: 1.10).
	ParseFlagPlaceInBin ParseFlags = 0b100
)

func marshalParseFlags(p uintptr) (interface{}, error) {
	return ParseFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ParseFlags.
func (p ParseFlags) String() string {
	if p == 0 {
		return "ParseFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(83)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case ParseFlagNone:
			builder.WriteString("None|")
		case ParseFlagFatalErrors:
			builder.WriteString("FatalErrors|")
		case ParseFlagNoSingleElementBins:
			builder.WriteString("NoSingleElementBins|")
		case ParseFlagPlaceInBin:
			builder.WriteString("PlaceInBin|")
		default:
			builder.WriteString(fmt.Sprintf("ParseFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p ParseFlags) Has(other ParseFlags) bool {
	return (p & other) == other
}

// ParseLaunch: create a new pipeline based on command line syntax. Please note
// that you might get a return value that is not NULL even though the error is
// set. In this case there was a recoverable parsing error and you can try to
// play the pipeline.
//
// To create a sub-pipeline (bin) for embedding into an existing pipeline use
// gst_parse_bin_from_description().
//
// The function takes the following parameters:
//
//    - pipelineDescription: command line describing the pipeline.
//
// The function returns the following values:
//
//    - element: new element on success, NULL on failure. If more than one
//      toplevel element is specified by the pipeline_description, all elements
//      are put into a Pipeline, which than is returned.
//
func ParseLaunch(pipelineDescription string) (Elementer, error) {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pipelineDescription)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_parse_launch(_arg1, &_cerr)
	runtime.KeepAlive(pipelineDescription)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunchFull: create a new pipeline based on command line syntax. Please
// note that you might get a return value that is not NULL even though the error
// is set. In this case there was a recoverable parsing error and you can try to
// play the pipeline.
//
// To create a sub-pipeline (bin) for embedding into an existing pipeline use
// gst_parse_bin_from_description_full().
//
// The function takes the following parameters:
//
//    - pipelineDescription: command line describing the pipeline.
//    - context (optional): parse context allocated with gst_parse_context_new(),
//      or NULL.
//    - flags: parsing options, or T_PARSE_FLAG_NONE.
//
// The function returns the following values:
//
//    - element: new element on success, NULL on failure. If more than one
//      toplevel element is specified by the pipeline_description, all elements
//      are put into a Pipeline, which then is returned (unless the
//      GST_PARSE_FLAG_PLACE_IN_BIN flag is set, in which case they are put in a
//      Bin instead).
//
func ParseLaunchFull(pipelineDescription string, context *ParseContext, flags ParseFlags) (Elementer, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.GstParseContext // out
	var _arg3 C.GstParseFlags    // out
	var _cret *C.GstElement      // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pipelineDescription)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg3 = C.GstParseFlags(flags)

	_cret = C.gst_parse_launch_full(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(pipelineDescription)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunchv: create a new element based on command line syntax. error will
// contain an error message if an erroneous pipeline is specified. An error does
// not mean that the pipeline could not be constructed.
//
// The function takes the following parameters:
//
//    - argv: null-terminated array of arguments.
//
// The function returns the following values:
//
//    - element: new element on success and NULL on failure.
//
func ParseLaunchv(argv []string) (Elementer, error) {
	var _arg1 **C.gchar     // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(argv) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(argv)+1)
			var zero *C.gchar
			out[len(argv)] = zero
			for i := range argv {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_parse_launchv(_arg1, &_cerr)
	runtime.KeepAlive(argv)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunchvFull: create a new element based on command line syntax. error
// will contain an error message if an erroneous pipeline is specified. An error
// does not mean that the pipeline could not be constructed.
//
// The function takes the following parameters:
//
//    - argv: null-terminated array of arguments.
//    - context (optional): parse context allocated with gst_parse_context_new(),
//      or NULL.
//    - flags: parsing options, or T_PARSE_FLAG_NONE.
//
// The function returns the following values:
//
//    - element: new element on success; on failure, either NULL or a
//      partially-constructed bin or element will be returned and error will be
//      set (unless you passed T_PARSE_FLAG_FATAL_ERRORS in flags, then NULL will
//      always be returned on failure).
//
func ParseLaunchvFull(argv []string, context *ParseContext, flags ParseFlags) (Elementer, error) {
	var _arg1 **C.gchar          // out
	var _arg2 *C.GstParseContext // out
	var _arg3 C.GstParseFlags    // out
	var _cret *C.GstElement      // in
	var _cerr *C.GError          // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(argv) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(argv)+1)
			var zero *C.gchar
			out[len(argv)] = zero
			for i := range argv {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if context != nil {
		_arg2 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg3 = C.GstParseFlags(flags)

	_cret = C.gst_parse_launchv_full(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(argv)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseContext: opaque structure.
//
// An instance of this type is always passed by reference.
type ParseContext struct {
	*parseContext
}

// parseContext is the struct that's finalized.
type parseContext struct {
	native *C.GstParseContext
}

func marshalParseContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ParseContext{&parseContext{(*C.GstParseContext)(b)}}, nil
}

// NewParseContext constructs a struct ParseContext.
func NewParseContext() *ParseContext {
	var _cret *C.GstParseContext // in

	_cret = C.gst_parse_context_new()

	var _parseContext *ParseContext // out

	if _cret != nil {
		_parseContext = (*ParseContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parseContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_parse_context_free((*C.GstParseContext)(intern.C))
			},
		)
	}

	return _parseContext
}

// Copy copies the context.
//
// The function returns the following values:
//
//    - parseContext (optional): copied ParseContext.
//
func (context *ParseContext) Copy() *ParseContext {
	var _arg0 *C.GstParseContext // out
	var _cret *C.GstParseContext // in

	_arg0 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_parse_context_copy(_arg0)
	runtime.KeepAlive(context)

	var _parseContext *ParseContext // out

	if _cret != nil {
		_parseContext = (*ParseContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parseContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_parse_context_free((*C.GstParseContext)(intern.C))
			},
		)
	}

	return _parseContext
}

// MissingElements: retrieve missing elements from a previous run of
// gst_parse_launch_full() or gst_parse_launchv_full(). Will only return results
// if an error code of GST_PARSE_ERROR_NO_SUCH_ELEMENT was returned.
//
// The function returns the following values:
//
//    - utf8s (optional): a NULL-terminated array of element factory name strings
//      of missing elements. Free with g_strfreev() when no longer needed.
//
func (context *ParseContext) MissingElements() []string {
	var _arg0 *C.GstParseContext // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_parse_context_get_missing_elements(_arg0)
	runtime.KeepAlive(context)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}
