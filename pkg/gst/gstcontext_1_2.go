// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

// GType values.
var (
	GTypeContext = coreglib.Type(C.gst_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeContext, F: marshalContext},
	})
}

// Context is a container object used to store contexts like a device context, a
// display server connection and similar concepts that should be shared between
// multiple elements.
//
// Applications can set a context on a complete pipeline by using
// gst_element_set_context(), which will then be propagated to all child
// elements. Elements can handle these in ElementClass::set_context and merge
// them with the context information they already have.
//
// When an element needs a context it will do the following actions in this
// order until one step succeeds:
//
// 1. Check if the element already has a context 2. Query downstream with
// GST_QUERY_CONTEXT for the context 3. Query upstream with GST_QUERY_CONTEXT
// for the context 4. Post a GST_MESSAGE_NEED_CONTEXT message on the bus with
// the required context types and afterwards check if a usable context was set
// now 5. Create a context by itself and post a GST_MESSAGE_HAVE_CONTEXT message
// on the bus.
//
// Bins will catch GST_MESSAGE_NEED_CONTEXT messages and will set any previously
// known context on the element that asks for it if possible. Otherwise the
// application should provide one if it can.
//
// Context can be persistent. A persistent Context is kept in elements when they
// reach GST_STATE_NULL, non-persistent ones will be removed. Also, a
// non-persistent context won't override a previous persistent context set to an
// element.
//
// An instance of this type is always passed by reference.
type Context struct {
	*context
}

// context is the struct that's finalized.
type context struct {
	native *C.GstContext
}

func marshalContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Context{&context{(*C.GstContext)(b)}}, nil
}

// NewContext constructs a struct Context.
func NewContext(contextType string, persistent bool) *Context {
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret *C.GstContext // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))
	if persistent {
		_arg2 = C.TRUE
	}

	_cret = C.gst_context_new(_arg1, _arg2)
	runtime.KeepAlive(contextType)
	runtime.KeepAlive(persistent)

	var _context *Context // out

	_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_context)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _context
}

// ContextType gets the type of context.
//
// The function returns the following values:
//
//    - utf8: type of the context.
//
func (context *Context) ContextType() string {
	var _arg0 *C.GstContext // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_get_context_type(_arg0)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Structure accesses the structure of the context.
//
// The function returns the following values:
//
//    - structure of the context. The structure is still owned by the context,
//      which means that you should not modify it, free it and that the pointer
//      becomes invalid when you free the context.
//
func (context *Context) Structure() *Structure {
	var _arg0 *C.GstContext   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_get_structure(_arg0)
	runtime.KeepAlive(context)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// HasContextType checks if context has context_type.
//
// The function takes the following parameters:
//
//    - contextType: context type to check.
//
// The function returns the following values:
//
//    - ok: TRUE if context has context_type.
//
func (context *Context) HasContextType(contextType string) bool {
	var _arg0 *C.GstContext // out
	var _arg1 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_context_has_context_type(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(contextType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPersistent checks if context is persistent.
//
// The function returns the following values:
//
//    - ok: TRUE if the context is persistent.
//
func (context *Context) IsPersistent() bool {
	var _arg0 *C.GstContext // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_is_persistent(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WritableStructure gets a writable version of the structure.
//
// The function returns the following values:
//
//    - structure of the context. The structure is still owned by the context,
//      which means that you should not free it and that the pointer becomes
//      invalid when you free the context. This function checks if context is
//      writable.
//
func (context *Context) WritableStructure() *Structure {
	var _arg0 *C.GstContext   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_writable_structure(_arg0)
	runtime.KeepAlive(context)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}
