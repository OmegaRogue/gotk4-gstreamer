// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void _gotk4_gst1_Bin_ConnectElementRemoved(gpointer, GstElement*, guintptr);
// extern void _gotk4_gst1_Bin_ConnectElementAdded(gpointer, GstElement*, guintptr);
// extern void _gotk4_gst1_Bin_ConnectDeepElementRemoved(gpointer, GstBin*, GstElement*, guintptr);
// extern void _gotk4_gst1_Bin_ConnectDeepElementAdded(gpointer, GstBin*, GstElement*, guintptr);
// extern void _gotk4_gst1_BinClass_handle_message(GstBin*, GstMessage*);
// extern void _gotk4_gst1_BinClass_element_removed(GstBin*, GstElement*);
// extern void _gotk4_gst1_BinClass_element_added(GstBin*, GstElement*);
// extern void _gotk4_gst1_BinClass_deep_element_removed(GstBin*, GstBin*, GstElement*);
// extern void _gotk4_gst1_BinClass_deep_element_added(GstBin*, GstBin*, GstElement*);
// extern gboolean _gotk4_gst1_Bin_ConnectDoLatency(gpointer, guintptr);
// extern gboolean _gotk4_gst1_BinClass_remove_element(GstBin*, GstElement*);
// extern gboolean _gotk4_gst1_BinClass_do_latency(GstBin*);
// extern gboolean _gotk4_gst1_BinClass_add_element(GstBin*, GstElement*);
// gboolean _gotk4_gst1_Bin_virtual_add_element(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   return ((gboolean (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Bin_virtual_do_latency(void* fnptr, GstBin* arg0) {
//   return ((gboolean (*)(GstBin*))(fnptr))(arg0);
// };
// gboolean _gotk4_gst1_Bin_virtual_remove_element(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   return ((gboolean (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bin_virtual_deep_element_added(void* fnptr, GstBin* arg0, GstBin* arg1, GstElement* arg2) {
//   ((void (*)(GstBin*, GstBin*, GstElement*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gst1_Bin_virtual_deep_element_removed(void* fnptr, GstBin* arg0, GstBin* arg1, GstElement* arg2) {
//   ((void (*)(GstBin*, GstBin*, GstElement*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gst1_Bin_virtual_element_added(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   ((void (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bin_virtual_element_removed(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   ((void (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bin_virtual_handle_message(void* fnptr, GstBin* arg0, GstMessage* arg1) {
//   ((void (*)(GstBin*, GstMessage*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBinFlags = coreglib.Type(C.gst_bin_flags_get_type())
	GTypeBin      = coreglib.Type(C.gst_bin_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBinFlags, F: marshalBinFlags},
		coreglib.TypeMarshaler{T: GTypeBin, F: marshalBin},
	})
}

// BinFlags are a set of flags specific to bins. Most are set/used internally.
// They can be checked using the GST_OBJECT_FLAG_IS_SET() macro, and (un)set
// using GST_OBJECT_FLAG_SET() and GST_OBJECT_FLAG_UNSET().
type BinFlags C.guint

const (
	// BinFlagNoResync: don't resync a state change when elements are added or
	// linked in the bin.
	BinFlagNoResync BinFlags = 0b100000000000000
	// BinFlagStreamsAware indicates whether the bin can handle elements that
	// add/remove source pads at any point in time without first posting a
	// no-more-pads signal.
	BinFlagStreamsAware BinFlags = 0b1000000000000000
	// BinFlagLast: last enum in the series of flags for bins. Derived classes
	// can use this as first value in a list of flags.
	BinFlagLast BinFlags = 0b10000000000000000000
)

func marshalBinFlags(p uintptr) (interface{}, error) {
	return BinFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BinFlags.
func (b BinFlags) String() string {
	if b == 0 {
		return "BinFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(47)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BinFlagNoResync:
			builder.WriteString("NoResync|")
		case BinFlagStreamsAware:
			builder.WriteString("StreamsAware|")
		case BinFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BinFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BinFlags) Has(other BinFlags) bool {
	return (b & other) == other
}

// BinOverrides contains methods that are overridable.
type BinOverrides struct {
	// AddElement: method to add an element to the bin.
	//
	// The function takes the following parameters:
	//
	//    - element to be added.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the element was added.
	//
	AddElement func(element Elementer) bool
	// DeepElementAdded: method called when an element was added somewhere in
	// the bin hierarchy.
	//
	// The function takes the following parameters:
	//
	//    - subBin to which the element was added.
	//    - child: element that was added.
	//
	DeepElementAdded func(subBin *Bin, child Elementer)
	// DeepElementRemoved: method called when an element was removed somewhere
	// in the bin hierarchy.
	//
	// The function takes the following parameters:
	//
	//    - subBin from which the element was removed.
	//    - child: element that was removed.
	//
	DeepElementRemoved func(subBin *Bin, child Elementer)
	// The function returns the following values:
	//
	DoLatency func() bool
	// ElementAdded: method called when an element was added to the bin.
	//
	// The function takes the following parameters:
	//
	//    - child: element that was added.
	//
	ElementAdded func(child Elementer)
	// ElementRemoved: method called when an element was removed from the bin.
	//
	// The function takes the following parameters:
	//
	//    - child: element that was removed.
	//
	ElementRemoved func(child Elementer)
	// HandleMessage: method to handle a message from the children.
	//
	// The function takes the following parameters:
	//
	//    - message to be handled.
	//
	HandleMessage func(message *Message)
	// RemoveElement: method to remove an element from the bin.
	//
	// The function takes the following parameters:
	//
	//    - element to be removed.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the element was removed.
	//
	RemoveElement func(element Elementer) bool
}

func defaultBinOverrides(v *Bin) BinOverrides {
	return BinOverrides{
		AddElement:         v.addElement,
		DeepElementAdded:   v.deepElementAdded,
		DeepElementRemoved: v.deepElementRemoved,
		DoLatency:          v.doLatency,
		ElementAdded:       v.elementAdded,
		ElementRemoved:     v.elementRemoved,
		HandleMessage:      v.handleMessage,
		RemoveElement:      v.removeElement,
	}
}

// Bin is an element that can contain other Element, allowing them to be managed
// as a group. Pads from the child elements can be ghosted to the bin, see
// GhostPad. This makes the bin look like any other elements and enables
// creation of higher-level abstraction elements.
//
// A new Bin is created with gst_bin_new(). Use a Pipeline instead if you want
// to create a toplevel bin because a normal bin doesn't have a bus or handle
// clock distribution of its own.
//
// After the bin has been created you will typically add elements to it with
// gst_bin_add(). You can remove elements with gst_bin_remove().
//
// An element can be retrieved from a bin with gst_bin_get_by_name(), using the
// elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
// purposes and will query the parent bins when the element is not found in the
// current bin.
//
// An iterator of elements in a bin can be retrieved with
// gst_bin_iterate_elements(). Various other iterators exist to retrieve the
// elements in a bin.
//
// gst_object_unref() is used to drop your reference to the bin.
//
// The Bin::element-added signal is fired whenever a new element is added to the
// bin. Likewise the Bin::element-removed signal is fired whenever an element is
// removed from the bin.
//
// A Bin internally intercepts every Message posted by its children and
// implements the following default behaviour for each of them:
//
// * GST_MESSAGE_EOS: This message is only posted by sinks in the PLAYING state.
// If all sinks posted the EOS message, this bin will post and EOS message
// upwards.
//
// * GST_MESSAGE_SEGMENT_START: Just collected and never forwarded upwards. The
// messages are used to decide when all elements have completed playback of
// their segment.
//
// * GST_MESSAGE_SEGMENT_DONE: Is posted by Bin when all elements that posted a
// SEGMENT_START have posted a SEGMENT_DONE.
//
// * GST_MESSAGE_DURATION_CHANGED: Is posted by an element that detected a
// change in the stream duration. The duration change is posted to the
// application so that it can refetch the new duration with a duration query.
//
//    Note that these messages can be posted before the bin is prerolled, in which
//    case the duration query might fail.
//
//    Note also that there might be a discrepancy (due to internal buffering/queueing)
//    between the stream being currently displayed and the returned duration query.
//
//    Applications might want to also query for duration (and changes) by
//    listening to the GST_MESSAGE_STREAM_START message, signaling the active start
//    of a (new) stream.
//
// * GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it can no
// longer provide a clock.
//
//    The default bin behaviour is to check if the lost clock was the one provided
//    by the bin. If so and the bin is currently in the PLAYING state, the message
//    is forwarded to the bin parent.
//
//    This message is also generated when a clock provider is removed from
//    the bin. If this message is received by the application, it should
//    PAUSE the pipeline and set it back to PLAYING to force a new clock
//    distribution.
//
// * GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element can
// provide a clock. This mostly happens when a new clock provider is added to
// the bin.
//
//    The default behaviour of the bin is to mark the currently selected clock as
//    dirty, which will perform a clock recalculation the next time the bin is
//    asked to provide a clock.
//
//    This message is never sent to the application but is forwarded to
//    the parent of the bin.
//
// * OTHERS: posted upwards.
//
// A Bin implements the following default behaviour for answering to a Query:
//
// * GST_QUERY_DURATION: The bin will forward the query to all sink elements
// contained within and will return the maximum value. If no sinks are available
// in the bin, the query fails.
//
// * GST_QUERY_POSITION: The query is sent to all sink elements in the bin and
// the MAXIMUM of all values is returned. If no sinks are available in the bin,
// the query fails.
//
// * OTHERS: the query is forwarded to all sink elements, the result of the
// first sink that answers the query successfully is returned. If no sink is in
// the bin, the query fails.
//
// A Bin will by default forward any event sent to it to all sink (
// GST_EVENT_TYPE_DOWNSTREAM ) or source ( GST_EVENT_TYPE_UPSTREAM ) elements
// depending on the event type.
//
// If all the elements return TRUE, the bin will also return TRUE, else FALSE is
// returned. If no elements of the required type are in the bin, the event
// handler will return TRUE.
type Bin struct {
	_ [0]func() // equal guard
	Element

	ChildProxy
}

var (
	_ Elementer = (*Bin)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Bin, *BinClass, BinOverrides](
		GTypeBin,
		initBinClass,
		wrapBin,
		defaultBinOverrides,
	)
}

func initBinClass(gclass unsafe.Pointer, overrides BinOverrides, classInitFunc func(*BinClass)) {
	pclass := (*C.GstBinClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBin))))

	if overrides.AddElement != nil {
		pclass.add_element = (*[0]byte)(C._gotk4_gst1_BinClass_add_element)
	}

	if overrides.DeepElementAdded != nil {
		pclass.deep_element_added = (*[0]byte)(C._gotk4_gst1_BinClass_deep_element_added)
	}

	if overrides.DeepElementRemoved != nil {
		pclass.deep_element_removed = (*[0]byte)(C._gotk4_gst1_BinClass_deep_element_removed)
	}

	if overrides.DoLatency != nil {
		pclass.do_latency = (*[0]byte)(C._gotk4_gst1_BinClass_do_latency)
	}

	if overrides.ElementAdded != nil {
		pclass.element_added = (*[0]byte)(C._gotk4_gst1_BinClass_element_added)
	}

	if overrides.ElementRemoved != nil {
		pclass.element_removed = (*[0]byte)(C._gotk4_gst1_BinClass_element_removed)
	}

	if overrides.HandleMessage != nil {
		pclass.handle_message = (*[0]byte)(C._gotk4_gst1_BinClass_handle_message)
	}

	if overrides.RemoveElement != nil {
		pclass.remove_element = (*[0]byte)(C._gotk4_gst1_BinClass_remove_element)
	}

	if classInitFunc != nil {
		class := (*BinClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBin(obj *coreglib.Object) *Bin {
	return &Bin{
		Element: Element{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
		ChildProxy: ChildProxy{
			Object: obj,
		},
	}
}

func marshalBin(p uintptr) (interface{}, error) {
	return wrapBin(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDeepElementAdded will be emitted after the element was added to
// sub_bin.
func (bin *Bin) ConnectDeepElementAdded(f func(subBin *Bin, element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "deep-element-added", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectDeepElementAdded), f)
}

// ConnectDeepElementRemoved will be emitted after the element was removed from
// sub_bin.
func (bin *Bin) ConnectDeepElementRemoved(f func(subBin *Bin, element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "deep-element-removed", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectDeepElementRemoved), f)
}

// ConnectDoLatency will be emitted when the bin needs to perform latency
// calculations. This signal is only emitted for toplevel bins or when
// Bin:async-handling is enabled.
//
// Only one signal handler is invoked. If no signals are connected, the default
// handler is invoked, which will query and distribute the lowest possible
// latency to all sinks.
//
// Connect to this signal if the default latency calculations are not
// sufficient, like when you need different latencies for different sinks in the
// same pipeline.
func (bin *Bin) ConnectDoLatency(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "do-latency", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectDoLatency), f)
}

// ConnectElementAdded will be emitted after the element was added to the bin.
func (bin *Bin) ConnectElementAdded(f func(element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "element-added", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectElementAdded), f)
}

// ConnectElementRemoved will be emitted after the element was removed from the
// bin.
func (bin *Bin) ConnectElementRemoved(f func(element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "element-removed", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectElementRemoved), f)
}

// NewBin creates a new bin with the given name.
//
// The function takes the following parameters:
//
//    - name (optional) of the new bin.
//
// The function returns the following values:
//
//    - bin: new Bin.
//
func NewBin(name string) *Bin {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_bin_new(_arg1)
	runtime.KeepAlive(name)

	var _bin *Bin // out

	_bin = wrapBin(coreglib.Take(unsafe.Pointer(_cret)))

	return _bin
}

// Add adds the given element to the bin. Sets the element's parent, and thus
// takes ownership of the element. An element can only be added to one bin.
//
// If the element's pads are linked to other pads, the pads will be unlinked
// before the element is added to the bin.
//
// > When you add an element to an already-running pipeline, you will have to >
// take care to set the state of the newly-added element to the desired > state
// (usually PLAYING or PAUSED, same you set the pipeline to originally) > with
// gst_element_set_state(), or use gst_element_sync_state_with_parent(). > The
// bin or pipeline will not take care of this for you.
//
// The function takes the following parameters:
//
//    - element to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the element could be added, FALSE if the bin does not want to
//      accept the element.
//
func (bin *Bin) Add(element Elementer) bool {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_bin_add(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FindUnlinkedPad: recursively looks for elements with an unlinked pad of the
// given direction within the specified bin and returns an unlinked pad if one
// is found, or NULL otherwise. If a pad is found, the caller owns a reference
// to it and should use gst_object_unref() on the pad when it is not needed any
// longer.
//
// The function takes the following parameters:
//
//    - direction: whether to look for an unlinked source or sink pad.
//
// The function returns the following values:
//
//    - pad (optional): unlinked pad of the given direction.
//
func (bin *Bin) FindUnlinkedPad(direction PadDirection) *Pad {
	var _arg0 *C.GstBin         // out
	var _arg1 C.GstPadDirection // out
	var _cret *C.GstPad         // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GstPadDirection(direction)

	_cret = C.gst_bin_find_unlinked_pad(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(direction)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// ByInterface looks for an element inside the bin that implements the given
// interface. If such an element is found, it returns the element. You can cast
// this element to the given interface afterwards. If you want all elements that
// implement the interface, use gst_bin_iterate_all_by_interface(). This
// function recurses into child bins.
//
// The function takes the following parameters:
//
//    - iface of an interface.
//
// The function returns the following values:
//
//    - element (optional) inside the bin implementing the interface.
//
func (bin *Bin) ByInterface(iface coreglib.Type) Elementer {
	var _arg0 *C.GstBin     // out
	var _arg1 C.GType       // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GType(iface)

	_cret = C.gst_bin_get_by_interface(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(iface)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ByName gets the element with the given name from a bin. This function
// recurses into child bins.
//
// The function takes the following parameters:
//
//    - name: element name to search for.
//
// The function returns the following values:
//
//    - element (optional) with the given name.
//
func (bin *Bin) ByName(name string) Elementer {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_bin_get_by_name(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ByNameRecurseUp gets the element with the given name from this bin. If the
// element is not found, a recursion is performed on the parent bin.
//
// The function takes the following parameters:
//
//    - name: element name to search for.
//
// The function returns the following values:
//
//    - element (optional) with the given name.
//
func (bin *Bin) ByNameRecurseUp(name string) Elementer {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_bin_get_by_name_recurse_up(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// The function returns the following values:
//
//    - elementFlags bin's suppressed ElementFlags.
//
func (bin *Bin) SuppressedFlags() ElementFlags {
	var _arg0 *C.GstBin         // out
	var _cret C.GstElementFlags // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_get_suppressed_flags(_arg0)
	runtime.KeepAlive(bin)

	var _elementFlags ElementFlags // out

	_elementFlags = ElementFlags(_cret)

	return _elementFlags
}

// IterateAllByElementFactoryName looks for all elements inside the bin with the
// given element factory name. The function recurses inside child bins. The
// iterator will yield a series of Element.
//
// The function takes the following parameters:
//
//    - factoryName: name of the ElementFactory.
//
// The function returns the following values:
//
//    - iterator (optional) of Element for all elements in the bin with the given
//      element factory name.
//
func (bin *Bin) IterateAllByElementFactoryName(factoryName string) *Iterator {
	var _arg0 *C.GstBin      // out
	var _arg1 *C.gchar       // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_bin_iterate_all_by_element_factory_name(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(factoryName)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateAllByInterface looks for all elements inside the bin that implements
// the given interface. You can safely cast all returned elements to the given
// interface. The function recurses inside child bins. The iterator will yield a
// series of Element.
//
// The function takes the following parameters:
//
//    - iface of an interface.
//
// The function returns the following values:
//
//    - iterator (optional) of Element for all elements in the bin implementing
//      the given interface.
//
func (bin *Bin) IterateAllByInterface(iface coreglib.Type) *Iterator {
	var _arg0 *C.GstBin      // out
	var _arg1 C.GType        // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GType(iface)

	_cret = C.gst_bin_iterate_all_by_interface(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(iface)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateElements gets an iterator for the elements in this bin.
//
// The function returns the following values:
//
//    - iterator (optional) of Element.
//
func (bin *Bin) IterateElements() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_elements(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateRecurse gets an iterator for the elements in this bin. This iterator
// recurses into GstBin children.
//
// The function returns the following values:
//
//    - iterator (optional) of Element.
//
func (bin *Bin) IterateRecurse() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_recurse(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateSinks gets an iterator for all elements in the bin that have the
// T_ELEMENT_FLAG_SINK flag set.
//
// The function returns the following values:
//
//    - iterator (optional) of Element.
//
func (bin *Bin) IterateSinks() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_sinks(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateSorted gets an iterator for the elements in this bin in topologically
// sorted order. This means that the elements are returned from the most
// downstream elements (sinks) to the sources.
//
// This function is used internally to perform the state changes of the bin
// elements and for clock selection.
//
// The function returns the following values:
//
//    - iterator (optional) of Element.
//
func (bin *Bin) IterateSorted() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_sorted(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateSources gets an iterator for all elements in the bin that have the
// T_ELEMENT_FLAG_SOURCE flag set.
//
// The function returns the following values:
//
//    - iterator (optional) of Element.
//
func (bin *Bin) IterateSources() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_sources(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// RecalculateLatency queries bin for the current latency and reconfigures this
// latency on all the elements using a LATENCY event.
//
// This method is typically called on the pipeline when a T_MESSAGE_LATENCY is
// posted on the bus.
//
// This function simply emits the Bin::do-latency signal so any custom latency
// calculations will be performed.
//
// The function returns the following values:
//
//    - ok: TRUE if the latency could be queried and reconfigured.
//
func (bin *Bin) RecalculateLatency() bool {
	var _arg0 *C.GstBin  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_recalculate_latency(_arg0)
	runtime.KeepAlive(bin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes the element from the bin, unparenting it as well. Unparenting
// the element means that the element will be dereferenced, so if the bin holds
// the only reference to the element, the element will be freed in the process
// of removing it from the bin. If you want the element to still exist after
// removing, you need to call gst_object_ref() before removing it from the bin.
//
// If the element's pads are linked to other pads, the pads will be unlinked
// before the element is removed from the bin.
//
// The function takes the following parameters:
//
//    - element to remove.
//
// The function returns the following values:
//
//    - ok: TRUE if the element could be removed, FALSE if the bin does not want
//      to remove the element.
//
func (bin *Bin) Remove(element Elementer) bool {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_bin_remove(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSuppressedFlags suppresses the given flags on the bin. ElementFlags of a
// child element are propagated when it is added to the bin. When suppressed
// flags are set, those specified flags will not be propagated to the bin.
//
// The function takes the following parameters:
//
//    - flags to suppress.
//
func (bin *Bin) SetSuppressedFlags(flags ElementFlags) {
	var _arg0 *C.GstBin         // out
	var _arg1 C.GstElementFlags // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GstElementFlags(flags)

	C.gst_bin_set_suppressed_flags(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(flags)
}

// SyncChildrenStates synchronizes the state of every child of bin with the
// state of bin. See also gst_element_sync_state_with_parent().
//
// The function returns the following values:
//
//    - ok: TRUE if syncing the state was successful for all children, otherwise
//      FALSE.
//
func (bin *Bin) SyncChildrenStates() bool {
	var _arg0 *C.GstBin  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_sync_children_states(_arg0)
	runtime.KeepAlive(bin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// addElement: method to add an element to the bin.
//
// The function takes the following parameters:
//
//    - element to be added.
//
// The function returns the following values:
//
//    - ok: TRUE if the element was added.
//
func (bin *Bin) addElement(element Elementer) bool {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.add_element

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Bin_virtual_add_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// deepElementAdded: method called when an element was added somewhere in the
// bin hierarchy.
//
// The function takes the following parameters:
//
//    - subBin to which the element was added.
//    - child: element that was added.
//
func (bin *Bin) deepElementAdded(subBin *Bin, child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.deep_element_added

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstBin     // out
	var _arg2 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(subBin).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_deep_element_added(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(subBin)
	runtime.KeepAlive(child)
}

// deepElementRemoved: method called when an element was removed somewhere in
// the bin hierarchy.
//
// The function takes the following parameters:
//
//    - subBin from which the element was removed.
//    - child: element that was removed.
//
func (bin *Bin) deepElementRemoved(subBin *Bin, child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.deep_element_removed

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstBin     // out
	var _arg2 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(subBin).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_deep_element_removed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(subBin)
	runtime.KeepAlive(child)
}

// The function returns the following values:
//
func (bin *Bin) doLatency() bool {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.do_latency

	var _arg0 *C.GstBin  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C._gotk4_gst1_Bin_virtual_do_latency(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(bin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// elementAdded: method called when an element was added to the bin.
//
// The function takes the following parameters:
//
//    - child: element that was added.
//
func (bin *Bin) elementAdded(child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.element_added

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_element_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(child)
}

// elementRemoved: method called when an element was removed from the bin.
//
// The function takes the following parameters:
//
//    - child: element that was removed.
//
func (bin *Bin) elementRemoved(child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.element_removed

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_element_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(child)
}

// handleMessage: method to handle a message from the children.
//
// The function takes the following parameters:
//
//    - message to be handled.
//
func (bin *Bin) handleMessage(message *Message) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.handle_message

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstMessage // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	C._gotk4_gst1_Bin_virtual_handle_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(message)
}

// removeElement: method to remove an element from the bin.
//
// The function takes the following parameters:
//
//    - element to be removed.
//
// The function returns the following values:
//
//    - ok: TRUE if the element was removed.
//
func (bin *Bin) removeElement(element Elementer) bool {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.remove_element

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Bin_virtual_remove_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BinClass subclasses can override BinClass::add_element and
// BinClass::remove_element to update the list of children in the bin.
//
// The BinClass::handle_message method can be overridden to implement custom
// message handling.
//
// BinClass::deep_element_added will be called when a new element has been added
// to any bin inside this bin, so it will also be called if a new child was
// added to a sub-bin of this bin. Bin implementations that override this
// message should chain up to the parent class implementation so the
// Bin::deep-element-added signal is emitted on all parents.
//
// An instance of this type is always passed by reference.
type BinClass struct {
	*binClass
}

// binClass is the struct that's finalized.
type binClass struct {
	native *C.GstBinClass
}

// ParentClass: bin parent class.
func (b *BinClass) ParentClass() *ElementClass {
	valptr := &b.native.parent_class
	var _v *ElementClass // out
	_v = (*ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (bin *Bin) AddMany(elements ...Elementer) bool {
	for _, elem := range elements {
		if !bin.Add(elem) {
			return false
		}
	}
	return false
}
