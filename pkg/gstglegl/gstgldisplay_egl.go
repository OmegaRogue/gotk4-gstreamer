// Code generated by girgen. DO NOT EDIT.

package gstglegl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstgl"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/egl/egl.h>
import "C"

// GType values.
var (
	GTypeGLDisplayEGL = coreglib.Type(C.gst_gl_display_egl_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLDisplayEGL, F: marshalGLDisplayEGL},
	})
}

const GL_DISPLAY_EGL_NAME = "gst.gl.display.egl"

// GLDisplayEGLOverrides contains methods that are overridable.
type GLDisplayEGLOverrides struct {
}

func defaultGLDisplayEGLOverrides(v *GLDisplayEGL) GLDisplayEGLOverrides {
	return GLDisplayEGLOverrides{}
}

// GLDisplayEGL contents of a GLDisplayEGL are private and should only be
// accessed through the provided API.
type GLDisplayEGL struct {
	_ [0]func() // equal guard
	gstgl.GLDisplay
}

var (
	_ gst.GstObjector = (*GLDisplayEGL)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLDisplayEGL, *GLDisplayEGLClass, GLDisplayEGLOverrides](
		GTypeGLDisplayEGL,
		initGLDisplayEGLClass,
		wrapGLDisplayEGL,
		defaultGLDisplayEGLOverrides,
	)
}

func initGLDisplayEGLClass(gclass unsafe.Pointer, overrides GLDisplayEGLOverrides, classInitFunc func(*GLDisplayEGLClass)) {
	if classInitFunc != nil {
		class := (*GLDisplayEGLClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLDisplayEGL(obj *coreglib.Object) *GLDisplayEGL {
	return &GLDisplayEGL{
		GLDisplay: gstgl.GLDisplay{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalGLDisplayEGL(p uintptr) (interface{}, error) {
	return wrapGLDisplayEGL(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLDisplayEGL: create a new GLDisplayEGL using the default
// EGL_DEFAULT_DISPLAY.
//
// The function returns the following values:
//
//    - glDisplayEGL: new GLDisplayEGL or NULL.
//
func NewGLDisplayEGL() *GLDisplayEGL {
	var _cret *C.GstGLDisplayEGL // in

	_cret = C.gst_gl_display_egl_new()

	var _glDisplayEGL *GLDisplayEGL // out

	_glDisplayEGL = wrapGLDisplayEGL(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplayEGL
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func NewGLDisplayEGLWithEglDisplay(display unsafe.Pointer) *GLDisplayEGL {
	var _arg1 C.gpointer         // out
	var _cret *C.GstGLDisplayEGL // in

	_arg1 = (C.gpointer)(unsafe.Pointer(display))

	_cret = C.gst_gl_display_egl_new_with_egl_display(_arg1)
	runtime.KeepAlive(display)

	var _glDisplayEGL *GLDisplayEGL // out

	_glDisplayEGL = wrapGLDisplayEGL(coreglib.Take(unsafe.Pointer(_cret)))

	return _glDisplayEGL
}

// GLDisplayEGLClass: instance of this type is always passed by reference.
type GLDisplayEGLClass struct {
	*glDisplayEGLClass
}

// glDisplayEGLClass is the struct that's finalized.
type glDisplayEGLClass struct {
	native *C.GstGLDisplayEGLClass
}

func (g *GLDisplayEGLClass) ObjectClass() *gstgl.GLDisplayClass {
	valptr := &g.native.object_class
	var _v *gstgl.GLDisplayClass // out
	_v = (*gstgl.GLDisplayClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (g *GLDisplayEGLClass) Padding() [4]unsafe.Pointer {
	valptr := &g.native._padding
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
