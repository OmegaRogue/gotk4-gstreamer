// Code generated by girgen. DO NOT EDIT.

package gstglegl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstgl"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/egl/egl.h>
import "C"

// GType values.
var (
	GTypeGLDisplayEGLDevice = coreglib.Type(C.gst_gl_display_egl_device_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLDisplayEGLDevice, F: marshalGLDisplayEGLDevice},
	})
}

// GLDisplayEGLDeviceOverrides contains methods that are overridable.
type GLDisplayEGLDeviceOverrides struct {
}

func defaultGLDisplayEGLDeviceOverrides(v *GLDisplayEGLDevice) GLDisplayEGLDeviceOverrides {
	return GLDisplayEGLDeviceOverrides{}
}

// GLDisplayEGLDevice contents of a GLDisplayEGLDevice are private and should
// only be accessed through the provided API.
type GLDisplayEGLDevice struct {
	_ [0]func() // equal guard
	gstgl.GLDisplay
}

var (
	_ gst.GstObjector = (*GLDisplayEGLDevice)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLDisplayEGLDevice, *GLDisplayEGLDeviceClass, GLDisplayEGLDeviceOverrides](
		GTypeGLDisplayEGLDevice,
		initGLDisplayEGLDeviceClass,
		wrapGLDisplayEGLDevice,
		defaultGLDisplayEGLDeviceOverrides,
	)
}

func initGLDisplayEGLDeviceClass(gclass unsafe.Pointer, overrides GLDisplayEGLDeviceOverrides, classInitFunc func(*GLDisplayEGLDeviceClass)) {
	if classInitFunc != nil {
		class := (*GLDisplayEGLDeviceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLDisplayEGLDevice(obj *coreglib.Object) *GLDisplayEGLDevice {
	return &GLDisplayEGLDevice{
		GLDisplay: gstgl.GLDisplay{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalGLDisplayEGLDevice(p uintptr) (interface{}, error) {
	return wrapGLDisplayEGLDevice(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLDisplayEGLDevice: create a new GLDisplayEGLDevice with an EGLDevice
// supported device.
//
// The function takes the following parameters:
//
//    - deviceIndex: index of device to use.
//
// The function returns the following values:
//
//    - glDisplayEGLDevice: new GLDisplayEGLDevice or NULL.
//
func NewGLDisplayEGLDevice(deviceIndex uint) *GLDisplayEGLDevice {
	var _arg1 C.guint                  // out
	var _cret *C.GstGLDisplayEGLDevice // in

	_arg1 = C.guint(deviceIndex)

	_cret = C.gst_gl_display_egl_device_new(_arg1)
	runtime.KeepAlive(deviceIndex)

	var _glDisplayEGLDevice *GLDisplayEGLDevice // out

	_glDisplayEGLDevice = wrapGLDisplayEGLDevice(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplayEGLDevice
}

// NewGLDisplayEGLDeviceWithEglDevice creates a new GLDisplayEGLDevice with
// EGLDeviceEXT . The device must be created using EGLDevice enumeration.
//
// The function takes the following parameters:
//
//    - device (optional): existing EGLDeviceEXT.
//
// The function returns the following values:
//
//    - glDisplayEGLDevice: new GLDisplayEGLDevice.
//
func NewGLDisplayEGLDeviceWithEglDevice(device unsafe.Pointer) *GLDisplayEGLDevice {
	var _arg1 C.gpointer               // out
	var _cret *C.GstGLDisplayEGLDevice // in

	_arg1 = (C.gpointer)(unsafe.Pointer(device))

	_cret = C.gst_gl_display_egl_device_new_with_egl_device(_arg1)
	runtime.KeepAlive(device)

	var _glDisplayEGLDevice *GLDisplayEGLDevice // out

	_glDisplayEGLDevice = wrapGLDisplayEGLDevice(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplayEGLDevice
}

// GLDisplayEGLDeviceClass: opaque GLDisplayEGLDeviceClass struct
//
// An instance of this type is always passed by reference.
type GLDisplayEGLDeviceClass struct {
	*glDisplayEGLDeviceClass
}

// glDisplayEGLDeviceClass is the struct that's finalized.
type glDisplayEGLDeviceClass struct {
	native *C.GstGLDisplayEGLDeviceClass
}

func (g *GLDisplayEGLDeviceClass) ObjectClass() *gstgl.GLDisplayClass {
	valptr := &g.native.object_class
	var _v *gstgl.GLDisplayClass // out
	_v = (*gstgl.GLDisplayClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (g *GLDisplayEGLDeviceClass) Padding() [4]unsafe.Pointer {
	valptr := &g.native._padding
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
