// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// GType values.
var (
	GTypeGLBufferAllocator        = coreglib.Type(C.gst_gl_buffer_allocator_get_type())
	GTypeGLBuffer                 = coreglib.Type(C.gst_gl_buffer_get_type())
	GTypeGLBufferAllocationParams = coreglib.Type(C.gst_gl_buffer_allocation_params_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLBufferAllocator, F: marshalGLBufferAllocator},
		coreglib.TypeMarshaler{T: GTypeGLBuffer, F: marshalGLBuffer},
		coreglib.TypeMarshaler{T: GTypeGLBufferAllocationParams, F: marshalGLBufferAllocationParams},
	})
}

// CAPS_FEATURE_MEMORY_GL_BUFFER: name of the caps feature indicating the use of
// GL buffers.
const CAPS_FEATURE_MEMORY_GL_BUFFER = "memory:GLBuffer"

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER: GL allocation flag indicating the
// allocation of a GL buffer.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER = 16

// GL_BUFFER_ALLOCATOR_NAME: name of the GL buffer allocator.
const GL_BUFFER_ALLOCATOR_NAME = "GLBuffer"

// GLBufferAllocatorOverrides contains methods that are overridable.
type GLBufferAllocatorOverrides struct {
}

func defaultGLBufferAllocatorOverrides(v *GLBufferAllocator) GLBufferAllocatorOverrides {
	return GLBufferAllocatorOverrides{}
}

// GLBufferAllocator: opaque GLBufferAllocator struct.
type GLBufferAllocator struct {
	_ [0]func() // equal guard
	GLBaseMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLBufferAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLBufferAllocator, *GLBufferAllocatorClass, GLBufferAllocatorOverrides](
		GTypeGLBufferAllocator,
		initGLBufferAllocatorClass,
		wrapGLBufferAllocator,
		defaultGLBufferAllocatorOverrides,
	)
}

func initGLBufferAllocatorClass(gclass unsafe.Pointer, overrides GLBufferAllocatorOverrides, classInitFunc func(*GLBufferAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLBufferAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBufferAllocator(obj *coreglib.Object) *GLBufferAllocator {
	return &GLBufferAllocator{
		GLBaseMemoryAllocator: GLBaseMemoryAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLBufferAllocator(p uintptr) (interface{}, error) {
	return wrapGLBufferAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLBuffer is a Memory subclass providing support for the mapping of GL
// buffers.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// An instance of this type is always passed by reference.
type GLBuffer struct {
	*glBuffer
}

// glBuffer is the struct that's finalized.
type glBuffer struct {
	native *C.GstGLBuffer
}

func marshalGLBuffer(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLBuffer{&glBuffer{(*C.GstGLBuffer)(b)}}, nil
}

// Mem: parent object.
func (g *GLBuffer) Mem() *GLBaseMemory {
	valptr := &g.native.mem
	var _v *GLBaseMemory // out
	_v = (*GLBaseMemory)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ID: buffer id for this memory.
func (g *GLBuffer) ID() uint {
	valptr := &g.native.id
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Target: openGL target of this texture for binding purposes.
func (g *GLBuffer) Target() uint {
	valptr := &g.native.target
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// UsageHints: openGL usage hints this buffer was created with.
func (g *GLBuffer) UsageHints() uint {
	valptr := &g.native.usage_hints
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// ID: buffer id for this memory.
func (g *GLBuffer) SetID(id uint) {
	valptr := &g.native.id
	*valptr = C.guint(id)
}

// Target: openGL target of this texture for binding purposes.
func (g *GLBuffer) SetTarget(target uint) {
	valptr := &g.native.target
	*valptr = C.guint(target)
}

// UsageHints: openGL usage hints this buffer was created with.
func (g *GLBuffer) SetUsageHints(usageHints uint) {
	valptr := &g.native.usage_hints
	*valptr = C.guint(usageHints)
}

// GLBufferAllocationParams: instance of this type is always passed by
// reference.
type GLBufferAllocationParams struct {
	*glBufferAllocationParams
}

// glBufferAllocationParams is the struct that's finalized.
type glBufferAllocationParams struct {
	native *C.GstGLBufferAllocationParams
}

func marshalGLBufferAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLBufferAllocationParams{&glBufferAllocationParams{(*C.GstGLBufferAllocationParams)(b)}}, nil
}

// NewGLBufferAllocationParams constructs a struct GLBufferAllocationParams.
func NewGLBufferAllocationParams(context GLContexter, allocSize uint, allocParams *gst.AllocationParams, glTarget uint, glUsage uint) *GLBufferAllocationParams {
	var _arg1 *C.GstGLContext                // out
	var _arg2 C.gsize                        // out
	var _arg3 *C.GstAllocationParams         // out
	var _arg4 C.guint                        // out
	var _arg5 C.guint                        // out
	var _cret *C.GstGLBufferAllocationParams // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.gsize(allocSize)
	if allocParams != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(allocParams)))
	}
	_arg4 = C.guint(glTarget)
	_arg5 = C.guint(glUsage)

	_cret = C.gst_gl_buffer_allocation_params_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allocSize)
	runtime.KeepAlive(allocParams)
	runtime.KeepAlive(glTarget)
	runtime.KeepAlive(glUsage)

	var _glBufferAllocationParams *GLBufferAllocationParams // out

	_glBufferAllocationParams = (*GLBufferAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glBufferAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _glBufferAllocationParams
}

// Parent: parent object.
func (g *GLBufferAllocationParams) Parent() *GLAllocationParams {
	valptr := &g.native.parent
	var _v *GLAllocationParams // out
	_v = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLTarget: openGL target to bind the buffer to.
func (g *GLBufferAllocationParams) GLTarget() uint {
	valptr := &g.native.gl_target
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// GLUsage: openGL usage hint to create the buffer with.
func (g *GLBufferAllocationParams) GLUsage() uint {
	valptr := &g.native.gl_usage
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// GLTarget: openGL target to bind the buffer to.
func (g *GLBufferAllocationParams) SetGLTarget(glTarget uint) {
	valptr := &g.native.gl_target
	*valptr = C.guint(glTarget)
}

// GLUsage: openGL usage hint to create the buffer with.
func (g *GLBufferAllocationParams) SetGLUsage(glUsage uint) {
	valptr := &g.native.gl_usage
	*valptr = C.guint(glUsage)
}

// GLBufferAllocatorClass only contains private data
//
// An instance of this type is always passed by reference.
type GLBufferAllocatorClass struct {
	*glBufferAllocatorClass
}

// glBufferAllocatorClass is the struct that's finalized.
type glBufferAllocatorClass struct {
	native *C.GstGLBufferAllocatorClass
}

func (g *GLBufferAllocatorClass) ParentClass() *GLBaseMemoryAllocatorClass {
	valptr := &g.native.parent_class
	var _v *GLBaseMemoryAllocatorClass // out
	_v = (*GLBaseMemoryAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
