// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstvideo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// The function takes the following parameters:
//
//    - element
//    - display
//
func GLElementPropagateDisplayContext(element gst.Elementer, display *GLDisplay) {
	var _arg1 *C.GstElement   // out
	var _arg2 *C.GstGLDisplay // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gst_gl_element_propagate_display_context(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(display)
}

// GLGetPlaneDataSize: retrieve the size in bytes of a video plane of data with
// a certain alignment.
//
// The function takes the following parameters:
//
//    - info: VideoInfo.
//    - align or NULL.
//    - plane number in info to retrieve the data size of.
//
// The function returns the following values:
//
func GLGetPlaneDataSize(info *gstvideo.VideoInfo, align *gstvideo.VideoAlignment, plane uint) uint {
	var _arg1 *C.GstVideoInfo      // out
	var _arg2 *C.GstVideoAlignment // out
	var _arg3 C.guint              // out
	var _cret C.gsize              // in

	_arg1 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(align)))
	_arg3 = C.guint(plane)

	_cret = C.gst_gl_get_plane_data_size(_arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(align)
	runtime.KeepAlive(plane)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function takes the following parameters:
//
//    - info: VideoInfo.
//    - valign or NULL.
//    - plane number in info to retrieve the data size of.
//
// The function returns the following values:
//
//    - gsize: difference between the supposed start of the plane from the info
//      and where the data from the previous plane ends.
//
func GLGetPlaneStart(info *gstvideo.VideoInfo, valign *gstvideo.VideoAlignment, plane uint) uint {
	var _arg1 *C.GstVideoInfo      // out
	var _arg2 *C.GstVideoAlignment // out
	var _arg3 C.guint              // out
	var _cret C.gsize              // in

	_arg1 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(valign)))
	_arg3 = C.guint(plane)

	_cret = C.gst_gl_get_plane_start(_arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(valign)
	runtime.KeepAlive(plane)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function takes the following parameters:
//
//    - element: Element.
//    - query of type GST_QUERY_CONTEXT.
//    - display (optional): GLDisplay.
//    - context (optional): GLContext.
//    - otherContext (optional): application provided GLContext.
//
// The function returns the following values:
//
//    - ok: whether the query was successfully responded to from the passed
//      display, context, and other_context.
//
func GLHandleContextQuery(element gst.Elementer, query *gst.Query, display *GLDisplay, context, otherContext GLContexter) bool {
	var _arg1 *C.GstElement   // out
	var _arg2 *C.GstQuery     // out
	var _arg3 *C.GstGLDisplay // out
	var _arg4 *C.GstGLContext // out
	var _arg5 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if display != nil {
		_arg3 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}
	if context != nil {
		_arg4 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}
	if otherContext != nil {
		_arg5 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))
	}

	_cret = C.gst_gl_handle_context_query(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(element)
	runtime.KeepAlive(query)
	runtime.KeepAlive(display)
	runtime.KeepAlive(context)
	runtime.KeepAlive(otherContext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLHandleSetContext: helper function for implementing
// ElementClass.set_context() in OpenGL capable elements.
//
// Retrieve's the GLDisplay or GLContext in context and places the result in
// display or other_context respectively.
//
// The function takes the following parameters:
//
//    - element: Element.
//    - context: Context.
//
// The function returns the following values:
//
//    - display: location of a GLDisplay.
//    - otherContext: location of a GLContext.
//    - ok: whether the display or other_context could be set successfully.
//
func GLHandleSetContext(element gst.Elementer, context *gst.Context) (*GLDisplay, GLContexter, bool) {
	var _arg1 *C.GstElement   // out
	var _arg2 *C.GstContext   // out
	var _arg3 *C.GstGLDisplay // in
	var _arg4 *C.GstGLContext // in
	var _cret C.gboolean      // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_gl_handle_set_context(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(element)
	runtime.KeepAlive(context)

	var _display *GLDisplay       // out
	var _otherContext GLContexter // out
	var _ok bool                  // out

	_display = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_arg3)))
	{
		objptr := unsafe.Pointer(_arg4)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_otherContext = rv
	}
	if _cret != 0 {
		_ok = true
	}

	return _display, _otherContext, _ok
}

// GLValueGetTextureTargetMask: see gst_gl_value_set_texture_target_from_mask()
// for what entails a mask.
//
// The function takes the following parameters:
//
//    - value: initialized #GValue of type G_TYPE_STRING.
//
// The function returns the following values:
//
//    - glTextureTarget: mask of GLTextureTarget's in value or
//      GST_GL_TEXTURE_TARGET_NONE on failure.
//
func GLValueGetTextureTargetMask(value *coreglib.Value) GLTextureTarget {
	var _arg1 *C.GValue            // out
	var _cret C.GstGLTextureTarget // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_gl_value_get_texture_target_mask(_arg1)
	runtime.KeepAlive(value)

	var _glTextureTarget GLTextureTarget // out

	_glTextureTarget = GLTextureTarget(_cret)

	return _glTextureTarget
}

// The function takes the following parameters:
//
//    - value: initialized #GValue of type G_TYPE_STRING.
//    - target: GLTextureTarget's.
//
// The function returns the following values:
//
//    - ok: whether the target could be set on value.
//
func GLValueSetTextureTarget(value *coreglib.Value, target GLTextureTarget) bool {
	var _arg1 *C.GValue            // out
	var _arg2 C.GstGLTextureTarget // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.GstGLTextureTarget(target)

	_cret = C.gst_gl_value_set_texture_target(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLValueSetTextureTargetFromMask: mask is a bitwise OR of (1 << target) where
// target is a valid GLTextureTarget.
//
// The function takes the following parameters:
//
//    - value: uninitialized #GValue.
//    - targetMask: bitwise mask of GLTextureTarget's.
//
// The function returns the following values:
//
//    - ok: whether the target_mask could be set on value.
//
func GLValueSetTextureTargetFromMask(value *coreglib.Value, targetMask GLTextureTarget) bool {
	var _arg1 *C.GValue            // out
	var _arg2 C.GstGLTextureTarget // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.GstGLTextureTarget(targetMask)

	_cret = C.gst_gl_value_set_texture_target_from_mask(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(targetMask)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
