// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
// extern gboolean _gotk4_gstgl1_GLFilterRenderFunc(GstGLFilter*, GstGLMemory*, gpointer);
// extern gboolean _gotk4_gstgl1_GLFilterClass_set_caps(GstGLFilter*, GstCaps*, GstCaps*);
// extern gboolean _gotk4_gstgl1_GLFilterClass_init_fbo(GstGLFilter*);
// extern gboolean _gotk4_gstgl1_GLFilterClass_filter_texture(GstGLFilter*, GstGLMemory*, GstGLMemory*);
// extern gboolean _gotk4_gstgl1_GLFilterClass_filter(GstGLFilter*, GstBuffer*, GstBuffer*);
// extern GstCaps* _gotk4_gstgl1_GLFilterClass_transform_internal_caps(GstGLFilter*, GstPadDirection, GstCaps*, GstCaps*);
// GstCaps* _gotk4_gstgl1_GLFilter_virtual_transform_internal_caps(void* fnptr, GstGLFilter* arg0, GstPadDirection arg1, GstCaps* arg2, GstCaps* arg3) {
//   return ((GstCaps* (*)(GstGLFilter*, GstPadDirection, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_filter(void* fnptr, GstGLFilter* arg0, GstBuffer* arg1, GstBuffer* arg2) {
//   return ((gboolean (*)(GstGLFilter*, GstBuffer*, GstBuffer*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_filter_texture(void* fnptr, GstGLFilter* arg0, GstGLMemory* arg1, GstGLMemory* arg2) {
//   return ((gboolean (*)(GstGLFilter*, GstGLMemory*, GstGLMemory*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_init_fbo(void* fnptr, GstGLFilter* arg0) {
//   return ((gboolean (*)(GstGLFilter*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_set_caps(void* fnptr, GstGLFilter* arg0, GstCaps* arg1, GstCaps* arg2) {
//   return ((gboolean (*)(GstGLFilter*, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeGLFilter = coreglib.Type(C.gst_gl_filter_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLFilter, F: marshalGLFilter},
	})
}

// GLFilterOverrides contains methods that are overridable.
type GLFilterOverrides struct {
	// The function takes the following parameters:
	//
	//    - inbuf
	//    - outbuf
	//
	// The function returns the following values:
	//
	Filter func(inbuf, outbuf *gst.Buffer) bool
	// FilterTexture calls filter_texture vfunc with correctly mapped GLMemorys.
	//
	// The function takes the following parameters:
	//
	//    - input buffer.
	//    - output buffer.
	//
	// The function returns the following values:
	//
	//    - ok: whether the transformation succeeded.
	//
	FilterTexture func(input, output *GLMemory) bool
	// The function returns the following values:
	//
	InitFbo func() bool
	// The function takes the following parameters:
	//
	//    - incaps
	//    - outcaps
	//
	// The function returns the following values:
	//
	SetCaps func(incaps, outcaps *gst.Caps) bool
	// The function takes the following parameters:
	//
	//    - direction
	//    - caps
	//    - filterCaps
	//
	// The function returns the following values:
	//
	TransformInternalCaps func(direction gst.PadDirection, caps, filterCaps *gst.Caps) *gst.Caps
}

func defaultGLFilterOverrides(v *GLFilter) GLFilterOverrides {
	return GLFilterOverrides{
		Filter:                v.filter,
		FilterTexture:         v.filterTexture,
		InitFbo:               v.initFbo,
		SetCaps:               v.setCaps,
		TransformInternalCaps: v.transformInternalCaps,
	}
}

// GLFilter helps to implement simple OpenGL filter elements taking a single
// input and producing a single output with a GLFramebuffer.
type GLFilter struct {
	_ [0]func() // equal guard
	GLBaseFilter
}

var (
	_ gstbase.BaseTransformer = (*GLFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLFilter, *GLFilterClass, GLFilterOverrides](
		GTypeGLFilter,
		initGLFilterClass,
		wrapGLFilter,
		defaultGLFilterOverrides,
	)
}

func initGLFilterClass(gclass unsafe.Pointer, overrides GLFilterOverrides, classInitFunc func(*GLFilterClass)) {
	pclass := (*C.GstGLFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLFilter))))

	if overrides.Filter != nil {
		pclass.filter = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_filter)
	}

	if overrides.FilterTexture != nil {
		pclass.filter_texture = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_filter_texture)
	}

	if overrides.InitFbo != nil {
		pclass.init_fbo = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_init_fbo)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_set_caps)
	}

	if overrides.TransformInternalCaps != nil {
		pclass.transform_internal_caps = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_transform_internal_caps)
	}

	if classInitFunc != nil {
		class := (*GLFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLFilter(obj *coreglib.Object) *GLFilter {
	return &GLFilter{
		GLBaseFilter: GLBaseFilter{
			BaseTransform: gstbase.BaseTransform{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLFilter(p uintptr) (interface{}, error) {
	return wrapGLFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DrawFullscreenQuad: render a fullscreen quad using the current GL state. The
// only GL state this modifies is the necessary vertex/index buffers and, if
// necessary, a Vertex Array Object for drawing a fullscreen quad. Framebuffer
// state, any shaders, viewport state, etc must be setup by the caller.
func (filter *GLFilter) DrawFullscreenQuad() {
	var _arg0 *C.GstGLFilter // out

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gst_gl_filter_draw_fullscreen_quad(_arg0)
	runtime.KeepAlive(filter)
}

// FilterTexture calls filter_texture vfunc with correctly mapped GLMemorys.
//
// The function takes the following parameters:
//
//    - input buffer.
//    - output buffer.
//
// The function returns the following values:
//
//    - ok: whether the transformation succeeded.
//
func (filter *GLFilter) FilterTexture(input, output *gst.Buffer) bool {
	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 *C.GstBuffer   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gst_gl_filter_filter_texture(_arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenderToTarget transforms input into output using func on through FBO.
//
// The function takes the following parameters:
//
//    - input texture.
//    - output texture.
//    - fn: function to transform input into output. called with data.
//
// The function returns the following values:
//
//    - ok: return value of func.
//
func (filter *GLFilter) RenderToTarget(input, output *GLMemory, fn GLFilterRenderFunc) bool {
	var _arg0 *C.GstGLFilter          // out
	var _arg1 *C.GstGLMemory          // out
	var _arg2 *C.GstGLMemory          // out
	var _arg3 C.GstGLFilterRenderFunc // out
	var _arg4 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(output)))
	_arg3 = (*[0]byte)(C._gotk4_gstgl1_GLFilterRenderFunc)
	_arg4 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg4))

	_cret = C.gst_gl_filter_render_to_target(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenderToTargetWithShader transforms input into output using shader with a
// FBO.
//
// See also: gst_gl_filter_render_to_target().
//
// The function takes the following parameters:
//
//    - input texture.
//    - output texture.
//    - shader to use.
//
func (filter *GLFilter) RenderToTargetWithShader(input, output *GLMemory, shader *GLShader) {
	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstGLMemory // out
	var _arg2 *C.GstGLMemory // out
	var _arg3 *C.GstGLShader // out

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(output)))
	_arg3 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	C.gst_gl_filter_render_to_target_with_shader(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)
	runtime.KeepAlive(shader)
}

// The function takes the following parameters:
//
//    - inbuf
//    - outbuf
//
// The function returns the following values:
//
func (filter *GLFilter) filter(inbuf, outbuf *gst.Buffer) bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.filter

	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 *C.GstBuffer   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_filter(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// filterTexture calls filter_texture vfunc with correctly mapped GLMemorys.
//
// The function takes the following parameters:
//
//    - input buffer.
//    - output buffer.
//
// The function returns the following values:
//
//    - ok: whether the transformation succeeded.
//
func (filter *GLFilter) filterTexture(input, output *GLMemory) bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.filter_texture

	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstGLMemory // out
	var _arg2 *C.GstGLMemory // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_filter_texture(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (filter *GLFilter) initFbo() bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.init_fbo

	var _arg0 *C.GstGLFilter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_init_fbo(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - incaps
//    - outcaps
//
// The function returns the following values:
//
func (filter *GLFilter) setCaps(incaps, outcaps *gst.Caps) bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.set_caps

	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstCaps     // out
	var _arg2 *C.GstCaps     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(incaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outcaps)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(incaps)
	runtime.KeepAlive(outcaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - direction
//    - caps
//    - filterCaps
//
// The function returns the following values:
//
func (filter *GLFilter) transformInternalCaps(direction gst.PadDirection, caps, filterCaps *gst.Caps) *gst.Caps {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.transform_internal_caps

	var _arg0 *C.GstGLFilter    // out
	var _arg1 C.GstPadDirection // out
	var _arg2 *C.GstCaps        // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filterCaps)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_transform_internal_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filterCaps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// The function takes the following parameters:
//
func GLFilterAddRGBAPadTemplates(klass *GLFilterClass) {
	var _arg1 *C.GstGLFilterClass // out

	_arg1 = (*C.GstGLFilterClass)(gextras.StructNative(unsafe.Pointer(klass)))

	C.gst_gl_filter_add_rgba_pad_templates(_arg1)
	runtime.KeepAlive(klass)
}

// GLFilterClass: instance of this type is always passed by reference.
type GLFilterClass struct {
	*glFilterClass
}

// glFilterClass is the struct that's finalized.
type glFilterClass struct {
	native *C.GstGLFilterClass
}

func (g *GLFilterClass) ParentClass() *GLBaseFilterClass {
	valptr := &g.native.parent_class
	var _v *GLBaseFilterClass // out
	_v = (*GLBaseFilterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
