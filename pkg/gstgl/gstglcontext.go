// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
// extern void _gotk4_gstgl1_GLContextClass_swap_buffers(GstGLContext*);
// extern void _gotk4_gstgl1_GLContextClass_get_gl_platform_version(GstGLContext*, gint*, gint*);
// extern void _gotk4_gstgl1_GLContextClass_destroy_context(GstGLContext*);
// extern guintptr _gotk4_gstgl1_GLContextClass_get_gl_context(GstGLContext*);
// extern gboolean _gotk4_gstgl1_GLContextClass_request_config(GstGLContext*, GstStructure*);
// extern gboolean _gotk4_gstgl1_GLContextClass_create_context(GstGLContext*, GstGLAPI, GstGLContext*, GError**);
// extern gboolean _gotk4_gstgl1_GLContextClass_choose_format(GstGLContext*, GError**);
// extern gboolean _gotk4_gstgl1_GLContextClass_check_feature(GstGLContext*, gchar*);
// extern gboolean _gotk4_gstgl1_GLContextClass_activate(GstGLContext*, gboolean);
// extern GstStructure* _gotk4_gstgl1_GLContextClass_get_config(GstGLContext*);
// extern GstGLPlatform _gotk4_gstgl1_GLContextClass_get_gl_platform(GstGLContext*);
// extern GstGLAPI _gotk4_gstgl1_GLContextClass_get_gl_api(GstGLContext*);
// GstGLAPI _gotk4_gstgl1_GLContext_virtual_get_gl_api(void* fnptr, GstGLContext* arg0) {
//   return ((GstGLAPI (*)(GstGLContext*))(fnptr))(arg0);
// };
// GstGLPlatform _gotk4_gstgl1_GLContext_virtual_get_gl_platform(void* fnptr, GstGLContext* arg0) {
//   return ((GstGLPlatform (*)(GstGLContext*))(fnptr))(arg0);
// };
// GstStructure* _gotk4_gstgl1_GLContext_virtual_get_config(void* fnptr, GstGLContext* arg0) {
//   return ((GstStructure* (*)(GstGLContext*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_activate(void* fnptr, GstGLContext* arg0, gboolean arg1) {
//   return ((gboolean (*)(GstGLContext*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_check_feature(void* fnptr, GstGLContext* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstGLContext*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_choose_format(void* fnptr, GstGLContext* arg0, GError** arg1) {
//   return ((gboolean (*)(GstGLContext*, GError**))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_create_context(void* fnptr, GstGLContext* arg0, GstGLAPI arg1, GstGLContext* arg2, GError** arg3) {
//   return ((gboolean (*)(GstGLContext*, GstGLAPI, GstGLContext*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_request_config(void* fnptr, GstGLContext* arg0, GstStructure* arg1) {
//   return ((gboolean (*)(GstGLContext*, GstStructure*))(fnptr))(arg0, arg1);
// };
// guintptr _gotk4_gstgl1_GLContext_virtual_get_gl_context(void* fnptr, GstGLContext* arg0) {
//   return ((guintptr (*)(GstGLContext*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLContext_virtual_destroy_context(void* fnptr, GstGLContext* arg0) {
//   ((void (*)(GstGLContext*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLContext_virtual_get_gl_platform_version(void* fnptr, GstGLContext* arg0, gint* arg1, gint* arg2) {
//   ((void (*)(GstGLContext*, gint*, gint*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstgl1_GLContext_virtual_swap_buffers(void* fnptr, GstGLContext* arg0) {
//   ((void (*)(GstGLContext*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeGLContextError = coreglib.Type(C.gst_gl_context_error_get_type())
	GTypeGLContext      = coreglib.Type(C.gst_gl_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLContextError, F: marshalGLContextError},
		coreglib.TypeMarshaler{T: GTypeGLContext, F: marshalGLContext},
	})
}

const GL_CONTEXT_TYPE_CGL = "gst.gl.context.CGL"
const GL_CONTEXT_TYPE_EAGL = "gst.gl.context.EAGL"
const GL_CONTEXT_TYPE_EGL = "gst.gl.context.EGL"
const GL_CONTEXT_TYPE_GLX = "gst.gl.context.GLX"
const GL_CONTEXT_TYPE_WGL = "gst.gl.context.WGL"

// GLContextError: openGL context errors.
type GLContextError C.gint

const (
	// GLContextErrorFailed: failed for an unspecified reason.
	GLContextErrorFailed GLContextError = iota
	// GLContextErrorWrongConfig: configuration requested is not correct.
	GLContextErrorWrongConfig
	// GLContextErrorWrongApi: openGL API requested is not correct.
	GLContextErrorWrongApi
	// GLContextErrorOldLibs: openGL libraries are too old.
	GLContextErrorOldLibs
	// GLContextErrorCreateContext: glXCreateContext (or similar) failed.
	GLContextErrorCreateContext
	// GLContextErrorResourceUnavailable: resource is not available.
	GLContextErrorResourceUnavailable
)

func marshalGLContextError(p uintptr) (interface{}, error) {
	return GLContextError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLContextError.
func (g GLContextError) String() string {
	switch g {
	case GLContextErrorFailed:
		return "Failed"
	case GLContextErrorWrongConfig:
		return "WrongConfig"
	case GLContextErrorWrongApi:
		return "WrongApi"
	case GLContextErrorOldLibs:
		return "OldLibs"
	case GLContextErrorCreateContext:
		return "CreateContext"
	case GLContextErrorResourceUnavailable:
		return "ResourceUnavailable"
	default:
		return fmt.Sprintf("GLContextError(%d)", g)
	}
}

// GLContextOverrides contains methods that are overridable.
type GLContextOverrides struct {
	// Activate: (De)activate the OpenGL context represented by this context.
	//
	// In OpenGL terms, calls eglMakeCurrent or similar with this context and
	// the currently set window. See gst_gl_context_set_window() for details.
	//
	// The function takes the following parameters:
	//
	//    - activate: TRUE to activate, FALSE to deactivate.
	//
	// The function returns the following values:
	//
	//    - ok: whether the activation succeeded.
	//
	Activate func(activate bool) bool
	// CheckFeature: check for an OpenGL feature being supported.
	//
	// Note: Most features require that the context be created before it is
	// possible to determine their existence and so will fail if that is not the
	// case.
	//
	// The function takes the following parameters:
	//
	//    - feature: platform specific feature.
	//
	// The function returns the following values:
	//
	//    - ok: whether feature is supported by context.
	//
	CheckFeature func(feature string) bool
	ChooseFormat func() error
	// The function takes the following parameters:
	//
	//    - glApi
	//    - otherContext
	//
	CreateContext  func(glApi GLAPI, otherContext GLContexter) error
	DestroyContext func()
	// Config: retrieve the OpenGL configuration for this context. The context
	// must have been successfully created for this function to return a valid
	// value.
	//
	// Not all implementations currently support retrieving the config and will
	// return NULL when not supported.
	//
	// The function returns the following values:
	//
	//    - structure (optional): configuration chosen for this OpenGL context.
	//
	Config func() *gst.Structure
	// GLApi: get the currently enabled OpenGL api.
	//
	// The currently available API may be limited by the GLDisplay in use and/or
	// the GLWindow chosen.
	//
	// The function returns the following values:
	//
	//    - glapI: available OpenGL api.
	//
	GLApi func() GLAPI
	// GLContext gets the backing OpenGL context used by context.
	//
	// The function returns the following values:
	//
	//    - guintptr: platform specific backing OpenGL context.
	//
	GLContext func() uintptr
	// GLPlatform gets the OpenGL platform that used by context.
	//
	// The function returns the following values:
	//
	//    - glPlatform: platform specific backing OpenGL context.
	//
	GLPlatform func() GLPlatform
	// GLPlatformVersion: get the version of the OpenGL platform (GLX, EGL, etc)
	// used. Only valid after a call to gst_gl_context_create().
	//
	// The function returns the following values:
	//
	//    - major: return for the major version.
	//    - minor: return for the minor version.
	//
	GLPlatformVersion func() (major, minor int)
	// RequestConfig: set the OpenGL configuration for this context. The context
	// must not have been created for this function to succeed. Setting a NULL
	// config has the affect of removing any specific configuration request.
	//
	// Not all implementations currently support retrieving the config and this
	// function will return FALSE when not supported.
	//
	// Note that calling this function may cause a subsequent
	// gst_gl_context_create() to fail if config could not be matched with the
	// platform-specific configuration.
	//
	// Note that the actual config used may be differ from the requested values.
	//
	// The function takes the following parameters:
	//
	//    - glConfig (optional): configuration structure for configuring the
	//      OpenGL context.
	//
	// The function returns the following values:
	//
	//    - ok: whether gl_config could be successfully set on context.
	//
	RequestConfig func(glConfig *gst.Structure) bool
	// SwapBuffers: swap the front and back buffers on the window attached to
	// context. This will display the frame on the next refresh cycle.
	SwapBuffers func()
}

func defaultGLContextOverrides(v *GLContext) GLContextOverrides {
	return GLContextOverrides{
		Activate:          v.activate,
		CheckFeature:      v.checkFeature,
		ChooseFormat:      v.chooseFormat,
		CreateContext:     v.createContext,
		DestroyContext:    v.destroyContext,
		Config:            v.config,
		GLApi:             v.glApi,
		GLContext:         v.glContext,
		GLPlatform:        v.glPlatform,
		GLPlatformVersion: v.glPlatformVersion,
		RequestConfig:     v.requestConfig,
		SwapBuffers:       v.swapBuffers,
	}
}

// GLContext wraps an OpenGL context object in a uniform API. As a result of the
// limitation on OpenGL context, this object is not thread safe unless specified
// and must only be activated in a single thread.
//
// Environment variables:
//
// - GST_GL_API: select which OpenGL API to create and OpenGL context for.
// Depending on the platform, the available values are 'opengl', 'opengl3' (core
// profile), and 'gles2'. See the the GLAPI enumeration for more details.
//
// - GST_GL_PLATFORM: select which OpenGL platform to create an OpenGL context
// with. Depending on the platform and the dependencies available build-time,
// the available values are, 'glx', 'egl', 'cgl', 'wgl', and 'eagl'
//
// - GST_GL_CONFIG: select the configuration used for creating the OpenGL
// context and OpenGL surface. Written out as a GstStructure that has been
// serialized to string. e.g.
// GST_GL_CONFIG="gst-gl-context-config,red-size=8,green-size=8,blue-size=8,alpha-size=8,depth-size=16".
// Not all platforms will support the same level of functionality.
type GLContext struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLContext)(nil)
)

// GLContexter describes types inherited from class GLContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLContexter interface {
	coreglib.Objector
	baseGLContext() *GLContext
}

var _ GLContexter = (*GLContext)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLContext, *GLContextClass, GLContextOverrides](
		GTypeGLContext,
		initGLContextClass,
		wrapGLContext,
		defaultGLContextOverrides,
	)
}

func initGLContextClass(gclass unsafe.Pointer, overrides GLContextOverrides, classInitFunc func(*GLContextClass)) {
	pclass := (*C.GstGLContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLContext))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_activate)
	}

	if overrides.CheckFeature != nil {
		pclass.check_feature = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_check_feature)
	}

	if overrides.ChooseFormat != nil {
		pclass.choose_format = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_choose_format)
	}

	if overrides.CreateContext != nil {
		pclass.create_context = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_create_context)
	}

	if overrides.DestroyContext != nil {
		pclass.destroy_context = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_destroy_context)
	}

	if overrides.Config != nil {
		pclass.get_config = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_config)
	}

	if overrides.GLApi != nil {
		pclass.get_gl_api = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_api)
	}

	if overrides.GLContext != nil {
		pclass.get_gl_context = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_context)
	}

	if overrides.GLPlatform != nil {
		pclass.get_gl_platform = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_platform)
	}

	if overrides.GLPlatformVersion != nil {
		pclass.get_gl_platform_version = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_platform_version)
	}

	if overrides.RequestConfig != nil {
		pclass.request_config = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_request_config)
	}

	if overrides.SwapBuffers != nil {
		pclass.swap_buffers = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_swap_buffers)
	}

	if classInitFunc != nil {
		class := (*GLContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLContext(obj *coreglib.Object) *GLContext {
	return &GLContext{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	return wrapGLContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (context *GLContext) baseGLContext() *GLContext {
	return context
}

// BaseGLContext returns the underlying base object.
func BaseGLContext(obj GLContexter) *GLContext {
	return obj.baseGLContext()
}

// NewGLContext: create a new GLContext with the specified display.
//
// The function takes the following parameters:
//
//    - display: GLDisplay.
//
// The function returns the following values:
//
//    - glContext: new GLContext.
//
func NewGLContext(display *GLDisplay) *GLContext {
	var _arg1 *C.GstGLDisplay // out
	var _cret *C.GstGLContext // in

	_arg1 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_context_new(_arg1)
	runtime.KeepAlive(display)

	var _glContext *GLContext // out

	_glContext = wrapGLContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _glContext
}

// NewGLContextWrapped wraps an existing OpenGL context into a GLContext.
//
// Note: The caller is responsible for ensuring that the OpenGL context
// represented by handle stays alive while the returned GLContext is active.
//
// context_type must not be GST_GL_PLATFORM_NONE or GST_GL_PLATFORM_ANY
//
// available_apis must not be GST_GL_API_NONE or GST_GL_API_ANY.
//
// The function takes the following parameters:
//
//    - display: GLDisplay.
//    - handle: openGL context to wrap.
//    - contextType specifying the type of context in handle.
//    - availableApis containing the available OpenGL apis in handle.
//
// The function returns the following values:
//
//    - glContext wrapping handle.
//
func NewGLContextWrapped(display *GLDisplay, handle uintptr, contextType GLPlatform, availableApis GLAPI) *GLContext {
	var _arg1 *C.GstGLDisplay // out
	var _arg2 C.guintptr      // out
	var _arg3 C.GstGLPlatform // out
	var _arg4 C.GstGLAPI      // out
	var _cret *C.GstGLContext // in

	_arg1 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg2 = (C.guintptr)(unsafe.Pointer(handle))
	_arg3 = C.GstGLPlatform(contextType)
	_arg4 = C.GstGLAPI(availableApis)

	_cret = C.gst_gl_context_new_wrapped(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(contextType)
	runtime.KeepAlive(availableApis)

	var _glContext *GLContext // out

	_glContext = wrapGLContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glContext
}

// Activate: (De)activate the OpenGL context represented by this context.
//
// In OpenGL terms, calls eglMakeCurrent or similar with this context and the
// currently set window. See gst_gl_context_set_window() for details.
//
// The function takes the following parameters:
//
//    - activate: TRUE to activate, FALSE to deactivate.
//
// The function returns the following values:
//
//    - ok: whether the activation succeeded.
//
func (context *GLContext) Activate(activate bool) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if activate {
		_arg1 = C.TRUE
	}

	_cret = C.gst_gl_context_activate(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(activate)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanShare: note: This will always fail for two wrapped GLContext's.
//
// The function takes the following parameters:
//
//    - otherContext: another GLContext.
//
// The function returns the following values:
//
//    - ok: whether context and other_context are able to share OpenGL resources.
//
func (context *GLContext) CanShare(otherContext GLContexter) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))

	_cret = C.gst_gl_context_can_share(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(otherContext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckFeature: check for an OpenGL feature being supported.
//
// Note: Most features require that the context be created before it is possible
// to determine their existence and so will fail if that is not the case.
//
// The function takes the following parameters:
//
//    - feature: platform specific feature.
//
// The function returns the following values:
//
//    - ok: whether feature is supported by context.
//
func (context *GLContext) CheckFeature(feature string) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_context_check_feature(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckFramebufferStatus: must be called with context current.
//
// The function takes the following parameters:
//
//    - fboTarget: GL value of the framebuffer target, GL_FRAMEBUFFER,
//      GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER.
//
// The function returns the following values:
//
//    - ok: whether whether the current framebuffer is complete.
//
func (context *GLContext) CheckFramebufferStatus(fboTarget uint) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.guint         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.guint(fboTarget)

	_cret = C.gst_gl_context_check_framebuffer_status(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(fboTarget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - api type required.
//    - maj: major version required.
//    - min: minor version required.
//
// The function returns the following values:
//
//    - ok: whether OpenGL context implements the required api and specified
//      version.
//
func (context *GLContext) CheckGLVersion(api GLAPI, maj, min int) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.GstGLAPI      // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLAPI(api)
	_arg2 = C.gint(maj)
	_arg3 = C.gint(min)

	_cret = C.gst_gl_context_check_gl_version(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(api)
	runtime.KeepAlive(maj)
	runtime.KeepAlive(min)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ClearFramebuffer: unbind the current framebuffer.
func (context *GLContext) ClearFramebuffer() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_clear_framebuffer(_arg0)
	runtime.KeepAlive(context)
}

// ClearShader clear's the currently set shader from the GL state machine.
//
// Note: must be called in the GL thread.
func (context *GLContext) ClearShader() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_clear_shader(_arg0)
	runtime.KeepAlive(context)
}

// Create creates an OpenGL context with the specified other_context as a
// context to share shareable OpenGL objects with. See the OpenGL specification
// for what is shared between OpenGL contexts.
//
// Since 1.20, the configuration can be overriden with the environment variable
// GST_GL_CONFIG which is a stringified Structure as would be returned from
// gst_gl_context_get_config(). If GST_GL_CONFIG is not set, then the config
// will be chosen from other_context by calling gst_gl_context_get_config() on
// other_context. Otherwise, a default configuration is used.
//
// Calling gst_gl_context_request_config()) before calling
// gst_gl_context_create() will override the config from other_context but will
// not override the GST_GL_CONFIG environment variable.
//
// If an error occurs, and error is not NULL, then error will contain details of
// the error and FALSE will be returned.
//
// Should only be called once.
//
// The function takes the following parameters:
//
//    - otherContext (optional) to share OpenGL objects with.
//
func (context *GLContext) Create(otherContext GLContexter) error {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if otherContext != nil {
		_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))
	}

	C.gst_gl_context_create(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(otherContext)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Destroy destroys an OpenGL context.
//
// Should only be called after gst_gl_context_create() has been successfully
// called for this context.
func (context *GLContext) Destroy() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_destroy(_arg0)
	runtime.KeepAlive(context)
}

// FillInfo fills context's info (version, extensions, vtable, etc) from the GL
// context in the current thread. Typically used with wrapped contexts to allow
// wrapped contexts to be used as regular GLContext's.
func (context *GLContext) FillInfo() error {
	var _arg0 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_fill_info(_arg0, &_cerr)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Config: retrieve the OpenGL configuration for this context. The context must
// have been successfully created for this function to return a valid value.
//
// Not all implementations currently support retrieving the config and will
// return NULL when not supported.
//
// The function returns the following values:
//
//    - structure (optional): configuration chosen for this OpenGL context.
//
func (context *GLContext) Config() *gst.Structure {
	var _arg0 *C.GstGLContext // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_config(_arg0)
	runtime.KeepAlive(context)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// The function returns the following values:
//
//    - glDisplay associated with this context.
//
func (context *GLContext) Display() *GLDisplay {
	var _arg0 *C.GstGLContext // out
	var _cret *C.GstGLDisplay // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_display(_arg0)
	runtime.KeepAlive(context)

	var _glDisplay *GLDisplay // out

	_glDisplay = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplay
}

// GLApi: get the currently enabled OpenGL api.
//
// The currently available API may be limited by the GLDisplay in use and/or the
// GLWindow chosen.
//
// The function returns the following values:
//
//    - glapI: available OpenGL api.
//
func (context *GLContext) GLApi() GLAPI {
	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_gl_api(_arg0)
	runtime.KeepAlive(context)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// GLContext gets the backing OpenGL context used by context.
//
// The function returns the following values:
//
//    - guintptr: platform specific backing OpenGL context.
//
func (context *GLContext) GLContext() uintptr {
	var _arg0 *C.GstGLContext // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_gl_context(_arg0)
	runtime.KeepAlive(context)

	var _guintptr uintptr // out

	_guintptr = (uintptr)(unsafe.Pointer(_cret))

	return _guintptr
}

// GLPlatform gets the OpenGL platform that used by context.
//
// The function returns the following values:
//
//    - glPlatform: platform specific backing OpenGL context.
//
func (context *GLContext) GLPlatform() GLPlatform {
	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLPlatform // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_gl_platform(_arg0)
	runtime.KeepAlive(context)

	var _glPlatform GLPlatform // out

	_glPlatform = GLPlatform(_cret)

	return _glPlatform
}

// GLPlatformVersion: get the version of the OpenGL platform (GLX, EGL, etc)
// used. Only valid after a call to gst_gl_context_create().
//
// The function returns the following values:
//
//    - major: return for the major version.
//    - minor: return for the minor version.
//
func (context *GLContext) GLPlatformVersion() (major, minor int) {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_get_gl_platform_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// GLVersion returns the OpenGL version implemented by context. See
// gst_gl_context_get_gl_api() for retrieving the OpenGL api implemented by
// context.
//
// The function returns the following values:
//
//    - maj: resulting major version.
//    - min: resulting minor version.
//
func (context *GLContext) GLVersion() (maj, min int) {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_get_gl_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _maj int // out
	var _min int // out

	_maj = int(_arg1)
	_min = int(_arg2)

	return _maj, _min
}

// ProcAddress: get a function pointer to a specified opengl function, name. If
// the the specific function does not exist, NULL is returned instead.
//
// Platform specific functions (names starting 'egl', 'glX', 'wgl', etc) can
// also be retrieved using this method.
//
// Note: This function may return valid function pointers that may not be valid
// to call in context. The caller is responsible for ensuring that the returned
// function is a valid function to call in context by either checking the OpenGL
// API and version or for an appropriate OpenGL extension.
//
// Note: On success, you need to cast the returned function pointer to the
// correct type to be able to call it correctly. On 32-bit Windows, this will
// include the GSTGLAPI identifier to use the correct calling convention. e.g.
//
//    void (GSTGLAPI *PFN_glGetIntegerv) (GLenum name, GLint * ret).
//
// The function takes the following parameters:
//
//    - name: opengl function name.
//
// The function returns the following values:
//
//    - gpointer (optional): function pointer or NULL.
//
func (context *GLContext) ProcAddress(name string) unsafe.Pointer {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.gchar        // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_context_get_proc_address(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// The function returns the following values:
//
//    - glWindow (optional): currently set window.
//
func (context *GLContext) Window() GLWindower {
	var _arg0 *C.GstGLContext // out
	var _cret *C.GstGLWindow  // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_window(_arg0)
	runtime.KeepAlive(context)

	var _glWindow GLWindower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLWindower)
				return ok
			})
			rv, ok := casted.(GLWindower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLWindower")
			}
			_glWindow = rv
		}
	}

	return _glWindow
}

// The function returns the following values:
//
//    - ok: whether the GLContext has been shared with another GLContext.
//
func (context *GLContext) IsShared() bool {
	var _arg0 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_is_shared(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequestConfig: set the OpenGL configuration for this context. The context
// must not have been created for this function to succeed. Setting a NULL
// config has the affect of removing any specific configuration request.
//
// Not all implementations currently support retrieving the config and this
// function will return FALSE when not supported.
//
// Note that calling this function may cause a subsequent
// gst_gl_context_create() to fail if config could not be matched with the
// platform-specific configuration.
//
// Note that the actual config used may be differ from the requested values.
//
// The function takes the following parameters:
//
//    - glConfig (optional): configuration structure for configuring the OpenGL
//      context.
//
// The function returns the following values:
//
//    - ok: whether gl_config could be successfully set on context.
//
func (context *GLContext) RequestConfig(glConfig *gst.Structure) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if glConfig != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(glConfig)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(glConfig)), nil)
	}

	_cret = C.gst_gl_context_request_config(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(glConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSharedWith will internally set context as shared with share.
//
// The function takes the following parameters:
//
//    - share: another GLContext.
//
func (context *GLContext) SetSharedWith(share GLContexter) {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(share).Native()))

	C.gst_gl_context_set_shared_with(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(share)
}

// SetWindow set's the current window on context to window. The window can only
// be changed before gst_gl_context_create() has been called and the window is
// not already running.
//
// The function takes the following parameters:
//
//    - window: GLWindow.
//
// The function returns the following values:
//
//    - ok: whether the window was successfully updated.
//
func (context *GLContext) SetWindow(window GLWindower) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLWindow  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_context_set_window(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - version: GLSLVersion.
//    - profile: GLSLProfile.
//
// The function returns the following values:
//
//    - ok: whether context supports the combination of version with profile.
//
func (context *GLContext) SupportsGlslProfileVersion(version GLSLVersion, profile GLSLProfile) bool {
	var _arg0 *C.GstGLContext  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_context_supports_glsl_profile_version(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - version: GLSLVersion.
//    - profile: GLSLProfile.
//
// The function returns the following values:
//
//    - ok: whether context supports the 'precision' specifier in GLSL shaders.
//
func (context *GLContext) SupportsPrecision(version GLSLVersion, profile GLSLProfile) bool {
	var _arg0 *C.GstGLContext  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_context_supports_precision(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - version: GLSLVersion.
//    - profile: GLSLProfile.
//
// The function returns the following values:
//
//    - ok: whether context supports the 'precision highp' specifier in GLSL
//      shaders.
//
func (context *GLContext) SupportsPrecisionHighp(version GLSLVersion, profile GLSLProfile) bool {
	var _arg0 *C.GstGLContext  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_context_supports_precision_highp(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SwapBuffers: swap the front and back buffers on the window attached to
// context. This will display the frame on the next refresh cycle.
func (context *GLContext) SwapBuffers() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_swap_buffers(_arg0)
	runtime.KeepAlive(context)
}

// Activate the OpenGL context represented by this context.
//
// In OpenGL terms, calls eglMakeCurrent or similar with this context and the
// currently set window. See gst_gl_context_set_window() for details.
//
// The function takes the following parameters:
//
//    - activate: TRUE to activate, FALSE to deactivate.
//
// The function returns the following values:
//
//    - ok: whether the activation succeeded.
//
func (context *GLContext) activate(activate bool) bool {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.activate

	var _arg0 *C.GstGLContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if activate {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gstgl1_GLContext_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(activate)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// checkFeature: check for an OpenGL feature being supported.
//
// Note: Most features require that the context be created before it is possible
// to determine their existence and so will fail if that is not the case.
//
// The function takes the following parameters:
//
//    - feature: platform specific feature.
//
// The function returns the following values:
//
//    - ok: whether feature is supported by context.
//
func (context *GLContext) checkFeature(feature string) bool {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.check_feature

	var _arg0 *C.GstGLContext // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gstgl1_GLContext_virtual_check_feature(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (context *GLContext) chooseFormat() error {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.choose_format

	var _arg0 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_choose_format(unsafe.Pointer(fnarg), _arg0, &_cerr)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
//    - glApi
//    - otherContext
//
func (context *GLContext) createContext(glApi GLAPI, otherContext GLContexter) error {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.create_context

	var _arg0 *C.GstGLContext // out
	var _arg1 C.GstGLAPI      // out
	var _arg2 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLAPI(glApi)
	_arg2 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))

	C._gotk4_gstgl1_GLContext_virtual_create_context(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(glApi)
	runtime.KeepAlive(otherContext)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (context *GLContext) destroyContext() {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.destroy_context

	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_destroy_context(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// Config: retrieve the OpenGL configuration for this context. The context must
// have been successfully created for this function to return a valid value.
//
// Not all implementations currently support retrieving the config and will
// return NULL when not supported.
//
// The function returns the following values:
//
//    - structure (optional): configuration chosen for this OpenGL context.
//
func (context *GLContext) config() *gst.Structure {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_config

	var _arg0 *C.GstGLContext // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_config(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// glApi: get the currently enabled OpenGL api.
//
// The currently available API may be limited by the GLDisplay in use and/or the
// GLWindow chosen.
//
// The function returns the following values:
//
//    - glapI: available OpenGL api.
//
func (context *GLContext) glApi() GLAPI {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_api

	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_gl_api(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// glContext gets the backing OpenGL context used by context.
//
// The function returns the following values:
//
//    - guintptr: platform specific backing OpenGL context.
//
func (context *GLContext) glContext() uintptr {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_context

	var _arg0 *C.GstGLContext // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_gl_context(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _guintptr uintptr // out

	_guintptr = (uintptr)(unsafe.Pointer(_cret))

	return _guintptr
}

// glPlatform gets the OpenGL platform that used by context.
//
// The function returns the following values:
//
//    - glPlatform: platform specific backing OpenGL context.
//
func (context *GLContext) glPlatform() GLPlatform {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_platform

	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLPlatform // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_gl_platform(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _glPlatform GLPlatform // out

	_glPlatform = GLPlatform(_cret)

	return _glPlatform
}

// glPlatformVersion: get the version of the OpenGL platform (GLX, EGL, etc)
// used. Only valid after a call to gst_gl_context_create().
//
// The function returns the following values:
//
//    - major: return for the major version.
//    - minor: return for the minor version.
//
func (context *GLContext) glPlatformVersion() (major, minor int) {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_platform_version

	var _arg0 *C.GstGLContext // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_get_gl_platform_version(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// requestConfig: set the OpenGL configuration for this context. The context
// must not have been created for this function to succeed. Setting a NULL
// config has the affect of removing any specific configuration request.
//
// Not all implementations currently support retrieving the config and this
// function will return FALSE when not supported.
//
// Note that calling this function may cause a subsequent
// gst_gl_context_create() to fail if config could not be matched with the
// platform-specific configuration.
//
// Note that the actual config used may be differ from the requested values.
//
// The function takes the following parameters:
//
//    - glConfig (optional): configuration structure for configuring the OpenGL
//      context.
//
// The function returns the following values:
//
//    - ok: whether gl_config could be successfully set on context.
//
func (context *GLContext) requestConfig(glConfig *gst.Structure) bool {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.request_config

	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if glConfig != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(glConfig)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(glConfig)), nil)
	}

	_cret = C._gotk4_gstgl1_GLContext_virtual_request_config(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(glConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// swapBuffers: swap the front and back buffers on the window attached to
// context. This will display the frame on the next refresh cycle.
func (context *GLContext) swapBuffers() {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.swap_buffers

	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_swap_buffers(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// GLContextClass: instance of this type is always passed by reference.
type GLContextClass struct {
	*glContextClass
}

// glContextClass is the struct that's finalized.
type glContextClass struct {
	native *C.GstGLContextClass
}

func (g *GLContextClass) ParentClass() *gst.ObjectClass {
	valptr := &g.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
