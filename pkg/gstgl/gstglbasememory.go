// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// GType values.
var (
	GTypeGLAllocationParams = coreglib.Type(C.gst_gl_allocation_params_get_type())
	GTypeGLBaseMemory       = coreglib.Type(C.gst_gl_base_memory_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLAllocationParams, F: marshalGLAllocationParams},
		coreglib.TypeMarshaler{T: GTypeGLBaseMemory, F: marshalGLBaseMemory},
	})
}

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC: GL Allocation flag indicating that the
// implementation should allocate the necessary resources.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC = 1

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER values >= than
// T_GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER can be used for user-defined purposes.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER = 65536

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE: GL Allocation flag for using
// the provided GPU handle as storage.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE = 4

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM: GL Allocation flag for using the
// provided system memory data as storage.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM = 2

// MAP_GL: flag indicating that we should map the GL object instead of to system
// memory.
//
// Combining T_MAP_GL with T_MAP_WRITE has the same semantics as though you are
// writing to OpenGL. Conversely, combining T_MAP_GL with T_MAP_READ has the
// same semantics as though you are reading from OpenGL.
const MAP_GL = 131072

// GLAllocationParams: instance of this type is always passed by reference.
type GLAllocationParams struct {
	*glAllocationParams
}

// glAllocationParams is the struct that's finalized.
type glAllocationParams struct {
	native *C.GstGLAllocationParams
}

func marshalGLAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLAllocationParams{&glAllocationParams{(*C.GstGLAllocationParams)(b)}}, nil
}

// The function returns the following values:
//
//    - glAllocationParams: copy of the GLAllocationParams specified by src or
//      NULL on failure.
//
func (src *GLAllocationParams) Copy() *GLAllocationParams {
	var _arg0 *C.GstGLAllocationParams // out
	var _cret *C.GstGLAllocationParams // in

	_arg0 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(src)))

	_cret = C.gst_gl_allocation_params_copy(_arg0)
	runtime.KeepAlive(src)

	var _glAllocationParams *GLAllocationParams // out

	_glAllocationParams = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_gl_allocation_params_free((*C.GstGLAllocationParams)(intern.C))
		},
	)

	return _glAllocationParams
}

// CopyData copies the dynamically allocated data from src to dest. Direct
// subclasses should call this function in their own overridden copy function.
//
// The function takes the following parameters:
//
//    - dest: destination GLAllocationParams.
//
func (src *GLAllocationParams) CopyData(dest *GLAllocationParams) {
	var _arg0 *C.GstGLAllocationParams // out
	var _arg1 *C.GstGLAllocationParams // out

	_arg0 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(dest)))

	C.gst_gl_allocation_params_copy_data(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// FreeData frees the dynamically allocated data in params. Direct subclasses
// should call this function in their own overridden free function.
func (params *GLAllocationParams) FreeData() {
	var _arg0 *C.GstGLAllocationParams // out

	_arg0 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	C.gst_gl_allocation_params_free_data(_arg0)
	runtime.KeepAlive(params)
}

// GLBaseMemory is a Memory subclass providing the basis of support for the
// mapping of GL buffers.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// An instance of this type is always passed by reference.
type GLBaseMemory struct {
	*glBaseMemory
}

// glBaseMemory is the struct that's finalized.
type glBaseMemory struct {
	native *C.GstGLBaseMemory
}

func marshalGLBaseMemory(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLBaseMemory{&glBaseMemory{(*C.GstGLBaseMemory)(b)}}, nil
}

// Mem: parent object.
func (g *GLBaseMemory) Mem() *gst.Memory {
	valptr := &g.native.mem
	var _v *gst.Memory // out
	_v = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Context to use for GL operations.
func (g *GLBaseMemory) Context() GLContexter {
	valptr := &g.native.context
	var _v GLContexter // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_v = rv
	}
	return _v
}

func (g *GLBaseMemory) MapFlags() gst.MapFlags {
	valptr := &g.native.map_flags
	var _v gst.MapFlags // out
	_v = gst.MapFlags(*valptr)
	return _v
}

func (g *GLBaseMemory) MapCount() int {
	valptr := &g.native.map_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GLBaseMemory) GLMapCount() int {
	valptr := &g.native.gl_map_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GLBaseMemory) Data() unsafe.Pointer {
	valptr := &g.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

func (g *GLBaseMemory) Query() *GLQuery {
	valptr := &g.native.query
	var _v *GLQuery // out
	_v = (*GLQuery)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

func (g *GLBaseMemory) SetMapCount(mapCount int) {
	valptr := &g.native.map_count
	*valptr = C.gint(mapCount)
}

func (g *GLBaseMemory) SetGLMapCount(glMapCount int) {
	valptr := &g.native.gl_map_count
	*valptr = C.gint(glMapCount)
}

// AllocData: note: only intended for subclass usage to allocate the system
// memory buffer on demand. If there is already a non-NULL data pointer in
// gl_mem->data, then this function imply returns TRUE.
//
// The function returns the following values:
//
//    - ok: whether the system memory could be allocated.
//
func (glMem *GLBaseMemory) AllocData() bool {
	var _arg0 *C.GstGLBaseMemory // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_base_memory_alloc_data(_arg0)
	runtime.KeepAlive(glMem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - dest: destination GLBaseMemory.
//    - offset to start at.
//    - size: number of bytes to copy.
//
// The function returns the following values:
//
//    - ok: whether the copy succeeded.
//
func (src *GLBaseMemory) Memcpy(dest *GLBaseMemory, offset int, size int) bool {
	var _arg0 *C.GstGLBaseMemory // out
	var _arg1 *C.GstGLBaseMemory // out
	var _arg2 C.gssize           // out
	var _arg3 C.gssize           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg2 = C.gssize(offset)
	_arg3 = C.gssize(size)

	_cret = C.gst_gl_base_memory_memcpy(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
