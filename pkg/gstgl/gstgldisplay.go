// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
// extern guintptr _gotk4_gstgl1_GLDisplayClass_get_handle(GstGLDisplay*);
// extern GstGLWindow* _gotk4_gstgl1_GLDisplayClass_create_window(GstGLDisplay*);
// extern GstGLContext* _gotk4_gstgl1_GLDisplay_ConnectCreateContext(gpointer, GstGLContext*, guintptr);
// GstGLWindow* _gotk4_gstgl1_GLDisplay_virtual_create_window(void* fnptr, GstGLDisplay* arg0) {
//   return ((GstGLWindow* (*)(GstGLDisplay*))(fnptr))(arg0);
// };
// guintptr _gotk4_gstgl1_GLDisplay_virtual_get_handle(void* fnptr, GstGLDisplay* arg0) {
//   return ((guintptr (*)(GstGLDisplay*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeGLDisplay = coreglib.Type(C.gst_gl_display_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLDisplay, F: marshalGLDisplay},
	})
}

// GL_DISPLAY_CONTEXT_TYPE: name used in Context queries for requesting a
// GLDisplay.
const GL_DISPLAY_CONTEXT_TYPE = "gst.gl.GLDisplay"

// GLDisplayOverrides contains methods that are overridable.
type GLDisplayOverrides struct {
	// The function returns the following values:
	//
	//    - glWindow: new GLWindow for display or NULL.
	//
	CreateWindow func() GLWindower
	// The function returns the following values:
	//
	//    - guintptr: native handle for the display.
	//
	Handle func() uintptr
}

func defaultGLDisplayOverrides(v *GLDisplay) GLDisplayOverrides {
	return GLDisplayOverrides{
		CreateWindow: v.createWindow,
		Handle:       v.handle,
	}
}

// GLDisplay represents a connection to the underlying windowing system.
// Elements are required to make use of Context to share and propagate a
// GLDisplay.
//
// There are a number of environment variables that influence the choice of
// platform and window system specific functionality.
//
// - GST_GL_WINDOW influences the window system to use. Common values are 'x11',
// 'wayland', 'win32' or 'cocoa'.
//
// - GST_GL_PLATFORM influences the OpenGL platform to use. Common values are
// 'egl', 'glx', 'wgl' or 'cgl'.
//
// - GST_GL_API influences the OpenGL API requested by the OpenGL platform.
// Common values are 'opengl', 'opengl3' and 'gles2'.
//
// > Certain window systems require a special function to be called to >
// initialize threading support. As this GStreamer GL library does not preclude
// > concurrent access to the windowing system, it is strongly advised that >
// applications ensure that threading support has been initialized before any >
// other toolkit/library functionality is accessed. Failure to do so could >
// result in sudden application abortion during execution. The most notably >
// example of such a function is X11's XInitThreads\().
type GLDisplay struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLDisplay)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLDisplay, *GLDisplayClass, GLDisplayOverrides](
		GTypeGLDisplay,
		initGLDisplayClass,
		wrapGLDisplay,
		defaultGLDisplayOverrides,
	)
}

func initGLDisplayClass(gclass unsafe.Pointer, overrides GLDisplayOverrides, classInitFunc func(*GLDisplayClass)) {
	pclass := (*C.GstGLDisplayClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLDisplay))))

	if overrides.CreateWindow != nil {
		pclass.create_window = (*[0]byte)(C._gotk4_gstgl1_GLDisplayClass_create_window)
	}

	if overrides.Handle != nil {
		pclass.get_handle = (*[0]byte)(C._gotk4_gstgl1_GLDisplayClass_get_handle)
	}

	if classInitFunc != nil {
		class := (*GLDisplayClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLDisplay(obj *coreglib.Object) *GLDisplay {
	return &GLDisplay{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLDisplay(p uintptr) (interface{}, error) {
	return wrapGLDisplay(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateContext overrides the GstGLContext creation mechanism. It can be
// called in any thread and it is emitted with display's object lock held.
func (display *GLDisplay) ConnectCreateContext(f func(context GLContexter) (glContext GLContexter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "create-context", false, unsafe.Pointer(C._gotk4_gstgl1_GLDisplay_ConnectCreateContext), f)
}

// The function returns the following values:
//
//    - glDisplay: new GLDisplay.
//
func NewGLDisplay() *GLDisplay {
	var _cret *C.GstGLDisplay // in

	_cret = C.gst_gl_display_new()

	var _glDisplay *GLDisplay // out

	_glDisplay = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplay
}

// NewGLDisplayWithType will always return a GLDisplay of a single type. This
// differs from gst_gl_display_new() and the seemingly equivalent call
// gst_gl_display_new_with_type (GST_GL_DISPLAY_TYPE_ANY) in that the latter may
// return NULL.
//
// The function takes the following parameters:
//
//    - typ: GLDisplayType.
//
// The function returns the following values:
//
//    - glDisplay (optional): new GLDisplay or NULL if type is not supported.
//
func NewGLDisplayWithType(typ GLDisplayType) *GLDisplay {
	var _arg1 C.GstGLDisplayType // out
	var _cret *C.GstGLDisplay    // in

	_arg1 = C.GstGLDisplayType(typ)

	_cret = C.gst_gl_display_new_with_type(_arg1)
	runtime.KeepAlive(typ)

	var _glDisplay *GLDisplay // out

	if _cret != nil {
		_glDisplay = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _glDisplay
}

// The function takes the following parameters:
//
//    - context: GLContext.
//
// The function returns the following values:
//
//    - ok: whether context was successfully added. FALSE may be returned if
//      there already exists another context for context's active thread.
//
//      Must be called with the object lock held.
//
func (display *GLDisplay) AddContext(context GLContexter) bool {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_display_add_context(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateContext: it requires the display's object lock to be held.
//
// The function takes the following parameters:
//
//    - otherContext: other GLContext to share resources with.
//
// The function returns the following values:
//
//    - pContext: resulting GLContext.
//
func (display *GLDisplay) CreateContext(otherContext GLContexter) (GLContexter, error) {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLContext // out
	var _arg2 *C.GstGLContext // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))

	C.gst_gl_display_create_context(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(display)
	runtime.KeepAlive(otherContext)

	var _pContext GLContexter // out
	var _goerr error          // out

	{
		objptr := unsafe.Pointer(_arg2)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_pContext = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pContext, _goerr
}

// The function returns the following values:
//
//    - glWindow: new GLWindow for display or NULL.
//
func (display *GLDisplay) CreateWindow() GLWindower {
	var _arg0 *C.GstGLDisplay // out
	var _cret *C.GstGLWindow  // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_create_window(_arg0)
	runtime.KeepAlive(display)

	var _glWindow GLWindower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gstgl.GLWindower is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLWindower)
			return ok
		})
		rv, ok := casted.(GLWindower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLWindower")
		}
		_glWindow = rv
	}

	return _glWindow
}

// FilterGLApi: limit the use of OpenGL to the requested gl_api. This is
// intended to allow application and elements to request a specific set of
// OpenGL API's based on what they support. See gst_gl_context_get_gl_api() for
// the retrieving the API supported by a GLContext.
//
// The function takes the following parameters:
//
//    - glApi to filter with.
//
func (display *GLDisplay) FilterGLApi(glApi GLAPI) {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 C.GstGLAPI      // out

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.GstGLAPI(glApi)

	C.gst_gl_display_filter_gl_api(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(glApi)
}

// GLApi: see gst_gl_display_filter_gl_api() for what the returned value
// represents.
//
// The function returns the following values:
//
//    - glapI configured for display.
//
func (display *GLDisplay) GLApi() GLAPI {
	var _arg0 *C.GstGLDisplay // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_gl_api(_arg0)
	runtime.KeepAlive(display)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// The function returns the following values:
//
func (display *GLDisplay) GLApiUnlocked() GLAPI {
	var _arg0 *C.GstGLDisplay // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_gl_api_unlocked(_arg0)
	runtime.KeepAlive(display)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// The function returns the following values:
//
//    - guintptr: native handle for the display.
//
func (display *GLDisplay) Handle() uintptr {
	var _arg0 *C.GstGLDisplay // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_handle(_arg0)
	runtime.KeepAlive(display)

	var _guintptr uintptr // out

	_guintptr = (uintptr)(unsafe.Pointer(_cret))

	return _guintptr
}

// The function returns the following values:
//
//    - glDisplayType of display.
//
func (display *GLDisplay) HandleType() GLDisplayType {
	var _arg0 *C.GstGLDisplay    // out
	var _cret C.GstGLDisplayType // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_handle_type(_arg0)
	runtime.KeepAlive(display)

	var _glDisplayType GLDisplayType // out

	_glDisplayType = GLDisplayType(_cret)

	return _glDisplayType
}

// RemoveContext: must be called with the object lock held.
//
// The function takes the following parameters:
//
//    - context to remove.
//
func (display *GLDisplay) RemoveContext(context GLContexter) {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLContext // out

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_display_remove_context(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//    - window to remove.
//
// The function returns the following values:
//
//    - ok: if window could be removed from display.
//
func (display *GLDisplay) RemoveWindow(window GLWindower) bool {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLWindow  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_display_remove_window(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - glWindow: new GLWindow for display or NULL.
//
func (display *GLDisplay) createWindow() GLWindower {
	gclass := (*C.GstGLDisplayClass)(coreglib.PeekParentClass(display))
	fnarg := gclass.create_window

	var _arg0 *C.GstGLDisplay // out
	var _cret *C.GstGLWindow  // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C._gotk4_gstgl1_GLDisplay_virtual_create_window(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(display)

	var _glWindow GLWindower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gstgl.GLWindower is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLWindower)
			return ok
		})
		rv, ok := casted.(GLWindower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLWindower")
		}
		_glWindow = rv
	}

	return _glWindow
}

// The function returns the following values:
//
//    - guintptr: native handle for the display.
//
func (display *GLDisplay) handle() uintptr {
	gclass := (*C.GstGLDisplayClass)(coreglib.PeekParentClass(display))
	fnarg := gclass.get_handle

	var _arg0 *C.GstGLDisplay // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C._gotk4_gstgl1_GLDisplay_virtual_get_handle(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(display)

	var _guintptr uintptr // out

	_guintptr = (uintptr)(unsafe.Pointer(_cret))

	return _guintptr
}

// GLDisplayClass: instance of this type is always passed by reference.
type GLDisplayClass struct {
	*glDisplayClass
}

// glDisplayClass is the struct that's finalized.
type glDisplayClass struct {
	native *C.GstGLDisplayClass
}

func (g *GLDisplayClass) ObjectClass() *gst.ObjectClass {
	valptr := &g.native.object_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
