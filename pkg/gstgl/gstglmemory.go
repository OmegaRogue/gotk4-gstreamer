// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstvideo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// GType values.
var (
	GTypeGLMemoryAllocator       = coreglib.Type(C.gst_gl_memory_allocator_get_type())
	GTypeGLMemory                = coreglib.Type(C.gst_gl_memory_get_type())
	GTypeGLVideoAllocationParams = coreglib.Type(C.gst_gl_video_allocation_params_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLMemoryAllocator, F: marshalGLMemoryAllocator},
		coreglib.TypeMarshaler{T: GTypeGLMemory, F: marshalGLMemory},
		coreglib.TypeMarshaler{T: GTypeGLVideoAllocationParams, F: marshalGLVideoAllocationParams},
	})
}

// CAPS_FEATURE_MEMORY_GL_MEMORY: name of the caps feature for indicating the
// use of GLMemory.
const CAPS_FEATURE_MEMORY_GL_MEMORY = "memory:GLMemory"

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO: GL allocation flag indicating the
// allocation of 2D video frames.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO = 8

// GL_MEMORY_ALLOCATOR_NAME: name of the GL memory allocator.
const GL_MEMORY_ALLOCATOR_NAME = "GLMemory"
const GL_MEMORY_VIDEO_EXT_FORMATS = ", BGR10A2_LE, RGB10A2_LE, P010_10LE, P012_LE, P016_LE, Y212_LE, Y412_LE"

// GL_MEMORY_VIDEO_FORMATS_STR: list of video formats that are supported by
// GLMemory.
const GL_MEMORY_VIDEO_FORMATS_STR = "{ RGBA, BGRA, RGBx, BGRx, ARGB, ABGR, xRGB, xBGR, GBRA, GBR, RGBP, BGRP, RGB, BGR, RGB16, BGR16, AYUV, VUYA, Y410, I420, YV12, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, Y41B, Y42B, Y444, GRAY8, GRAY16_LE, GRAY16_BE, ARGB64, A420, AV12"

// GLMemoryAllocatorOverrides contains methods that are overridable.
type GLMemoryAllocatorOverrides struct {
}

func defaultGLMemoryAllocatorOverrides(v *GLMemoryAllocator) GLMemoryAllocatorOverrides {
	return GLMemoryAllocatorOverrides{}
}

// GLMemoryAllocator: opaque GLMemoryAllocator struct.
type GLMemoryAllocator struct {
	_ [0]func() // equal guard
	GLBaseMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLMemoryAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLMemoryAllocator, *GLMemoryAllocatorClass, GLMemoryAllocatorOverrides](
		GTypeGLMemoryAllocator,
		initGLMemoryAllocatorClass,
		wrapGLMemoryAllocator,
		defaultGLMemoryAllocatorOverrides,
	)
}

func initGLMemoryAllocatorClass(gclass unsafe.Pointer, overrides GLMemoryAllocatorOverrides, classInitFunc func(*GLMemoryAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLMemoryAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLMemoryAllocator(obj *coreglib.Object) *GLMemoryAllocator {
	return &GLMemoryAllocator{
		GLBaseMemoryAllocator: GLBaseMemoryAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLMemoryAllocator(p uintptr) (interface{}, error) {
	return wrapGLMemoryAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLMemory is a GLBaseMemory subclass providing support for the mapping of
// OpenGL textures.
//
// GLMemory is created or wrapped through gst_gl_base_memory_alloc() with
// GLVideoAllocationParams.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// The Caps that is used for GLMemory based buffers should contain the
// GST_CAPS_FEATURE_MEMORY_GL_MEMORY as a CapsFeatures and should contain a
// 'texture-target' field with one of the GLTextureTarget values as a string,
// i.e. some combination of 'texture-target=(string){2D, rectangle,
// external-oes}'.
//
// An instance of this type is always passed by reference.
type GLMemory struct {
	*glMemory
}

// glMemory is the struct that's finalized.
type glMemory struct {
	native *C.GstGLMemory
}

func marshalGLMemory(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLMemory{&glMemory{(*C.GstGLMemory)(b)}}, nil
}

// Mem: parent GLBaseMemory object.
func (g *GLMemory) Mem() *GLBaseMemory {
	valptr := &g.native.mem
	var _v *GLBaseMemory // out
	_v = (*GLBaseMemory)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TexID: GL texture id for this memory.
func (g *GLMemory) TexID() uint {
	valptr := &g.native.tex_id
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TexTarget: GL texture target for this memory.
func (g *GLMemory) TexTarget() GLTextureTarget {
	valptr := &g.native.tex_target
	var _v GLTextureTarget // out
	_v = GLTextureTarget(*valptr)
	return _v
}

// TexFormat: texture type.
func (g *GLMemory) TexFormat() GLFormat {
	valptr := &g.native.tex_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

// Info texture's VideoInfo.
func (g *GLMemory) Info() *gstvideo.VideoInfo {
	valptr := &g.native.info
	var _v *gstvideo.VideoInfo // out
	_v = (*gstvideo.VideoInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// VAlign: data alignment for system memory mapping.
func (g *GLMemory) VAlign() *gstvideo.VideoAlignment {
	valptr := &g.native.valign
	var _v *gstvideo.VideoAlignment // out
	_v = (*gstvideo.VideoAlignment)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Plane: data plane in info.
func (g *GLMemory) Plane() uint {
	valptr := &g.native.plane
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TexScaling: GL shader scaling parameters for valign and/or width/height.
func (g *GLMemory) TexScaling() [2]float32 {
	valptr := &g.native.tex_scaling
	var _v [2]float32 // out
	_v = *(*[2]float32)(unsafe.Pointer(&*valptr))
	return _v
}

func (g *GLMemory) TextureWrapped() bool {
	valptr := &g.native.texture_wrapped
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

func (g *GLMemory) UnpackLength() uint {
	valptr := &g.native.unpack_length
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

func (g *GLMemory) TexWidth() uint {
	valptr := &g.native.tex_width
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TexID: GL texture id for this memory.
func (g *GLMemory) SetTexID(texId uint) {
	valptr := &g.native.tex_id
	*valptr = C.guint(texId)
}

// Plane: data plane in info.
func (g *GLMemory) SetPlane(plane uint) {
	valptr := &g.native.plane
	*valptr = C.guint(plane)
}

func (g *GLMemory) SetTextureWrapped(textureWrapped bool) {
	valptr := &g.native.texture_wrapped
	if textureWrapped {
		*valptr = C.TRUE
	}
}

func (g *GLMemory) SetUnpackLength(unpackLength uint) {
	valptr := &g.native.unpack_length
	*valptr = C.guint(unpackLength)
}

func (g *GLMemory) SetTexWidth(texWidth uint) {
	valptr := &g.native.tex_width
	*valptr = C.guint(texWidth)
}

// CopyInto copies gl_mem into the texture specified by tex_id. The format of
// tex_id is specified by tex_format, width and height.
//
// The function takes the following parameters:
//
//    - texId: openGL texture id.
//    - target: GLTextureTarget.
//    - texFormat: GLFormat.
//    - width of tex_id.
//    - height of tex_id.
//
// The function returns the following values:
//
//    - ok: whether the copy succeeded.
//
func (glMem *GLMemory) CopyInto(texId uint, target GLTextureTarget, texFormat GLFormat, width int, height int) bool {
	var _arg0 *C.GstGLMemory       // out
	var _arg1 C.guint              // out
	var _arg2 C.GstGLTextureTarget // out
	var _arg3 C.GstGLFormat        // out
	var _arg4 C.gint               // out
	var _arg5 C.gint               // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = C.guint(texId)
	_arg2 = C.GstGLTextureTarget(target)
	_arg3 = C.GstGLFormat(texFormat)
	_arg4 = C.gint(width)
	_arg5 = C.gint(height)

	_cret = C.gst_gl_memory_copy_into(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(texId)
	runtime.KeepAlive(target)
	runtime.KeepAlive(texFormat)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyTeximage copies the texture in GLMemory into the texture specified by
// tex_id, out_target, out_tex_format, out_width and out_height.
//
// The function takes the following parameters:
//
//    - texId: destination texture id.
//    - outTarget: destination GLTextureTarget.
//    - outTexFormat: destination GLFormat.
//    - outWidth: destination width.
//    - outHeight: destination height.
//
// The function returns the following values:
//
//    - ok: whether the copy succeeded.
//
func (src *GLMemory) CopyTeximage(texId uint, outTarget GLTextureTarget, outTexFormat GLFormat, outWidth int, outHeight int) bool {
	var _arg0 *C.GstGLMemory       // out
	var _arg1 C.guint              // out
	var _arg2 C.GstGLTextureTarget // out
	var _arg3 C.GstGLFormat        // out
	var _arg4 C.gint               // out
	var _arg5 C.gint               // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = C.guint(texId)
	_arg2 = C.GstGLTextureTarget(outTarget)
	_arg3 = C.GstGLFormat(outTexFormat)
	_arg4 = C.gint(outWidth)
	_arg5 = C.gint(outHeight)

	_cret = C.gst_gl_memory_copy_teximage(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(src)
	runtime.KeepAlive(texId)
	runtime.KeepAlive(outTarget)
	runtime.KeepAlive(outTexFormat)
	runtime.KeepAlive(outWidth)
	runtime.KeepAlive(outHeight)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - glFormat of gl_mem.
//
func (glMem *GLMemory) TextureFormat() GLFormat {
	var _arg0 *C.GstGLMemory // out
	var _cret C.GstGLFormat  // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_format(_arg0)
	runtime.KeepAlive(glMem)

	var _glFormat GLFormat // out

	_glFormat = GLFormat(_cret)

	return _glFormat
}

// The function returns the following values:
//
//    - gint: texture height of gl_mem.
//
func (glMem *GLMemory) TextureHeight() int {
	var _arg0 *C.GstGLMemory // out
	var _cret C.gint         // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_height(_arg0)
	runtime.KeepAlive(glMem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//    - guint: openGL texture handle of gl_mem.
//
func (glMem *GLMemory) TextureID() uint {
	var _arg0 *C.GstGLMemory // out
	var _cret C.guint        // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_id(_arg0)
	runtime.KeepAlive(glMem)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//    - glTextureTarget of gl_mem.
//
func (glMem *GLMemory) TextureTarget() GLTextureTarget {
	var _arg0 *C.GstGLMemory       // out
	var _cret C.GstGLTextureTarget // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_target(_arg0)
	runtime.KeepAlive(glMem)

	var _glTextureTarget GLTextureTarget // out

	_glTextureTarget = GLTextureTarget(_cret)

	return _glTextureTarget
}

// The function returns the following values:
//
//    - gint: texture width of gl_mem.
//
func (glMem *GLMemory) TextureWidth() int {
	var _arg0 *C.GstGLMemory // out
	var _cret C.gint         // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_width(_arg0)
	runtime.KeepAlive(glMem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReadPixels reads the texture in GLMemory into write_pointer if no buffer is
// bound to GL_PIXEL_PACK_BUFFER. Otherwise write_pointer is the byte offset
// into the currently bound GL_PIXEL_PACK_BUFFER buffer to store the result of
// glReadPixels. See the OpenGL specification for glReadPixels for more details.
//
// The function takes the following parameters:
//
//    - writePointer (optional): data pointer to pass to glReadPixels.
//
// The function returns the following values:
//
//    - ok: whether theread operation succeeded.
//
func (glMem *GLMemory) ReadPixels(writePointer unsafe.Pointer) bool {
	var _arg0 *C.GstGLMemory // out
	var _arg1 C.gpointer     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = (C.gpointer)(unsafe.Pointer(writePointer))

	_cret = C.gst_gl_memory_read_pixels(_arg0, _arg1)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(writePointer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Texsubimage reads the texture in read_pointer into gl_mem.
//
// See gst_gl_memory_read_pixels() for what read_pointer signifies.
//
// The function takes the following parameters:
//
//    - readPointer (optional): data pointer to pass to glTexSubImage.
//
func (glMem *GLMemory) Texsubimage(readPointer unsafe.Pointer) {
	var _arg0 *C.GstGLMemory // out
	var _arg1 C.gpointer     // out

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = (C.gpointer)(unsafe.Pointer(readPointer))

	C.gst_gl_memory_texsubimage(_arg0, _arg1)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(readPointer)
}

// GLMemoryAllocatorClass: instance of this type is always passed by reference.
type GLMemoryAllocatorClass struct {
	*glMemoryAllocatorClass
}

// glMemoryAllocatorClass is the struct that's finalized.
type glMemoryAllocatorClass struct {
	native *C.GstGLMemoryAllocatorClass
}

// GLVideoAllocationParams: instance of this type is always passed by reference.
type GLVideoAllocationParams struct {
	*glVideoAllocationParams
}

// glVideoAllocationParams is the struct that's finalized.
type glVideoAllocationParams struct {
	native *C.GstGLVideoAllocationParams
}

func marshalGLVideoAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLVideoAllocationParams{&glVideoAllocationParams{(*C.GstGLVideoAllocationParams)(b)}}, nil
}

// NewGLVideoAllocationParams constructs a struct GLVideoAllocationParams.
func NewGLVideoAllocationParams(context GLContexter, allocParams *gst.AllocationParams, vInfo *gstvideo.VideoInfo, plane uint, valign *gstvideo.VideoAlignment, target GLTextureTarget, texFormat GLFormat) *GLVideoAllocationParams {
	var _arg1 *C.GstGLContext               // out
	var _arg2 *C.GstAllocationParams        // out
	var _arg3 *C.GstVideoInfo               // out
	var _arg4 C.guint                       // out
	var _arg5 *C.GstVideoAlignment          // out
	var _arg6 C.GstGLTextureTarget          // out
	var _arg7 C.GstGLFormat                 // out
	var _cret *C.GstGLVideoAllocationParams // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if allocParams != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(allocParams)))
	}
	_arg3 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(vInfo)))
	_arg4 = C.guint(plane)
	if valign != nil {
		_arg5 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(valign)))
	}
	_arg6 = C.GstGLTextureTarget(target)
	_arg7 = C.GstGLFormat(texFormat)

	_cret = C.gst_gl_video_allocation_params_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allocParams)
	runtime.KeepAlive(vInfo)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(valign)
	runtime.KeepAlive(target)
	runtime.KeepAlive(texFormat)

	var _glVideoAllocationParams *GLVideoAllocationParams // out

	_glVideoAllocationParams = (*GLVideoAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glVideoAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _glVideoAllocationParams
}

// Parent: parent GLAllocationParams structure.
func (g *GLVideoAllocationParams) Parent() *GLAllocationParams {
	valptr := &g.native.parent
	var _v *GLAllocationParams // out
	_v = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// VInfo to allocate.
func (g *GLVideoAllocationParams) VInfo() *gstvideo.VideoInfo {
	valptr := &g.native.v_info
	var _v *gstvideo.VideoInfo // out
	_v = (*gstvideo.VideoInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Plane: video plane index to allocate.
func (g *GLVideoAllocationParams) Plane() uint {
	valptr := &g.native.plane
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// VAlign to align the system representation to (may be NULL for the default).
func (g *GLVideoAllocationParams) VAlign() *gstvideo.VideoAlignment {
	valptr := &g.native.valign
	var _v *gstvideo.VideoAlignment // out
	_v = (*gstvideo.VideoAlignment)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Target to allocate.
func (g *GLVideoAllocationParams) Target() GLTextureTarget {
	valptr := &g.native.target
	var _v GLTextureTarget // out
	_v = GLTextureTarget(*valptr)
	return _v
}

// TexFormat to allocate.
func (g *GLVideoAllocationParams) TexFormat() GLFormat {
	valptr := &g.native.tex_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

// Plane: video plane index to allocate.
func (g *GLVideoAllocationParams) SetPlane(plane uint) {
	valptr := &g.native.plane
	*valptr = C.guint(plane)
}

// CopyData: copy and set any dynamically allocated resources in dest_vid.
// Intended for subclass usage only to chain up at the end of a subclass copy
// function.
//
// The function takes the following parameters:
//
//    - destVid: destination GLVideoAllocationParams to copy into.
//
func (srcVid *GLVideoAllocationParams) CopyData(destVid *GLVideoAllocationParams) {
	var _arg0 *C.GstGLVideoAllocationParams // out
	var _arg1 *C.GstGLVideoAllocationParams // out

	_arg0 = (*C.GstGLVideoAllocationParams)(gextras.StructNative(unsafe.Pointer(srcVid)))
	_arg1 = (*C.GstGLVideoAllocationParams)(gextras.StructNative(unsafe.Pointer(destVid)))

	C.gst_gl_video_allocation_params_copy_data(_arg0, _arg1)
	runtime.KeepAlive(srcVid)
	runtime.KeepAlive(destVid)
}

// FreeData: unset and free any dynamically allocated resources. Intended for
// subclass usage only to chain up at the end of a subclass free function.
func (params *GLVideoAllocationParams) FreeData() {
	var _arg0 *C.GstGLVideoAllocationParams // out

	_arg0 = (*C.GstGLVideoAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	C.gst_gl_video_allocation_params_free_data(_arg0)
	runtime.KeepAlive(params)
}
