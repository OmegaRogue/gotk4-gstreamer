// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// GType values.
var (
	GTypeGLRenderbufferAllocator        = coreglib.Type(C.gst_gl_renderbuffer_allocator_get_type())
	GTypeGLRenderbufferAllocationParams = coreglib.Type(C.gst_gl_renderbuffer_allocation_params_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLRenderbufferAllocator, F: marshalGLRenderbufferAllocator},
		coreglib.TypeMarshaler{T: GTypeGLRenderbufferAllocationParams, F: marshalGLRenderbufferAllocationParams},
	})
}

// GL_RENDERBUFFER_ALLOCATOR_NAME: name of the GL renderbuffer allocator.
const GL_RENDERBUFFER_ALLOCATOR_NAME = "GLRenderbuffer"

// GLRenderbufferAllocatorOverrides contains methods that are overridable.
type GLRenderbufferAllocatorOverrides struct {
}

func defaultGLRenderbufferAllocatorOverrides(v *GLRenderbufferAllocator) GLRenderbufferAllocatorOverrides {
	return GLRenderbufferAllocatorOverrides{}
}

// GLRenderbufferAllocator: opaque GLRenderbufferAllocator struct.
type GLRenderbufferAllocator struct {
	_ [0]func() // equal guard
	GLBaseMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLRenderbufferAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLRenderbufferAllocator, *GLRenderbufferAllocatorClass, GLRenderbufferAllocatorOverrides](
		GTypeGLRenderbufferAllocator,
		initGLRenderbufferAllocatorClass,
		wrapGLRenderbufferAllocator,
		defaultGLRenderbufferAllocatorOverrides,
	)
}

func initGLRenderbufferAllocatorClass(gclass unsafe.Pointer, overrides GLRenderbufferAllocatorOverrides, classInitFunc func(*GLRenderbufferAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLRenderbufferAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLRenderbufferAllocator(obj *coreglib.Object) *GLRenderbufferAllocator {
	return &GLRenderbufferAllocator{
		GLBaseMemoryAllocator: GLBaseMemoryAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLRenderbufferAllocator(p uintptr) (interface{}, error) {
	return wrapGLRenderbufferAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLRenderbufferAllocationParams: allocation parameters
//
// An instance of this type is always passed by reference.
type GLRenderbufferAllocationParams struct {
	*glRenderbufferAllocationParams
}

// glRenderbufferAllocationParams is the struct that's finalized.
type glRenderbufferAllocationParams struct {
	native *C.GstGLRenderbufferAllocationParams
}

func marshalGLRenderbufferAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLRenderbufferAllocationParams{&glRenderbufferAllocationParams{(*C.GstGLRenderbufferAllocationParams)(b)}}, nil
}

// NewGLRenderbufferAllocationParams constructs a struct GLRenderbufferAllocationParams.
func NewGLRenderbufferAllocationParams(context GLContexter, allocParams *gst.AllocationParams, renderbufferFormat GLFormat, width uint, height uint) *GLRenderbufferAllocationParams {
	var _arg1 *C.GstGLContext                      // out
	var _arg2 *C.GstAllocationParams               // out
	var _arg3 C.GstGLFormat                        // out
	var _arg4 C.guint                              // out
	var _arg5 C.guint                              // out
	var _cret *C.GstGLRenderbufferAllocationParams // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if allocParams != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(allocParams)))
	}
	_arg3 = C.GstGLFormat(renderbufferFormat)
	_arg4 = C.guint(width)
	_arg5 = C.guint(height)

	_cret = C.gst_gl_renderbuffer_allocation_params_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allocParams)
	runtime.KeepAlive(renderbufferFormat)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _glRenderbufferAllocationParams *GLRenderbufferAllocationParams // out

	_glRenderbufferAllocationParams = (*GLRenderbufferAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glRenderbufferAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _glRenderbufferAllocationParams
}

// RenderbufferFormat: GLFormat.
func (g *GLRenderbufferAllocationParams) RenderbufferFormat() GLFormat {
	valptr := &g.native.renderbuffer_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

// Width: width.
func (g *GLRenderbufferAllocationParams) Width() uint {
	valptr := &g.native.width
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Height: height.
func (g *GLRenderbufferAllocationParams) Height() uint {
	valptr := &g.native.height
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Width: width.
func (g *GLRenderbufferAllocationParams) SetWidth(width uint) {
	valptr := &g.native.width
	*valptr = C.guint(width)
}

// Height: height.
func (g *GLRenderbufferAllocationParams) SetHeight(height uint) {
	valptr := &g.native.height
	*valptr = C.guint(height)
}

// GLRenderbufferAllocatorClass only contains private data
//
// An instance of this type is always passed by reference.
type GLRenderbufferAllocatorClass struct {
	*glRenderbufferAllocatorClass
}

// glRenderbufferAllocatorClass is the struct that's finalized.
type glRenderbufferAllocatorClass struct {
	native *C.GstGLRenderbufferAllocatorClass
}

func (g *GLRenderbufferAllocatorClass) ParentClass() *GLBaseMemoryAllocatorClass {
	valptr := &g.native.parent_class
	var _v *GLBaseMemoryAllocatorClass // out
	_v = (*GLBaseMemoryAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
