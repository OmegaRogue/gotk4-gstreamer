// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// GType values.
var (
	GTypeGLUpload = coreglib.Type(C.gst_gl_upload_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLUpload, F: marshalGLUpload},
	})
}

// GLUploadOverrides contains methods that are overridable.
type GLUploadOverrides struct {
}

func defaultGLUploadOverrides(v *GLUpload) GLUploadOverrides {
	return GLUploadOverrides{}
}

// GLUpload is an object that uploads data from system memory into GL textures.
//
// A GLUpload can be created with gst_gl_upload_new().
type GLUpload struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLUpload)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLUpload, *GLUploadClass, GLUploadOverrides](
		GTypeGLUpload,
		initGLUploadClass,
		wrapGLUpload,
		defaultGLUploadOverrides,
	)
}

func initGLUploadClass(gclass unsafe.Pointer, overrides GLUploadOverrides, classInitFunc func(*GLUploadClass)) {
	if classInitFunc != nil {
		class := (*GLUploadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLUpload(obj *coreglib.Object) *GLUpload {
	return &GLUpload{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLUpload(p uintptr) (interface{}, error) {
	return wrapGLUpload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//    - context: GLContext.
//
// The function returns the following values:
//
//    - glUpload: new GLUpload object.
//
func NewGLUpload(context GLContexter) *GLUpload {
	var _arg1 *C.GstGLContext // out
	var _cret *C.GstGLUpload  // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_upload_new(_arg1)
	runtime.KeepAlive(context)

	var _glUpload *GLUpload // out

	_glUpload = wrapGLUpload(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glUpload
}

// The function returns the following values:
//
//    - inCaps (optional): input Caps.
//    - outCaps (optional): output Caps.
//
func (upload *GLUpload) Caps() (inCaps, outCaps *gst.Caps) {
	var _arg0 *C.GstGLUpload // out
	var _arg1 *C.GstCaps     // in
	var _arg2 *C.GstCaps     // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))

	C.gst_gl_upload_get_caps(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(upload)

	var _inCaps *gst.Caps  // out
	var _outCaps *gst.Caps // out

	if _arg1 != nil {
		_inCaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_inCaps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if _arg2 != nil {
		_outCaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_outCaps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _inCaps, _outCaps
}

// PerformWithBuffer uploads buffer using the transformation specified by
// gst_gl_upload_set_caps() creating a new Buffer in outbuf_ptr.
//
// The function takes the following parameters:
//
//    - buffer: input Buffer.
//
// The function returns the following values:
//
//    - outbufPtr: resulting Buffer.
//    - glUploadReturn: whether the upload was successful.
//
func (upload *GLUpload) PerformWithBuffer(buffer *gst.Buffer) (*gst.Buffer, GLUploadReturn) {
	var _arg0 *C.GstGLUpload      // out
	var _arg1 *C.GstBuffer        // out
	var _arg2 *C.GstBuffer        // in
	var _cret C.GstGLUploadReturn // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_gl_upload_perform_with_buffer(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(buffer)

	var _outbufPtr *gst.Buffer         // out
	var _glUploadReturn GLUploadReturn // out

	_outbufPtr = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_outbufPtr)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_glUploadReturn = GLUploadReturn(_cret)

	return _outbufPtr, _glUploadReturn
}

// ProposeAllocation adds the required allocation parameters to support
// uploading.
//
// The function takes the following parameters:
//
//    - decideQuery (optional) from a decide allocation.
//    - query: proposed allocation query.
//
func (upload *GLUpload) ProposeAllocation(decideQuery, query *gst.Query) {
	var _arg0 *C.GstGLUpload // out
	var _arg1 *C.GstQuery    // out
	var _arg2 *C.GstQuery    // out

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	if decideQuery != nil {
		_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(decideQuery)))
	}
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_gl_upload_propose_allocation(_arg0, _arg1, _arg2)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(decideQuery)
	runtime.KeepAlive(query)
}

// SetCaps initializes upload with the information required for upload.
//
// The function takes the following parameters:
//
//    - inCaps: input Caps.
//    - outCaps: output Caps.
//
// The function returns the following values:
//
//    - ok: whether in_caps and out_caps could be set on upload.
//
func (upload *GLUpload) SetCaps(inCaps, outCaps *gst.Caps) bool {
	var _arg0 *C.GstGLUpload // out
	var _arg1 *C.GstCaps     // out
	var _arg2 *C.GstCaps     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(inCaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outCaps)))

	_cret = C.gst_gl_upload_set_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(inCaps)
	runtime.KeepAlive(outCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (upload *GLUpload) SetContext(context GLContexter) {
	var _arg0 *C.GstGLUpload  // out
	var _arg1 *C.GstGLContext // out

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_upload_set_context(_arg0, _arg1)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//    - context
//    - direction
//    - caps
//    - filter
//
// The function returns the following values:
//
func (upload *GLUpload) TransformCaps(context GLContexter, direction gst.PadDirection, caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstGLUpload    // out
	var _arg1 *C.GstGLContext   // out
	var _arg2 C.GstPadDirection // out
	var _arg3 *C.GstCaps        // out
	var _arg4 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C.gst_gl_upload_transform_caps(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(context)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// The function returns the following values:
//
func GLUploadGetInputTemplateCaps() *gst.Caps {
	var _cret *C.GstCaps // in

	_cret = C.gst_gl_upload_get_input_template_caps()

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// GLUploadClass struct only contains private data
//
// An instance of this type is always passed by reference.
type GLUploadClass struct {
	*glUploadClass
}

// glUploadClass is the struct that's finalized.
type glUploadClass struct {
	native *C.GstGLUploadClass
}

func (g *GLUploadClass) ObjectClass() *gst.ObjectClass {
	valptr := &g.native.object_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
