// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
import "C"

// GType values.
var (
	GTypeGLMemoryPBOAllocator = coreglib.Type(C.gst_gl_memory_pbo_allocator_get_type())
	GTypeGLMemoryPBO          = coreglib.Type(C.gst_gl_memory_pbo_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLMemoryPBOAllocator, F: marshalGLMemoryPBOAllocator},
		coreglib.TypeMarshaler{T: GTypeGLMemoryPBO, F: marshalGLMemoryPBO},
	})
}

// GL_MEMORY_PBO_ALLOCATOR_NAME: name of the GL Memory PBO allocator.
const GL_MEMORY_PBO_ALLOCATOR_NAME = "GLMemoryPBO"

// GLMemoryPBOAllocatorOverrides contains methods that are overridable.
type GLMemoryPBOAllocatorOverrides struct {
}

func defaultGLMemoryPBOAllocatorOverrides(v *GLMemoryPBOAllocator) GLMemoryPBOAllocatorOverrides {
	return GLMemoryPBOAllocatorOverrides{}
}

// GLMemoryPBOAllocator: opaque GLMemoryPBOAllocator struct.
type GLMemoryPBOAllocator struct {
	_ [0]func() // equal guard
	GLMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLMemoryPBOAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLMemoryPBOAllocator, *GLMemoryPBOAllocatorClass, GLMemoryPBOAllocatorOverrides](
		GTypeGLMemoryPBOAllocator,
		initGLMemoryPBOAllocatorClass,
		wrapGLMemoryPBOAllocator,
		defaultGLMemoryPBOAllocatorOverrides,
	)
}

func initGLMemoryPBOAllocatorClass(gclass unsafe.Pointer, overrides GLMemoryPBOAllocatorOverrides, classInitFunc func(*GLMemoryPBOAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLMemoryPBOAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLMemoryPBOAllocator(obj *coreglib.Object) *GLMemoryPBOAllocator {
	return &GLMemoryPBOAllocator{
		GLMemoryAllocator: GLMemoryAllocator{
			GLBaseMemoryAllocator: GLBaseMemoryAllocator{
				Allocator: gst.Allocator{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLMemoryPBOAllocator(p uintptr) (interface{}, error) {
	return wrapGLMemoryPBOAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLMemoryPBO is created or wrapped through gst_gl_base_memory_alloc() with
// GLVideoAllocationParams.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// An instance of this type is always passed by reference.
type GLMemoryPBO struct {
	*glMemoryPBO
}

// glMemoryPBO is the struct that's finalized.
type glMemoryPBO struct {
	native *C.GstGLMemoryPBO
}

func marshalGLMemoryPBO(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLMemoryPBO{&glMemoryPBO{(*C.GstGLMemoryPBO)(b)}}, nil
}

// CopyIntoTexture copies gl_mem into the texture specified by tex_id. The
// format of tex_id is specified by tex_format, width and height.
//
// If respecify is TRUE, then the copy is performed in terms of the texture
// data. This is useful for splitting RGBA textures into RG or R textures or
// vice versa. The requirement for this to succeed is that the backing texture
// data must be the same size, i.e. say a RGBA8 texture is converted into a RG8
// texture, then the RG texture must have twice as many pixels available for
// output as the RGBA texture.
//
// Otherwise, if respecify is FALSE, then the copy is performed per texel using
// glCopyTexImage. See the OpenGL specification for details on the mappings
// between texture formats.
//
// The function takes the following parameters:
//
//    - texId: destination texture id.
//    - target: destination GLTextureTarget.
//    - texFormat: destination GLFormat.
//    - width of tex_id.
//    - height of tex_id.
//    - stride of the backing texture data.
//    - respecify: whether to copy the data or copy per texel.
//
// The function returns the following values:
//
//    - ok: whether the copy succeeded.
//
func (glMem *GLMemoryPBO) CopyIntoTexture(texId uint, target GLTextureTarget, texFormat GLFormat, width int, height int, stride int, respecify bool) bool {
	var _arg0 *C.GstGLMemoryPBO    // out
	var _arg1 C.guint              // out
	var _arg2 C.GstGLTextureTarget // out
	var _arg3 C.GstGLFormat        // out
	var _arg4 C.gint               // out
	var _arg5 C.gint               // out
	var _arg6 C.gint               // out
	var _arg7 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLMemoryPBO)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = C.guint(texId)
	_arg2 = C.GstGLTextureTarget(target)
	_arg3 = C.GstGLFormat(texFormat)
	_arg4 = C.gint(width)
	_arg5 = C.gint(height)
	_arg6 = C.gint(stride)
	if respecify {
		_arg7 = C.TRUE
	}

	_cret = C.gst_gl_memory_pbo_copy_into_texture(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(texId)
	runtime.KeepAlive(target)
	runtime.KeepAlive(texFormat)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(stride)
	runtime.KeepAlive(respecify)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DownloadTransfer: transfer the texture data from the texture into the PBO if
// necessary.
func (glMem *GLMemoryPBO) DownloadTransfer() {
	var _arg0 *C.GstGLMemoryPBO // out

	_arg0 = (*C.GstGLMemoryPBO)(gextras.StructNative(unsafe.Pointer(glMem)))

	C.gst_gl_memory_pbo_download_transfer(_arg0)
	runtime.KeepAlive(glMem)
}

// UploadTransfer: transfer the texture data from the PBO into the texture if
// necessary.
func (glMem *GLMemoryPBO) UploadTransfer() {
	var _arg0 *C.GstGLMemoryPBO // out

	_arg0 = (*C.GstGLMemoryPBO)(gextras.StructNative(unsafe.Pointer(glMem)))

	C.gst_gl_memory_pbo_upload_transfer(_arg0)
	runtime.KeepAlive(glMem)
}

func GLMemoryPBOInitOnce() {
	C.gst_gl_memory_pbo_init_once()
}

// GLMemoryPBOAllocatorClass: only contains private data
//
// An instance of this type is always passed by reference.
type GLMemoryPBOAllocatorClass struct {
	*glMemoryPBOAllocatorClass
}

// glMemoryPBOAllocatorClass is the struct that's finalized.
type glMemoryPBOAllocatorClass struct {
	native *C.GstGLMemoryPBOAllocatorClass
}

func (g *GLMemoryPBOAllocatorClass) ParentClass() *GLMemoryAllocatorClass {
	valptr := &g.native.parent_class
	var _v *GLMemoryAllocatorClass // out
	_v = (*GLMemoryAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
