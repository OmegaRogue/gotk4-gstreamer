// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
// extern void _gotk4_gstgl1_GLBaseFilterClass_gl_stop(GstGLBaseFilter*);
// extern gboolean _gotk4_gstgl1_GLBaseFilterClass_gl_start(GstGLBaseFilter*);
// extern gboolean _gotk4_gstgl1_GLBaseFilterClass_gl_set_caps(GstGLBaseFilter*, GstCaps*, GstCaps*);
// gboolean _gotk4_gstgl1_GLBaseFilter_virtual_gl_set_caps(void* fnptr, GstGLBaseFilter* arg0, GstCaps* arg1, GstCaps* arg2) {
//   return ((gboolean (*)(GstGLBaseFilter*, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLBaseFilter_virtual_gl_start(void* fnptr, GstGLBaseFilter* arg0) {
//   return ((gboolean (*)(GstGLBaseFilter*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLBaseFilter_virtual_gl_stop(void* fnptr, GstGLBaseFilter* arg0) {
//   ((void (*)(GstGLBaseFilter*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeGLBaseFilter = coreglib.Type(C.gst_gl_base_filter_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLBaseFilter, F: marshalGLBaseFilter},
	})
}

// GLBaseFilterOverrides contains methods that are overridable.
type GLBaseFilterOverrides struct {
	// The function takes the following parameters:
	//
	//    - incaps
	//    - outcaps
	//
	// The function returns the following values:
	//
	GLSetCaps func(incaps, outcaps *gst.Caps) bool
	// The function returns the following values:
	//
	GLStart func() bool
	GLStop  func()
}

func defaultGLBaseFilterOverrides(v *GLBaseFilter) GLBaseFilterOverrides {
	return GLBaseFilterOverrides{
		GLSetCaps: v.glSetCaps,
		GLStart:   v.glStart,
		GLStop:    v.glStop,
	}
}

// GLBaseFilter handles the nitty gritty details of retrieving an OpenGL
// context. It also provided some wrappers around BaseTransform's start(),
// stop() and set_caps() virtual methods that ensure an OpenGL context is
// available and current in the calling thread.
type GLBaseFilter struct {
	_ [0]func() // equal guard
	gstbase.BaseTransform
}

var (
	_ gstbase.BaseTransformer = (*GLBaseFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLBaseFilter, *GLBaseFilterClass, GLBaseFilterOverrides](
		GTypeGLBaseFilter,
		initGLBaseFilterClass,
		wrapGLBaseFilter,
		defaultGLBaseFilterOverrides,
	)
}

func initGLBaseFilterClass(gclass unsafe.Pointer, overrides GLBaseFilterOverrides, classInitFunc func(*GLBaseFilterClass)) {
	pclass := (*C.GstGLBaseFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLBaseFilter))))

	if overrides.GLSetCaps != nil {
		pclass.gl_set_caps = (*[0]byte)(C._gotk4_gstgl1_GLBaseFilterClass_gl_set_caps)
	}

	if overrides.GLStart != nil {
		pclass.gl_start = (*[0]byte)(C._gotk4_gstgl1_GLBaseFilterClass_gl_start)
	}

	if overrides.GLStop != nil {
		pclass.gl_stop = (*[0]byte)(C._gotk4_gstgl1_GLBaseFilterClass_gl_stop)
	}

	if classInitFunc != nil {
		class := (*GLBaseFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBaseFilter(obj *coreglib.Object) *GLBaseFilter {
	return &GLBaseFilter{
		BaseTransform: gstbase.BaseTransform{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLBaseFilter(p uintptr) (interface{}, error) {
	return wrapGLBaseFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//    - ok: whether an OpenGL context could be retrieved or created successfully.
//
func (filter *GLBaseFilter) FindGLContext() bool {
	var _arg0 *C.GstGLBaseFilter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gst_gl_base_filter_find_gl_context(_arg0)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - glContext (optional) found by filter.
//
func (filter *GLBaseFilter) GLContext() GLContexter {
	var _arg0 *C.GstGLBaseFilter // out
	var _cret *C.GstGLContext    // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gst_gl_base_filter_get_gl_context(_arg0)
	runtime.KeepAlive(filter)

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// The function takes the following parameters:
//
//    - incaps
//    - outcaps
//
// The function returns the following values:
//
func (filter *GLBaseFilter) glSetCaps(incaps, outcaps *gst.Caps) bool {
	gclass := (*C.GstGLBaseFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.gl_set_caps

	var _arg0 *C.GstGLBaseFilter // out
	var _arg1 *C.GstCaps         // out
	var _arg2 *C.GstCaps         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(incaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outcaps)))

	_cret = C._gotk4_gstgl1_GLBaseFilter_virtual_gl_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(incaps)
	runtime.KeepAlive(outcaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (filter *GLBaseFilter) glStart() bool {
	gclass := (*C.GstGLBaseFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.gl_start

	var _arg0 *C.GstGLBaseFilter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C._gotk4_gstgl1_GLBaseFilter_virtual_gl_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (filter *GLBaseFilter) glStop() {
	gclass := (*C.GstGLBaseFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.gl_stop

	var _arg0 *C.GstGLBaseFilter // out

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C._gotk4_gstgl1_GLBaseFilter_virtual_gl_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filter)
}

// GLBaseFilterClass: base class for GStreamer GL Filter.
//
// An instance of this type is always passed by reference.
type GLBaseFilterClass struct {
	*glBaseFilterClass
}

// glBaseFilterClass is the struct that's finalized.
type glBaseFilterClass struct {
	native *C.GstGLBaseFilterClass
}

func (g *GLBaseFilterClass) ParentClass() *gstbase.BaseTransformClass {
	valptr := &g.native.parent_class
	var _v *gstbase.BaseTransformClass // out
	_v = (*gstbase.BaseTransformClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SupportedGLApi: logical-OR of GLAPI's supported by this element.
func (g *GLBaseFilterClass) SupportedGLApi() GLAPI {
	valptr := &g.native.supported_gl_api
	var _v GLAPI // out
	_v = GLAPI(*valptr)
	return _v
}
