// Code generated by girgen. DO NOT EDIT.

package gstrtp

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/rtp/rtp.h>
import "C"

// GType values.
var (
	GTypeRTPBaseAudioPayload = coreglib.Type(C.gst_rtp_base_audio_payload_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRTPBaseAudioPayload, F: marshalRTPBaseAudioPayload},
	})
}

// RTPBaseAudioPayloadOverrides contains methods that are overridable.
type RTPBaseAudioPayloadOverrides struct {
}

func defaultRTPBaseAudioPayloadOverrides(v *RTPBaseAudioPayload) RTPBaseAudioPayloadOverrides {
	return RTPBaseAudioPayloadOverrides{}
}

// RTPBaseAudioPayload provides a base class for audio RTP payloaders for frame
// or sample based audio codecs (constant bitrate)
//
// This class derives from GstRTPBasePayload. It can be used for payloading
// audio codecs. It will only work with constant bitrate codecs. It supports
// both frame based and sample based codecs. It takes care of packing up the
// audio data into RTP packets and filling up the headers accordingly. The
// payloading is done based on the maximum MTU (mtu) and the maximum time per
// packet (max-ptime). The general idea is to divide large data buffers into
// smaller RTP packets. The RTP packet size is the minimum of either the MTU,
// max-ptime (if set) or available data. The RTP packet size is always larger or
// equal to min-ptime (if set). If min-ptime is not set, any residual data is
// sent in a last RTP packet. In the case of frame based codecs, the resulting
// RTP packets always contain full frames.
//
//
// Usage
//
// To use this base class, your child element needs to call either
// gst_rtp_base_audio_payload_set_frame_based() or
// gst_rtp_base_audio_payload_set_sample_based(). This is usually done in the
// element's _init() function. Then, the child element must call either
// gst_rtp_base_audio_payload_set_frame_options(),
// gst_rtp_base_audio_payload_set_sample_options() or
// gst_rtp_base_audio_payload_set_samplebits_options. Since
// GstRTPBaseAudioPayload derives from GstRTPBasePayload, the child element must
// set any variables or call/override any functions required by that base class.
// The child element does not need to override any other functions specific to
// GstRTPBaseAudioPayload.
type RTPBaseAudioPayload struct {
	_ [0]func() // equal guard
	RTPBasePayload
}

var (
	_ RTPBasePayloader = (*RTPBaseAudioPayload)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*RTPBaseAudioPayload, *RTPBaseAudioPayloadClass, RTPBaseAudioPayloadOverrides](
		GTypeRTPBaseAudioPayload,
		initRTPBaseAudioPayloadClass,
		wrapRTPBaseAudioPayload,
		defaultRTPBaseAudioPayloadOverrides,
	)
}

func initRTPBaseAudioPayloadClass(gclass unsafe.Pointer, overrides RTPBaseAudioPayloadOverrides, classInitFunc func(*RTPBaseAudioPayloadClass)) {
	if classInitFunc != nil {
		class := (*RTPBaseAudioPayloadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPBaseAudioPayload(obj *coreglib.Object) *RTPBaseAudioPayload {
	return &RTPBaseAudioPayload{
		RTPBasePayload: RTPBasePayload{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalRTPBaseAudioPayload(p uintptr) (interface{}, error) {
	return wrapRTPBaseAudioPayload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Flush: create an RTP buffer and store payload_len bytes of the adapter as the
// payload. Set the timestamp on the new buffer to timestamp before pushing the
// buffer downstream.
//
// If payload_len is -1, all pending bytes will be flushed. If timestamp is -1,
// the timestamp will be calculated automatically.
//
// The function takes the following parameters:
//
//    - payloadLen: length of payload.
//    - timestamp: ClockTime.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (baseaudiopayload *RTPBaseAudioPayload) Flush(payloadLen uint, timestamp gst.ClockTime) gst.FlowReturn {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.guint                   // out
	var _arg2 C.GstClockTime            // out
	var _cret C.GstFlowReturn           // in

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(baseaudiopayload).Native()))
	_arg1 = C.guint(payloadLen)
	_arg2 = C.guint64(timestamp)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_rtp_base_audio_payload_flush(_arg0, _arg1, _arg2)
	runtime.KeepAlive(baseaudiopayload)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(timestamp)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Adapter gets the internal adapter used by the depayloader.
//
// The function returns the following values:
//
//    - adapter: Adapter.
//
func (rtpbaseaudiopayload *RTPBaseAudioPayload) Adapter() *gstbase.Adapter {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _cret *C.GstAdapter             // in

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(rtpbaseaudiopayload).Native()))

	_cret = C.gst_rtp_base_audio_payload_get_adapter(_arg0)
	runtime.KeepAlive(rtpbaseaudiopayload)

	var _adapter *gstbase.Adapter // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_adapter = &gstbase.Adapter{
			Object: obj,
		}
	}

	return _adapter
}

// Push: create an RTP buffer and store payload_len bytes of data as the
// payload. Set the timestamp on the new buffer to timestamp before pushing the
// buffer downstream.
//
// The function takes the following parameters:
//
//    - data to set as payload.
//    - timestamp: ClockTime.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (baseaudiopayload *RTPBaseAudioPayload) Push(data []byte, timestamp gst.ClockTime) gst.FlowReturn {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 *C.guint8                 // out
	var _arg2 C.guint
	var _arg3 C.GstClockTime  // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(baseaudiopayload).Native()))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg3 = C.guint64(timestamp)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_rtp_base_audio_payload_push(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(baseaudiopayload)
	runtime.KeepAlive(data)
	runtime.KeepAlive(timestamp)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetFrameBased tells RTPBaseAudioPayload that the child element is for a frame
// based audio codec.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetFrameBased() {
	var _arg0 *C.GstRTPBaseAudioPayload // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(rtpbaseaudiopayload).Native()))

	C.gst_rtp_base_audio_payload_set_frame_based(_arg0)
	runtime.KeepAlive(rtpbaseaudiopayload)
}

// SetFrameOptions sets the options for frame based audio codecs.
//
// The function takes the following parameters:
//
//    - frameDuration: duraction of an audio frame in milliseconds.
//    - frameSize: size of an audio frame in bytes.
//
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetFrameOptions(frameDuration, frameSize int) {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.gint                    // out
	var _arg2 C.gint                    // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(rtpbaseaudiopayload).Native()))
	_arg1 = C.gint(frameDuration)
	_arg2 = C.gint(frameSize)

	C.gst_rtp_base_audio_payload_set_frame_options(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtpbaseaudiopayload)
	runtime.KeepAlive(frameDuration)
	runtime.KeepAlive(frameSize)
}

// SetSampleBased tells RTPBaseAudioPayload that the child element is for a
// sample based audio codec.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetSampleBased() {
	var _arg0 *C.GstRTPBaseAudioPayload // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(rtpbaseaudiopayload).Native()))

	C.gst_rtp_base_audio_payload_set_sample_based(_arg0)
	runtime.KeepAlive(rtpbaseaudiopayload)
}

// SetSampleOptions sets the options for sample based audio codecs.
//
// The function takes the following parameters:
//
//    - sampleSize: size per sample in bytes.
//
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetSampleOptions(sampleSize int) {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.gint                    // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(rtpbaseaudiopayload).Native()))
	_arg1 = C.gint(sampleSize)

	C.gst_rtp_base_audio_payload_set_sample_options(_arg0, _arg1)
	runtime.KeepAlive(rtpbaseaudiopayload)
	runtime.KeepAlive(sampleSize)
}

// SetSamplebitsOptions sets the options for sample based audio codecs.
//
// The function takes the following parameters:
//
//    - sampleSize: size per sample in bits.
//
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetSamplebitsOptions(sampleSize int) {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.gint                    // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.InternObject(rtpbaseaudiopayload).Native()))
	_arg1 = C.gint(sampleSize)

	C.gst_rtp_base_audio_payload_set_samplebits_options(_arg0, _arg1)
	runtime.KeepAlive(rtpbaseaudiopayload)
	runtime.KeepAlive(sampleSize)
}

// RTPBaseAudioPayloadClass: base class for audio RTP payloader.
//
// An instance of this type is always passed by reference.
type RTPBaseAudioPayloadClass struct {
	*rtpBaseAudioPayloadClass
}

// rtpBaseAudioPayloadClass is the struct that's finalized.
type rtpBaseAudioPayloadClass struct {
	native *C.GstRTPBaseAudioPayloadClass
}

// ParentClass: parent class.
func (r *RTPBaseAudioPayloadClass) ParentClass() *RTPBasePayloadClass {
	valptr := &r.native.parent_class
	var _v *RTPBasePayloadClass // out
	_v = (*RTPBasePayloadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
