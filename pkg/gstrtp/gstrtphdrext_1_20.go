// Code generated by girgen. DO NOT EDIT.

package gstrtp

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/rtp/rtp.h>
// extern gssize _gotk4_gstrtp1_RTPHeaderExtensionClass_write(GstRTPHeaderExtension*, GstBuffer*, GstRTPHeaderExtensionFlags, GstBuffer*, guint8*, gsize);
// extern gsize _gotk4_gstrtp1_RTPHeaderExtensionClass_get_max_size(GstRTPHeaderExtension*, GstBuffer*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_update_non_rtp_src_caps(GstRTPHeaderExtension*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_set_non_rtp_sink_caps(GstRTPHeaderExtension*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_set_caps_from_attributes(GstRTPHeaderExtension*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_set_attributes(GstRTPHeaderExtension*, GstRTPHeaderExtensionDirection, gchar*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_read(GstRTPHeaderExtension*, GstRTPHeaderExtensionFlags, guint8*, gsize, GstBuffer*);
// extern GstRTPHeaderExtensionFlags _gotk4_gstrtp1_RTPHeaderExtensionClass_get_supported_flags(GstRTPHeaderExtension*);
// GstRTPHeaderExtensionFlags _gotk4_gstrtp1_RTPHeaderExtension_virtual_get_supported_flags(void* fnptr, GstRTPHeaderExtension* arg0) {
//   return ((GstRTPHeaderExtensionFlags (*)(GstRTPHeaderExtension*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_read(void* fnptr, GstRTPHeaderExtension* arg0, GstRTPHeaderExtensionFlags arg1, guint8* arg2, gsize arg3, GstBuffer* arg4) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstRTPHeaderExtensionFlags, guint8*, gsize, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_set_attributes(void* fnptr, GstRTPHeaderExtension* arg0, GstRTPHeaderExtensionDirection arg1, gchar* arg2) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstRTPHeaderExtensionDirection, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_set_caps_from_attributes(void* fnptr, GstRTPHeaderExtension* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_set_non_rtp_sink_caps(void* fnptr, GstRTPHeaderExtension* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_update_non_rtp_src_caps(void* fnptr, GstRTPHeaderExtension* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gsize _gotk4_gstrtp1_RTPHeaderExtension_virtual_get_max_size(void* fnptr, GstRTPHeaderExtension* arg0, GstBuffer* arg1) {
//   return ((gsize (*)(GstRTPHeaderExtension*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gssize _gotk4_gstrtp1_RTPHeaderExtension_virtual_write(void* fnptr, GstRTPHeaderExtension* arg0, GstBuffer* arg1, GstRTPHeaderExtensionFlags arg2, GstBuffer* arg3, guint8* arg4, gsize arg5) {
//   return ((gssize (*)(GstRTPHeaderExtension*, GstBuffer*, GstRTPHeaderExtensionFlags, GstBuffer*, guint8*, gsize))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
import "C"

// GType values.
var (
	GTypeRTPHeaderExtensionDirection = coreglib.Type(C.gst_rtp_header_extension_direction_get_type())
	GTypeRTPHeaderExtensionFlags     = coreglib.Type(C.gst_rtp_header_extension_flags_get_type())
	GTypeRTPHeaderExtension          = coreglib.Type(C.gst_rtp_header_extension_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRTPHeaderExtensionDirection, F: marshalRTPHeaderExtensionDirection},
		coreglib.TypeMarshaler{T: GTypeRTPHeaderExtensionFlags, F: marshalRTPHeaderExtensionFlags},
		coreglib.TypeMarshaler{T: GTypeRTPHeaderExtension, F: marshalRTPHeaderExtension},
	})
}

// RTP_HDREXT_ELEMENT_CLASS: constant string used in element classification to
// signal that this element is a RTP header extension.
const RTP_HDREXT_ELEMENT_CLASS = "Network/Extension/RTPHeader"
const RTP_HEADER_EXTENSION_URI_METADATA_KEY = "RTP-Header-Extension-URI"

// RTPHeaderExtensionDirection: direction to which to apply the RTP Header
// Extension.
type RTPHeaderExtensionDirection C.guint

const (
	// RtpHeaderExtensionDirectionInactive: neither send nor receive RTP Header
	// Extensions.
	RtpHeaderExtensionDirectionInactive RTPHeaderExtensionDirection = 0b0
	// RtpHeaderExtensionDirectionSendonly: only send RTP Header Extensions
	// GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY: Only receive RTP Header
	// Extensions.
	RtpHeaderExtensionDirectionSendonly RTPHeaderExtensionDirection = 0b1
	RtpHeaderExtensionDirectionRecvonly RTPHeaderExtensionDirection = 0b10
	// RtpHeaderExtensionDirectionSendrecv: send and receive RTP Header
	// Extensions ext.
	RtpHeaderExtensionDirectionSendrecv RTPHeaderExtensionDirection = 0b11
	// RtpHeaderExtensionDirectionInherited: RTP header extension direction is
	// inherited from the stream.
	RtpHeaderExtensionDirectionInherited RTPHeaderExtensionDirection = 0b100
)

func marshalRTPHeaderExtensionDirection(p uintptr) (interface{}, error) {
	return RTPHeaderExtensionDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTPHeaderExtensionDirection.
func (r RTPHeaderExtensionDirection) String() string {
	if r == 0 {
		return "RTPHeaderExtensionDirection(0)"
	}

	var builder strings.Builder
	builder.Grow(180)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtpHeaderExtensionDirectionInactive:
			builder.WriteString("Inactive|")
		case RtpHeaderExtensionDirectionSendonly:
			builder.WriteString("Sendonly|")
		case RtpHeaderExtensionDirectionRecvonly:
			builder.WriteString("Recvonly|")
		case RtpHeaderExtensionDirectionSendrecv:
			builder.WriteString("Sendrecv|")
		case RtpHeaderExtensionDirectionInherited:
			builder.WriteString("Inherited|")
		default:
			builder.WriteString(fmt.Sprintf("RTPHeaderExtensionDirection(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTPHeaderExtensionDirection) Has(other RTPHeaderExtensionDirection) bool {
	return (r & other) == other
}

// RTPHeaderExtensionFlags flags that apply to a RTP Audio/Video header
// extension.
type RTPHeaderExtensionFlags C.guint

const (
	// RtpHeaderExtensionOneByte: one byte rtp extension header. 1-16 data bytes
	// per extension with a maximum of 14 extension ids in total.
	RtpHeaderExtensionOneByte RTPHeaderExtensionFlags = 0b1
	// RtpHeaderExtensionTwoByte: two byte rtp extension header. 256 data bytes
	// per extension with a maximum of 255 (or 256 including appbits) extensions
	// in total.
	RtpHeaderExtensionTwoByte RTPHeaderExtensionFlags = 0b10
)

func marshalRTPHeaderExtensionFlags(p uintptr) (interface{}, error) {
	return RTPHeaderExtensionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTPHeaderExtensionFlags.
func (r RTPHeaderExtensionFlags) String() string {
	if r == 0 {
		return "RTPHeaderExtensionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(51)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtpHeaderExtensionOneByte:
			builder.WriteString("OneByte|")
		case RtpHeaderExtensionTwoByte:
			builder.WriteString("TwoByte|")
		default:
			builder.WriteString(fmt.Sprintf("RTPHeaderExtensionFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTPHeaderExtensionFlags) Has(other RTPHeaderExtensionFlags) bool {
	return (r & other) == other
}

// RtpGetHeaderExtensionList: retrieve all the factories of the currently
// registered RTP header extensions. Call gst_element_factory_create() with each
// factory to create the associated RTPHeaderExtension.
//
// The function returns the following values:
//
//    - list of ElementFactory's. Use gst_plugin_feature_list_free() after use.
//
func RtpGetHeaderExtensionList() []*gst.ElementFactory {
	var _cret *C.GList // in

	_cret = C.gst_rtp_get_header_extension_list()

	var _list []*gst.ElementFactory // out

	_list = make([]*gst.ElementFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstElementFactory)(v)
		var dst *gst.ElementFactory // out
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(src))
			dst = &gst.ElementFactory{
				PluginFeature: gst.PluginFeature{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			}
		}
		_list = append(_list, dst)
	})

	return _list
}

// RTPHeaderExtensionOverrides contains methods that are overridable.
type RTPHeaderExtensionOverrides struct {
	// MaxSize: this is used to know how much data a certain header extension
	// will need for both allocating the resulting data, and deciding how much
	// payload data can be generated.
	//
	// Implementations should return as accurate a value as is possible using
	// the information given in the input buffer.
	//
	// The function takes the following parameters:
	//
	//    - inputMeta: Buffer.
	//
	// The function returns the following values:
	//
	//    - gsize: maximum size of the data written by this extension.
	//
	MaxSize func(inputMeta *gst.Buffer) uint
	// The function returns the following values:
	//
	//    - rtpHeaderExtensionFlags flags supported by this instance of ext.
	//
	SupportedFlags func() RTPHeaderExtensionFlags
	// Read the RTP header extension from data.
	//
	// The function takes the following parameters:
	//
	//    - readFlags for how the extension should be written.
	//    - data: location to read the rtp header extension from.
	//    - buffer to modify if necessary.
	//
	// The function returns the following values:
	//
	//    - ok: whether the extension could be read from data.
	//
	Read func(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool
	// The function takes the following parameters:
	//
	//    - direction
	//    - attributes
	//
	// The function returns the following values:
	//
	SetAttributes func(direction RTPHeaderExtensionDirection, attributes string) bool
	// SetCapsFromAttributes: gst_rtp_header_extension_set_id() must have been
	// called with a valid extension id that is contained in these caps.
	//
	// The only current known caps format is based on the SDP standard as
	// produced by gst_sdp_media_attributes_to_caps().
	//
	// The function takes the following parameters:
	//
	//    - caps: writable Caps to modify.
	//
	// The function returns the following values:
	//
	//    - ok: whether the configured attributes on ext can successfully be set
	//      on caps.
	//
	SetCapsFromAttributes func(caps *gst.Caps) bool
	// SetNonRtpSinkCaps passes RTP payloader's sink (i.e. not payloaded) caps
	// to the header extension.
	//
	// The function takes the following parameters:
	//
	//    - caps: sink Caps.
	//
	// The function returns the following values:
	//
	//    - ok: whether caps could be read successfully.
	//
	SetNonRtpSinkCaps func(caps *gst.Caps) bool
	// UpdateNonRtpSrcCaps updates depayloader src caps based on the information
	// received in RTP header. caps must be writable as this function may modify
	// them.
	//
	// The function takes the following parameters:
	//
	//    - caps: src Caps to modify.
	//
	// The function returns the following values:
	//
	//    - ok: whether caps were modified successfully.
	//
	UpdateNonRtpSrcCaps func(caps *gst.Caps) bool
	// Write writes the RTP header extension to data using information available
	// from the input_meta. data will be sized to be at least the value returned
	// from gst_rtp_header_extension_get_max_size().
	//
	// The function takes the following parameters:
	//
	//    - inputMeta: input Buffer to read information from if necessary.
	//    - writeFlags for how the extension should be written.
	//    - output RTP Buffer.
	//    - data: location to write the rtp header extension into.
	//
	// The function returns the following values:
	//
	//    - gssize: size of the data written, < 0 on failure.
	//
	Write func(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int
}

func defaultRTPHeaderExtensionOverrides(v *RTPHeaderExtension) RTPHeaderExtensionOverrides {
	return RTPHeaderExtensionOverrides{
		MaxSize:               v.maxSize,
		SupportedFlags:        v.supportedFlags,
		Read:                  v.read,
		SetAttributes:         v.setAttributes,
		SetCapsFromAttributes: v.setCapsFromAttributes,
		SetNonRtpSinkCaps:     v.setNonRtpSinkCaps,
		UpdateNonRtpSrcCaps:   v.updateNonRtpSrcCaps,
		Write:                 v.write,
	}
}

// RTPHeaderExtension: instance struct for a RTP Audio/Video header extension.
type RTPHeaderExtension struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*RTPHeaderExtension)(nil)
)

// RTPHeaderExtensioner describes types inherited from class RTPHeaderExtension.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RTPHeaderExtensioner interface {
	coreglib.Objector
	baseRTPHeaderExtension() *RTPHeaderExtension
}

var _ RTPHeaderExtensioner = (*RTPHeaderExtension)(nil)

func init() {
	coreglib.RegisterClassInfo[*RTPHeaderExtension, *RTPHeaderExtensionClass, RTPHeaderExtensionOverrides](
		GTypeRTPHeaderExtension,
		initRTPHeaderExtensionClass,
		wrapRTPHeaderExtension,
		defaultRTPHeaderExtensionOverrides,
	)
}

func initRTPHeaderExtensionClass(gclass unsafe.Pointer, overrides RTPHeaderExtensionOverrides, classInitFunc func(*RTPHeaderExtensionClass)) {
	pclass := (*C.GstRTPHeaderExtensionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRTPHeaderExtension))))

	if overrides.MaxSize != nil {
		pclass.get_max_size = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_get_max_size)
	}

	if overrides.SupportedFlags != nil {
		pclass.get_supported_flags = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_get_supported_flags)
	}

	if overrides.Read != nil {
		pclass.read = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_read)
	}

	if overrides.SetAttributes != nil {
		pclass.set_attributes = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_set_attributes)
	}

	if overrides.SetCapsFromAttributes != nil {
		pclass.set_caps_from_attributes = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_set_caps_from_attributes)
	}

	if overrides.SetNonRtpSinkCaps != nil {
		pclass.set_non_rtp_sink_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_set_non_rtp_sink_caps)
	}

	if overrides.UpdateNonRtpSrcCaps != nil {
		pclass.update_non_rtp_src_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_update_non_rtp_src_caps)
	}

	if overrides.Write != nil {
		pclass.write = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_write)
	}

	if classInitFunc != nil {
		class := (*RTPHeaderExtensionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPHeaderExtension(obj *coreglib.Object) *RTPHeaderExtension {
	return &RTPHeaderExtension{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalRTPHeaderExtension(p uintptr) (interface{}, error) {
	return wrapRTPHeaderExtension(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (ext *RTPHeaderExtension) baseRTPHeaderExtension() *RTPHeaderExtension {
	return ext
}

// BaseRTPHeaderExtension returns the underlying base object.
func BaseRTPHeaderExtension(obj RTPHeaderExtensioner) *RTPHeaderExtension {
	return obj.baseRTPHeaderExtension()
}

// Direction: retrieve the direction.
//
// The function returns the following values:
//
//    - rtpHeaderExtensionDirection: direction.
//
func (ext *RTPHeaderExtension) Direction() RTPHeaderExtensionDirection {
	var _arg0 *C.GstRTPHeaderExtension         // out
	var _cret C.GstRTPHeaderExtensionDirection // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_direction(_arg0)
	runtime.KeepAlive(ext)

	var _rtpHeaderExtensionDirection RTPHeaderExtensionDirection // out

	_rtpHeaderExtensionDirection = RTPHeaderExtensionDirection(_cret)

	return _rtpHeaderExtensionDirection
}

// The function returns the following values:
//
//    - guint: RTP extension id configured on ext.
//
func (ext *RTPHeaderExtension) ID() uint {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret C.guint                  // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_id(_arg0)
	runtime.KeepAlive(ext)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaxSize: this is used to know how much data a certain header extension will
// need for both allocating the resulting data, and deciding how much payload
// data can be generated.
//
// Implementations should return as accurate a value as is possible using the
// information given in the input buffer.
//
// The function takes the following parameters:
//
//    - inputMeta: Buffer.
//
// The function returns the following values:
//
//    - gsize: maximum size of the data written by this extension.
//
func (ext *RTPHeaderExtension) MaxSize(inputMeta *gst.Buffer) uint {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstBuffer             // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))

	_cret = C.gst_rtp_header_extension_get_max_size(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function returns the following values:
//
//    - utf8 field name used in SDP-like Caps for this ext configuration.
//
func (ext *RTPHeaderExtension) SdpCapsFieldName() string {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_sdp_caps_field_name(_arg0)
	runtime.KeepAlive(ext)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// The function returns the following values:
//
//    - rtpHeaderExtensionFlags flags supported by this instance of ext.
//
func (ext *RTPHeaderExtension) SupportedFlags() RTPHeaderExtensionFlags {
	var _arg0 *C.GstRTPHeaderExtension     // out
	var _cret C.GstRTPHeaderExtensionFlags // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_supported_flags(_arg0)
	runtime.KeepAlive(ext)

	var _rtpHeaderExtensionFlags RTPHeaderExtensionFlags // out

	_rtpHeaderExtensionFlags = RTPHeaderExtensionFlags(_cret)

	return _rtpHeaderExtensionFlags
}

// The function returns the following values:
//
//    - utf8: RTP extension URI for this object.
//
func (ext *RTPHeaderExtension) URI() string {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_uri(_arg0)
	runtime.KeepAlive(ext)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Read the RTP header extension from data.
//
// The function takes the following parameters:
//
//    - readFlags for how the extension should be written.
//    - data: location to read the rtp header extension from.
//    - buffer to modify if necessary.
//
// The function returns the following values:
//
//    - ok: whether the extension could be read from data.
//
func (ext *RTPHeaderExtension) Read(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool {
	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 C.GstRTPHeaderExtensionFlags // out
	var _arg2 *C.guint8                    // out
	var _arg3 C.gsize
	var _arg4 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionFlags(readFlags)
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtp_header_extension_read(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(readFlags)
	runtime.KeepAlive(data)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributesFromCaps: gst_rtp_header_extension_set_id() must have been
// called with a valid extension id that is contained in these caps.
//
// The only current known caps format is based on the SDP standard as produced
// by gst_sdp_media_attributes_to_caps().
//
// The function takes the following parameters:
//
//    - caps to configure this extension with.
//
// The function returns the following values:
//
//    - ok: whether the caps could be successfully set on ext.
//
func (ext *RTPHeaderExtension) SetAttributesFromCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_set_attributes_from_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCapsFromAttributes: gst_rtp_header_extension_set_id() must have been
// called with a valid extension id that is contained in these caps.
//
// The only current known caps format is based on the SDP standard as produced
// by gst_sdp_media_attributes_to_caps().
//
// The function takes the following parameters:
//
//    - caps: writable Caps to modify.
//
// The function returns the following values:
//
//    - ok: whether the configured attributes on ext can successfully be set on
//      caps.
//
func (ext *RTPHeaderExtension) SetCapsFromAttributes(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_set_caps_from_attributes(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCapsFromAttributesHelper: helper implementation for
// GstRTPExtensionClass::set_caps_from_attributes that sets the ext uri on caps
// with the specified extension id as required for sdp Caps.
//
// Requires that the extension does not have any attributes or direction
// advertised in caps.
//
// The function takes the following parameters:
//
//    - caps to write fields into.
//    - attributes
//
// The function returns the following values:
//
//    - ok: whether the ext attributes could be set on caps.
//
func (ext *RTPHeaderExtension) SetCapsFromAttributesHelper(caps *gst.Caps, attributes string) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _arg2 *C.gchar                 // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_rtp_header_extension_set_caps_from_attributes_helper(_arg0, _arg1, _arg2)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(attributes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDirection: set the direction that this header extension should be used in.
// If T_RTP_HEADER_EXTENSION_DIRECTION_INHERITED is included, the direction will
// not be included in the caps (as it shouldn't be in the extmap line in the
// SDP).
//
// The function takes the following parameters:
//
//    - direction: direction.
//
func (ext *RTPHeaderExtension) SetDirection(direction RTPHeaderExtensionDirection) {
	var _arg0 *C.GstRTPHeaderExtension         // out
	var _arg1 C.GstRTPHeaderExtensionDirection // out

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionDirection(direction)

	C.gst_rtp_header_extension_set_direction(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(direction)
}

// SetID sets the RTP extension id on ext.
//
// The function takes the following parameters:
//
//    - extId: id of this extension.
//
func (ext *RTPHeaderExtension) SetID(extId uint) {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 C.guint                  // out

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = C.guint(extId)

	C.gst_rtp_header_extension_set_id(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(extId)
}

// SetNonRtpSinkCaps passes RTP payloader's sink (i.e. not payloaded) caps to
// the header extension.
//
// The function takes the following parameters:
//
//    - caps: sink Caps.
//
// The function returns the following values:
//
//    - ok: whether caps could be read successfully.
//
func (ext *RTPHeaderExtension) SetNonRtpSinkCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_set_non_rtp_sink_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetWantsUpdateNonRtpSrcCaps: call this function in a subclass from
// RTPHeaderExtensionClass::read to tell the depayloader whether the data just
// parsed from RTP packet require updating its src (non-RTP) caps. If state is
// TRUE, RTPBaseDepayload will eventually invoke
// gst_rtp_header_extension_update_non_rtp_src_caps() to have the caps update
// applied. Applying the update also flips the internal "wants update" flag back
// to FALSE.
//
// The function takes the following parameters:
//
//    - state: TRUE if caps update is needed.
//
func (ext *RTPHeaderExtension) SetWantsUpdateNonRtpSrcCaps(state bool) {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	if state {
		_arg1 = C.TRUE
	}

	C.gst_rtp_header_extension_set_wants_update_non_rtp_src_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(state)
}

// UpdateNonRtpSrcCaps updates depayloader src caps based on the information
// received in RTP header. caps must be writable as this function may modify
// them.
//
// The function takes the following parameters:
//
//    - caps: src Caps to modify.
//
// The function returns the following values:
//
//    - ok: whether caps were modified successfully.
//
func (ext *RTPHeaderExtension) UpdateNonRtpSrcCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_update_non_rtp_src_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WantsUpdateNonRtpSrcCaps: call this function after
// gst_rtp_header_extension_read() to check if the depayloader's src caps need
// updating with data received in the last RTP packet.
//
// The function returns the following values:
//
//    - ok: whether ext wants to update depayloader's src caps.
//
func (ext *RTPHeaderExtension) WantsUpdateNonRtpSrcCaps() bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_wants_update_non_rtp_src_caps(_arg0)
	runtime.KeepAlive(ext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Write writes the RTP header extension to data using information available
// from the input_meta. data will be sized to be at least the value returned
// from gst_rtp_header_extension_get_max_size().
//
// The function takes the following parameters:
//
//    - inputMeta: input Buffer to read information from if necessary.
//    - writeFlags for how the extension should be written.
//    - output RTP Buffer.
//    - data: location to write the rtp header extension into.
//
// The function returns the following values:
//
//    - gssize: size of the data written, < 0 on failure.
//
func (ext *RTPHeaderExtension) Write(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int {
	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 *C.GstBuffer                 // out
	var _arg2 C.GstRTPHeaderExtensionFlags // out
	var _arg3 *C.GstBuffer                 // out
	var _arg4 *C.guint8                    // out
	var _arg5 C.gsize
	var _cret C.gssize // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))
	_arg2 = C.GstRTPHeaderExtensionFlags(writeFlags)
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(output)))
	_arg5 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_header_extension_write(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)
	runtime.KeepAlive(writeFlags)
	runtime.KeepAlive(output)
	runtime.KeepAlive(data)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// maxSize: this is used to know how much data a certain header extension will
// need for both allocating the resulting data, and deciding how much payload
// data can be generated.
//
// Implementations should return as accurate a value as is possible using the
// information given in the input buffer.
//
// The function takes the following parameters:
//
//    - inputMeta: Buffer.
//
// The function returns the following values:
//
//    - gsize: maximum size of the data written by this extension.
//
func (ext *RTPHeaderExtension) maxSize(inputMeta *gst.Buffer) uint {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.get_max_size

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstBuffer             // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_get_max_size(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function returns the following values:
//
//    - rtpHeaderExtensionFlags flags supported by this instance of ext.
//
func (ext *RTPHeaderExtension) supportedFlags() RTPHeaderExtensionFlags {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.get_supported_flags

	var _arg0 *C.GstRTPHeaderExtension     // out
	var _cret C.GstRTPHeaderExtensionFlags // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_get_supported_flags(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ext)

	var _rtpHeaderExtensionFlags RTPHeaderExtensionFlags // out

	_rtpHeaderExtensionFlags = RTPHeaderExtensionFlags(_cret)

	return _rtpHeaderExtensionFlags
}

// Read: read the RTP header extension from data.
//
// The function takes the following parameters:
//
//    - readFlags for how the extension should be written.
//    - data: location to read the rtp header extension from.
//    - buffer to modify if necessary.
//
// The function returns the following values:
//
//    - ok: whether the extension could be read from data.
//
func (ext *RTPHeaderExtension) read(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.read

	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 C.GstRTPHeaderExtensionFlags // out
	var _arg2 *C.guint8                    // out
	var _arg3 C.gsize
	var _arg4 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionFlags(readFlags)
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_read(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(readFlags)
	runtime.KeepAlive(data)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - direction
//    - attributes
//
// The function returns the following values:
//
func (ext *RTPHeaderExtension) setAttributes(direction RTPHeaderExtensionDirection, attributes string) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.set_attributes

	var _arg0 *C.GstRTPHeaderExtension         // out
	var _arg1 C.GstRTPHeaderExtensionDirection // out
	var _arg2 *C.gchar                         // out
	var _cret C.gboolean                       // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionDirection(direction)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_set_attributes(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(attributes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setCapsFromAttributes: gst_rtp_header_extension_set_id() must have been
// called with a valid extension id that is contained in these caps.
//
// The only current known caps format is based on the SDP standard as produced
// by gst_sdp_media_attributes_to_caps().
//
// The function takes the following parameters:
//
//    - caps: writable Caps to modify.
//
// The function returns the following values:
//
//    - ok: whether the configured attributes on ext can successfully be set on
//      caps.
//
func (ext *RTPHeaderExtension) setCapsFromAttributes(caps *gst.Caps) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.set_caps_from_attributes

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_set_caps_from_attributes(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setNonRtpSinkCaps passes RTP payloader's sink (i.e. not payloaded) caps to
// the header extension.
//
// The function takes the following parameters:
//
//    - caps: sink Caps.
//
// The function returns the following values:
//
//    - ok: whether caps could be read successfully.
//
func (ext *RTPHeaderExtension) setNonRtpSinkCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.set_non_rtp_sink_caps

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_set_non_rtp_sink_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// updateNonRtpSrcCaps updates depayloader src caps based on the information
// received in RTP header. caps must be writable as this function may modify
// them.
//
// The function takes the following parameters:
//
//    - caps: src Caps to modify.
//
// The function returns the following values:
//
//    - ok: whether caps were modified successfully.
//
func (ext *RTPHeaderExtension) updateNonRtpSrcCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.update_non_rtp_src_caps

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_update_non_rtp_src_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Write writes the RTP header extension to data using information available
// from the input_meta. data will be sized to be at least the value returned
// from gst_rtp_header_extension_get_max_size().
//
// The function takes the following parameters:
//
//    - inputMeta: input Buffer to read information from if necessary.
//    - writeFlags for how the extension should be written.
//    - output RTP Buffer.
//    - data: location to write the rtp header extension into.
//
// The function returns the following values:
//
//    - gssize: size of the data written, < 0 on failure.
//
func (ext *RTPHeaderExtension) write(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.write

	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 *C.GstBuffer                 // out
	var _arg2 C.GstRTPHeaderExtensionFlags // out
	var _arg3 *C.GstBuffer                 // out
	var _arg4 *C.guint8                    // out
	var _arg5 C.gsize
	var _cret C.gssize // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.InternObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))
	_arg2 = C.GstRTPHeaderExtensionFlags(writeFlags)
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(output)))
	_arg5 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_write(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)
	runtime.KeepAlive(writeFlags)
	runtime.KeepAlive(output)
	runtime.KeepAlive(data)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// The function takes the following parameters:
//
//    - uri: rtp header extension URI to search for.
//
// The function returns the following values:
//
//    - rtpHeaderExtension (optional) for uri or NULL.
//
func RTPHeaderExtensionCreateFromURI(uri string) RTPHeaderExtensioner {
	var _arg1 *C.gchar                 // out
	var _cret *C.GstRTPHeaderExtension // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_rtp_header_extension_create_from_uri(_arg1)
	runtime.KeepAlive(uri)

	var _rtpHeaderExtension RTPHeaderExtensioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(RTPHeaderExtensioner)
				return ok
			})
			rv, ok := casted.(RTPHeaderExtensioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstrtp.RTPHeaderExtensioner")
			}
			_rtpHeaderExtension = rv
		}
	}

	return _rtpHeaderExtension
}

// RTPHeaderExtensionClass: base class for RTP Header extensions.
//
// An instance of this type is always passed by reference.
type RTPHeaderExtensionClass struct {
	*rtpHeaderExtensionClass
}

// rtpHeaderExtensionClass is the struct that's finalized.
type rtpHeaderExtensionClass struct {
	native *C.GstRTPHeaderExtensionClass
}

// ParentClass: parent class.
func (r *RTPHeaderExtensionClass) ParentClass() *gst.ElementClass {
	valptr := &r.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SetURI: set the URI for this RTP header extension implementation.
//
// The function takes the following parameters:
//
//    - uri: RTP Header extension uri for klass.
//
func (klass *RTPHeaderExtensionClass) SetURI(uri string) {
	var _arg0 *C.GstRTPHeaderExtensionClass // out
	var _arg1 *C.gchar                      // out

	_arg0 = (*C.GstRTPHeaderExtensionClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_rtp_header_extension_class_set_uri(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(uri)
}
