// Code generated by girgen. DO NOT EDIT.

package gstrtp

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/rtp/rtp.h>
import "C"

// GType values.
var (
	GTypeRTCPFBType   = coreglib.Type(C.gst_rtcpfb_type_get_type())
	GTypeRTCPSDESType = coreglib.Type(C.gst_rtcpsdes_type_get_type())
	GTypeRTCPType     = coreglib.Type(C.gst_rtcp_type_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRTCPFBType, F: marshalRTCPFBType},
		coreglib.TypeMarshaler{T: GTypeRTCPSDESType, F: marshalRTCPSDESType},
		coreglib.TypeMarshaler{T: GTypeRTCPType, F: marshalRTCPType},
	})
}

// RTCP_MAX_BYE_SSRC_COUNT: maximum amount of SSRCs in a BYE packet.
const RTCP_MAX_BYE_SSRC_COUNT = 31

// RTCP_MAX_RB_COUNT: maximum amount of Receiver report blocks in RR and SR
// messages.
const RTCP_MAX_RB_COUNT = 31

// RTCP_MAX_SDES: maximum text length for an SDES item.
const RTCP_MAX_SDES = 255

// RTCP_MAX_SDES_ITEM_COUNT: maximum amount of SDES items.
const RTCP_MAX_SDES_ITEM_COUNT = 31

// RTCP_REDUCED_SIZE_VALID_MASK: mask for version and packet type pair allowing
// reduced size packets, basically it accepts other types than RR and SR.
const RTCP_REDUCED_SIZE_VALID_MASK = 49400

// RTCP_VALID_MASK: mask for version, padding bit and packet type pair.
const RTCP_VALID_MASK = 57598

// RTCP_VALID_VALUE: valid value for the first two bytes of an RTCP packet after
// applying T_RTCP_VALID_MASK to them.
const RTCP_VALID_VALUE = 200

// RTCP_VERSION: supported RTCP version 2.
const RTCP_VERSION = 2

// RTCPFBType: different types of feedback messages.
type RTCPFBType C.gint

const (
	// RtcpFbTypeInvalid: invalid type.
	RtcpFbTypeInvalid RTCPFBType = 0
	// RtcpRtpfbTypeNack: generic NACK.
	RtcpRtpfbTypeNack RTCPFBType = 1
	// RtcpRtpfbTypeTmmbr: temporary Maximum Media Stream Bit Rate Request.
	RtcpRtpfbTypeTmmbr RTCPFBType = 3
	// RtcpRtpfbTypeTmmbn: temporary Maximum Media Stream Bit Rate Notification.
	RtcpRtpfbTypeTmmbn RTCPFBType = 4
	// RtcpRtpfbTypeRtcpSrReq: request an SR packet for early synchronization.
	RtcpRtpfbTypeRtcpSrReq RTCPFBType = 5
	RtcpRtpfbTypeTwcc      RTCPFBType = 15
	// RtcpPsfbTypePli: picture Loss Indication.
	RtcpPsfbTypePli RTCPFBType = 1
	// RtcpPsfbTypeSli: slice Loss Indication.
	RtcpPsfbTypeSli RTCPFBType = 2
	// RtcpPsfbTypeRpsi: reference Picture Selection Indication.
	RtcpPsfbTypeRpsi RTCPFBType = 3
	// RtcpPsfbTypeAfb: application layer Feedback.
	RtcpPsfbTypeAfb RTCPFBType = 15
	// RtcpPsfbTypeFir: full Intra Request Command.
	RtcpPsfbTypeFir RTCPFBType = 4
	// RtcpPsfbTypeTstr: temporal-Spatial Trade-off Request.
	RtcpPsfbTypeTstr RTCPFBType = 5
	// RtcpPsfbTypeTstn: temporal-Spatial Trade-off Notification.
	RtcpPsfbTypeTstn RTCPFBType = 6
	// RtcpPsfbTypeVbcn: video Back Channel Message.
	RtcpPsfbTypeVbcn RTCPFBType = 7
)

func marshalRTCPFBType(p uintptr) (interface{}, error) {
	return RTCPFBType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPFBType.
func (r RTCPFBType) String() string {
	switch r {
	case RtcpFbTypeInvalid:
		return "FbTypeInvalid"
	case RtcpRtpfbTypeNack:
		return "RtpfbTypeNack"
	case RtcpRtpfbTypeTmmbr:
		return "RtpfbTypeTmmbr"
	case RtcpRtpfbTypeTmmbn:
		return "RtpfbTypeTmmbn"
	case RtcpRtpfbTypeRtcpSrReq:
		return "RtpfbTypeRtcpSrReq"
	case RtcpRtpfbTypeTwcc:
		return "RtpfbTypeTwcc"
	case RtcpPsfbTypeSli:
		return "PsfbTypeSli"
	case RtcpPsfbTypeTstn:
		return "PsfbTypeTstn"
	case RtcpPsfbTypeVbcn:
		return "PsfbTypeVbcn"
	default:
		return fmt.Sprintf("RTCPFBType(%d)", r)
	}
}

// RTCPSDESType: different types of SDES content.
type RTCPSDESType C.gint

const (
	// RtcpSdesInvalid: invalid SDES entry.
	RtcpSdesInvalid RTCPSDESType = -1
	// RtcpSdesEnd: end of SDES list.
	RtcpSdesEnd RTCPSDESType = 0
	// RtcpSdesCname: canonical name.
	RtcpSdesCname RTCPSDESType = 1
	// RtcpSdesName: user name.
	RtcpSdesName RTCPSDESType = 2
	// RtcpSdesEmail user's electronic mail address.
	RtcpSdesEmail RTCPSDESType = 3
	// RtcpSdesPhone user's phone number.
	RtcpSdesPhone RTCPSDESType = 4
	// RtcpSdesLoc: geographic user location.
	RtcpSdesLoc RTCPSDESType = 5
	// RtcpSdesTool: name of application or tool.
	RtcpSdesTool RTCPSDESType = 6
	// RtcpSdesNote: notice about the source.
	RtcpSdesNote RTCPSDESType = 7
	// RtcpSdesPriv: private extensions.
	RtcpSdesPriv RTCPSDESType = 8
	// RtcpSdesH323Caddr: h.323 callable address.
	RtcpSdesH323Caddr RTCPSDESType = 9
	// RtcpSdesApsi: application Specific Identifier (RFC6776).
	RtcpSdesApsi RTCPSDESType = 10
	// RtcpSdesRgrp: reporting Group Identifier (RFC8861).
	RtcpSdesRgrp RTCPSDESType = 11
	// RtcpSdesRtpStreamID: rtpStreamId SDES item (RFC8852).
	RtcpSdesRtpStreamID RTCPSDESType = 12
	// RtcpSdesRepairedRtpStreamID: repairedRtpStreamId SDES item (RFC8852).
	RtcpSdesRepairedRtpStreamID RTCPSDESType = 13
	// RtcpSdesCcid: CLUE CaptId (RFC8849).
	RtcpSdesCcid RTCPSDESType = 14
	// RtcpSdesMid: MID SDES item (RFC8843).
	RtcpSdesMid RTCPSDESType = 15
)

func marshalRTCPSDESType(p uintptr) (interface{}, error) {
	return RTCPSDESType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPSDESType.
func (r RTCPSDESType) String() string {
	switch r {
	case RtcpSdesInvalid:
		return "Invalid"
	case RtcpSdesEnd:
		return "End"
	case RtcpSdesCname:
		return "Cname"
	case RtcpSdesName:
		return "Name"
	case RtcpSdesEmail:
		return "Email"
	case RtcpSdesPhone:
		return "Phone"
	case RtcpSdesLoc:
		return "Loc"
	case RtcpSdesTool:
		return "Tool"
	case RtcpSdesNote:
		return "Note"
	case RtcpSdesPriv:
		return "Priv"
	case RtcpSdesH323Caddr:
		return "H323Caddr"
	case RtcpSdesApsi:
		return "Apsi"
	case RtcpSdesRgrp:
		return "Rgrp"
	case RtcpSdesRtpStreamID:
		return "RtpStreamID"
	case RtcpSdesRepairedRtpStreamID:
		return "RepairedRtpStreamID"
	case RtcpSdesCcid:
		return "Ccid"
	case RtcpSdesMid:
		return "Mid"
	default:
		return fmt.Sprintf("RTCPSDESType(%d)", r)
	}
}

// RTCPType: different RTCP packet types.
type RTCPType C.gint

const (
	// RtcpTypeInvalid: invalid type.
	RtcpTypeInvalid RTCPType = 0
	// RtcpTypeSr: sender report.
	RtcpTypeSr RTCPType = 200
	// RtcpTypeRr: receiver report.
	RtcpTypeRr RTCPType = 201
	// RtcpTypeSdes: source description.
	RtcpTypeSdes RTCPType = 202
	// RtcpTypeBye: goodbye.
	RtcpTypeBye RTCPType = 203
	// RtcpTypeApp: application defined.
	RtcpTypeApp RTCPType = 204
	// RtcpTypeRtpfb: transport layer feedback.
	RtcpTypeRtpfb RTCPType = 205
	// RtcpTypePsfb: payload-specific feedback.
	RtcpTypePsfb RTCPType = 206
	// RtcpTypeXR: extended report.
	RtcpTypeXR RTCPType = 207
)

func marshalRTCPType(p uintptr) (interface{}, error) {
	return RTCPType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPType.
func (r RTCPType) String() string {
	switch r {
	case RtcpTypeInvalid:
		return "Invalid"
	case RtcpTypeSr:
		return "Sr"
	case RtcpTypeRr:
		return "Rr"
	case RtcpTypeSdes:
		return "Sdes"
	case RtcpTypeBye:
		return "Bye"
	case RtcpTypeApp:
		return "App"
	case RtcpTypeRtpfb:
		return "Rtpfb"
	case RtcpTypePsfb:
		return "Psfb"
	case RtcpTypeXR:
		return "XR"
	default:
		return fmt.Sprintf("RTCPType(%d)", r)
	}
}

// RtcpNtpToUnix converts an NTP time to UNIX nanoseconds. ntptime can typically
// be the NTP time of an SR RTCP message and contains, in the upper 32 bits, the
// number of seconds since 1900 and, in the lower 32 bits, the fractional
// seconds. The resulting value will be the number of nanoseconds since 1970.
//
// The function takes the following parameters:
//
//    - ntptime: NTP timestamp.
//
// The function returns the following values:
//
//    - guint64: UNIX time for ntptime in nanoseconds.
//
func RtcpNtpToUnix(ntptime uint64) uint64 {
	var _arg1 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(ntptime)

	_cret = C.gst_rtcp_ntp_to_unix(_arg1)
	runtime.KeepAlive(ntptime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RtcpSdesNameToType: convert name into a GstRTCPSDESType. name is typically a
// key in a Structure containing SDES items.
//
// The function takes the following parameters:
//
//    - name: SDES name.
//
// The function returns the following values:
//
//    - rtcpsdesType for name or T_RTCP_SDES_PRIV when name is a private sdes
//      item.
//
func RtcpSdesNameToType(name string) RTCPSDESType {
	var _arg1 *C.gchar          // out
	var _cret C.GstRTCPSDESType // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_rtcp_sdes_name_to_type(_arg1)
	runtime.KeepAlive(name)

	var _rtcpsdesType RTCPSDESType // out

	_rtcpsdesType = RTCPSDESType(_cret)

	return _rtcpsdesType
}

// RtcpSdesTypeToName converts type to the string equivalent. The string is
// typically used as a key in a Structure containing SDES items.
//
// The function takes the following parameters:
//
//    - typ: RTCPSDESType.
//
// The function returns the following values:
//
//    - utf8: string equivalent of type.
//
func RtcpSdesTypeToName(typ RTCPSDESType) string {
	var _arg1 C.GstRTCPSDESType // out
	var _cret *C.gchar          // in

	_arg1 = C.GstRTCPSDESType(typ)

	_cret = C.gst_rtcp_sdes_type_to_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RtcpUnixToNtp converts a UNIX timestamp in nanoseconds to an NTP time. The
// caller should pass a value with nanoseconds since 1970. The NTP time will, in
// the upper 32 bits, contain the number of seconds since 1900 and, in the lower
// 32 bits, the fractional seconds. The resulting value can be used as an
// ntptime for constructing SR RTCP packets.
//
// The function takes the following parameters:
//
//    - unixtime: UNIX timestamp in nanoseconds.
//
// The function returns the following values:
//
//    - guint64: NTP time for unixtime.
//
func RtcpUnixToNtp(unixtime uint64) uint64 {
	var _arg1 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(unixtime)

	_cret = C.gst_rtcp_unix_to_ntp(_arg1)
	runtime.KeepAlive(unixtime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RTCPBuffer: note: The API in this module is not yet declared stable.
//
// The GstRTPCBuffer helper functions makes it easy to parse and create regular
// Buffer objects that contain compound RTCP packets. These buffers are
// typically of 'application/x-rtcp' Caps.
//
// An RTCP buffer consists of 1 or more RTCPPacket structures that you can
// retrieve with gst_rtcp_buffer_get_first_packet(). RTCPPacket acts as a
// pointer into the RTCP buffer; you can move to the next packet with
// gst_rtcp_packet_move_to_next().
//
// An instance of this type is always passed by reference.
type RTCPBuffer struct {
	*rtcpBuffer
}

// rtcpBuffer is the struct that's finalized.
type rtcpBuffer struct {
	native *C.GstRTCPBuffer
}

func (r *RTCPBuffer) Buffer() *gst.Buffer {
	valptr := &r.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

func (r *RTCPBuffer) Map() *gst.MapInfo {
	valptr := &r.native._map
	var _v *gst.MapInfo // out
	_v = (*gst.MapInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AddPacket: add a new packet of type to rtcp. packet will point to the newly
// created packet.
//
// The function takes the following parameters:
//
//    - typ of the new packet.
//    - packet: pointer to new packet.
//
// The function returns the following values:
//
//    - ok: TRUE if the packet could be created. This function returns FALSE if
//      the max mtu is exceeded for the buffer.
//
func (rtcp *RTCPBuffer) AddPacket(typ RTCPType, packet *RTCPPacket) bool {
	var _arg0 *C.GstRTCPBuffer // out
	var _arg1 C.GstRTCPType    // out
	var _arg2 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))
	_arg1 = C.GstRTCPType(typ)
	_arg2 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_buffer_add_packet(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtcp)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FirstPacket: initialize a new RTCPPacket pointer that points to the first
// packet in rtcp.
//
// The function takes the following parameters:
//
//    - packet: RTCPPacket.
//
// The function returns the following values:
//
//    - ok: TRUE if the packet existed in rtcp.
//
func (rtcp *RTCPBuffer) FirstPacket(packet *RTCPPacket) bool {
	var _arg0 *C.GstRTCPBuffer // out
	var _arg1 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))
	_arg1 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_buffer_get_first_packet(_arg0, _arg1)
	runtime.KeepAlive(rtcp)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PacketCount: get the number of RTCP packets in rtcp.
//
// The function returns the following values:
//
//    - guint: number of RTCP packets in rtcp.
//
func (rtcp *RTCPBuffer) PacketCount() uint {
	var _arg0 *C.GstRTCPBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))

	_cret = C.gst_rtcp_buffer_get_packet_count(_arg0)
	runtime.KeepAlive(rtcp)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Unmap: finish rtcp after being constructed. This function is usually called
// after gst_rtcp_buffer_map() and after adding the RTCP items to the new
// buffer.
//
// The function adjusts the size of rtcp with the total length of all the added
// packets.
//
// The function returns the following values:
//
func (rtcp *RTCPBuffer) Unmap() bool {
	var _arg0 *C.GstRTCPBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))

	_cret = C.gst_rtcp_buffer_unmap(_arg0)
	runtime.KeepAlive(rtcp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPBufferMap: open buffer for reading or writing, depending on flags. The
// resulting RTCP buffer state is stored in rtcp.
//
// The function takes the following parameters:
//
//    - buffer with an RTCP packet.
//    - flags for the mapping.
//    - rtcp: resulting RTCPBuffer.
//
// The function returns the following values:
//
func RTCPBufferMap(buffer *gst.Buffer, flags gst.MapFlags, rtcp *RTCPBuffer) bool {
	var _arg1 *C.GstBuffer     // out
	var _arg2 C.GstMapFlags    // out
	var _arg3 *C.GstRTCPBuffer // out
	var _cret C.gboolean       // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstMapFlags(flags)
	_arg3 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))

	_cret = C.gst_rtcp_buffer_map(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(rtcp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewRTCPBuffer: create a new buffer for constructing RTCP packets. The packet
// will have a maximum size of mtu.
//
// The function takes the following parameters:
//
//    - mtu: maximum mtu size.
//
// The function returns the following values:
//
//    - buffer: newly allocated buffer.
//
func NewRTCPBuffer(mtu uint) *gst.Buffer {
	var _arg1 C.guint      // out
	var _cret *C.GstBuffer // in

	_arg1 = C.guint(mtu)

	_cret = C.gst_rtcp_buffer_new(_arg1)
	runtime.KeepAlive(mtu)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewRTCPBufferCopyData: create a new buffer and set the data to a copy of len
// bytes of data and the size to len. The data will be freed when the buffer is
// freed.
//
// The function takes the following parameters:
//
//    - data for the new buffer.
//
// The function returns the following values:
//
//    - buffer: newly allocated buffer with a copy of data and of size len.
//
func NewRTCPBufferCopyData(data []byte) *gst.Buffer {
	var _arg1 C.gconstpointer // out
	var _arg2 C.guint
	var _cret *C.GstBuffer // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_new_copy_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewRTCPBufferTakeData: create a new buffer and set the data and size of the
// buffer to data and len respectively. data will be freed when the buffer is
// unreffed, so this function transfers ownership of data to the new buffer.
//
// The function takes the following parameters:
//
//    - data for the new buffer.
//
// The function returns the following values:
//
//    - buffer: newly allocated buffer with data and of size len.
//
func NewRTCPBufferTakeData(data []byte) *gst.Buffer {
	var _arg1 C.gpointer // out
	var _arg2 C.guint
	var _cret *C.GstBuffer // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_new_take_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// RTCPBufferValidate: check if the data pointed to by buffer is a valid RTCP
// packet using gst_rtcp_buffer_validate_data().
//
// The function takes the following parameters:
//
//    - buffer to validate.
//
// The function returns the following values:
//
//    - ok: TRUE if buffer is a valid RTCP packet.
//
func RTCPBufferValidate(buffer *gst.Buffer) bool {
	var _arg1 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtcp_buffer_validate(_arg1)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPBufferValidateData: check if the data and size point to the data of a
// valid compound, non-reduced size RTCP packet. Use this function to validate a
// packet before using the other functions in this module.
//
// The function takes the following parameters:
//
//    - data to validate.
//
// The function returns the following values:
//
//    - ok: TRUE if the data points to a valid RTCP packet.
//
func RTCPBufferValidateData(data []byte) bool {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_validate_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPPacket: data structure that points to a packet at offset in buffer. The
// size of the structure is made public to allow stack allocations.
//
// An instance of this type is always passed by reference.
type RTCPPacket struct {
	*rtcpPacket
}

// rtcpPacket is the struct that's finalized.
type rtcpPacket struct {
	native *C.GstRTCPPacket
}

// Rtcp: pointer to RTCP buffer.
func (r *RTCPPacket) Rtcp() *RTCPBuffer {
	valptr := &r.native.rtcp
	var _v *RTCPBuffer // out
	_v = (*RTCPBuffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Offset: offset of packet in buffer data.
func (r *RTCPPacket) Offset() uint {
	valptr := &r.native.offset
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: offset of packet in buffer data.
func (r *RTCPPacket) SetOffset(offset uint) {
	valptr := &r.native.offset
	*valptr = C.guint(offset)
}

// AddProfileSpecificExt: add profile-specific extension data to packet. If
// packet already contains profile-specific extension data will be appended to
// the existing extension.
//
// The function takes the following parameters:
//
//    - data: profile-specific data.
//
// The function returns the following values:
//
//    - ok: TRUE if the profile specific extension data was added.
//
func (packet *RTCPPacket) AddProfileSpecificExt(data []byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_packet_add_profile_specific_ext(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddRb: add a new report block to packet with the given values.
//
// The function takes the following parameters:
//
//    - ssrc: data source being reported.
//    - fractionlost: fraction lost since last SR/RR.
//    - packetslost: cumululative number of packets lost.
//    - exthighestseq: extended last sequence number received.
//    - jitter: interarrival jitter.
//    - lsr: last SR packet from this source.
//    - dlsr: delay since last SR packet.
//
// The function returns the following values:
//
//    - ok: TRUE if the packet was created. This function can return FALSE if the
//      max MTU is exceeded or the number of report blocks is greater than
//      T_RTCP_MAX_RB_COUNT.
//
func (packet *RTCPPacket) AddRb(ssrc uint32, fractionlost byte, packetslost int32, exthighestseq uint32, jitter uint32, lsr uint32, dlsr uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _arg2 C.guint8         // out
	var _arg3 C.gint32         // out
	var _arg4 C.guint32        // out
	var _arg5 C.guint32        // out
	var _arg6 C.guint32        // out
	var _arg7 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)
	_arg2 = C.guint8(fractionlost)
	_arg3 = C.gint32(packetslost)
	_arg4 = C.guint32(exthighestseq)
	_arg5 = C.guint32(jitter)
	_arg6 = C.guint32(lsr)
	_arg7 = C.guint32(dlsr)

	_cret = C.gst_rtcp_packet_add_rb(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(fractionlost)
	runtime.KeepAlive(packetslost)
	runtime.KeepAlive(exthighestseq)
	runtime.KeepAlive(jitter)
	runtime.KeepAlive(lsr)
	runtime.KeepAlive(dlsr)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppGetData: get the application-dependent data attached to a RTPFB or PSFB
// packet.
//
// The function returns the following values:
//
//    - guint8: pointer to the data.
//
func (packet *RTCPPacket) AppGetData() *byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_data(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// AppGetDataLength: get the length of the application-dependent data attached
// to an APP packet.
//
// The function returns the following values:
//
//    - guint16: length of data in 32-bit words.
//
func (packet *RTCPPacket) AppGetDataLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_data_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// AppGetName: get the name field of the APP packet.
//
// The function returns the following values:
//
//    - utf8: 4-byte name field, not zero-terminated.
//
func (packet *RTCPPacket) AppGetName() string {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_name(_arg0)
	runtime.KeepAlive(packet)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// AppGetSsrc: get the SSRC/CSRC field of the APP packet.
//
// The function returns the following values:
//
//    - guint32: SSRC/CSRC.
//
func (packet *RTCPPacket) AppGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// AppGetSubtype: get the subtype field of the APP packet.
//
// The function returns the following values:
//
//    - guint8: subtype.
//
func (packet *RTCPPacket) AppGetSubtype() byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint8         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_subtype(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// AppSetDataLength: set the length of the application-dependent data attached
// to an APP packet.
//
// The function takes the following parameters:
//
//    - wordlen: length of the data in 32-bit words.
//
// The function returns the following values:
//
//    - ok: TRUE if there was enough space in the packet to add this much data.
//
func (packet *RTCPPacket) AppSetDataLength(wordlen uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint16        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint16(wordlen)

	_cret = C.gst_rtcp_packet_app_set_data_length(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(wordlen)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppSetName: set the name field of the APP packet.
//
// The function takes the following parameters:
//
//    - name: 4-byte ASCII name.
//
func (packet *RTCPPacket) AppSetName(name string) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_rtcp_packet_app_set_name(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(name)
}

// AppSetSsrc: set the SSRC/CSRC field of the APP packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC/CSRC of the packet.
//
func (packet *RTCPPacket) AppSetSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_app_set_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// AppSetSubtype: set the subtype field of the APP packet.
//
// The function takes the following parameters:
//
//    - subtype of the packet.
//
func (packet *RTCPPacket) AppSetSubtype(subtype byte) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint8         // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint8(subtype)

	C.gst_rtcp_packet_app_set_subtype(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(subtype)
}

// ByeAddSsrc: add ssrc to the BYE packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the ssrc was added. This function can return FALSE if the max
//      MTU is exceeded or the number of sources blocks is greater than
//      T_RTCP_MAX_BYE_SSRC_COUNT.
//
func (packet *RTCPPacket) ByeAddSsrc(ssrc uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	_cret = C.gst_rtcp_packet_bye_add_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ByeAddSsrcs adds len SSRCs in ssrc to BYE packet.
//
// The function takes the following parameters:
//
//    - ssrc: array of SSRCs to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the all the SSRCs were added. This function can return FALSE
//      if the max MTU is exceeded or the number of sources blocks is greater
//      than T_RTCP_MAX_BYE_SSRC_COUNT.
//
func (packet *RTCPPacket) ByeAddSsrcs(ssrc []uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg2 = (C.guint)(len(ssrc))
	if len(ssrc) > 0 {
		_arg1 = (*C.guint32)(unsafe.Pointer(&ssrc[0]))
	}

	_cret = C.gst_rtcp_packet_bye_add_ssrcs(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ByeGetNthSsrc: get the nth SSRC of the BYE packet.
//
// The function takes the following parameters:
//
//    - nth SSRC to get.
//
// The function returns the following values:
//
//    - guint32: nth SSRC of packet.
//
func (packet *RTCPPacket) ByeGetNthSsrc(nth uint) uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)

	_cret = C.gst_rtcp_packet_bye_get_nth_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// ByeGetReason: get the reason in packet.
//
// The function returns the following values:
//
//    - utf8: reason for the BYE packet or NULL if the packet did not contain a
//      reason string. The string must be freed with g_free() after usage.
//
func (packet *RTCPPacket) ByeGetReason() string {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_bye_get_reason(_arg0)
	runtime.KeepAlive(packet)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ByeGetReasonLen: get the length of the reason string.
//
// The function returns the following values:
//
//    - guint8: length of the reason string or 0 when there is no reason string
//      present.
//
func (packet *RTCPPacket) ByeGetReasonLen() byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint8         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_bye_get_reason_len(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// ByeGetSsrcCount: get the number of SSRC fields in packet.
//
// The function returns the following values:
//
//    - guint: number of SSRC fields in packet.
//
func (packet *RTCPPacket) ByeGetSsrcCount() uint {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_bye_get_ssrc_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ByeSetReason: set the reason string to reason in packet.
//
// The function takes the following parameters:
//
//    - reason string.
//
// The function returns the following values:
//
//    - ok: TRUE if the string could be set.
//
func (packet *RTCPPacket) ByeSetReason(reason string) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(reason)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_rtcp_packet_bye_set_reason(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(reason)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyProfileSpecificExt: profile-specific extension data is copied into a new
// allocated memory area data. This must be freed with g_free() after usage.
//
// The function returns the following values:
//
//    - data: result profile-specific data.
//    - ok: TRUE if there was valid data.
//
func (packet *RTCPPacket) CopyProfileSpecificExt() ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // in
	var _arg2 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_copy_profile_specific_ext(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(packet)

	var _data []byte // out
	var _ok bool     // out

	defer C.free(unsafe.Pointer(_arg1))
	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// FbGetFci: get the Feedback Control Information attached to a RTPFB or PSFB
// packet.
//
// The function returns the following values:
//
//    - guint8: pointer to the FCI.
//
func (packet *RTCPPacket) FbGetFci() *byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_fci(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// FbGetFciLength: get the length of the Feedback Control Information attached
// to a RTPFB or PSFB packet.
//
// The function returns the following values:
//
//    - guint16: length of the FCI in 32-bit words.
//
func (packet *RTCPPacket) FbGetFciLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_fci_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// FbGetMediaSsrc: get the media SSRC field of the RTPFB or PSFB packet.
//
// The function returns the following values:
//
//    - guint32: media SSRC.
//
func (packet *RTCPPacket) FbGetMediaSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_media_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// FbGetSenderSsrc: get the sender SSRC field of the RTPFB or PSFB packet.
//
// The function returns the following values:
//
//    - guint32: sender SSRC.
//
func (packet *RTCPPacket) FbGetSenderSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_sender_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// FbGetType: get the feedback message type of the FB packet.
//
// The function returns the following values:
//
//    - rtcpfbType: feedback message type.
//
func (packet *RTCPPacket) FbGetType() RTCPFBType {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.GstRTCPFBType  // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_type(_arg0)
	runtime.KeepAlive(packet)

	var _rtcpfbType RTCPFBType // out

	_rtcpfbType = RTCPFBType(_cret)

	return _rtcpfbType
}

// FbSetFciLength: set the length of the Feedback Control Information attached
// to a RTPFB or PSFB packet.
//
// The function takes the following parameters:
//
//    - wordlen: length of the FCI in 32-bit words.
//
// The function returns the following values:
//
//    - ok: TRUE if there was enough space in the packet to add this much FCI.
//
func (packet *RTCPPacket) FbSetFciLength(wordlen uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint16        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint16(wordlen)

	_cret = C.gst_rtcp_packet_fb_set_fci_length(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(wordlen)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FbSetMediaSsrc: set the media SSRC field of the RTPFB or PSFB packet.
//
// The function takes the following parameters:
//
//    - ssrc: media SSRC.
//
func (packet *RTCPPacket) FbSetMediaSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_fb_set_media_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// FbSetSenderSsrc: set the sender SSRC field of the RTPFB or PSFB packet.
//
// The function takes the following parameters:
//
//    - ssrc: sender SSRC.
//
func (packet *RTCPPacket) FbSetSenderSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_fb_set_sender_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// FbSetType: set the feedback message type of the FB packet.
//
// The function takes the following parameters:
//
//    - typ to set.
//
func (packet *RTCPPacket) FbSetType(typ RTCPFBType) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.GstRTCPFBType  // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.GstRTCPFBType(typ)

	C.gst_rtcp_packet_fb_set_type(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)
}

// Count: get the count field in packet.
//
// The function returns the following values:
//
//    - guint8: count field in packet or -1 if packet does not point to a valid
//      packet.
//
func (packet *RTCPPacket) Count() byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint8         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Length: get the length field of packet. This is the length of the packet in
// 32-bit words minus one.
//
// The function returns the following values:
//
//    - guint16: length field of packet.
//
func (packet *RTCPPacket) Length() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Padding: get the packet padding of the packet pointed to by packet.
//
// The function returns the following values:
//
//    - ok: if the packet has the padding bit set.
//
func (packet *RTCPPacket) Padding() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_padding(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - data: result profile-specific data.
//    - ok: TRUE if there was valid data.
//
func (packet *RTCPPacket) ProfileSpecificExt() ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // in
	var _arg2 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_profile_specific_ext(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(packet)

	var _data []byte // out
	var _ok bool     // out

	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// The function returns the following values:
//
//    - guint16: number of 32-bit words containing profile-specific extension
//      data from packet.
//
func (packet *RTCPPacket) ProfileSpecificExtLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_profile_specific_ext_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Rb: parse the values of the nth report block in packet and store the result
// in the values.
//
// The function takes the following parameters:
//
//    - nth report block in packet.
//
// The function returns the following values:
//
//    - ssrc: result for data source being reported.
//    - fractionlost: result for fraction lost since last SR/RR.
//    - packetslost: result for the cumululative number of packets lost.
//    - exthighestseq: result for the extended last sequence number received.
//    - jitter: result for the interarrival jitter.
//    - lsr: result for the last SR packet from this source.
//    - dlsr: result for the delay since last SR packet.
//
func (packet *RTCPPacket) Rb(nth uint) (ssrc uint32, fractionlost byte, packetslost int32, exthighestseq uint32, jitter uint32, lsr uint32, dlsr uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 C.guint32        // in
	var _arg3 C.guint8         // in
	var _arg4 C.gint32         // in
	var _arg5 C.guint32        // in
	var _arg6 C.guint32        // in
	var _arg7 C.guint32        // in
	var _arg8 C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)

	C.gst_rtcp_packet_get_rb(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7, &_arg8)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)

	var _ssrc uint32          // out
	var _fractionlost byte    // out
	var _packetslost int32    // out
	var _exthighestseq uint32 // out
	var _jitter uint32        // out
	var _lsr uint32           // out
	var _dlsr uint32          // out

	_ssrc = uint32(_arg2)
	_fractionlost = byte(_arg3)
	_packetslost = int32(_arg4)
	_exthighestseq = uint32(_arg5)
	_jitter = uint32(_arg6)
	_lsr = uint32(_arg7)
	_dlsr = uint32(_arg8)

	return _ssrc, _fractionlost, _packetslost, _exthighestseq, _jitter, _lsr, _dlsr
}

// RbCount: get the number of report blocks in packet.
//
// The function returns the following values:
//
//    - guint: number of report blocks in packet.
//
func (packet *RTCPPacket) RbCount() uint {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_rb_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Type: get the packet type of the packet pointed to by packet.
//
// The function returns the following values:
//
//    - rtcpType: packet type or GST_RTCP_TYPE_INVALID when packet is not
//      pointing to a valid packet.
//
func (packet *RTCPPacket) Type() RTCPType {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.GstRTCPType    // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_type(_arg0)
	runtime.KeepAlive(packet)

	var _rtcpType RTCPType // out

	_rtcpType = RTCPType(_cret)

	return _rtcpType
}

// MoveToNext: move the packet pointer packet to the next packet in the payload.
// Use gst_rtcp_buffer_get_first_packet() to initialize packet.
//
// The function returns the following values:
//
//    - ok: TRUE if packet is pointing to a valid packet after calling this
//      function.
//
func (packet *RTCPPacket) MoveToNext() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_move_to_next(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes the packet pointed to by packet and moves pointer to the next
// one.
//
// The function returns the following values:
//
//    - ok: TRUE if packet is pointing to a valid packet after calling this
//      function.
//
func (packet *RTCPPacket) Remove() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_remove(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RrGetSsrc: get the ssrc field of the RR packet.
//
// The function returns the following values:
//
//    - guint32: ssrc.
//
func (packet *RTCPPacket) RrGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_rr_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// RrSetSsrc: set the ssrc field of the RR packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC to set.
//
func (packet *RTCPPacket) RrSetSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_rr_set_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// SdesAddEntry: add a new SDES entry to the current item in packet.
//
// The function takes the following parameters:
//
//    - typ of the SDES entry.
//    - data: data.
//
// The function returns the following values:
//
//    - ok: TRUE if the item could be added, FALSE if the MTU has been reached.
//
func (packet *RTCPPacket) SdesAddEntry(typ RTCPSDESType, data []byte) bool {
	var _arg0 *C.GstRTCPPacket  // out
	var _arg1 C.GstRTCPSDESType // out
	var _arg3 *C.guint8         // out
	var _arg2 C.guint8
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.GstRTCPSDESType(typ)
	_arg2 = (C.guint8)(len(data))
	if len(data) > 0 {
		_arg3 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_packet_sdes_add_entry(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesAddItem: add a new SDES item for ssrc to packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC of the new item to add.
//
// The function returns the following values:
//
//    - ok: TRUE if the item could be added, FALSE if the maximum amount of items
//      has been exceeded for the SDES packet or the MTU has been reached.
//
func (packet *RTCPPacket) SdesAddItem(ssrc uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	_cret = C.gst_rtcp_packet_sdes_add_item(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesCopyEntry: this function is like gst_rtcp_packet_sdes_get_entry() but it
// returns a null-terminated copy of the data instead. use g_free() after usage.
//
// The function takes the following parameters:
//
//    - typ: result of the entry type.
//
// The function returns the following values:
//
//    - data: result entry data.
//    - ok: TRUE if there was valid data.
//
func (packet *RTCPPacket) SdesCopyEntry(typ *RTCPSDESType) ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket   // out
	var _arg1 *C.GstRTCPSDESType // out
	var _arg3 *C.guint8          // in
	var _arg2 C.guint8           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.GstRTCPSDESType)(unsafe.Pointer(typ))

	_cret = C.gst_rtcp_packet_sdes_copy_entry(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _ok bool     // out

	defer C.free(unsafe.Pointer(_arg3))
	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// SdesFirstEntry: move to the first SDES entry in the current item.
//
// The function returns the following values:
//
//    - ok: TRUE if there was a first entry.
//
func (packet *RTCPPacket) SdesFirstEntry() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_first_entry(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesFirstItem: move to the first SDES item in packet.
//
// The function returns the following values:
//
//    - ok: TRUE if there was a first item.
//
func (packet *RTCPPacket) SdesFirstItem() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_first_item(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesGetEntry: get the data of the current SDES item entry. type (when not
// NULL) will contain the type of the entry. data (when not NULL) will point to
// len bytes.
//
// When type refers to a text item, data will point to a UTF8 string. Note that
// this UTF8 string is NOT null-terminated. Use
// gst_rtcp_packet_sdes_copy_entry() to get a null-terminated copy of the entry.
//
// The function takes the following parameters:
//
//    - typ: result of the entry type.
//
// The function returns the following values:
//
//    - data: result entry data.
//    - ok: TRUE if there was valid data.
//
func (packet *RTCPPacket) SdesGetEntry(typ *RTCPSDESType) ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket   // out
	var _arg1 *C.GstRTCPSDESType // out
	var _arg3 *C.guint8          // in
	var _arg2 C.guint8           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.GstRTCPSDESType)(unsafe.Pointer(typ))

	_cret = C.gst_rtcp_packet_sdes_get_entry(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _ok bool     // out

	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// SdesGetItemCount: get the number of items in the SDES packet packet.
//
// The function returns the following values:
//
//    - guint: number of items in packet.
//
func (packet *RTCPPacket) SdesGetItemCount() uint {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_get_item_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SdesGetSsrc: get the SSRC of the current SDES item.
//
// The function returns the following values:
//
//    - guint32: SSRC of the current item.
//
func (packet *RTCPPacket) SdesGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// SdesNextEntry: move to the next SDES entry in the current item.
//
// The function returns the following values:
//
//    - ok: TRUE if there was a next entry.
//
func (packet *RTCPPacket) SdesNextEntry() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_next_entry(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesNextItem: move to the next SDES item in packet.
//
// The function returns the following values:
//
//    - ok: TRUE if there was a next item.
//
func (packet *RTCPPacket) SdesNextItem() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_next_item(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRb: set the nth new report block in packet with the given values.
//
// Note: Not implemented.
//
// The function takes the following parameters:
//
//    - nth report block to set.
//    - ssrc: data source being reported.
//    - fractionlost: fraction lost since last SR/RR.
//    - packetslost: cumululative number of packets lost.
//    - exthighestseq: extended last sequence number received.
//    - jitter: interarrival jitter.
//    - lsr: last SR packet from this source.
//    - dlsr: delay since last SR packet.
//
func (packet *RTCPPacket) SetRb(nth uint, ssrc uint32, fractionlost byte, packetslost int32, exthighestseq uint32, jitter uint32, lsr uint32, dlsr uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 C.guint32        // out
	var _arg3 C.guint8         // out
	var _arg4 C.gint32         // out
	var _arg5 C.guint32        // out
	var _arg6 C.guint32        // out
	var _arg7 C.guint32        // out
	var _arg8 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)
	_arg2 = C.guint32(ssrc)
	_arg3 = C.guint8(fractionlost)
	_arg4 = C.gint32(packetslost)
	_arg5 = C.guint32(exthighestseq)
	_arg6 = C.guint32(jitter)
	_arg7 = C.guint32(lsr)
	_arg8 = C.guint32(dlsr)

	C.gst_rtcp_packet_set_rb(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(fractionlost)
	runtime.KeepAlive(packetslost)
	runtime.KeepAlive(exthighestseq)
	runtime.KeepAlive(jitter)
	runtime.KeepAlive(lsr)
	runtime.KeepAlive(dlsr)
}

// SrGetSenderInfo: parse the SR sender info and store the values.
//
// The function returns the following values:
//
//    - ssrc: result SSRC.
//    - ntptime: result NTP time.
//    - rtptime: result RTP time.
//    - packetCount: result packet count.
//    - octetCount: result octet count.
//
func (packet *RTCPPacket) SrGetSenderInfo() (ssrc uint32, ntptime uint64, rtptime uint32, packetCount uint32, octetCount uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // in
	var _arg2 C.guint64        // in
	var _arg3 C.guint32        // in
	var _arg4 C.guint32        // in
	var _arg5 C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	C.gst_rtcp_packet_sr_get_sender_info(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(packet)

	var _ssrc uint32        // out
	var _ntptime uint64     // out
	var _rtptime uint32     // out
	var _packetCount uint32 // out
	var _octetCount uint32  // out

	_ssrc = uint32(_arg1)
	_ntptime = uint64(_arg2)
	_rtptime = uint32(_arg3)
	_packetCount = uint32(_arg4)
	_octetCount = uint32(_arg5)

	return _ssrc, _ntptime, _rtptime, _packetCount, _octetCount
}

// SrSetSenderInfo: set the given values in the SR packet packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC.
//    - ntptime: NTP time.
//    - rtptime: RTP time.
//    - packetCount: packet count.
//    - octetCount: octet count.
//
func (packet *RTCPPacket) SrSetSenderInfo(ssrc uint32, ntptime uint64, rtptime uint32, packetCount uint32, octetCount uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _arg2 C.guint64        // out
	var _arg3 C.guint32        // out
	var _arg4 C.guint32        // out
	var _arg5 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)
	_arg2 = C.guint64(ntptime)
	_arg3 = C.guint32(rtptime)
	_arg4 = C.guint32(packetCount)
	_arg5 = C.guint32(octetCount)

	C.gst_rtcp_packet_sr_set_sender_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(ntptime)
	runtime.KeepAlive(rtptime)
	runtime.KeepAlive(packetCount)
	runtime.KeepAlive(octetCount)
}

// XRFirstRb: move to the first extended report block in XR packet.
//
// The function returns the following values:
//
//    - ok: TRUE if there was a first extended report block.
//
func (packet *RTCPPacket) XRFirstRb() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_first_rb(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - guint16: number of 32-bit words containing type-specific block data from
//      packet.
//
func (packet *RTCPPacket) XRGetBlockLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_get_block_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// XRGetBlockType: get the extended report block type of the XR packet.
//
// The function returns the following values:
//
//    - rtcpxrType: extended report block type.
//
func (packet *RTCPPacket) XRGetBlockType() RTCPXRType {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.GstRTCPXRType  // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_get_block_type(_arg0)
	runtime.KeepAlive(packet)

	var _rtcpxrType RTCPXRType // out

	_rtcpxrType = RTCPXRType(_cret)

	return _rtcpxrType
}

// XRGetDlrrBlock: parse the extended report block for DLRR report block type.
//
// The function takes the following parameters:
//
//    - nth: index of sub-block to retrieve.
//    - ssrc: SSRC of the receiver.
//    - lastRr: last receiver reference timestamp of ssrc.
//    - delay since last_rr.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetDlrrBlock(nth uint, ssrc *uint32, lastRr *uint32, delay *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 *C.guint32       // out
	var _arg3 *C.guint32       // out
	var _arg4 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)
	_arg2 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg3 = (*C.guint32)(unsafe.Pointer(lastRr))
	_arg4 = (*C.guint32)(unsafe.Pointer(delay))

	_cret = C.gst_rtcp_packet_xr_get_dlrr_block(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(lastRr)
	runtime.KeepAlive(delay)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetPrtBySeq: retrieve the packet receipt time of seq which ranges in
// [begin_seq, end_seq).
//
// The function takes the following parameters:
//
//    - seq: sequence to retrieve the time.
//    - receiptTime: packet receipt time of seq.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block returns the receipt time correctly.
//
func (packet *RTCPPacket) XRGetPrtBySeq(seq uint16, receiptTime *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint16        // out
	var _arg2 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint16(seq)
	_arg2 = (*C.guint32)(unsafe.Pointer(receiptTime))

	_cret = C.gst_rtcp_packet_xr_get_prt_by_seq(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(seq)
	runtime.KeepAlive(receiptTime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetPrtInfo: parse the Packet Recept Times Report Block from a XR packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC of the RTP data packet source being reported upon by this
//      report block.
//    - thinning: amount of thinning performed on the sequence number space.
//    - beginSeq: first sequence number that this block reports on.
//    - endSeq: last sequence number that this block reports on plus one.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetPrtInfo(ssrc *uint32, thinning *byte, beginSeq *uint16, endSeq *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint16       // out
	var _arg4 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg2 = (*C.guint8)(unsafe.Pointer(thinning))
	_arg3 = (*C.guint16)(unsafe.Pointer(beginSeq))
	_arg4 = (*C.guint16)(unsafe.Pointer(endSeq))

	_cret = C.gst_rtcp_packet_xr_get_prt_info(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(thinning)
	runtime.KeepAlive(beginSeq)
	runtime.KeepAlive(endSeq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetRLEInfo: parse the extended report block for Loss RLE and Duplicated LRE
// block type.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC of the RTP data packet source being reported upon by this
//      report block.
//    - thinning: amount of thinning performed on the sequence number space.
//    - beginSeq: first sequence number that this block reports on.
//    - endSeq: last sequence number that this block reports on plus one.
//    - chunkCount: number of chunks calculated by block length.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetRLEInfo(ssrc *uint32, thinning *byte, beginSeq *uint16, endSeq *uint16, chunkCount *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint16       // out
	var _arg4 *C.guint16       // out
	var _arg5 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg2 = (*C.guint8)(unsafe.Pointer(thinning))
	_arg3 = (*C.guint16)(unsafe.Pointer(beginSeq))
	_arg4 = (*C.guint16)(unsafe.Pointer(endSeq))
	_arg5 = (*C.guint32)(unsafe.Pointer(chunkCount))

	_cret = C.gst_rtcp_packet_xr_get_rle_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(thinning)
	runtime.KeepAlive(beginSeq)
	runtime.KeepAlive(endSeq)
	runtime.KeepAlive(chunkCount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetRLENthChunk: retrieve actual chunk data.
//
// The function takes the following parameters:
//
//    - nth: index of chunk to retrieve.
//    - chunk: nth chunk.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block returns chunk correctly.
//
func (packet *RTCPPacket) XRGetRLENthChunk(nth uint, chunk *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)
	_arg2 = (*C.guint16)(unsafe.Pointer(chunk))

	_cret = C.gst_rtcp_packet_xr_get_rle_nth_chunk(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)
	runtime.KeepAlive(chunk)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - timestamp: NTP timestamp.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block returns the reference time correctly.
//
func (packet *RTCPPacket) XRGetRrt(timestamp *uint64) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint64       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint64)(unsafe.Pointer(timestamp))

	_cret = C.gst_rtcp_packet_xr_get_rrt(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(timestamp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetSsrc: get the ssrc field of the XR packet.
//
// The function returns the following values:
//
//    - guint32: ssrc.
//
func (packet *RTCPPacket) XRGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// XRGetSummaryInfo: extract a basic information from static summary report
// block of XR packet.
//
// The function takes the following parameters:
//
//    - ssrc: SSRC of the source.
//    - beginSeq: first sequence number that this block reports on.
//    - endSeq: last sequence number that this block reports on plus one.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetSummaryInfo(ssrc *uint32, beginSeq *uint16, endSeq *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint16       // out
	var _arg3 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg2 = (*C.guint16)(unsafe.Pointer(beginSeq))
	_arg3 = (*C.guint16)(unsafe.Pointer(endSeq))

	_cret = C.gst_rtcp_packet_xr_get_summary_info(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(beginSeq)
	runtime.KeepAlive(endSeq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetSummaryJitter: extract jitter information from the statistics summary.
// If the jitter flag in a block header is set as zero, all of jitters will be
// zero.
//
// The function takes the following parameters:
//
//    - minJitter: minimum relative transit time between two sequences.
//    - maxJitter: maximum relative transit time between two sequences.
//    - meanJitter: mean relative transit time between two sequences.
//    - devJitter: standard deviation of the relative transit time between two
//      sequences.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetSummaryJitter(minJitter *uint32, maxJitter *uint32, meanJitter *uint32, devJitter *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint32       // out
	var _arg3 *C.guint32       // out
	var _arg4 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(minJitter))
	_arg2 = (*C.guint32)(unsafe.Pointer(maxJitter))
	_arg3 = (*C.guint32)(unsafe.Pointer(meanJitter))
	_arg4 = (*C.guint32)(unsafe.Pointer(devJitter))

	_cret = C.gst_rtcp_packet_xr_get_summary_jitter(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(minJitter)
	runtime.KeepAlive(maxJitter)
	runtime.KeepAlive(meanJitter)
	runtime.KeepAlive(devJitter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetSummaryPkt: get the number of lost or duplicate packets. If the flag in
// a block header is set as zero, lost_packets or dup_packets will be zero.
//
// The function takes the following parameters:
//
//    - lostPackets: number of lost packets between begin_seq and end_seq.
//    - dupPackets: number of duplicate packets between begin_seq and end_seq.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetSummaryPkt(lostPackets *uint32, dupPackets *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(lostPackets))
	_arg2 = (*C.guint32)(unsafe.Pointer(dupPackets))

	_cret = C.gst_rtcp_packet_xr_get_summary_pkt(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(lostPackets)
	runtime.KeepAlive(dupPackets)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - burstDensity: fraction of RTP data packets within burst periods.
//    - gapDensity: fraction of RTP data packets within inter-burst gaps.
//    - burstDuration: mean duration(ms) of the burst periods.
//    - gapDuration: mean duration(ms) of the gap periods.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipBurstMetrics(burstDensity *byte, gapDensity *byte, burstDuration *uint16, gapDuration *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint16       // out
	var _arg4 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(burstDensity))
	_arg2 = (*C.guint8)(unsafe.Pointer(gapDensity))
	_arg3 = (*C.guint16)(unsafe.Pointer(burstDuration))
	_arg4 = (*C.guint16)(unsafe.Pointer(gapDuration))

	_cret = C.gst_rtcp_packet_xr_get_voip_burst_metrics(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(burstDensity)
	runtime.KeepAlive(gapDensity)
	runtime.KeepAlive(burstDuration)
	runtime.KeepAlive(gapDuration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - gmin: gap threshold.
//    - rxConfig: receiver configuration byte.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipConfigurationParams(gmin *byte, rxConfig *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(gmin))
	_arg2 = (*C.guint8)(unsafe.Pointer(rxConfig))

	_cret = C.gst_rtcp_packet_xr_get_voip_configuration_params(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(gmin)
	runtime.KeepAlive(rxConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - roundtripDelay: most recently calculated round trip time between RTP
//      interfaces(ms).
//    - endSystemDelay: most recently estimated end system delay(ms).
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipDelayMetrics(roundtripDelay *uint16, endSystemDelay *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint16       // out
	var _arg2 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint16)(unsafe.Pointer(roundtripDelay))
	_arg2 = (*C.guint16)(unsafe.Pointer(endSystemDelay))

	_cret = C.gst_rtcp_packet_xr_get_voip_delay_metrics(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(roundtripDelay)
	runtime.KeepAlive(endSystemDelay)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - jbNominal: current nominal jitter buffer delay(ms).
//    - jbMaximum: current maximum jitter buffer delay(ms).
//    - jbAbsMax: absolute maximum delay(ms).
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipJitterBufferParams(jbNominal *uint16, jbMaximum *uint16, jbAbsMax *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint16       // out
	var _arg2 *C.guint16       // out
	var _arg3 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint16)(unsafe.Pointer(jbNominal))
	_arg2 = (*C.guint16)(unsafe.Pointer(jbMaximum))
	_arg3 = (*C.guint16)(unsafe.Pointer(jbAbsMax))

	_cret = C.gst_rtcp_packet_xr_get_voip_jitter_buffer_params(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(jbNominal)
	runtime.KeepAlive(jbMaximum)
	runtime.KeepAlive(jbAbsMax)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - ssrc: SSRC of source.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipMetricsSsrc(ssrc *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))

	_cret = C.gst_rtcp_packet_xr_get_voip_metrics_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - lossRate: fraction of RTP data packets from the source lost.
//    - discardRate: fraction of RTP data packets from the source that have been
//      discarded.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipPacketMetrics(lossRate *byte, discardRate *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(lossRate))
	_arg2 = (*C.guint8)(unsafe.Pointer(discardRate))

	_cret = C.gst_rtcp_packet_xr_get_voip_packet_metrics(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(lossRate)
	runtime.KeepAlive(discardRate)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - rFactor: r factor is a voice quality metric describing the segment of the
//      call.
//    - extRFactor: external R factor is a voice quality metric.
//    - mosLq: estimated mean opinion score for listening quality.
//    - mosCq: estimated mean opinion score for conversational quality.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipQualityMetrics(rFactor *byte, extRFactor *byte, mosLq *byte, mosCq *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint8        // out
	var _arg4 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(rFactor))
	_arg2 = (*C.guint8)(unsafe.Pointer(extRFactor))
	_arg3 = (*C.guint8)(unsafe.Pointer(mosLq))
	_arg4 = (*C.guint8)(unsafe.Pointer(mosCq))

	_cret = C.gst_rtcp_packet_xr_get_voip_quality_metrics(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(rFactor)
	runtime.KeepAlive(extRFactor)
	runtime.KeepAlive(mosLq)
	runtime.KeepAlive(mosCq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - signalLevel: ratio of the signal level to a 0 dBm reference.
//    - noiseLevel: ratio of the silent period background noise level to a 0 dBm
//      reference.
//    - rerl: residual echo return loss value.
//    - gmin: gap threshold.
//
// The function returns the following values:
//
//    - ok: TRUE if the report block is correctly parsed.
//
func (packet *RTCPPacket) XRGetVoipSignalMetrics(signalLevel *byte, noiseLevel *byte, rerl *byte, gmin *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint8        // out
	var _arg4 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(signalLevel))
	_arg2 = (*C.guint8)(unsafe.Pointer(noiseLevel))
	_arg3 = (*C.guint8)(unsafe.Pointer(rerl))
	_arg4 = (*C.guint8)(unsafe.Pointer(gmin))

	_cret = C.gst_rtcp_packet_xr_get_voip_signal_metrics(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(signalLevel)
	runtime.KeepAlive(noiseLevel)
	runtime.KeepAlive(rerl)
	runtime.KeepAlive(gmin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRNextRb: move to the next extended report block in XR packet.
//
// The function returns the following values:
//
//    - ok: TRUE if there was a next extended report block.
//
func (packet *RTCPPacket) XRNextRb() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_next_rb(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
