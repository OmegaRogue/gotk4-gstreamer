// Code generated by girgen. DO NOT EDIT.

package gstrtp

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/rtp/rtp.h>
// extern void _gotk4_gstrtp1_RTPBasePayload_ConnectClearExtensions(gpointer, guintptr);
// extern void _gotk4_gstrtp1_RTPBasePayload_ConnectAddExtension(gpointer, GstRTPHeaderExtension*, guintptr);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_src_event(GstRTPBasePayload*, GstEvent*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_sink_event(GstRTPBasePayload*, GstEvent*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_set_caps(GstRTPBasePayload*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_query(GstRTPBasePayload*, GstPad*, GstQuery*);
// extern GstRTPHeaderExtension* _gotk4_gstrtp1_RTPBasePayload_ConnectRequestExtension(gpointer, guint, gchar*, guintptr);
// extern GstFlowReturn _gotk4_gstrtp1_RTPBasePayloadClass_handle_buffer(GstRTPBasePayload*, GstBuffer*);
// extern GstCaps* _gotk4_gstrtp1_RTPBasePayloadClass_get_caps(GstRTPBasePayload*, GstPad*, GstCaps*);
// GstCaps* _gotk4_gstrtp1_RTPBasePayload_virtual_get_caps(void* fnptr, GstRTPBasePayload* arg0, GstPad* arg1, GstCaps* arg2) {
//   return ((GstCaps* (*)(GstRTPBasePayload*, GstPad*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gstrtp1_RTPBasePayload_virtual_handle_buffer(void* fnptr, GstRTPBasePayload* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstRTPBasePayload*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_query(void* fnptr, GstRTPBasePayload* arg0, GstPad* arg1, GstQuery* arg2) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstPad*, GstQuery*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_set_caps(void* fnptr, GstRTPBasePayload* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_sink_event(void* fnptr, GstRTPBasePayload* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_src_event(void* fnptr, GstRTPBasePayload* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstEvent*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeRTPBasePayload = coreglib.Type(C.gst_rtp_base_payload_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRTPBasePayload, F: marshalRTPBasePayload},
	})
}

// RTPBasePayloadOverrides contains methods that are overridable.
type RTPBasePayloadOverrides struct {
	// The function takes the following parameters:
	//
	//    - pad
	//    - filter
	//
	// The function returns the following values:
	//
	Caps func(pad *gst.Pad, filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	HandleBuffer func(buffer *gst.Buffer) gst.FlowReturn
	// The function takes the following parameters:
	//
	//    - pad
	//    - query
	//
	// The function returns the following values:
	//
	Query func(pad *gst.Pad, query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetCaps func(caps *gst.Caps) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
}

func defaultRTPBasePayloadOverrides(v *RTPBasePayload) RTPBasePayloadOverrides {
	return RTPBasePayloadOverrides{
		Caps:         v.caps,
		HandleBuffer: v.handleBuffer,
		Query:        v.query,
		SetCaps:      v.setCaps,
		SinkEvent:    v.sinkEvent,
		SrcEvent:     v.srcEvent,
	}
}

// RTPBasePayload provides a base class for RTP payloaders.
type RTPBasePayload struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*RTPBasePayload)(nil)
)

// RTPBasePayloader describes types inherited from class RTPBasePayload.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RTPBasePayloader interface {
	coreglib.Objector
	baseRTPBasePayload() *RTPBasePayload
}

var _ RTPBasePayloader = (*RTPBasePayload)(nil)

func init() {
	coreglib.RegisterClassInfo[*RTPBasePayload, *RTPBasePayloadClass, RTPBasePayloadOverrides](
		GTypeRTPBasePayload,
		initRTPBasePayloadClass,
		wrapRTPBasePayload,
		defaultRTPBasePayloadOverrides,
	)
}

func initRTPBasePayloadClass(gclass unsafe.Pointer, overrides RTPBasePayloadOverrides, classInitFunc func(*RTPBasePayloadClass)) {
	pclass := (*C.GstRTPBasePayloadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRTPBasePayload))))

	if overrides.Caps != nil {
		pclass.get_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_get_caps)
	}

	if overrides.HandleBuffer != nil {
		pclass.handle_buffer = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_handle_buffer)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_query)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_set_caps)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_sink_event)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_src_event)
	}

	if classInitFunc != nil {
		class := (*RTPBasePayloadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPBasePayload(obj *coreglib.Object) *RTPBasePayload {
	return &RTPBasePayload{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalRTPBasePayload(p uintptr) (interface{}, error) {
	return wrapRTPBasePayload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (payload *RTPBasePayload) baseRTPBasePayload() *RTPBasePayload {
	return payload
}

// BaseRTPBasePayload returns the underlying base object.
func BaseRTPBasePayload(obj RTPBasePayloader) *RTPBasePayload {
	return obj.baseRTPBasePayload()
}

// ConnectAddExtension: add ext as an extension for writing part of an RTP
// header extension onto outgoing RTP packets.
func (payload *RTPBasePayload) ConnectAddExtension(f func(ext RTPHeaderExtensioner)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(payload, "add-extension", false, unsafe.Pointer(C._gotk4_gstrtp1_RTPBasePayload_ConnectAddExtension), f)
}

// ConnectClearExtensions: clear all RTP header extensions used by this
// payloader.
func (payload *RTPBasePayload) ConnectClearExtensions(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(payload, "clear-extensions", false, unsafe.Pointer(C._gotk4_gstrtp1_RTPBasePayload_ConnectClearExtensions), f)
}

// ConnectRequestExtension: returned ext must be configured with the correct
// ext_id and with the necessary attributes as required by the extension
// implementation.
func (payload *RTPBasePayload) ConnectRequestExtension(f func(extId uint, extUri string) (rtpHeaderExtension RTPHeaderExtensioner)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(payload, "request-extension", false, unsafe.Pointer(C._gotk4_gstrtp1_RTPBasePayload_ConnectRequestExtension), f)
}

// AllocateOutputBuffer: allocate a new Buffer with enough data to hold an RTP
// packet with minimum csrc_count CSRCs, a payload length of payload_len and
// padding of pad_len. If payload has RTPBasePayload:source-info TRUE additional
// CSRCs may be allocated and filled with RTP source information.
//
// The function takes the following parameters:
//
//    - payloadLen: length of the payload.
//    - padLen: amount of padding.
//    - csrcCount: minimum number of CSRC entries.
//
// The function returns the following values:
//
//    - buffer: newly allocated buffer that can hold an RTP packet with given
//      parameters.
//
func (payload *RTPBasePayload) AllocateOutputBuffer(payloadLen uint, padLen, csrcCount byte) *gst.Buffer {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 C.guint              // out
	var _arg2 C.guint8             // out
	var _arg3 C.guint8             // out
	var _cret *C.GstBuffer         // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = C.guint(payloadLen)
	_arg2 = C.guint8(padLen)
	_arg3 = C.guint8(csrcCount)

	_cret = C.gst_rtp_base_payload_allocate_output_buffer(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// SourceCount: count the total number of RTP sources found in the meta of
// buffer, which will be automically added by
// gst_rtp_base_payload_allocate_output_buffer(). If RTPBasePayload:source-info
// is FALSE the count will be 0.
//
// The function takes the following parameters:
//
//    - buffer typically the buffer to payload.
//
// The function returns the following values:
//
//    - guint: number of sources.
//
func (payload *RTPBasePayload) SourceCount(buffer *gst.Buffer) uint {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBuffer         // out
	var _cret C.guint              // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtp_base_payload_get_source_count(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsFilled: check if the packet with size and duration would exceed the
// configured maximum size.
//
// The function takes the following parameters:
//
//    - size of the packet.
//    - duration of the packet.
//
// The function returns the following values:
//
//    - ok: TRUE if the packet of size and duration would exceed the configured
//      MTU or max_ptime.
//
func (payload *RTPBasePayload) IsFilled(size uint, duration gst.ClockTime) bool {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 C.guint              // out
	var _arg2 C.GstClockTime       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = C.guint(size)
	_arg2 = C.guint64(duration)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_rtp_base_payload_is_filled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(size)
	runtime.KeepAlive(duration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSourceInfoEnabled queries whether the payloader will add contributing
// sources (CSRCs) to the RTP header from RTPSourceMeta.
//
// The function returns the following values:
//
//    - ok: TRUE if source-info is enabled.
//
func (payload *RTPBasePayload) IsSourceInfoEnabled() bool {
	var _arg0 *C.GstRTPBasePayload // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))

	_cret = C.gst_rtp_base_payload_is_source_info_enabled(_arg0)
	runtime.KeepAlive(payload)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Push buffer to the peer element of the payloader. The SSRC, payload type,
// seqnum and timestamp of the RTP buffer will be updated first.
//
// This function takes ownership of buffer.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (payload *RTPBasePayload) Push(buffer *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBuffer         // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_rtp_base_payload_push(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushList: push list to the peer element of the payloader. The SSRC, payload
// type, seqnum and timestamp of the RTP buffer will be updated first.
//
// This function takes ownership of list.
//
// The function takes the following parameters:
//
//    - list: BufferList.
//
// The function returns the following values:
//
//    - flowReturn: FlowReturn.
//
func (payload *RTPBasePayload) PushList(list *gst.BufferList) gst.FlowReturn {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBufferList     // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_rtp_base_payload_push_list(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(list)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetOptions: set the rtp options of the payloader. These options will be set
// in the caps of the payloader. Subclasses must call this method before calling
// gst_rtp_base_payload_push() or gst_rtp_base_payload_set_outcaps().
//
// The function takes the following parameters:
//
//    - media type (typically "audio" or "video").
//    - dynamic: if the payload type is dynamic.
//    - encodingName: encoding name.
//    - clockRate: clock rate of the media.
//
func (payload *RTPBasePayload) SetOptions(media string, dynamic bool, encodingName string, clockRate uint32) {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gboolean           // out
	var _arg3 *C.gchar             // out
	var _arg4 C.guint32            // out

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(media)))
	defer C.free(unsafe.Pointer(_arg1))
	if dynamic {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(encodingName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.guint32(clockRate)

	C.gst_rtp_base_payload_set_options(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(media)
	runtime.KeepAlive(dynamic)
	runtime.KeepAlive(encodingName)
	runtime.KeepAlive(clockRate)
}

// SetOutcapsStructure: configure the output caps with the optional fields.
//
// The function takes the following parameters:
//
//    - s (optional) with the caps fields.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps could be set.
//
func (payload *RTPBasePayload) SetOutcapsStructure(s *gst.Structure) bool {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstStructure      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	if s != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(s)))
	}

	_cret = C.gst_rtp_base_payload_set_outcaps_structure(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(s)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSourceInfoEnabled: enable or disable adding contributing sources to RTP
// packets from RTPSourceMeta.
//
// The function takes the following parameters:
//
//    - enable: whether to add contributing sources to RTP packets.
//
func (payload *RTPBasePayload) SetSourceInfoEnabled(enable bool) {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gst_rtp_base_payload_set_source_info_enabled(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(enable)
}

// The function takes the following parameters:
//
//    - pad
//    - filter
//
// The function returns the following values:
//
func (payload *RTPBasePayload) caps(pad *gst.Pad, filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.get_caps

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstPad            // out
	var _arg2 *C.GstCaps           // out
	var _cret *C.GstCaps           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_get_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (payload *RTPBasePayload) handleBuffer(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.handle_buffer

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBuffer         // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_handle_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
//    - pad
//    - query
//
// The function returns the following values:
//
func (payload *RTPBasePayload) query(pad *gst.Pad, query *gst.Query) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.query

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstPad            // out
	var _arg2 *C.GstQuery          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (payload *RTPBasePayload) setCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.set_caps

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (payload *RTPBasePayload) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.sink_event

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstEvent          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (payload *RTPBasePayload) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.src_event

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstEvent          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.InternObject(payload).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTPBasePayloadClass: base class for audio RTP payloader.
//
// An instance of this type is always passed by reference.
type RTPBasePayloadClass struct {
	*rtpBasePayloadClass
}

// rtpBasePayloadClass is the struct that's finalized.
type rtpBasePayloadClass struct {
	native *C.GstRTPBasePayloadClass
}

// ParentClass: parent class.
func (r *RTPBasePayloadClass) ParentClass() *gst.ElementClass {
	valptr := &r.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
