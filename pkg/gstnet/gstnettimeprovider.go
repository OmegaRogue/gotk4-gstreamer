// Code generated by girgen. DO NOT EDIT.

package gstnet

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/net/net.h>
import "C"

// GType values.
var (
	GTypeNetTimeProvider = coreglib.Type(C.gst_net_time_provider_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNetTimeProvider, F: marshalNetTimeProvider},
	})
}

// NetTimeProviderOverrides contains methods that are overridable.
type NetTimeProviderOverrides struct {
}

func defaultNetTimeProviderOverrides(v *NetTimeProvider) NetTimeProviderOverrides {
	return NetTimeProviderOverrides{}
}

// NetTimeProvider: this object exposes the time of a Clock on the network.
//
// A NetTimeProvider is created with gst_net_time_provider_new() which takes a
// Clock, an address and a port number as arguments.
//
// After creating the object, a client clock such as NetClientClock can query
// the exposed clock over the network for its values.
//
// The NetTimeProvider typically wraps the clock used by a Pipeline.
type NetTimeProvider struct {
	_ [0]func() // equal guard
	gst.GstObject

	gio.Initable
}

var (
	_ gst.GstObjector = (*NetTimeProvider)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NetTimeProvider, *NetTimeProviderClass, NetTimeProviderOverrides](
		GTypeNetTimeProvider,
		initNetTimeProviderClass,
		wrapNetTimeProvider,
		defaultNetTimeProviderOverrides,
	)
}

func initNetTimeProviderClass(gclass unsafe.Pointer, overrides NetTimeProviderOverrides, classInitFunc func(*NetTimeProviderClass)) {
	if classInitFunc != nil {
		class := (*NetTimeProviderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetTimeProvider(obj *coreglib.Object) *NetTimeProvider {
	return &NetTimeProvider{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalNetTimeProvider(p uintptr) (interface{}, error) {
	return wrapNetTimeProvider(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNetTimeProvider allows network clients to get the current time of clock.
//
// The function takes the following parameters:
//
//    - clock to export over the network.
//    - address (optional) to bind on as a dotted quad (xxx.xxx.xxx.xxx), IPv6
//      address, or NULL to bind to all addresses.
//    - port to bind on, or 0 to let the kernel choose.
//
// The function returns the following values:
//
//    - netTimeProvider: new NetTimeProvider, or NULL on error.
//
func NewNetTimeProvider(clock gst.Clocker, address string, port int) *NetTimeProvider {
	var _arg1 *C.GstClock           // out
	var _arg2 *C.gchar              // out
	var _arg3 C.gint                // out
	var _cret *C.GstNetTimeProvider // in

	_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if address != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.gint(port)

	_cret = C.gst_net_time_provider_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var _netTimeProvider *NetTimeProvider // out

	_netTimeProvider = wrapNetTimeProvider(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _netTimeProvider
}

// NetTimeProviderClass: instance of this type is always passed by reference.
type NetTimeProviderClass struct {
	*netTimeProviderClass
}

// netTimeProviderClass is the struct that's finalized.
type netTimeProviderClass struct {
	native *C.GstNetTimeProviderClass
}

func (n *NetTimeProviderClass) ParentClass() *gst.ObjectClass {
	valptr := &n.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (n *NetTimeProviderClass) GstReserved() [4]unsafe.Pointer {
	valptr := &n.native._gst_reserved
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
