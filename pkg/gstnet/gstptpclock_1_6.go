// Code generated by girgen. DO NOT EDIT.

package gstnet

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/net/net.h>
// extern void callbackDelete(gpointer);
// extern gboolean _gotk4_gstnet1_PtpStatisticsCallback(guint8, GstStructure*, gpointer);
import "C"

// GType values.
var (
	GTypePtpClock = coreglib.Type(C.gst_ptp_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePtpClock, F: marshalPtpClock},
	})
}

// PtpDeinit: deinitialize the GStreamer PTP subsystem and stop the PTP clock.
// If there are any remaining GstPtpClock instances, they won't be further
// synchronized to the PTP network clock.
func PtpDeinit() {
	C.gst_ptp_deinit()
}

// PtpInit: initialize the GStreamer PTP subsystem and create a PTP ordinary
// clock in slave-only mode for all domains on the given interfaces with the
// given clock_id.
//
// If clock_id is GST_PTP_CLOCK_ID_NONE, a clock id is automatically generated
// from the MAC address of the first network interface.
//
// This function is automatically called by gst_ptp_clock_new() with default
// parameters if it wasn't called before.
//
// The function takes the following parameters:
//
//    - clockId: PTP clock id of this process' clock or GST_PTP_CLOCK_ID_NONE.
//    - interfaces (optional): network interfaces to run the clock on.
//
// The function returns the following values:
//
//    - ok: TRUE if the GStreamer PTP clock subsystem could be initialized.
//
func PtpInit(clockId uint64, interfaces []string) bool {
	var _arg1 C.guint64  // out
	var _arg2 **C.gchar  // out
	var _cret C.gboolean // in

	_arg1 = C.guint64(clockId)
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(interfaces) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(interfaces)+1)
			var zero *C.gchar
			out[len(interfaces)] = zero
			for i := range interfaces {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(interfaces[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_ptp_init(_arg1, _arg2)
	runtime.KeepAlive(clockId)
	runtime.KeepAlive(interfaces)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpIsInitialized: check if the GStreamer PTP clock subsystem is initialized.
//
// The function returns the following values:
//
//    - ok: TRUE if the GStreamer PTP clock subsystem is initialized.
//
func PtpIsInitialized() bool {
	var _cret C.gboolean // in

	_cret = C.gst_ptp_is_initialized()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpIsSupported: check if PTP clocks are generally supported on this system,
// and if previous initializations did not fail.
//
// The function returns the following values:
//
//    - ok: TRUE if PTP clocks are generally supported on this system, and
//      previous initializations did not fail.
//
func PtpIsSupported() bool {
	var _cret C.gboolean // in

	_cret = C.gst_ptp_is_supported()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpStatisticsCallbackAdd installs a new statistics callback for gathering PTP
// statistics. See GstPtpStatisticsCallback for a list of statistics that are
// provided.
//
// The function takes the following parameters:
//
//    - callback: gstPtpStatisticsCallback to call.
//
// The function returns the following values:
//
//    - gulong: id for the callback that can be passed to
//      gst_ptp_statistics_callback_remove().
//
func PtpStatisticsCallbackAdd(callback PtpStatisticsCallback) uint32 {
	var _arg1 C.GstPtpStatisticsCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.gulong // in

	_arg1 = (*[0]byte)(C._gotk4_gstnet1_PtpStatisticsCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_ptp_statistics_callback_add(_arg1, _arg2, _arg3)
	runtime.KeepAlive(callback)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// PtpStatisticsCallbackRemove removes a PTP statistics callback that was
// previously added with gst_ptp_statistics_callback_add().
//
// The function takes the following parameters:
//
//    - id: callback id to remove.
//
func PtpStatisticsCallbackRemove(id uint32) {
	var _arg1 C.gulong // out

	_arg1 = C.gulong(id)

	C.gst_ptp_statistics_callback_remove(_arg1)
	runtime.KeepAlive(id)
}

// PtpClockOverrides contains methods that are overridable.
type PtpClockOverrides struct {
}

func defaultPtpClockOverrides(v *PtpClock) PtpClockOverrides {
	return PtpClockOverrides{}
}

// PtpClock implements a PTP (IEEE1588:2008) ordinary clock in slave-only mode,
// that allows a GStreamer pipeline to synchronize to a PTP network clock in
// some specific domain.
//
// The PTP subsystem can be initialized with gst_ptp_init(), which then starts a
// helper process to do the actual communication via the PTP ports. This is
// required as PTP listens on ports < 1024 and thus requires special privileges.
// Once this helper process is started, the main process will synchronize to all
// PTP domains that are detected on the selected interfaces.
//
// gst_ptp_clock_new() then allows to create a GstClock that provides the PTP
// time from a master clock inside a specific PTP domain. This clock will only
// return valid timestamps once the timestamps in the PTP domain are known. To
// check this, you can use gst_clock_wait_for_sync(), the GstClock::synced
// signal and gst_clock_is_synced().
//
// To gather statistics about the PTP clock synchronization,
// gst_ptp_statistics_callback_add() can be used. This gives the application the
// possibility to collect all kinds of statistics from the clock
// synchronization.
type PtpClock struct {
	_ [0]func() // equal guard
	gst.SystemClock
}

var (
	_ gst.Clocker = (*PtpClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*PtpClock, *PtpClockClass, PtpClockOverrides](
		GTypePtpClock,
		initPtpClockClass,
		wrapPtpClock,
		defaultPtpClockOverrides,
	)
}

func initPtpClockClass(gclass unsafe.Pointer, overrides PtpClockOverrides, classInitFunc func(*PtpClockClass)) {
	if classInitFunc != nil {
		class := (*PtpClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPtpClock(obj *coreglib.Object) *PtpClock {
	return &PtpClock{
		SystemClock: gst.SystemClock{
			Clock: gst.Clock{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalPtpClock(p uintptr) (interface{}, error) {
	return wrapPtpClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPtpClock creates a new PTP clock instance that exports the PTP time of the
// master clock in domain. This clock can be slaved to other clocks as needed.
//
// If gst_ptp_init() was not called before, this will call gst_ptp_init() with
// default parameters.
//
// This clock only returns valid timestamps after it received the first times
// from the PTP master clock on the network. Once this happens the
// GstPtpClock::internal-clock property will become non-NULL. You can check this
// with gst_clock_wait_for_sync(), the GstClock::synced signal and
// gst_clock_is_synced().
//
// The function takes the following parameters:
//
//    - name: name of the clock.
//    - domain: PTP domain.
//
// The function returns the following values:
//
//    - ptpClock: new Clock.
//
func NewPtpClock(name string, domain uint) *PtpClock {
	var _arg1 *C.gchar    // out
	var _arg2 C.guint     // out
	var _cret *C.GstClock // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(domain)

	_cret = C.gst_ptp_clock_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(domain)

	var _ptpClock *PtpClock // out

	_ptpClock = wrapPtpClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ptpClock
}
