// Code generated by girgen. DO NOT EDIT.

package gstnet

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/net/net.h>
import "C"

// BufferAddNetControlMessageMeta attaches message as metadata in a
// NetControlMessageMeta to buffer.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - message: GSocketControlMessage to attach to buffer.
//
// The function returns the following values:
//
//    - netControlMessageMeta connected to buffer.
//
func BufferAddNetControlMessageMeta(buffer *gst.Buffer, message gio.SocketControlMessager) *NetControlMessageMeta {
	var _arg1 *C.GstBuffer                // out
	var _arg2 *C.GSocketControlMessage    // out
	var _cret *C.GstNetControlMessageMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.InternObject(message).Native()))

	_cret = C.gst_buffer_add_net_control_message_meta(_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(message)

	var _netControlMessageMeta *NetControlMessageMeta // out

	_netControlMessageMeta = (*NetControlMessageMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _netControlMessageMeta
}

// The function returns the following values:
//
func NetControlMessageMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_net_control_message_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// NetControlMessageMeta can be used to store control messages (ancillary data)
// which was received with or is to be sent alongside the buffer data. When used
// with socket sinks and sources which understand this meta it allows sending
// and receiving ancillary data such as unix credentials (See
// CredentialsMessage) and Unix file descriptions (See FDMessage).
//
// An instance of this type is always passed by reference.
type NetControlMessageMeta struct {
	*netControlMessageMeta
}

// netControlMessageMeta is the struct that's finalized.
type netControlMessageMeta struct {
	native *C.GstNetControlMessageMeta
}

// Meta: parent type.
func (n *NetControlMessageMeta) Meta() *gst.Meta {
	valptr := &n.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Message stored as metadata.
func (n *NetControlMessageMeta) Message() gio.SocketControlMessager {
	valptr := &n.native.message
	var _v gio.SocketControlMessager // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gio.SocketControlMessager is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.SocketControlMessager)
			return ok
		})
		rv, ok := casted.(gio.SocketControlMessager)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketControlMessager")
		}
		_v = rv
	}
	return _v
}

// The function returns the following values:
//
func NetControlMessageMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_net_control_message_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}
