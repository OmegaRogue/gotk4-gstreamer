// Code generated by girgen. DO NOT EDIT.

package gstnet

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/net/net.h>
import "C"

// GType values.
var (
	GTypeNetClientClock = coreglib.Type(C.gst_net_client_clock_get_type())
	GTypeNtpClock       = coreglib.Type(C.gst_ntp_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNetClientClock, F: marshalNetClientClock},
		coreglib.TypeMarshaler{T: GTypeNtpClock, F: marshalNtpClock},
	})
}

// NetClientClockOverrides contains methods that are overridable.
type NetClientClockOverrides struct {
}

func defaultNetClientClockOverrides(v *NetClientClock) NetClientClockOverrides {
	return NetClientClockOverrides{}
}

// NetClientClock implements a custom Clock that synchronizes its time to a
// remote time provider such as NetTimeProvider. NtpClock implements a Clock
// that synchronizes its time to a remote NTPv4 server.
//
// A new clock is created with gst_net_client_clock_new() or
// gst_ntp_clock_new(), which takes the address and port of the remote time
// provider along with a name and an initial time.
//
// This clock will poll the time provider and will update its calibration
// parameters based on the local and remote observations.
//
// The "round-trip" property limits the maximum round trip packets can take.
//
// Various parameters of the clock can be configured with the parent Clock
// "timeout", "window-size" and "window-threshold" object properties.
//
// A NetClientClock and NtpClock is typically set on a Pipeline with
// gst_pipeline_use_clock().
//
// If you set a Bus on the clock via the "bus" object property, it will send
// GST_MESSAGE_ELEMENT messages with an attached Structure containing statistics
// about clock accuracy and network traffic.
type NetClientClock struct {
	_ [0]func() // equal guard
	gst.SystemClock
}

var (
	_ gst.Clocker = (*NetClientClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NetClientClock, *NetClientClockClass, NetClientClockOverrides](
		GTypeNetClientClock,
		initNetClientClockClass,
		wrapNetClientClock,
		defaultNetClientClockOverrides,
	)
}

func initNetClientClockClass(gclass unsafe.Pointer, overrides NetClientClockOverrides, classInitFunc func(*NetClientClockClass)) {
	if classInitFunc != nil {
		class := (*NetClientClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetClientClock(obj *coreglib.Object) *NetClientClock {
	return &NetClientClock{
		SystemClock: gst.SystemClock{
			Clock: gst.Clock{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalNetClientClock(p uintptr) (interface{}, error) {
	return wrapNetClientClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNetClientClock: create a new NetClientClock that will report the time
// provided by the NetTimeProvider on remote_address and remote_port.
//
// The function takes the following parameters:
//
//    - name for the clock.
//    - remoteAddress address or hostname of the remote clock provider.
//    - remotePort: port of the remote clock provider.
//    - baseTime: initial time of the clock.
//
// The function returns the following values:
//
//    - netClientClock: new Clock that receives a time from the remote clock.
//
func NewNetClientClock(name, remoteAddress string, remotePort int, baseTime gst.ClockTime) *NetClientClock {
	var _arg1 *C.gchar       // out
	var _arg2 *C.gchar       // out
	var _arg3 C.gint         // out
	var _arg4 C.GstClockTime // out
	var _cret *C.GstClock    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(remoteAddress)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(remotePort)
	_arg4 = C.guint64(baseTime)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_net_client_clock_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(remoteAddress)
	runtime.KeepAlive(remotePort)
	runtime.KeepAlive(baseTime)

	var _netClientClock *NetClientClock // out

	_netClientClock = wrapNetClientClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _netClientClock
}

// NtpClockOverrides contains methods that are overridable.
type NtpClockOverrides struct {
}

func defaultNtpClockOverrides(v *NtpClock) NtpClockOverrides {
	return NtpClockOverrides{}
}

type NtpClock struct {
	_ [0]func() // equal guard
	NetClientClock
}

var (
	_ gst.Clocker = (*NtpClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NtpClock, *NtpClockClass, NtpClockOverrides](
		GTypeNtpClock,
		initNtpClockClass,
		wrapNtpClock,
		defaultNtpClockOverrides,
	)
}

func initNtpClockClass(gclass unsafe.Pointer, overrides NtpClockOverrides, classInitFunc func(*NtpClockClass)) {
	if classInitFunc != nil {
		class := (*NtpClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNtpClock(obj *coreglib.Object) *NtpClock {
	return &NtpClock{
		NetClientClock: NetClientClock{
			SystemClock: gst.SystemClock{
				Clock: gst.Clock{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalNtpClock(p uintptr) (interface{}, error) {
	return wrapNtpClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNtpClock: create a new NtpClock that will report the time provided by the
// NTPv4 server on remote_address and remote_port.
//
// The function takes the following parameters:
//
//    - name for the clock.
//    - remoteAddress address or hostname of the remote clock provider.
//    - remotePort: port of the remote clock provider.
//    - baseTime: initial time of the clock.
//
// The function returns the following values:
//
//    - ntpClock: new Clock that receives a time from the remote clock.
//
func NewNtpClock(name, remoteAddress string, remotePort int, baseTime gst.ClockTime) *NtpClock {
	var _arg1 *C.gchar       // out
	var _arg2 *C.gchar       // out
	var _arg3 C.gint         // out
	var _arg4 C.GstClockTime // out
	var _cret *C.GstClock    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(remoteAddress)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(remotePort)
	_arg4 = C.guint64(baseTime)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_ntp_clock_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(remoteAddress)
	runtime.KeepAlive(remotePort)
	runtime.KeepAlive(baseTime)

	var _ntpClock *NtpClock // out

	_ntpClock = wrapNtpClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ntpClock
}

// NetClientClockClass: instance of this type is always passed by reference.
type NetClientClockClass struct {
	*netClientClockClass
}

// netClientClockClass is the struct that's finalized.
type netClientClockClass struct {
	native *C.GstNetClientClockClass
}

func (n *NetClientClockClass) ParentClass() *gst.SystemClockClass {
	valptr := &n.native.parent_class
	var _v *gst.SystemClockClass // out
	_v = (*gst.SystemClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NtpClockClass: instance of this type is always passed by reference.
type NtpClockClass struct {
	*ntpClockClass
}

// ntpClockClass is the struct that's finalized.
type ntpClockClass struct {
	native *C.GstNtpClockClass
}

func (n *NtpClockClass) ParentClass() *gst.SystemClockClass {
	valptr := &n.native.parent_class
	var _v *gst.SystemClockClass // out
	_v = (*gst.SystemClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
