// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
import "C"

// GType values.
var (
	GTypeAudioChannelPosition = coreglib.Type(C.gst_audio_channel_position_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioChannelPosition, F: marshalAudioChannelPosition},
	})
}

// AudioChannelPosition: audio channel positions.
//
// These are the channels defined in SMPTE 2036-2-2008 Table 1 for 22.2 audio
// systems with the Surround and Wide channels from DTS Coherent Acoustics
// (v.1.3.1) and 10.2 and 7.1 layouts. In the caps the actual channel layout is
// expressed with a channel count and a channel mask, which describes the
// existing channels. The positions in the bit mask correspond to the enum
// values. For negotiation it is allowed to have more bits set in the channel
// mask than the number of channels to specify the allowed channel positions but
// this is not allowed in negotiated caps. It is not allowed in any situation
// other than the one mentioned below to have less bits set in the channel mask
// than the number of channels.
//
// GST_AUDIO_CHANNEL_POSITION_MONO can only be used with a single mono channel
// that has no direction information and would be mixed into all directional
// channels. This is expressed in caps by having a single channel and no channel
// mask.
//
// GST_AUDIO_CHANNEL_POSITION_NONE can only be used if all channels have this
// position. This is expressed in caps by having a channel mask with no bits
// set.
//
// As another special case it is allowed to have two channels without a channel
// mask. This implicitly means that this is a stereo stream with a front left
// and front right channel.
type AudioChannelPosition C.gint

const (
	// AudioChannelPositionNone: used for position-less channels, e.g. from a
	// sound card that records 1024 channels; mutually exclusive with any other
	// channel position.
	AudioChannelPositionNone AudioChannelPosition = -3
	// AudioChannelPositionMono: mono without direction; can only be used with 1
	// channel.
	AudioChannelPositionMono AudioChannelPosition = -2
	// AudioChannelPositionInvalid: invalid position.
	AudioChannelPositionInvalid AudioChannelPosition = -1
	// AudioChannelPositionFrontLeft: front left.
	AudioChannelPositionFrontLeft AudioChannelPosition = 0
	// AudioChannelPositionFrontRight: front right.
	AudioChannelPositionFrontRight AudioChannelPosition = 1
	// AudioChannelPositionFrontCenter: front center.
	AudioChannelPositionFrontCenter AudioChannelPosition = 2
	// AudioChannelPositionLfe1: low-frequency effects 1 (subwoofer).
	AudioChannelPositionLfe1 AudioChannelPosition = 3
	// AudioChannelPositionRearLeft: rear left.
	AudioChannelPositionRearLeft AudioChannelPosition = 4
	// AudioChannelPositionRearRight: rear right.
	AudioChannelPositionRearRight AudioChannelPosition = 5
	// AudioChannelPositionFrontLeftOfCenter: front left of center.
	AudioChannelPositionFrontLeftOfCenter AudioChannelPosition = 6
	// AudioChannelPositionFrontRightOfCenter: front right of center.
	AudioChannelPositionFrontRightOfCenter AudioChannelPosition = 7
	// AudioChannelPositionRearCenter: rear center.
	AudioChannelPositionRearCenter AudioChannelPosition = 8
	// AudioChannelPositionLfe2: low-frequency effects 2 (subwoofer).
	AudioChannelPositionLfe2 AudioChannelPosition = 9
	// AudioChannelPositionSideLeft: side left.
	AudioChannelPositionSideLeft AudioChannelPosition = 10
	// AudioChannelPositionSideRight: side right.
	AudioChannelPositionSideRight AudioChannelPosition = 11
	// AudioChannelPositionTopFrontLeft: top front left.
	AudioChannelPositionTopFrontLeft AudioChannelPosition = 12
	// AudioChannelPositionTopFrontRight: top front right.
	AudioChannelPositionTopFrontRight AudioChannelPosition = 13
	// AudioChannelPositionTopFrontCenter: top front center.
	AudioChannelPositionTopFrontCenter AudioChannelPosition = 14
	// AudioChannelPositionTopCenter: top center.
	AudioChannelPositionTopCenter AudioChannelPosition = 15
	// AudioChannelPositionTopRearLeft: top rear left.
	AudioChannelPositionTopRearLeft AudioChannelPosition = 16
	// AudioChannelPositionTopRearRight: top rear right.
	AudioChannelPositionTopRearRight AudioChannelPosition = 17
	// AudioChannelPositionTopSideLeft: top side right.
	AudioChannelPositionTopSideLeft AudioChannelPosition = 18
	// AudioChannelPositionTopSideRight: top rear right.
	AudioChannelPositionTopSideRight AudioChannelPosition = 19
	// AudioChannelPositionTopRearCenter: top rear center.
	AudioChannelPositionTopRearCenter AudioChannelPosition = 20
	// AudioChannelPositionBottomFrontCenter: bottom front center.
	AudioChannelPositionBottomFrontCenter AudioChannelPosition = 21
	// AudioChannelPositionBottomFrontLeft: bottom front left.
	AudioChannelPositionBottomFrontLeft AudioChannelPosition = 22
	// AudioChannelPositionBottomFrontRight: bottom front right.
	AudioChannelPositionBottomFrontRight AudioChannelPosition = 23
	// AudioChannelPositionWideLeft: wide left (between front left and side
	// left).
	AudioChannelPositionWideLeft AudioChannelPosition = 24
	// AudioChannelPositionWideRight: wide right (between front right and side
	// right).
	AudioChannelPositionWideRight AudioChannelPosition = 25
	// AudioChannelPositionSurroundLeft: surround left (between rear left and
	// side left).
	AudioChannelPositionSurroundLeft AudioChannelPosition = 26
	// AudioChannelPositionSurroundRight: surround right (between rear right and
	// side right).
	AudioChannelPositionSurroundRight AudioChannelPosition = 27
)

func marshalAudioChannelPosition(p uintptr) (interface{}, error) {
	return AudioChannelPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioChannelPosition.
func (a AudioChannelPosition) String() string {
	switch a {
	case AudioChannelPositionNone:
		return "None"
	case AudioChannelPositionMono:
		return "Mono"
	case AudioChannelPositionInvalid:
		return "Invalid"
	case AudioChannelPositionFrontLeft:
		return "FrontLeft"
	case AudioChannelPositionFrontRight:
		return "FrontRight"
	case AudioChannelPositionFrontCenter:
		return "FrontCenter"
	case AudioChannelPositionLfe1:
		return "Lfe1"
	case AudioChannelPositionRearLeft:
		return "RearLeft"
	case AudioChannelPositionRearRight:
		return "RearRight"
	case AudioChannelPositionFrontLeftOfCenter:
		return "FrontLeftOfCenter"
	case AudioChannelPositionFrontRightOfCenter:
		return "FrontRightOfCenter"
	case AudioChannelPositionRearCenter:
		return "RearCenter"
	case AudioChannelPositionLfe2:
		return "Lfe2"
	case AudioChannelPositionSideLeft:
		return "SideLeft"
	case AudioChannelPositionSideRight:
		return "SideRight"
	case AudioChannelPositionTopFrontLeft:
		return "TopFrontLeft"
	case AudioChannelPositionTopFrontRight:
		return "TopFrontRight"
	case AudioChannelPositionTopFrontCenter:
		return "TopFrontCenter"
	case AudioChannelPositionTopCenter:
		return "TopCenter"
	case AudioChannelPositionTopRearLeft:
		return "TopRearLeft"
	case AudioChannelPositionTopRearRight:
		return "TopRearRight"
	case AudioChannelPositionTopSideLeft:
		return "TopSideLeft"
	case AudioChannelPositionTopSideRight:
		return "TopSideRight"
	case AudioChannelPositionTopRearCenter:
		return "TopRearCenter"
	case AudioChannelPositionBottomFrontCenter:
		return "BottomFrontCenter"
	case AudioChannelPositionBottomFrontLeft:
		return "BottomFrontLeft"
	case AudioChannelPositionBottomFrontRight:
		return "BottomFrontRight"
	case AudioChannelPositionWideLeft:
		return "WideLeft"
	case AudioChannelPositionWideRight:
		return "WideRight"
	case AudioChannelPositionSurroundLeft:
		return "SurroundLeft"
	case AudioChannelPositionSurroundRight:
		return "SurroundRight"
	default:
		return fmt.Sprintf("AudioChannelPosition(%d)", a)
	}
}

// AudioChannelPositionsFromMask: convert the channels present in channel_mask
// to a position array (which should have at least channels entries ensured by
// caller). If channel_mask is set to 0, it is considered as 'not present' for
// purpose of conversion. A partially valid channel_mask with less bits set than
// the number of channels is considered valid.
//
// The function takes the following parameters:
//
//    - channelMask: input channel_mask.
//    - position: the GstAudioChannelPosition<!-- -->s.
//
// The function returns the following values:
//
//    - ok: TRUE if channel and channel mask are valid and could be converted.
//
func AudioChannelPositionsFromMask(channelMask uint64, position []AudioChannelPosition) bool {
	var _arg2 C.guint64                  // out
	var _arg3 *C.GstAudioChannelPosition // out
	var _arg1 C.gint
	var _cret C.gboolean // in

	_arg2 = C.guint64(channelMask)
	_arg1 = (C.gint)(len(position))
	if len(position) > 0 {
		_arg3 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&position[0]))
	}

	_cret = C.gst_audio_channel_positions_from_mask(_arg1, _arg2, _arg3)
	runtime.KeepAlive(channelMask)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioChannelPositionsToMask: convert the position array of channels channels
// to a bitmask.
//
// If force_order is TRUE it additionally checks if the channels are in the
// order required by GStreamer.
//
// The function takes the following parameters:
//
//    - position: GstAudioChannelPositions.
//    - forceOrder: only consider the GStreamer channel order.
//
// The function returns the following values:
//
//    - channelMask: output channel mask.
//    - ok: TRUE if the channel positions are valid and could be converted.
//
func AudioChannelPositionsToMask(position []AudioChannelPosition, forceOrder bool) (uint64, bool) {
	var _arg1 *C.GstAudioChannelPosition // out
	var _arg2 C.gint
	var _arg3 C.gboolean // out
	var _arg4 C.guint64  // in
	var _cret C.gboolean // in

	_arg2 = (C.gint)(len(position))
	if len(position) > 0 {
		_arg1 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&position[0]))
	}
	if forceOrder {
		_arg3 = C.TRUE
	}

	_cret = C.gst_audio_channel_positions_to_mask(_arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(position)
	runtime.KeepAlive(forceOrder)

	var _channelMask uint64 // out
	var _ok bool            // out

	_channelMask = uint64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _channelMask, _ok
}

// AudioChannelPositionsToValidOrder reorders the channel positions in position
// from any order to the GStreamer channel order.
//
// The function takes the following parameters:
//
//    - position: channel positions to reorder to.
//
// The function returns the following values:
//
//    - ok: TRUE if the channel positions are valid and reordering was
//      successful.
//
func AudioChannelPositionsToValidOrder(position []AudioChannelPosition) bool {
	var _arg1 *C.GstAudioChannelPosition // out
	var _arg2 C.gint
	var _cret C.gboolean // in

	_arg2 = (C.gint)(len(position))
	if len(position) > 0 {
		_arg1 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&position[0]))
	}

	_cret = C.gst_audio_channel_positions_to_valid_order(_arg1, _arg2)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioCheckValidChannelPositions checks if position contains valid channel
// positions for channels channels. If force_order is TRUE it additionally
// checks if the channels are in the order required by GStreamer.
//
// The function takes the following parameters:
//
//    - position: GstAudioChannelPositions to check.
//    - forceOrder: only consider the GStreamer channel order.
//
// The function returns the following values:
//
//    - ok: TRUE if the channel positions are valid.
//
func AudioCheckValidChannelPositions(position []AudioChannelPosition, forceOrder bool) bool {
	var _arg1 *C.GstAudioChannelPosition // out
	var _arg2 C.gint
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg2 = (C.gint)(len(position))
	if len(position) > 0 {
		_arg1 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&position[0]))
	}
	if forceOrder {
		_arg3 = C.TRUE
	}

	_cret = C.gst_audio_check_valid_channel_positions(_arg1, _arg2, _arg3)
	runtime.KeepAlive(position)
	runtime.KeepAlive(forceOrder)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioGetChannelReorderMap returns a reorder map for from to to that can be
// used in custom channel reordering code, e.g. to convert from or to the
// GStreamer channel order. from and to must contain the same number of
// positions and the same positions, only in a different order.
//
// The resulting reorder_map can be used for reordering by assigning channel i
// of the input to channel reorder_map[i] of the output.
//
// The function takes the following parameters:
//
//    - from: channel positions to reorder from.
//    - to: channel positions to reorder to.
//    - reorderMap: pointer to the reorder map.
//
// The function returns the following values:
//
//    - ok: TRUE if the channel positions are valid and reordering is possible.
//
func AudioGetChannelReorderMap(from, to []AudioChannelPosition, reorderMap []int) bool {
	var _arg2 *C.GstAudioChannelPosition // out
	var _arg1 C.gint
	var _arg3 *C.GstAudioChannelPosition // out
	var _arg4 *C.gint                    // out
	var _cret C.gboolean                 // in

	_arg1 = (C.gint)(len(from))
	if len(from) > 0 {
		_arg2 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&from[0]))
	}
	_arg1 = (C.gint)(len(to))
	if len(to) > 0 {
		_arg3 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&to[0]))
	}
	_arg1 = (C.gint)(len(reorderMap))
	_arg4 = (*C.gint)(C.calloc(C.size_t(len(reorderMap)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.gint)(_arg4), len(reorderMap))
		for i := range reorderMap {
			out[i] = C.gint(reorderMap[i])
		}
	}

	_cret = C.gst_audio_get_channel_reorder_map(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(from)
	runtime.KeepAlive(to)
	runtime.KeepAlive(reorderMap)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioReorderChannels reorders data from the channel positions from to the
// channel positions to. from and to must contain the same number of positions
// and the same positions, only in a different order.
//
// Note: this function assumes the audio data is in interleaved layout.
//
// The function takes the following parameters:
//
//    - data: pointer to the memory.
//    - format: GstAudioFormat of the buffer.
//    - from: channel positions in the buffer.
//    - to: channel positions to convert to.
//
// The function returns the following values:
//
//    - ok: TRUE if the reordering was possible.
//
func AudioReorderChannels(data []byte, format AudioFormat, from, to []AudioChannelPosition) bool {
	var _arg1 C.gpointer // out
	var _arg2 C.gsize
	var _arg3 C.GstAudioFormat           // out
	var _arg5 *C.GstAudioChannelPosition // out
	var _arg4 C.gint
	var _arg6 *C.GstAudioChannelPosition // out
	var _cret C.gboolean                 // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	}
	_arg3 = C.GstAudioFormat(format)
	_arg4 = (C.gint)(len(from))
	if len(from) > 0 {
		_arg5 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&from[0]))
	}
	_arg4 = (C.gint)(len(to))
	if len(to) > 0 {
		_arg6 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&to[0]))
	}

	_cret = C.gst_audio_reorder_channels(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(data)
	runtime.KeepAlive(format)
	runtime.KeepAlive(from)
	runtime.KeepAlive(to)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioBufferReorderChannels reorders buffer from the channel positions from to
// the channel positions to. from and to must contain the same number of
// positions and the same positions, only in a different order. buffer must be
// writable.
//
// The function takes the following parameters:
//
//    - buffer to reorder.
//    - format: GstAudioFormat of the buffer.
//    - from: channel positions in the buffer.
//    - to: channel positions to convert to.
//
// The function returns the following values:
//
//    - ok: TRUE if the reordering was possible.
//
func AudioBufferReorderChannels(buffer *gst.Buffer, format AudioFormat, from, to []AudioChannelPosition) bool {
	var _arg1 *C.GstBuffer               // out
	var _arg2 C.GstAudioFormat           // out
	var _arg4 *C.GstAudioChannelPosition // out
	var _arg3 C.gint
	var _arg5 *C.GstAudioChannelPosition // out
	var _cret C.gboolean                 // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstAudioFormat(format)
	_arg3 = (C.gint)(len(from))
	if len(from) > 0 {
		_arg4 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&from[0]))
	}
	_arg3 = (C.gint)(len(to))
	if len(to) > 0 {
		_arg5 = (*C.GstAudioChannelPosition)(unsafe.Pointer(&to[0]))
	}

	_cret = C.gst_audio_buffer_reorder_channels(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(format)
	runtime.KeepAlive(from)
	runtime.KeepAlive(to)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
