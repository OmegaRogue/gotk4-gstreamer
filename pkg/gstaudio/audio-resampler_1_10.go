// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
import "C"

// GType values.
var (
	GTypeAudioResamplerFilterInterpolation = coreglib.Type(C.gst_audio_resampler_filter_interpolation_get_type())
	GTypeAudioResamplerFilterMode          = coreglib.Type(C.gst_audio_resampler_filter_mode_get_type())
	GTypeAudioResamplerMethod              = coreglib.Type(C.gst_audio_resampler_method_get_type())
	GTypeAudioResamplerFlags               = coreglib.Type(C.gst_audio_resampler_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioResamplerFilterInterpolation, F: marshalAudioResamplerFilterInterpolation},
		coreglib.TypeMarshaler{T: GTypeAudioResamplerFilterMode, F: marshalAudioResamplerFilterMode},
		coreglib.TypeMarshaler{T: GTypeAudioResamplerMethod, F: marshalAudioResamplerMethod},
		coreglib.TypeMarshaler{T: GTypeAudioResamplerFlags, F: marshalAudioResamplerFlags},
	})
}

// AudioResamplerFilterInterpolation: different filter interpolation methods.
type AudioResamplerFilterInterpolation C.gint

const (
	// AudioResamplerFilterInterpolationNone: no interpolation.
	AudioResamplerFilterInterpolationNone AudioResamplerFilterInterpolation = iota
	// AudioResamplerFilterInterpolationLinear: linear interpolation of the
	// filter coefficients.
	AudioResamplerFilterInterpolationLinear
	// AudioResamplerFilterInterpolationCubic: cubic interpolation of the filter
	// coefficients.
	AudioResamplerFilterInterpolationCubic
)

func marshalAudioResamplerFilterInterpolation(p uintptr) (interface{}, error) {
	return AudioResamplerFilterInterpolation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioResamplerFilterInterpolation.
func (a AudioResamplerFilterInterpolation) String() string {
	switch a {
	case AudioResamplerFilterInterpolationNone:
		return "None"
	case AudioResamplerFilterInterpolationLinear:
		return "Linear"
	case AudioResamplerFilterInterpolationCubic:
		return "Cubic"
	default:
		return fmt.Sprintf("AudioResamplerFilterInterpolation(%d)", a)
	}
}

// AudioResamplerFilterMode: select for the filter tables should be set up.
type AudioResamplerFilterMode C.gint

const (
	// AudioResamplerFilterModeInterpolated: use interpolated filter tables.
	// This uses less memory but more CPU and is slightly less accurate but it
	// allows for more efficient variable rate resampling with
	// gst_audio_resampler_update().
	AudioResamplerFilterModeInterpolated AudioResamplerFilterMode = iota
	// AudioResamplerFilterModeFull: use full filter table. This uses more
	// memory but less CPU.
	AudioResamplerFilterModeFull
	// AudioResamplerFilterModeAuto: automatically choose between interpolated
	// and full filter tables.
	AudioResamplerFilterModeAuto
)

func marshalAudioResamplerFilterMode(p uintptr) (interface{}, error) {
	return AudioResamplerFilterMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioResamplerFilterMode.
func (a AudioResamplerFilterMode) String() string {
	switch a {
	case AudioResamplerFilterModeInterpolated:
		return "Interpolated"
	case AudioResamplerFilterModeFull:
		return "Full"
	case AudioResamplerFilterModeAuto:
		return "Auto"
	default:
		return fmt.Sprintf("AudioResamplerFilterMode(%d)", a)
	}
}

// AudioResamplerMethod: different subsampling and upsampling methods.
type AudioResamplerMethod C.gint

const (
	// AudioResamplerMethodNearest duplicates the samples when upsampling and
	// drops when downsampling.
	AudioResamplerMethodNearest AudioResamplerMethod = iota
	// AudioResamplerMethodLinear uses linear interpolation to reconstruct
	// missing samples and averaging to downsample.
	AudioResamplerMethodLinear
	// AudioResamplerMethodCubic uses cubic interpolation.
	AudioResamplerMethodCubic
	// AudioResamplerMethodBlackmanNuttall uses Blackman-Nuttall windowed sinc
	// interpolation.
	AudioResamplerMethodBlackmanNuttall
	// AudioResamplerMethodKaiser uses Kaiser windowed sinc interpolation.
	AudioResamplerMethodKaiser
)

func marshalAudioResamplerMethod(p uintptr) (interface{}, error) {
	return AudioResamplerMethod(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioResamplerMethod.
func (a AudioResamplerMethod) String() string {
	switch a {
	case AudioResamplerMethodNearest:
		return "Nearest"
	case AudioResamplerMethodLinear:
		return "Linear"
	case AudioResamplerMethodCubic:
		return "Cubic"
	case AudioResamplerMethodBlackmanNuttall:
		return "BlackmanNuttall"
	case AudioResamplerMethodKaiser:
		return "Kaiser"
	default:
		return fmt.Sprintf("AudioResamplerMethod(%d)", a)
	}
}

// AudioResamplerFlags: different resampler flags.
type AudioResamplerFlags C.guint

const (
	// AudioResamplerFlagNone: no flags.
	AudioResamplerFlagNone AudioResamplerFlags = 0b0
	// AudioResamplerFlagNonInterleavedIn: input samples are non-interleaved. an
	// array of blocks of samples, one for each channel, should be passed to the
	// resample function.
	AudioResamplerFlagNonInterleavedIn AudioResamplerFlags = 0b1
	// AudioResamplerFlagNonInterleavedOut: output samples are non-interleaved.
	// an array of blocks of samples, one for each channel, should be passed to
	// the resample function.
	AudioResamplerFlagNonInterleavedOut AudioResamplerFlags = 0b10
	// AudioResamplerFlagVariableRate: optimize for dynamic updates of the
	// sample rates with gst_audio_resampler_update(). This will select an
	// interpolating filter when T_AUDIO_RESAMPLER_FILTER_MODE_AUTO is
	// configured.
	AudioResamplerFlagVariableRate AudioResamplerFlags = 0b100
)

func marshalAudioResamplerFlags(p uintptr) (interface{}, error) {
	return AudioResamplerFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AudioResamplerFlags.
func (a AudioResamplerFlags) String() string {
	if a == 0 {
		return "AudioResamplerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(124)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AudioResamplerFlagNone:
			builder.WriteString("None|")
		case AudioResamplerFlagNonInterleavedIn:
			builder.WriteString("NonInterleavedIn|")
		case AudioResamplerFlagNonInterleavedOut:
			builder.WriteString("NonInterleavedOut|")
		case AudioResamplerFlagVariableRate:
			builder.WriteString("VariableRate|")
		default:
			builder.WriteString(fmt.Sprintf("AudioResamplerFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AudioResamplerFlags) Has(other AudioResamplerFlags) bool {
	return (a & other) == other
}
