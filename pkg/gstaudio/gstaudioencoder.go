// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void _gotk4_gstaudio1_AudioEncoderClass_flush(GstAudioEncoder*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_transform_meta(GstAudioEncoder*, GstBuffer*, GstMeta*, GstBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_stop(GstAudioEncoder*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_start(GstAudioEncoder*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_src_query(GstAudioEncoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_src_event(GstAudioEncoder*, GstEvent*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_sink_query(GstAudioEncoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_sink_event(GstAudioEncoder*, GstEvent*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_set_format(GstAudioEncoder*, GstAudioInfo*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_propose_allocation(GstAudioEncoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_open(GstAudioEncoder*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_negotiate(GstAudioEncoder*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_decide_allocation(GstAudioEncoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioEncoderClass_close(GstAudioEncoder*);
// extern GstFlowReturn _gotk4_gstaudio1_AudioEncoderClass_handle_frame(GstAudioEncoder*, GstBuffer*);
// extern GstCaps* _gotk4_gstaudio1_AudioEncoderClass_getcaps(GstAudioEncoder*, GstCaps*);
// GstCaps* _gotk4_gstaudio1_AudioEncoder_virtual_getcaps(void* fnptr, GstAudioEncoder* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstAudioEncoder*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstaudio1_AudioEncoder_virtual_handle_frame(void* fnptr, GstAudioEncoder* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstAudioEncoder*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_close(void* fnptr, GstAudioEncoder* arg0) {
//   return ((gboolean (*)(GstAudioEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_decide_allocation(void* fnptr, GstAudioEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_negotiate(void* fnptr, GstAudioEncoder* arg0) {
//   return ((gboolean (*)(GstAudioEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_open(void* fnptr, GstAudioEncoder* arg0) {
//   return ((gboolean (*)(GstAudioEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_propose_allocation(void* fnptr, GstAudioEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_set_format(void* fnptr, GstAudioEncoder* arg0, GstAudioInfo* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstAudioInfo*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_sink_event(void* fnptr, GstAudioEncoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_sink_query(void* fnptr, GstAudioEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_src_event(void* fnptr, GstAudioEncoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_src_query(void* fnptr, GstAudioEncoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioEncoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_start(void* fnptr, GstAudioEncoder* arg0) {
//   return ((gboolean (*)(GstAudioEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_stop(void* fnptr, GstAudioEncoder* arg0) {
//   return ((gboolean (*)(GstAudioEncoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioEncoder_virtual_transform_meta(void* fnptr, GstAudioEncoder* arg0, GstBuffer* arg1, GstMeta* arg2, GstBuffer* arg3) {
//   return ((gboolean (*)(GstAudioEncoder*, GstBuffer*, GstMeta*, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstaudio1_AudioEncoder_virtual_flush(void* fnptr, GstAudioEncoder* arg0) {
//   ((void (*)(GstAudioEncoder*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioEncoder = coreglib.Type(C.gst_audio_encoder_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioEncoder, F: marshalAudioEncoder},
	})
}

// AUDIO_ENCODER_SINK_NAME: name of the templates for the sink pad.
const AUDIO_ENCODER_SINK_NAME = "sink"

// AUDIO_ENCODER_SRC_NAME: name of the templates for the source pad.
const AUDIO_ENCODER_SRC_NAME = "src"

// AudioEncoderOverrides contains methods that are overridable.
type AudioEncoderOverrides struct {
	// The function returns the following values:
	//
	Close func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	Flush            func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	caps func(filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	HandleFrame func(buffer *gst.Buffer) gst.FlowReturn
	// Negotiate with downstream elements to currently configured Caps. Unmark
	// GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if negotiate
	// fails.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the negotiation succeeded, else FALSE.
	//
	Negotiate func() bool
	// The function returns the following values:
	//
	Open func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProposeAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetFormat func(info *AudioInfo) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkQuery func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcQuery func(query *gst.Query) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function takes the following parameters:
	//
	//    - outbuf
	//    - meta
	//    - inbuf
	//
	// The function returns the following values:
	//
	TransformMeta func(outbuf *gst.Buffer, meta *gst.Meta, inbuf *gst.Buffer) bool
}

func defaultAudioEncoderOverrides(v *AudioEncoder) AudioEncoderOverrides {
	return AudioEncoderOverrides{
		Close:             v.close,
		DecideAllocation:  v.decideAllocation,
		Flush:             v.flush,
		caps:              v.caps,
		HandleFrame:       v.handleFrame,
		Negotiate:         v.negotiate,
		Open:              v.open,
		ProposeAllocation: v.proposeAllocation,
		SetFormat:         v.setFormat,
		SinkEvent:         v.sinkEvent,
		SinkQuery:         v.sinkQuery,
		SrcEvent:          v.srcEvent,
		SrcQuery:          v.srcQuery,
		Start:             v.start,
		Stop:              v.stop,
		TransformMeta:     v.transformMeta,
	}
}

// AudioEncoder: this base class is for audio encoders turning raw audio samples
// into encoded audio data.
//
// GstAudioEncoder and subclass should cooperate as follows.
//
// Configuration
//
//    * Initially, GstAudioEncoder calls start when the encoder element
//      is activated, which allows subclass to perform any global setup.
//
//    * GstAudioEncoder calls set_format to inform subclass of the format
//      of input audio data that it is about to receive.  Subclass should
//      setup for encoding and configure various base class parameters
//      appropriately, notably those directing desired input data handling.
//      While unlikely, it might be called more than once, if changing input
//      parameters require reconfiguration.
//
//    * GstAudioEncoder calls stop at end of all processing.
//
// As of configuration stage, and throughout processing, GstAudioEncoder
// maintains various parameters that provide required context, e.g. describing
// the format of input audio data. Conversely, subclass can and should configure
// these context parameters to inform base class of its expectation w.r.t.
// buffer handling.
//
// Data processing
//
//    * Base class gathers input sample data (as directed by the context's
//      frame_samples and frame_max) and provides this to subclass' handle_frame.
//    * If codec processing results in encoded data, subclass should call
//      gst_audio_encoder_finish_frame() to have encoded data pushed
//      downstream. Alternatively, it might also call
//      gst_audio_encoder_finish_frame() (with a NULL buffer and some number of
//      dropped samples) to indicate dropped (non-encoded) samples.
//    * Just prior to actually pushing a buffer downstream,
//      it is passed to pre_push.
//    * During the parsing process GstAudioEncoderClass will handle both
//      srcpad and sinkpad events. Sink events will be passed to subclass
//      if event callback has been provided.
//
// Shutdown phase
//
//    * GstAudioEncoder class calls stop to inform the subclass that data
//      parsing will be stopped.
//
// Subclass is responsible for providing pad template caps for source and sink
// pads. The pads need to be named "sink" and "src". It also needs to set the
// fixed caps on srcpad, when the format is ensured. This is typically when base
// class calls subclass' set_format function, though it might be delayed until
// calling gst_audio_encoder_finish_frame.
//
// In summary, above process should have subclass concentrating on codec data
// processing while leaving other matters to base class, such as most notably
// timestamp handling. While it may exert more control in this area (see e.g.
// pre_push), it is very much not recommended.
//
// In particular, base class will either favor tracking upstream timestamps (at
// the possible expense of jitter) or aim to arrange for a perfect stream of
// output timestamps, depending on AudioEncoder:perfect-timestamp. However, in
// the latter case, the input may not be so perfect or ideal, which is handled
// as follows. An input timestamp is compared with the expected timestamp as
// dictated by input sample stream and if the deviation is less than
// AudioEncoder:tolerance, the deviation is discarded. Otherwise, it is
// considered a discontuinity and subsequent output timestamp is resynced to the
// new position after performing configured discontinuity processing. In the
// non-perfect-timestamp case, an upstream variation exceeding tolerance only
// leads to marking DISCONT on subsequent outgoing (while timestamps are
// adjusted to upstream regardless of variation). While DISCONT is also marked
// in the perfect-timestamp case, this one optionally (see
// AudioEncoder:hard-resync) performs some additional steps, such as clipping of
// (early) input samples or draining all currently remaining input data,
// depending on the direction of the discontuinity.
//
// If perfect timestamps are arranged, it is also possible to request baseclass
// (usually set by subclass) to provide additional buffer metadata (in OFFSET
// and OFFSET_END) fields according to granule defined semantics currently
// needed by oggmux. Specifically, OFFSET is set to granulepos (= sample count
// including buffer) and OFFSET_END to corresponding timestamp (as determined by
// same sample count and sample rate).
//
// Things that subclass need to take care of:
//
//    * Provide pad templates
//    * Set source pad caps when appropriate
//    * Inform base class of buffer processing needs using context's
//       frame_samples and frame_bytes.
//    * Set user-configurable properties to sane defaults for format and
//       implementing codec at hand, e.g. those controlling timestamp behaviour
//       and discontinuity processing.
//    * Accept data in handle_frame and provide encoded results to
//       gst_audio_encoder_finish_frame().
type AudioEncoder struct {
	_ [0]func() // equal guard
	gst.Element

	gst.Preset
}

var (
	_ gst.Elementer = (*AudioEncoder)(nil)
)

// AudioEncoderer describes types inherited from class AudioEncoder.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioEncoderer interface {
	coreglib.Objector
	baseAudioEncoder() *AudioEncoder
}

var _ AudioEncoderer = (*AudioEncoder)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioEncoder, *AudioEncoderClass, AudioEncoderOverrides](
		GTypeAudioEncoder,
		initAudioEncoderClass,
		wrapAudioEncoder,
		defaultAudioEncoderOverrides,
	)
}

func initAudioEncoderClass(gclass unsafe.Pointer, overrides AudioEncoderOverrides, classInitFunc func(*AudioEncoderClass)) {
	pclass := (*C.GstAudioEncoderClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioEncoder))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_close)
	}

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_decide_allocation)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_flush)
	}

	if overrides.caps != nil {
		pclass.getcaps = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_getcaps)
	}

	if overrides.HandleFrame != nil {
		pclass.handle_frame = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_handle_frame)
	}

	if overrides.Negotiate != nil {
		pclass.negotiate = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_negotiate)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_open)
	}

	if overrides.ProposeAllocation != nil {
		pclass.propose_allocation = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_propose_allocation)
	}

	if overrides.SetFormat != nil {
		pclass.set_format = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_set_format)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_sink_event)
	}

	if overrides.SinkQuery != nil {
		pclass.sink_query = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_sink_query)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_src_event)
	}

	if overrides.SrcQuery != nil {
		pclass.src_query = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_src_query)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_stop)
	}

	if overrides.TransformMeta != nil {
		pclass.transform_meta = (*[0]byte)(C._gotk4_gstaudio1_AudioEncoderClass_transform_meta)
	}

	if classInitFunc != nil {
		class := (*AudioEncoderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioEncoder(obj *coreglib.Object) *AudioEncoder {
	return &AudioEncoder{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
		Preset: gst.Preset{
			Object: obj,
		},
	}
}

func marshalAudioEncoder(p uintptr) (interface{}, error) {
	return wrapAudioEncoder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (enc *AudioEncoder) baseAudioEncoder() *AudioEncoder {
	return enc
}

// BaseAudioEncoder returns the underlying base object.
func BaseAudioEncoder(obj AudioEncoderer) *AudioEncoder {
	return obj.baseAudioEncoder()
}

// AllocateOutputBuffer: helper function that allocates a buffer to hold an
// encoded audio frame for enc's current output format.
//
// The function takes the following parameters:
//
//    - size of the buffer.
//
// The function returns the following values:
//
//    - buffer: allocated buffer.
//
func (enc *AudioEncoder) AllocateOutputBuffer(size uint) *gst.Buffer {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gsize            // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.gsize(size)

	_cret = C.gst_audio_encoder_allocate_output_buffer(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// FinishFrame collects encoded data and pushes encoded data downstream. Source
// pad caps must be set when this is called.
//
// If samples < 0, then best estimate is all samples provided to encoder
// (subclass) so far. buf may be NULL, in which case next number of samples are
// considered discarded, e.g. as a result of discontinuous transmission, and a
// discontinuity is marked.
//
// Note that samples received in AudioEncoderClass.handle_frame() may be
// invalidated by a call to this function.
//
// The function takes the following parameters:
//
//    - buffer (optional): encoded data.
//    - samples: number of samples (per channel) represented by encoded data.
//
// The function returns the following values:
//
//    - flowReturn that should be escalated to caller (of caller).
//
func (enc *AudioEncoder) FinishFrame(buffer *gst.Buffer, samples int) gst.FlowReturn {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstBuffer       // out
	var _arg2 C.gint             // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if buffer != nil {
		_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)
	}
	_arg2 = C.gint(samples)

	_cret = C.gst_audio_encoder_finish_frame(_arg0, _arg1, _arg2)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(samples)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Allocator lets AudioEncoder sub-classes to know the memory allocator used by
// the base class and its params.
//
// Unref the allocator after use it.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) the AllocationParams of allocator.
//
func (enc *AudioEncoder) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstAudioEncoder    // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	C.gst_audio_encoder_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(enc)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_params)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocator, _params
}

// The function returns the following values:
//
//    - audioInfo describing the input audio format.
//
func (enc *AudioEncoder) AudioInfo() *AudioInfo {
	var _arg0 *C.GstAudioEncoder // out
	var _cret *C.GstAudioInfo    // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_audio_info(_arg0)
	runtime.KeepAlive(enc)

	var _audioInfo *AudioInfo // out

	_audioInfo = (*AudioInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _audioInfo
}

// Drainable queries encoder drain handling.
//
// The function returns the following values:
//
//    - ok: TRUE if drainable handling is enabled.
//
//      MT safe.
//
func (enc *AudioEncoder) Drainable() bool {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_drainable(_arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - gint: currently configured maximum handled frames.
//
func (enc *AudioEncoder) FrameMax() int {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_frame_max(_arg0)
	runtime.KeepAlive(enc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//    - gint: currently maximum requested samples per frame.
//
func (enc *AudioEncoder) FrameSamplesMax() int {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_frame_samples_max(_arg0)
	runtime.KeepAlive(enc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//    - gint: currently minimum requested samples per frame.
//
func (enc *AudioEncoder) FrameSamplesMin() int {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_frame_samples_min(_arg0)
	runtime.KeepAlive(enc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HardMin queries encoder hard minimum handling.
//
// The function returns the following values:
//
//    - ok: TRUE if hard minimum handling is enabled.
//
//      MT safe.
//
func (enc *AudioEncoder) HardMin() bool {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_hard_min(_arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (enc *AudioEncoder) HardResync() bool {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_hard_resync(_arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Latency sets the variables pointed to by min and max to the currently
// configured latency.
//
// The function returns the following values:
//
//    - min (optional): pointer to storage to hold minimum latency.
//    - max (optional): pointer to storage to hold maximum latency.
//
func (enc *AudioEncoder) Latency() (min, max gst.ClockTime) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.GstClockTime     // in
	var _arg2 C.GstClockTime     // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	C.gst_audio_encoder_get_latency(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(enc)

	var _min gst.ClockTime // out
	var _max gst.ClockTime // out

	_min = uint64(_arg1)
	type _ = gst.ClockTime
	type _ = uint64
	_max = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64

	return _min, _max
}

// The function returns the following values:
//
//    - gint: currently configured encoder lookahead.
//
func (enc *AudioEncoder) Lookahead() int {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_lookahead(_arg0)
	runtime.KeepAlive(enc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarkGranule queries if the encoder will handle granule marking.
//
// The function returns the following values:
//
//    - ok: TRUE if granule marking is enabled.
//
//      MT safe.
//
func (enc *AudioEncoder) MarkGranule() bool {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_mark_granule(_arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PerfectTimestamp queries encoder perfect timestamp behaviour.
//
// The function returns the following values:
//
//    - ok: TRUE if perfect timestamp setting enabled.
//
//      MT safe.
//
func (enc *AudioEncoder) PerfectTimestamp() bool {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_perfect_timestamp(_arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Tolerance queries current audio jitter tolerance threshold.
//
// The function returns the following values:
//
//    - clockTime: encoder audio jitter tolerance threshold.
//
//      MT safe.
//
func (enc *AudioEncoder) Tolerance() gst.ClockTime {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.GstClockTime     // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_get_tolerance(_arg0)
	runtime.KeepAlive(enc)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Negotiate with downstream elements to currently configured Caps. Unmark
// GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if negotiate
// fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (enc *AudioEncoder) Negotiate() bool {
	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C.gst_audio_encoder_negotiate(_arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyGetcaps returns caps that express caps (or sink template caps if caps ==
// NULL) restricted to channel/rate combinations supported by downstream
// elements (e.g. muxers).
//
// The function takes the following parameters:
//
//    - caps (optional): initial caps.
//    - filter (optional) caps.
//
// The function returns the following values:
//
//    - ret owned by caller.
//
func (enc *AudioEncoder) ProxyGetcaps(caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstCaps         // out
	var _arg2 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	if filter != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_audio_encoder_proxy_getcaps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// SetAllocationCaps sets a caps in allocation query which are different from
// the set pad's caps. Use this function before calling
// gst_audio_encoder_negotiate(). Setting to NULL the allocation query will use
// the caps from the pad.
//
// The function takes the following parameters:
//
//    - allocationCaps (optional) or NULL.
//
func (enc *AudioEncoder) SetAllocationCaps(allocationCaps *gst.Caps) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstCaps         // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if allocationCaps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(allocationCaps)))
	}

	C.gst_audio_encoder_set_allocation_caps(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(allocationCaps)
}

// SetDrainable configures encoder drain handling. If drainable, subclass might
// be handed a NULL buffer to have it return any leftover encoded data.
// Otherwise, it is not considered so capable and will only ever be passed real
// data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (enc *AudioEncoder) SetDrainable(enabled bool) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_encoder_set_drainable(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(enabled)
}

// SetFrameMax sets max number of frames accepted at once (assumed minimally 1).
// Requires frame_samples_min and frame_samples_max to be the equal.
//
// Note: This value will be reset to 0 every time before
// AudioEncoderClass.set_format() is called.
//
// The function takes the following parameters:
//
//    - num: number of frames.
//
func (enc *AudioEncoder) SetFrameMax(num int) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.gint(num)

	C.gst_audio_encoder_set_frame_max(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(num)
}

// SetFrameSamplesMax sets number of samples (per channel) subclass needs to be
// handed, at most or will be handed all available if 0.
//
// If an exact number of samples is required,
// gst_audio_encoder_set_frame_samples_min() must be called with the same
// number.
//
// Note: This value will be reset to 0 every time before
// AudioEncoderClass.set_format() is called.
//
// The function takes the following parameters:
//
//    - num: number of samples per frame.
//
func (enc *AudioEncoder) SetFrameSamplesMax(num int) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.gint(num)

	C.gst_audio_encoder_set_frame_samples_max(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(num)
}

// SetFrameSamplesMin sets number of samples (per channel) subclass needs to be
// handed, at least or will be handed all available if 0.
//
// If an exact number of samples is required,
// gst_audio_encoder_set_frame_samples_max() must be called with the same
// number.
//
// Note: This value will be reset to 0 every time before
// AudioEncoderClass.set_format() is called.
//
// The function takes the following parameters:
//
//    - num: number of samples per frame.
//
func (enc *AudioEncoder) SetFrameSamplesMin(num int) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.gint(num)

	C.gst_audio_encoder_set_frame_samples_min(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(num)
}

// SetHardMin configures encoder hard minimum handling. If enabled, subclass
// will never be handed less samples than it configured, which otherwise might
// occur near end-of-data handling. Instead, the leftover samples will simply be
// discarded.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (enc *AudioEncoder) SetHardMin(enabled bool) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_encoder_set_hard_min(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(enabled)
}

// The function takes the following parameters:
//
func (enc *AudioEncoder) SetHardResync(enabled bool) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_encoder_set_hard_resync(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(enabled)
}

// SetHeaders: set the codec headers to be sent downstream whenever requested.
//
// The function takes the following parameters:
//
//    - headers: list of Buffer containing the codec header.
//
func (enc *AudioEncoder) SetHeaders(headers []*gst.Buffer) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GList           // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	for i := len(headers) - 1; i >= 0; i-- {
		src := headers[i]
		var dst *C.GstBuffer // out
		dst = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}

	C.gst_audio_encoder_set_headers(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(headers)
}

// SetLatency sets encoder latency.
//
// The function takes the following parameters:
//
//    - min: minimum latency.
//    - max: maximum latency.
//
func (enc *AudioEncoder) SetLatency(min, max gst.ClockTime) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTime     // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.guint64(min)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(max)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_encoder_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetLookahead sets encoder lookahead (in units of input rate samples)
//
// Note: This value will be reset to 0 every time before
// AudioEncoderClass.set_format() is called.
//
// The function takes the following parameters:
//
//    - num: lookahead.
//
func (enc *AudioEncoder) SetLookahead(num int) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.gint(num)

	C.gst_audio_encoder_set_lookahead(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(num)
}

// SetMarkGranule: enable or disable encoder granule handling.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (enc *AudioEncoder) SetMarkGranule(enabled bool) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_encoder_set_mark_granule(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(enabled)
}

// SetOutputFormat: configure output caps on the srcpad of enc.
//
// The function takes the following parameters:
//
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE on success.
//
func (enc *AudioEncoder) SetOutputFormat(caps *gst.Caps) bool {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstCaps         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_audio_encoder_set_output_format(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPerfectTimestamp: enable or disable encoder perfect output timestamp
// preference.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (enc *AudioEncoder) SetPerfectTimestamp(enabled bool) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_encoder_set_perfect_timestamp(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(enabled)
}

// SetTolerance configures encoder audio jitter tolerance threshold.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - tolerance: new tolerance.
//
func (enc *AudioEncoder) SetTolerance(tolerance gst.ClockTime) {
	var _arg0 *C.GstAudioEncoder // out
	var _arg1 C.GstClockTime     // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = C.guint64(tolerance)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_encoder_set_tolerance(_arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(tolerance)
}

// The function returns the following values:
//
func (enc *AudioEncoder) close() bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.close

	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (enc *AudioEncoder) flush() {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.flush

	var _arg0 *C.GstAudioEncoder // out

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	C._gotk4_gstaudio1_AudioEncoder_virtual_flush(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(enc)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) caps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.getcaps

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_getcaps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) handleFrame(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.handle_frame

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstBuffer       // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_handle_frame(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Negotiate: negotiate with downstream elements to currently configured Caps.
// Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
// negotiate fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (enc *AudioEncoder) negotiate() bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.negotiate

	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_negotiate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (enc *AudioEncoder) open() bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.open

	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) proposeAllocation(query *gst.Query) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.propose_allocation

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_propose_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) setFormat(info *AudioInfo) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.set_format

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstAudioInfo    // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_set_format(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.sink_event

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *AudioEncoder) sinkQuery(query *gst.Query) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.sink_query

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_sink_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (enc *AudioEncoder) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.src_event

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (encoder *AudioEncoder) srcQuery(query *gst.Query) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(encoder))
	fnarg := gclass.src_query

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(encoder).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_src_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(encoder)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (enc *AudioEncoder) start() bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.start

	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (enc *AudioEncoder) stop() bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.stop

	var _arg0 *C.GstAudioEncoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(enc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - outbuf
//    - meta
//    - inbuf
//
// The function returns the following values:
//
func (enc *AudioEncoder) transformMeta(outbuf *gst.Buffer, meta *gst.Meta, inbuf *gst.Buffer) bool {
	gclass := (*C.GstAudioEncoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.transform_meta

	var _arg0 *C.GstAudioEncoder // out
	var _arg1 *C.GstBuffer       // out
	var _arg2 *C.GstMeta         // out
	var _arg3 *C.GstBuffer       // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioEncoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))
	_arg2 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))

	_cret = C._gotk4_gstaudio1_AudioEncoder_virtual_transform_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(inbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioEncoderClass subclasses can override any of the available virtual
// methods or not, as needed. At minimum set_format and handle_frame needs to be
// overridden.
//
// An instance of this type is always passed by reference.
type AudioEncoderClass struct {
	*audioEncoderClass
}

// audioEncoderClass is the struct that's finalized.
type audioEncoderClass struct {
	native *C.GstAudioEncoderClass
}

// ElementClass: parent class structure.
func (a *AudioEncoderClass) ElementClass() *gst.ElementClass {
	valptr := &a.native.element_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
