// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void _gotk4_gstaudio1_AudioAggregatorPadClass_update_conversion_info(GstAudioAggregatorPad*);
// extern gboolean _gotk4_gstaudio1_AudioAggregatorClass_aggregate_one_buffer(GstAudioAggregator*, GstAudioAggregatorPad*, GstBuffer*, guint, GstBuffer*, guint, guint);
// extern GstBuffer* _gotk4_gstaudio1_AudioAggregatorPadClass_convert_buffer(GstAudioAggregatorPad*, GstAudioInfo*, GstAudioInfo*, GstBuffer*);
// extern GstBuffer* _gotk4_gstaudio1_AudioAggregatorClass_create_output_buffer(GstAudioAggregator*, guint);
// GstBuffer* _gotk4_gstaudio1_AudioAggregatorPad_virtual_convert_buffer(void* fnptr, GstAudioAggregatorPad* arg0, GstAudioInfo* arg1, GstAudioInfo* arg2, GstBuffer* arg3) {
//   return ((GstBuffer* (*)(GstAudioAggregatorPad*, GstAudioInfo*, GstAudioInfo*, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstBuffer* _gotk4_gstaudio1_AudioAggregator_virtual_create_output_buffer(void* fnptr, GstAudioAggregator* arg0, guint arg1) {
//   return ((GstBuffer* (*)(GstAudioAggregator*, guint))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioAggregator_virtual_aggregate_one_buffer(void* fnptr, GstAudioAggregator* arg0, GstAudioAggregatorPad* arg1, GstBuffer* arg2, guint arg3, GstBuffer* arg4, guint arg5, guint arg6) {
//   return ((gboolean (*)(GstAudioAggregator*, GstAudioAggregatorPad*, GstBuffer*, guint, GstBuffer*, guint, guint))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gstaudio1_AudioAggregatorPad_virtual_update_conversion_info(void* fnptr, GstAudioAggregatorPad* arg0) {
//   ((void (*)(GstAudioAggregatorPad*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioAggregator           = coreglib.Type(C.gst_audio_aggregator_get_type())
	GTypeAudioAggregatorConvertPad = coreglib.Type(C.gst_audio_aggregator_convert_pad_get_type())
	GTypeAudioAggregatorPad        = coreglib.Type(C.gst_audio_aggregator_pad_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioAggregator, F: marshalAudioAggregator},
		coreglib.TypeMarshaler{T: GTypeAudioAggregatorConvertPad, F: marshalAudioAggregatorConvertPad},
		coreglib.TypeMarshaler{T: GTypeAudioAggregatorPad, F: marshalAudioAggregatorPad},
	})
}

// AudioAggregatorOverrides contains methods that are overridable.
type AudioAggregatorOverrides struct {
	// The function takes the following parameters:
	//
	//    - pad
	//    - inbuf
	//    - inOffset
	//    - outbuf
	//    - outOffset
	//    - numFrames
	//
	// The function returns the following values:
	//
	AggregateOneBuffer func(pad *AudioAggregatorPad, inbuf *gst.Buffer, inOffset uint, outbuf *gst.Buffer, outOffset, numFrames uint) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	CreateOutputBuffer func(numFrames uint) *gst.Buffer
}

func defaultAudioAggregatorOverrides(v *AudioAggregator) AudioAggregatorOverrides {
	return AudioAggregatorOverrides{
		AggregateOneBuffer: v.aggregateOneBuffer,
		CreateOutputBuffer: v.createOutputBuffer,
	}
}

// AudioAggregator subclasses must use (a subclass of) AudioAggregatorPad for
// both their source and sink pads,
// gst_element_class_add_static_pad_template_with_gtype() is a convenient
// helper.
//
// AudioAggregator can perform conversion on the data arriving on its sink pads,
// based on the format expected downstream: in order to enable that behaviour,
// the GType of the sink pads must either be a (subclass of)
// AudioAggregatorConvertPad to use the default AudioConverter implementation,
// or a subclass of AudioAggregatorPad implementing
// AudioAggregatorPadClass.convert_buffer.
//
// To allow for the output caps to change, the mechanism is the same as above,
// with the GType of the source pad.
//
// See AudioMixer for an example.
//
// When conversion is enabled, AudioAggregator will accept any type of raw audio
// caps and perform conversion on the data arriving on its sink pads, with
// whatever downstream expects as the target format.
//
// In case downstream caps are not fully fixated, it will use the first
// configured sink pad to finish fixating its source pad caps.
//
// A notable exception for now is the sample rate, sink pads must have the same
// sample rate as either the downstream requirement, or the first configured
// pad, or a combination of both (when downstream specifies a range or a set of
// acceptable rates).
//
// The Aggregator::samples-selected signal is provided with some additional
// information about the output buffer:
//
// - "offset" G_TYPE_UINT64 Offset in samples since segment start for the
// position that is next to be filled in the output buffer.
//
// - "frames" G_TYPE_UINT Number of frames per output buffer.
//
// In addition the gst_aggregator_peek_next_sample() function returns additional
// information in the info Structure of the returned sample:
//
// - "output-offset" G_TYPE_UINT64 Sample offset in output segment relative to
// the output segment's start where the current position of this input buffer
// would be placed
//
// - "position" G_TYPE_UINT current position in the input buffer in samples
//
// - "size" G_TYPE_UINT size of the input buffer in samples.
type AudioAggregator struct {
	_ [0]func() // equal guard
	gstbase.Aggregator
}

var (
	_ gstbase.Aggregatorrer = (*AudioAggregator)(nil)
)

// AudioAggregatorrer describes types inherited from class AudioAggregator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioAggregatorrer interface {
	coreglib.Objector
	baseAudioAggregator() *AudioAggregator
}

var _ AudioAggregatorrer = (*AudioAggregator)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioAggregator, *AudioAggregatorClass, AudioAggregatorOverrides](
		GTypeAudioAggregator,
		initAudioAggregatorClass,
		wrapAudioAggregator,
		defaultAudioAggregatorOverrides,
	)
}

func initAudioAggregatorClass(gclass unsafe.Pointer, overrides AudioAggregatorOverrides, classInitFunc func(*AudioAggregatorClass)) {
	pclass := (*C.GstAudioAggregatorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioAggregator))))

	if overrides.AggregateOneBuffer != nil {
		pclass.aggregate_one_buffer = (*[0]byte)(C._gotk4_gstaudio1_AudioAggregatorClass_aggregate_one_buffer)
	}

	if overrides.CreateOutputBuffer != nil {
		pclass.create_output_buffer = (*[0]byte)(C._gotk4_gstaudio1_AudioAggregatorClass_create_output_buffer)
	}

	if classInitFunc != nil {
		class := (*AudioAggregatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioAggregator(obj *coreglib.Object) *AudioAggregator {
	return &AudioAggregator{
		Aggregator: gstbase.Aggregator{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalAudioAggregator(p uintptr) (interface{}, error) {
	return wrapAudioAggregator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (aagg *AudioAggregator) baseAudioAggregator() *AudioAggregator {
	return aagg
}

// BaseAudioAggregator returns the underlying base object.
func BaseAudioAggregator(obj AudioAggregatorrer) *AudioAggregator {
	return obj.baseAudioAggregator()
}

// The function takes the following parameters:
//
//    - pad
//    - caps
//
func (aagg *AudioAggregator) SetSinkCaps(pad *AudioAggregatorPad, caps *gst.Caps) {
	var _arg0 *C.GstAudioAggregator    // out
	var _arg1 *C.GstAudioAggregatorPad // out
	var _arg2 *C.GstCaps               // out

	_arg0 = (*C.GstAudioAggregator)(unsafe.Pointer(coreglib.InternObject(aagg).Native()))
	_arg1 = (*C.GstAudioAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_audio_aggregator_set_sink_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(aagg)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)
}

// The function takes the following parameters:
//
//    - pad
//    - inbuf
//    - inOffset
//    - outbuf
//    - outOffset
//    - numFrames
//
// The function returns the following values:
//
func (aagg *AudioAggregator) aggregateOneBuffer(pad *AudioAggregatorPad, inbuf *gst.Buffer, inOffset uint, outbuf *gst.Buffer, outOffset, numFrames uint) bool {
	gclass := (*C.GstAudioAggregatorClass)(coreglib.PeekParentClass(aagg))
	fnarg := gclass.aggregate_one_buffer

	var _arg0 *C.GstAudioAggregator    // out
	var _arg1 *C.GstAudioAggregatorPad // out
	var _arg2 *C.GstBuffer             // out
	var _arg3 C.guint                  // out
	var _arg4 *C.GstBuffer             // out
	var _arg5 C.guint                  // out
	var _arg6 C.guint                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstAudioAggregator)(unsafe.Pointer(coreglib.InternObject(aagg).Native()))
	_arg1 = (*C.GstAudioAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))
	_arg3 = C.guint(inOffset)
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))
	_arg5 = C.guint(outOffset)
	_arg6 = C.guint(numFrames)

	_cret = C._gotk4_gstaudio1_AudioAggregator_virtual_aggregate_one_buffer(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(aagg)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(inOffset)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(outOffset)
	runtime.KeepAlive(numFrames)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (aagg *AudioAggregator) createOutputBuffer(numFrames uint) *gst.Buffer {
	gclass := (*C.GstAudioAggregatorClass)(coreglib.PeekParentClass(aagg))
	fnarg := gclass.create_output_buffer

	var _arg0 *C.GstAudioAggregator // out
	var _arg1 C.guint               // out
	var _cret *C.GstBuffer          // in

	_arg0 = (*C.GstAudioAggregator)(unsafe.Pointer(coreglib.InternObject(aagg).Native()))
	_arg1 = C.guint(numFrames)

	_cret = C._gotk4_gstaudio1_AudioAggregator_virtual_create_output_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(aagg)
	runtime.KeepAlive(numFrames)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// AudioAggregatorConvertPadOverrides contains methods that are overridable.
type AudioAggregatorConvertPadOverrides struct {
}

func defaultAudioAggregatorConvertPadOverrides(v *AudioAggregatorConvertPad) AudioAggregatorConvertPadOverrides {
	return AudioAggregatorConvertPadOverrides{}
}

// AudioAggregatorConvertPad: implementation of GstPad that can be used with
// AudioAggregator.
//
// See AudioAggregator for more details.
type AudioAggregatorConvertPad struct {
	_ [0]func() // equal guard
	AudioAggregatorPad
}

var (
	_ gst.GstObjector = (*AudioAggregatorConvertPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioAggregatorConvertPad, *AudioAggregatorConvertPadClass, AudioAggregatorConvertPadOverrides](
		GTypeAudioAggregatorConvertPad,
		initAudioAggregatorConvertPadClass,
		wrapAudioAggregatorConvertPad,
		defaultAudioAggregatorConvertPadOverrides,
	)
}

func initAudioAggregatorConvertPadClass(gclass unsafe.Pointer, overrides AudioAggregatorConvertPadOverrides, classInitFunc func(*AudioAggregatorConvertPadClass)) {
	if classInitFunc != nil {
		class := (*AudioAggregatorConvertPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioAggregatorConvertPad(obj *coreglib.Object) *AudioAggregatorConvertPad {
	return &AudioAggregatorConvertPad{
		AudioAggregatorPad: AudioAggregatorPad{
			AggregatorPad: gstbase.AggregatorPad{
				Pad: gst.Pad{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalAudioAggregatorConvertPad(p uintptr) (interface{}, error) {
	return wrapAudioAggregatorConvertPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AudioAggregatorPadOverrides contains methods that are overridable.
type AudioAggregatorPadOverrides struct {
	// The function takes the following parameters:
	//
	//    - inInfo
	//    - outInfo
	//    - buffer
	//
	// The function returns the following values:
	//
	ConvertBuffer        func(inInfo, outInfo *AudioInfo, buffer *gst.Buffer) *gst.Buffer
	UpdateConversionInfo func()
}

func defaultAudioAggregatorPadOverrides(v *AudioAggregatorPad) AudioAggregatorPadOverrides {
	return AudioAggregatorPadOverrides{
		ConvertBuffer:        v.convertBuffer,
		UpdateConversionInfo: v.updateConversionInfo,
	}
}

// AudioAggregatorPad: default implementation of GstPad used with
// AudioAggregator.
type AudioAggregatorPad struct {
	_ [0]func() // equal guard
	gstbase.AggregatorPad
}

var (
	_ gst.GstObjector = (*AudioAggregatorPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioAggregatorPad, *AudioAggregatorPadClass, AudioAggregatorPadOverrides](
		GTypeAudioAggregatorPad,
		initAudioAggregatorPadClass,
		wrapAudioAggregatorPad,
		defaultAudioAggregatorPadOverrides,
	)
}

func initAudioAggregatorPadClass(gclass unsafe.Pointer, overrides AudioAggregatorPadOverrides, classInitFunc func(*AudioAggregatorPadClass)) {
	pclass := (*C.GstAudioAggregatorPadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioAggregatorPad))))

	if overrides.ConvertBuffer != nil {
		pclass.convert_buffer = (*[0]byte)(C._gotk4_gstaudio1_AudioAggregatorPadClass_convert_buffer)
	}

	if overrides.UpdateConversionInfo != nil {
		pclass.update_conversion_info = (*[0]byte)(C._gotk4_gstaudio1_AudioAggregatorPadClass_update_conversion_info)
	}

	if classInitFunc != nil {
		class := (*AudioAggregatorPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioAggregatorPad(obj *coreglib.Object) *AudioAggregatorPad {
	return &AudioAggregatorPad{
		AggregatorPad: gstbase.AggregatorPad{
			Pad: gst.Pad{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalAudioAggregatorPad(p uintptr) (interface{}, error) {
	return wrapAudioAggregatorPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//    - inInfo
//    - outInfo
//    - buffer
//
// The function returns the following values:
//
func (pad *AudioAggregatorPad) convertBuffer(inInfo, outInfo *AudioInfo, buffer *gst.Buffer) *gst.Buffer {
	gclass := (*C.GstAudioAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.convert_buffer

	var _arg0 *C.GstAudioAggregatorPad // out
	var _arg1 *C.GstAudioInfo          // out
	var _arg2 *C.GstAudioInfo          // out
	var _arg3 *C.GstBuffer             // out
	var _cret *C.GstBuffer             // in

	_arg0 = (*C.GstAudioAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(inInfo)))
	_arg2 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(outInfo)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstaudio1_AudioAggregatorPad_virtual_convert_buffer(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(inInfo)
	runtime.KeepAlive(outInfo)
	runtime.KeepAlive(buffer)

	var _ret *gst.Buffer // out

	_ret = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

func (pad *AudioAggregatorPad) updateConversionInfo() {
	gclass := (*C.GstAudioAggregatorPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.update_conversion_info

	var _arg0 *C.GstAudioAggregatorPad // out

	_arg0 = (*C.GstAudioAggregatorPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gstaudio1_AudioAggregatorPad_virtual_update_conversion_info(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pad)
}

// AudioAggregatorClass: instance of this type is always passed by reference.
type AudioAggregatorClass struct {
	*audioAggregatorClass
}

// audioAggregatorClass is the struct that's finalized.
type audioAggregatorClass struct {
	native *C.GstAudioAggregatorClass
}

func (a *AudioAggregatorClass) ParentClass() *gstbase.AggregatorClass {
	valptr := &a.native.parent_class
	var _v *gstbase.AggregatorClass // out
	_v = (*gstbase.AggregatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AudioAggregatorConvertPadClass: instance of this type is always passed by
// reference.
type AudioAggregatorConvertPadClass struct {
	*audioAggregatorConvertPadClass
}

// audioAggregatorConvertPadClass is the struct that's finalized.
type audioAggregatorConvertPadClass struct {
	native *C.GstAudioAggregatorConvertPadClass
}

func (a *AudioAggregatorConvertPadClass) ParentClass() *AudioAggregatorPadClass {
	valptr := &a.native.parent_class
	var _v *AudioAggregatorPadClass // out
	_v = (*AudioAggregatorPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AudioAggregatorPadClass: instance of this type is always passed by reference.
type AudioAggregatorPadClass struct {
	*audioAggregatorPadClass
}

// audioAggregatorPadClass is the struct that's finalized.
type audioAggregatorPadClass struct {
	native *C.GstAudioAggregatorPadClass
}

func (a *AudioAggregatorPadClass) ParentClass() *gstbase.AggregatorPadClass {
	valptr := &a.native.parent_class
	var _v *gstbase.AggregatorPadClass // out
	_v = (*gstbase.AggregatorPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
