// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern gboolean _gotk4_gstaudio1_AudioFilterClass_setup(GstAudioFilter*, GstAudioInfo*);
// gboolean _gotk4_gstaudio1_AudioFilter_virtual_setup(void* fnptr, GstAudioFilter* arg0, GstAudioInfo* arg1) {
//   return ((gboolean (*)(GstAudioFilter*, GstAudioInfo*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeAudioFilter = coreglib.Type(C.gst_audio_filter_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioFilter, F: marshalAudioFilter},
	})
}

// AudioFilterOverrides contains methods that are overridable.
type AudioFilterOverrides struct {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Setup func(info *AudioInfo) bool
}

func defaultAudioFilterOverrides(v *AudioFilter) AudioFilterOverrides {
	return AudioFilterOverrides{
		Setup: v.setup,
	}
}

// AudioFilter is a BaseTransform<!-- -->-derived base class for simple audio
// filters, ie. those that output the same format that they get as input.
//
// AudioFilter will parse the input format for you (with error checking) before
// calling your setup function. Also, elements deriving from AudioFilter may use
// gst_audio_filter_class_add_pad_templates() from their class_init function to
// easily configure the set of caps/formats that the element is able to handle.
//
// Derived classes should override the AudioFilterClass.setup() and
// BaseTransformClass.transform_ip() and/or BaseTransformClass.transform()
// virtual functions in their class_init function.
type AudioFilter struct {
	_ [0]func() // equal guard
	gstbase.BaseTransform
}

var (
	_ gstbase.BaseTransformer = (*AudioFilter)(nil)
)

// AudioFilterer describes types inherited from class AudioFilter.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioFilterer interface {
	coreglib.Objector
	baseAudioFilter() *AudioFilter
}

var _ AudioFilterer = (*AudioFilter)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioFilter, *AudioFilterClass, AudioFilterOverrides](
		GTypeAudioFilter,
		initAudioFilterClass,
		wrapAudioFilter,
		defaultAudioFilterOverrides,
	)
}

func initAudioFilterClass(gclass unsafe.Pointer, overrides AudioFilterOverrides, classInitFunc func(*AudioFilterClass)) {
	pclass := (*C.GstAudioFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioFilter))))

	if overrides.Setup != nil {
		pclass.setup = (*[0]byte)(C._gotk4_gstaudio1_AudioFilterClass_setup)
	}

	if classInitFunc != nil {
		class := (*AudioFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioFilter(obj *coreglib.Object) *AudioFilter {
	return &AudioFilter{
		BaseTransform: gstbase.BaseTransform{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalAudioFilter(p uintptr) (interface{}, error) {
	return wrapAudioFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *AudioFilter) baseAudioFilter() *AudioFilter {
	return v
}

// BaseAudioFilter returns the underlying base object.
func BaseAudioFilter(obj AudioFilterer) *AudioFilter {
	return obj.baseAudioFilter()
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (filter *AudioFilter) setup(info *AudioInfo) bool {
	gclass := (*C.GstAudioFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.setup

	var _arg0 *C.GstAudioFilter // out
	var _arg1 *C.GstAudioInfo   // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstAudioFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C._gotk4_gstaudio1_AudioFilter_virtual_setup(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioFilterClass: in addition to the setup virtual function, you should also
// override the GstBaseTransform::transform and/or
// GstBaseTransform::transform_ip virtual function.
//
// An instance of this type is always passed by reference.
type AudioFilterClass struct {
	*audioFilterClass
}

// audioFilterClass is the struct that's finalized.
type audioFilterClass struct {
	native *C.GstAudioFilterClass
}

// Basetransformclass: parent class.
func (a *AudioFilterClass) Basetransformclass() *gstbase.BaseTransformClass {
	valptr := &a.native.basetransformclass
	var _v *gstbase.BaseTransformClass // out
	_v = (*gstbase.BaseTransformClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AddPadTemplates: convenience function to add pad templates to this element
// class, with allowed_caps as the caps that can be handled.
//
// This function is usually used from within a GObject class_init function.
//
// The function takes the following parameters:
//
//    - allowedCaps: what formats the filter can handle, as Caps.
//
func (klass *AudioFilterClass) AddPadTemplates(allowedCaps *gst.Caps) {
	var _arg0 *C.GstAudioFilterClass // out
	var _arg1 *C.GstCaps             // out

	_arg0 = (*C.GstAudioFilterClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(allowedCaps)))

	C.gst_audio_filter_class_add_pad_templates(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(allowedCaps)
}
