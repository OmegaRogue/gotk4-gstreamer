// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void callbackDelete(gpointer);
// extern GstClockTime _gotk4_gstaudio1_AudioClockGetTimeFunc(GstClock*, gpointer);
import "C"

// GType values.
var (
	GTypeAudioClock = coreglib.Type(C.gst_audio_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioClock, F: marshalAudioClock},
	})
}

// AudioClockGetTimeFunc: this function will be called whenever the current
// clock time needs to be calculated. If this function returns
// T_CLOCK_TIME_NONE, the last reported time will be returned by the clock.
type AudioClockGetTimeFunc func(clock gst.Clocker) (clockTime gst.ClockTime)

// AudioClockOverrides contains methods that are overridable.
type AudioClockOverrides struct {
}

func defaultAudioClockOverrides(v *AudioClock) AudioClockOverrides {
	return AudioClockOverrides{}
}

// AudioClock makes it easy for elements to implement a Clock, they simply need
// to provide a function that returns the current clock time.
//
// This object is internally used to implement the clock in AudioBaseSink.
type AudioClock struct {
	_ [0]func() // equal guard
	gst.SystemClock
}

var (
	_ gst.Clocker = (*AudioClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioClock, *AudioClockClass, AudioClockOverrides](
		GTypeAudioClock,
		initAudioClockClass,
		wrapAudioClock,
		defaultAudioClockOverrides,
	)
}

func initAudioClockClass(gclass unsafe.Pointer, overrides AudioClockOverrides, classInitFunc func(*AudioClockClass)) {
	if classInitFunc != nil {
		class := (*AudioClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioClock(obj *coreglib.Object) *AudioClock {
	return &AudioClock{
		SystemClock: gst.SystemClock{
			Clock: gst.Clock{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalAudioClock(p uintptr) (interface{}, error) {
	return wrapAudioClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAudioClock: create a new AudioClock instance. Whenever the clock time
// should be calculated it will call func with user_data. When func returns
// T_CLOCK_TIME_NONE, the clock will return the last reported time.
//
// The function takes the following parameters:
//
//    - name of the clock.
//    - fn: function.
//
// The function returns the following values:
//
//    - audioClock: new AudioClock casted to a Clock.
//
func NewAudioClock(name string, fn AudioClockGetTimeFunc) *AudioClock {
	var _arg1 *C.gchar                   // out
	var _arg2 C.GstAudioClockGetTimeFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret *C.GstClock // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*[0]byte)(C._gotk4_gstaudio1_AudioClockGetTimeFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_audio_clock_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(fn)

	var _audioClock *AudioClock // out

	_audioClock = wrapAudioClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _audioClock
}

// Adjust time with the internal offset of the audio clock.
//
// The function takes the following parameters:
//
//    - time: ClockTime.
//
// The function returns the following values:
//
//    - clockTime: time adjusted with the internal offset.
//
func (clock *AudioClock) Adjust(time gst.ClockTime) gst.ClockTime {
	var _arg0 *C.GstAudioClock // out
	var _arg1 C.GstClockTime   // out
	var _cret C.GstClockTime   // in

	_arg0 = (*C.GstAudioClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(time)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_audio_clock_adjust(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(time)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Time: report the time as returned by the AudioClockGetTimeFunc without
// applying any offsets.
//
// The function returns the following values:
//
//    - clockTime: time as reported by the time function of the audio clock.
//
func (clock *AudioClock) Time() gst.ClockTime {
	var _arg0 *C.GstAudioClock // out
	var _cret C.GstClockTime   // in

	_arg0 = (*C.GstAudioClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_audio_clock_get_time(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Invalidate the clock function. Call this function when the provided
// AudioClockGetTimeFunc cannot be called anymore, for example, when the
// user_data becomes invalid.
//
// After calling this function, clock will return the last returned time for the
// rest of its lifetime.
func (clock *AudioClock) Invalidate() {
	var _arg0 *C.GstAudioClock // out

	_arg0 = (*C.GstAudioClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	C.gst_audio_clock_invalidate(_arg0)
	runtime.KeepAlive(clock)
}

// Reset: inform clock that future calls to AudioClockGetTimeFunc will return
// values starting from time. The clock will update an internal offset to make
// sure that future calls to internal_time will return an increasing result as
// required by the Clock object.
//
// The function takes the following parameters:
//
//    - time: ClockTime.
//
func (clock *AudioClock) Reset(time gst.ClockTime) {
	var _arg0 *C.GstAudioClock // out
	var _arg1 C.GstClockTime   // out

	_arg0 = (*C.GstAudioClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.guint64(time)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_clock_reset(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(time)
}

// AudioClockClass: instance of this type is always passed by reference.
type AudioClockClass struct {
	*audioClockClass
}

// audioClockClass is the struct that's finalized.
type audioClockClass struct {
	native *C.GstAudioClockClass
}

func (a *AudioClockClass) ParentClass() *gst.SystemClockClass {
	valptr := &a.native.parent_class
	var _v *gst.SystemClockClass // out
	_v = (*gst.SystemClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
