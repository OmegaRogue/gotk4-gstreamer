// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern GstAudioRingBuffer* _gotk4_gstaudio1_AudioBaseSrcClass_create_ringbuffer(GstAudioBaseSrc*);
// GstAudioRingBuffer* _gotk4_gstaudio1_AudioBaseSrc_virtual_create_ringbuffer(void* fnptr, GstAudioBaseSrc* arg0) {
//   return ((GstAudioRingBuffer* (*)(GstAudioBaseSrc*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioBaseSrcSlaveMethod = coreglib.Type(C.gst_audio_base_src_slave_method_get_type())
	GTypeAudioBaseSrc            = coreglib.Type(C.gst_audio_base_src_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioBaseSrcSlaveMethod, F: marshalAudioBaseSrcSlaveMethod},
		coreglib.TypeMarshaler{T: GTypeAudioBaseSrc, F: marshalAudioBaseSrc},
	})
}

// AudioBaseSrcSlaveMethod: different possible clock slaving algorithms when the
// internal audio clock was not selected as the pipeline clock.
type AudioBaseSrcSlaveMethod C.gint

const (
	// AudioBaseSrcSlaveResample: resample to match the master clock.
	AudioBaseSrcSlaveResample AudioBaseSrcSlaveMethod = iota
	// AudioBaseSrcSlaveReTimestamp: retimestamp output buffers with master
	// clock time.
	AudioBaseSrcSlaveReTimestamp
	// AudioBaseSrcSlaveSkew: adjust capture pointer when master clock drifts
	// too much.
	AudioBaseSrcSlaveSkew
	// AudioBaseSrcSlaveNone: no adjustment is done.
	AudioBaseSrcSlaveNone
)

func marshalAudioBaseSrcSlaveMethod(p uintptr) (interface{}, error) {
	return AudioBaseSrcSlaveMethod(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioBaseSrcSlaveMethod.
func (a AudioBaseSrcSlaveMethod) String() string {
	switch a {
	case AudioBaseSrcSlaveResample:
		return "Resample"
	case AudioBaseSrcSlaveReTimestamp:
		return "ReTimestamp"
	case AudioBaseSrcSlaveSkew:
		return "Skew"
	case AudioBaseSrcSlaveNone:
		return "None"
	default:
		return fmt.Sprintf("AudioBaseSrcSlaveMethod(%d)", a)
	}
}

// AudioBaseSrcOverrides contains methods that are overridable.
type AudioBaseSrcOverrides struct {
	// CreateRingbuffer: create and return the AudioRingBuffer for src. This
	// function will call the ::create_ringbuffer vmethod and will set src as
	// the parent of the returned buffer (see gst_object_set_parent()).
	//
	// The function returns the following values:
	//
	//    - audioRingBuffer: new ringbuffer of src.
	//
	CreateRingbuffer func() AudioRingBufferer
}

func defaultAudioBaseSrcOverrides(v *AudioBaseSrc) AudioBaseSrcOverrides {
	return AudioBaseSrcOverrides{
		CreateRingbuffer: v.createRingbuffer,
	}
}

// AudioBaseSrc: this is the base class for audio sources. Subclasses need to
// implement the ::create_ringbuffer vmethod. This base class will then take
// care of reading samples from the ringbuffer, synchronisation and flushing.
type AudioBaseSrc struct {
	_ [0]func() // equal guard
	gstbase.PushSrc
}

var (
	_ gstbase.BaseSrcer = (*AudioBaseSrc)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioBaseSrc, *AudioBaseSrcClass, AudioBaseSrcOverrides](
		GTypeAudioBaseSrc,
		initAudioBaseSrcClass,
		wrapAudioBaseSrc,
		defaultAudioBaseSrcOverrides,
	)
}

func initAudioBaseSrcClass(gclass unsafe.Pointer, overrides AudioBaseSrcOverrides, classInitFunc func(*AudioBaseSrcClass)) {
	pclass := (*C.GstAudioBaseSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioBaseSrc))))

	if overrides.CreateRingbuffer != nil {
		pclass.create_ringbuffer = (*[0]byte)(C._gotk4_gstaudio1_AudioBaseSrcClass_create_ringbuffer)
	}

	if classInitFunc != nil {
		class := (*AudioBaseSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioBaseSrc(obj *coreglib.Object) *AudioBaseSrc {
	return &AudioBaseSrc{
		PushSrc: gstbase.PushSrc{
			BaseSrc: gstbase.BaseSrc{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalAudioBaseSrc(p uintptr) (interface{}, error) {
	return wrapAudioBaseSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CreateRingbuffer: create and return the AudioRingBuffer for src. This
// function will call the ::create_ringbuffer vmethod and will set src as the
// parent of the returned buffer (see gst_object_set_parent()).
//
// The function returns the following values:
//
//    - audioRingBuffer: new ringbuffer of src.
//
func (src *AudioBaseSrc) CreateRingbuffer() AudioRingBufferer {
	var _arg0 *C.GstAudioBaseSrc    // out
	var _cret *C.GstAudioRingBuffer // in

	_arg0 = (*C.GstAudioBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_audio_base_src_create_ringbuffer(_arg0)
	runtime.KeepAlive(src)

	var _audioRingBuffer AudioRingBufferer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gstaudio.AudioRingBufferer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AudioRingBufferer)
			return ok
		})
		rv, ok := casted.(AudioRingBufferer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstaudio.AudioRingBufferer")
		}
		_audioRingBuffer = rv
	}

	return _audioRingBuffer
}

// ProvideClock queries whether src will provide a clock or not. See also
// gst_audio_base_src_set_provide_clock.
//
// The function returns the following values:
//
//    - ok: TRUE if src will provide a clock.
//
func (src *AudioBaseSrc) ProvideClock() bool {
	var _arg0 *C.GstAudioBaseSrc // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_audio_base_src_get_provide_clock(_arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SlaveMethod: get the current slave method used by src.
//
// The function returns the following values:
//
//    - audioBaseSrcSlaveMethod: current slave method used by src.
//
func (src *AudioBaseSrc) SlaveMethod() AudioBaseSrcSlaveMethod {
	var _arg0 *C.GstAudioBaseSrc           // out
	var _cret C.GstAudioBaseSrcSlaveMethod // in

	_arg0 = (*C.GstAudioBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C.gst_audio_base_src_get_slave_method(_arg0)
	runtime.KeepAlive(src)

	var _audioBaseSrcSlaveMethod AudioBaseSrcSlaveMethod // out

	_audioBaseSrcSlaveMethod = AudioBaseSrcSlaveMethod(_cret)

	return _audioBaseSrcSlaveMethod
}

// SetProvideClock controls whether src will provide a clock or not. If provide
// is TRUE, gst_element_provide_clock() will return a clock that reflects the
// datarate of src. If provide is FALSE, gst_element_provide_clock() will return
// NULL.
//
// The function takes the following parameters:
//
//    - provide: new state.
//
func (src *AudioBaseSrc) SetProvideClock(provide bool) {
	var _arg0 *C.GstAudioBaseSrc // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if provide {
		_arg1 = C.TRUE
	}

	C.gst_audio_base_src_set_provide_clock(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(provide)
}

// SetSlaveMethod controls how clock slaving will be performed in src.
//
// The function takes the following parameters:
//
//    - method: new slave method.
//
func (src *AudioBaseSrc) SetSlaveMethod(method AudioBaseSrcSlaveMethod) {
	var _arg0 *C.GstAudioBaseSrc           // out
	var _arg1 C.GstAudioBaseSrcSlaveMethod // out

	_arg0 = (*C.GstAudioBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.GstAudioBaseSrcSlaveMethod(method)

	C.gst_audio_base_src_set_slave_method(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(method)
}

// createRingbuffer: create and return the AudioRingBuffer for src. This
// function will call the ::create_ringbuffer vmethod and will set src as the
// parent of the returned buffer (see gst_object_set_parent()).
//
// The function returns the following values:
//
//    - audioRingBuffer: new ringbuffer of src.
//
func (src *AudioBaseSrc) createRingbuffer() AudioRingBufferer {
	gclass := (*C.GstAudioBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.create_ringbuffer

	var _arg0 *C.GstAudioBaseSrc    // out
	var _cret *C.GstAudioRingBuffer // in

	_arg0 = (*C.GstAudioBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstaudio1_AudioBaseSrc_virtual_create_ringbuffer(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _audioRingBuffer AudioRingBufferer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gstaudio.AudioRingBufferer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AudioRingBufferer)
			return ok
		})
		rv, ok := casted.(AudioRingBufferer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstaudio.AudioRingBufferer")
		}
		_audioRingBuffer = rv
	}

	return _audioRingBuffer
}

// AudioBaseSrcClass class. Override the vmethod to implement functionality.
//
// An instance of this type is always passed by reference.
type AudioBaseSrcClass struct {
	*audioBaseSrcClass
}

// audioBaseSrcClass is the struct that's finalized.
type audioBaseSrcClass struct {
	native *C.GstAudioBaseSrcClass
}

// ParentClass: parent class.
func (a *AudioBaseSrcClass) ParentClass() *gstbase.PushSrcClass {
	valptr := &a.native.parent_class
	var _v *gstbase.PushSrcClass // out
	_v = (*gstbase.PushSrcClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
