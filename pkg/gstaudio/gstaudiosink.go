// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void _gotk4_gstaudio1_AudioSinkClass_stop(GstAudioSink*);
// extern void _gotk4_gstaudio1_AudioSinkClass_resume(GstAudioSink*);
// extern void _gotk4_gstaudio1_AudioSinkClass_reset(GstAudioSink*);
// extern void _gotk4_gstaudio1_AudioSinkClass_pause(GstAudioSink*);
// extern guint _gotk4_gstaudio1_AudioSinkClass_delay(GstAudioSink*);
// extern gint _gotk4_gstaudio1_AudioSinkClass_write(GstAudioSink*, gpointer, guint);
// extern gboolean _gotk4_gstaudio1_AudioSinkClass_unprepare(GstAudioSink*);
// extern gboolean _gotk4_gstaudio1_AudioSinkClass_prepare(GstAudioSink*, GstAudioRingBufferSpec*);
// extern gboolean _gotk4_gstaudio1_AudioSinkClass_open(GstAudioSink*);
// extern gboolean _gotk4_gstaudio1_AudioSinkClass_close(GstAudioSink*);
// gboolean _gotk4_gstaudio1_AudioSink_virtual_close(void* fnptr, GstAudioSink* arg0) {
//   return ((gboolean (*)(GstAudioSink*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioSink_virtual_open(void* fnptr, GstAudioSink* arg0) {
//   return ((gboolean (*)(GstAudioSink*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioSink_virtual_prepare(void* fnptr, GstAudioSink* arg0, GstAudioRingBufferSpec* arg1) {
//   return ((gboolean (*)(GstAudioSink*, GstAudioRingBufferSpec*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioSink_virtual_unprepare(void* fnptr, GstAudioSink* arg0) {
//   return ((gboolean (*)(GstAudioSink*))(fnptr))(arg0);
// };
// gint _gotk4_gstaudio1_AudioSink_virtual_write(void* fnptr, GstAudioSink* arg0, gpointer arg1, guint arg2) {
//   return ((gint (*)(GstAudioSink*, gpointer, guint))(fnptr))(arg0, arg1, arg2);
// };
// guint _gotk4_gstaudio1_AudioSink_virtual_delay(void* fnptr, GstAudioSink* arg0) {
//   return ((guint (*)(GstAudioSink*))(fnptr))(arg0);
// };
// void _gotk4_gstaudio1_AudioSink_virtual_pause(void* fnptr, GstAudioSink* arg0) {
//   ((void (*)(GstAudioSink*))(fnptr))(arg0);
// };
// void _gotk4_gstaudio1_AudioSink_virtual_reset(void* fnptr, GstAudioSink* arg0) {
//   ((void (*)(GstAudioSink*))(fnptr))(arg0);
// };
// void _gotk4_gstaudio1_AudioSink_virtual_resume(void* fnptr, GstAudioSink* arg0) {
//   ((void (*)(GstAudioSink*))(fnptr))(arg0);
// };
// void _gotk4_gstaudio1_AudioSink_virtual_stop(void* fnptr, GstAudioSink* arg0) {
//   ((void (*)(GstAudioSink*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioSink = coreglib.Type(C.gst_audio_sink_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioSink, F: marshalAudioSink},
	})
}

// AudioSinkOverrides contains methods that are overridable.
type AudioSinkOverrides struct {
	// The function returns the following values:
	//
	Close func() bool
	// The function returns the following values:
	//
	Delay func() uint
	// The function returns the following values:
	//
	Open  func() bool
	Pause func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Prepare func(spec *AudioRingBufferSpec) bool
	Reset   func()
	Resume  func()
	Stop    func()
	// The function returns the following values:
	//
	Unprepare func() bool
	// The function takes the following parameters:
	//
	//    - data (optional)
	//    - length
	//
	// The function returns the following values:
	//
	Write func(data unsafe.Pointer, length uint) int
}

func defaultAudioSinkOverrides(v *AudioSink) AudioSinkOverrides {
	return AudioSinkOverrides{
		Close:     v.close,
		Delay:     v.delay,
		Open:      v.open,
		Pause:     v.pause,
		Prepare:   v.prepare,
		Reset:     v.reset,
		Resume:    v.resume,
		Stop:      v.stop,
		Unprepare: v.unprepare,
		Write:     v.write,
	}
}

// AudioSink: this is the most simple base class for audio sinks that only
// requires subclasses to implement a set of simple functions:
//
// * open() :Open the device.
//
// * prepare() :Configure the device with the specified format.
//
// * write() :Write samples to the device.
//
// * reset() :Unblock writes and flush the device.
//
// * delay() :Get the number of samples written but not yet played by the
// device.
//
// * unprepare() :Undo operations done by prepare.
//
// * close() :Close the device.
//
// All scheduling of samples and timestamps is done in this base class together
// with AudioBaseSink using a default implementation of a AudioRingBuffer that
// uses threads.
type AudioSink struct {
	_ [0]func() // equal guard
	AudioBaseSink
}

var (
	_ gstbase.BaseSinker = (*AudioSink)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioSink, *AudioSinkClass, AudioSinkOverrides](
		GTypeAudioSink,
		initAudioSinkClass,
		wrapAudioSink,
		defaultAudioSinkOverrides,
	)
}

func initAudioSinkClass(gclass unsafe.Pointer, overrides AudioSinkOverrides, classInitFunc func(*AudioSinkClass)) {
	pclass := (*C.GstAudioSinkClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioSink))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_close)
	}

	if overrides.Delay != nil {
		pclass.delay = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_delay)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_open)
	}

	if overrides.Pause != nil {
		pclass.pause = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_pause)
	}

	if overrides.Prepare != nil {
		pclass.prepare = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_prepare)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_reset)
	}

	if overrides.Resume != nil {
		pclass.resume = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_resume)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_stop)
	}

	if overrides.Unprepare != nil {
		pclass.unprepare = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_unprepare)
	}

	if overrides.Write != nil {
		pclass.write = (*[0]byte)(C._gotk4_gstaudio1_AudioSinkClass_write)
	}

	if classInitFunc != nil {
		class := (*AudioSinkClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioSink(obj *coreglib.Object) *AudioSink {
	return &AudioSink{
		AudioBaseSink: AudioBaseSink{
			BaseSink: gstbase.BaseSink{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalAudioSink(p uintptr) (interface{}, error) {
	return wrapAudioSink(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
func (sink *AudioSink) close() bool {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.close

	var _arg0 *C.GstAudioSink // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstaudio1_AudioSink_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (sink *AudioSink) delay() uint {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.delay

	var _arg0 *C.GstAudioSink // out
	var _cret C.guint         // in

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstaudio1_AudioSink_virtual_delay(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
func (sink *AudioSink) open() bool {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.open

	var _arg0 *C.GstAudioSink // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstaudio1_AudioSink_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (sink *AudioSink) pause() {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.pause

	var _arg0 *C.GstAudioSink // out

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	C._gotk4_gstaudio1_AudioSink_virtual_pause(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (sink *AudioSink) prepare(spec *AudioRingBufferSpec) bool {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.prepare

	var _arg0 *C.GstAudioSink           // out
	var _arg1 *C.GstAudioRingBufferSpec // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))

	_cret = C._gotk4_gstaudio1_AudioSink_virtual_prepare(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (sink *AudioSink) reset() {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.reset

	var _arg0 *C.GstAudioSink // out

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	C._gotk4_gstaudio1_AudioSink_virtual_reset(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)
}

func (sink *AudioSink) resume() {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.resume

	var _arg0 *C.GstAudioSink // out

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	C._gotk4_gstaudio1_AudioSink_virtual_resume(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)
}

func (sink *AudioSink) stop() {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.stop

	var _arg0 *C.GstAudioSink // out

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	C._gotk4_gstaudio1_AudioSink_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)
}

// The function returns the following values:
//
func (sink *AudioSink) unprepare() bool {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.unprepare

	var _arg0 *C.GstAudioSink // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C._gotk4_gstaudio1_AudioSink_virtual_unprepare(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - data (optional)
//    - length
//
// The function returns the following values:
//
func (sink *AudioSink) write(data unsafe.Pointer, length uint) int {
	gclass := (*C.GstAudioSinkClass)(coreglib.PeekParentClass(sink))
	fnarg := gclass.write

	var _arg0 *C.GstAudioSink // out
	var _arg1 C.gpointer      // out
	var _arg2 C.guint         // out
	var _cret C.gint          // in

	_arg0 = (*C.GstAudioSink)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))
	_arg2 = C.guint(length)

	_cret = C._gotk4_gstaudio1_AudioSink_virtual_write(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(data)
	runtime.KeepAlive(length)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AudioSinkClass: instance of this type is always passed by reference.
type AudioSinkClass struct {
	*audioSinkClass
}

// audioSinkClass is the struct that's finalized.
type audioSinkClass struct {
	native *C.GstAudioSinkClass
}

// ParentClass: parent class structure.
func (a *AudioSinkClass) ParentClass() *AudioBaseSinkClass {
	valptr := &a.native.parent_class
	var _v *AudioBaseSinkClass // out
	_v = (*AudioBaseSinkClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Extension class extension structure. Since: 1.18.
func (a *AudioSinkClass) Extension() *AudioSinkClassExtension {
	valptr := &a.native.extension
	var _v *AudioSinkClassExtension // out
	_v = (*AudioSinkClassExtension)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// AudioSinkClassExtension: instance of this type is always passed by reference.
type AudioSinkClassExtension struct {
	*audioSinkClassExtension
}

// audioSinkClassExtension is the struct that's finalized.
type audioSinkClassExtension struct {
	native *C.GstAudioSinkClassExtension
}
