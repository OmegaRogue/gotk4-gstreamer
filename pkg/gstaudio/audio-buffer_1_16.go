// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/audio/audio.h>
import "C"

// AudioBuffer: structure containing the result of an audio buffer map
// operation, which is executed with gst_audio_buffer_map(). For non-interleaved
// (planar) buffers, the beginning of each channel in the buffer has its own
// pointer in the planes array. For interleaved buffers, the planes array only
// contains one item, which is the pointer to the beginning of the buffer, and
// n_planes equals 1.
//
// The different channels in planes are always in the GStreamer channel order.
//
// An instance of this type is always passed by reference.
type AudioBuffer struct {
	*audioBuffer
}

// audioBuffer is the struct that's finalized.
type audioBuffer struct {
	native *C.GstAudioBuffer
}

// Info describing the audio properties of this buffer.
func (a *AudioBuffer) Info() *AudioInfo {
	valptr := &a.native.info
	var _v *AudioInfo // out
	_v = (*AudioInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NSamples: size of the buffer in samples.
func (a *AudioBuffer) NSamples() uint {
	valptr := &a.native.n_samples
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// NPlanes: number of planes available.
func (a *AudioBuffer) NPlanes() int {
	valptr := &a.native.n_planes
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Planes: array of n_planes pointers pointing to the start of each plane in the
// mapped buffer.
func (a *AudioBuffer) Planes() *unsafe.Pointer {
	valptr := &a.native.planes
	var _v *unsafe.Pointer // out
	_v = (*unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Buffer: mapped buffer.
func (a *AudioBuffer) Buffer() *gst.Buffer {
	valptr := &a.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// NSamples: size of the buffer in samples.
func (a *AudioBuffer) SetNSamples(nSamples uint) {
	valptr := &a.native.n_samples
	*valptr = C.gsize(nSamples)
}

// NPlanes: number of planes available.
func (a *AudioBuffer) SetNPlanes(nPlanes int) {
	valptr := &a.native.n_planes
	*valptr = C.gint(nPlanes)
}

// Unmap unmaps an audio buffer that was previously mapped with
// gst_audio_buffer_map().
func (buffer *AudioBuffer) Unmap() {
	var _arg0 *C.GstAudioBuffer // out

	_arg0 = (*C.GstAudioBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C.gst_audio_buffer_unmap(_arg0)
	runtime.KeepAlive(buffer)
}

// AudioBufferMap maps an audio gstbuffer so that it can be read or written and
// stores the result of the map operation in buffer.
//
// This is especially useful when the gstbuffer is in non-interleaved (planar)
// layout, in which case this function will use the information in the
// gstbuffer's attached AudioMeta in order to map each channel in a separate
// "plane" in AudioBuffer. If a AudioMeta is not attached on the gstbuffer, then
// it must be in interleaved layout.
//
// If a AudioMeta is attached, then the AudioInfo on the meta is checked against
// info. Normally, they should be equal, but in case they are not, a g_critical
// will be printed and the AudioInfo from the meta will be used.
//
// In non-interleaved buffers, it is possible to have each channel on a separate
// Memory. In this case, each memory will be mapped separately to avoid copying
// their contents in a larger memory area. Do note though that it is not
// supported to have a single channel spanning over two or more different Memory
// objects. Although the map operation will likely succeed in this case, it will
// be highly sub-optimal and it is recommended to merge all the memories in the
// buffer before calling this function.
//
// Note: The actual Buffer is not ref'ed, but it is required to stay valid as
// long as it's mapped.
//
// The function takes the following parameters:
//
//    - info: audio properties of the buffer.
//    - gstbuffer to be mapped.
//    - flags access mode for the memory.
//
// The function returns the following values:
//
//    - buffer: pointer to a AudioBuffer.
//    - ok: TRUE if the map operation succeeded or FALSE on failure.
//
func AudioBufferMap(info *AudioInfo, gstbuffer *gst.Buffer, flags gst.MapFlags) (*AudioBuffer, bool) {
	var _arg1 C.GstAudioBuffer // in
	var _arg2 *C.GstAudioInfo  // out
	var _arg3 *C.GstBuffer     // out
	var _arg4 C.GstMapFlags    // out
	var _cret C.gboolean       // in

	_arg2 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(gstbuffer)))
	_arg4 = C.GstMapFlags(flags)

	_cret = C.gst_audio_buffer_map(&_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(info)
	runtime.KeepAlive(gstbuffer)
	runtime.KeepAlive(flags)

	var _buffer *AudioBuffer // out
	var _ok bool             // out

	_buffer = (*AudioBuffer)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _buffer, _ok
}
