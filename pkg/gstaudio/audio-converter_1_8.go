// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
import "C"

// GType values.
var (
	GTypeAudioConverter = coreglib.Type(C.gst_audio_converter_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioConverter, F: marshalAudioConverter},
	})
}

// AudioConverter: this object is used to convert audio samples from one format
// to another. The object can perform conversion of:
//
//    * audio format with optional dithering and noise shaping
//
//    * audio samplerate
//
//    * audio channels and channel layout
//
// An instance of this type is always passed by reference.
type AudioConverter struct {
	*audioConverter
}

// audioConverter is the struct that's finalized.
type audioConverter struct {
	native *C.GstAudioConverter
}

func marshalAudioConverter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AudioConverter{&audioConverter{(*C.GstAudioConverter)(b)}}, nil
}

// NewAudioConverter constructs a struct AudioConverter.
func NewAudioConverter(flags AudioConverterFlags, inInfo *AudioInfo, outInfo *AudioInfo, config *gst.Structure) *AudioConverter {
	var _arg1 C.GstAudioConverterFlags // out
	var _arg2 *C.GstAudioInfo          // out
	var _arg3 *C.GstAudioInfo          // out
	var _arg4 *C.GstStructure          // out
	var _cret *C.GstAudioConverter     // in

	_arg1 = C.GstAudioConverterFlags(flags)
	_arg2 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(inInfo)))
	_arg3 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(outInfo)))
	if config != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)
	}

	_cret = C.gst_audio_converter_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(inInfo)
	runtime.KeepAlive(outInfo)
	runtime.KeepAlive(config)

	var _audioConverter *AudioConverter // out

	_audioConverter = (*AudioConverter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_audioConverter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_audio_converter_free((*C.GstAudioConverter)(intern.C))
		},
	)

	return _audioConverter
}

// Convert: convenience wrapper around gst_audio_converter_samples(), which will
// perform allocation of the output buffer based on the result from
// gst_audio_converter_get_out_frames().
//
// The function takes the following parameters:
//
//    - flags: extra AudioConverterFlags.
//    - in: input data.
//
// The function returns the following values:
//
//    - out: pointer where the output data will be written.
//    - ok: TRUE is the conversion could be performed.
//
func (convert *AudioConverter) Convert(flags AudioConverterFlags, in []byte) ([]byte, bool) {
	var _arg0 *C.GstAudioConverter     // out
	var _arg1 C.GstAudioConverterFlags // out
	var _arg2 C.gpointer               // out
	var _arg3 C.gsize
	var _arg4 C.gpointer // in
	var _arg5 C.gsize    // in
	var _cret C.gboolean // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))
	_arg1 = C.GstAudioConverterFlags(flags)
	_arg3 = (C.gsize)(len(in))
	if len(in) > 0 {
		_arg2 = (C.gpointer)(unsafe.Pointer(&in[0]))
	}

	_cret = C.gst_audio_converter_convert(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(in)

	var _out []byte // out
	var _ok bool    // out

	defer C.free(unsafe.Pointer(_arg4))
	_out = make([]byte, _arg5)
	copy(_out, unsafe.Slice((*byte)(unsafe.Pointer(_arg4)), _arg5))
	if _cret != 0 {
		_ok = true
	}

	return _out, _ok
}

// Config: get the current configuration of convert.
//
// The function returns the following values:
//
//    - inRate (optional): result input rate.
//    - outRate (optional): result output rate.
//    - structure: a Structure that remains valid for as long as convert is valid
//      or until gst_audio_converter_update_config() is called.
//
func (convert *AudioConverter) Config() (inRate int, outRate int, structure *gst.Structure) {
	var _arg0 *C.GstAudioConverter // out
	var _arg1 C.gint               // in
	var _arg2 C.gint               // in
	var _cret *C.GstStructure      // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))

	_cret = C.gst_audio_converter_get_config(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(convert)

	var _inRate int               // out
	var _outRate int              // out
	var _structure *gst.Structure // out

	_inRate = int(_arg1)
	_outRate = int(_arg2)
	_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _inRate, _outRate, _structure
}

// InFrames: calculate how many input frames are currently needed by convert to
// produce out_frames of output frames.
//
// The function takes the following parameters:
//
//    - outFrames: number of output frames.
//
// The function returns the following values:
//
//    - gsize: number of input frames.
//
func (convert *AudioConverter) InFrames(outFrames uint) uint {
	var _arg0 *C.GstAudioConverter // out
	var _arg1 C.gsize              // out
	var _cret C.gsize              // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))
	_arg1 = C.gsize(outFrames)

	_cret = C.gst_audio_converter_get_in_frames(_arg0, _arg1)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(outFrames)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// MaxLatency: get the maximum number of input frames that the converter would
// need before producing output.
//
// The function returns the following values:
//
//    - gsize: latency of convert as expressed in the number of frames.
//
func (convert *AudioConverter) MaxLatency() uint {
	var _arg0 *C.GstAudioConverter // out
	var _cret C.gsize              // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))

	_cret = C.gst_audio_converter_get_max_latency(_arg0)
	runtime.KeepAlive(convert)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// OutFrames: calculate how many output frames can be produced when in_frames
// input frames are given to convert.
//
// The function takes the following parameters:
//
//    - inFrames: number of input frames.
//
// The function returns the following values:
//
//    - gsize: number of output frames.
//
func (convert *AudioConverter) OutFrames(inFrames uint) uint {
	var _arg0 *C.GstAudioConverter // out
	var _arg1 C.gsize              // out
	var _cret C.gsize              // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))
	_arg1 = C.gsize(inFrames)

	_cret = C.gst_audio_converter_get_out_frames(_arg0, _arg1)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(inFrames)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// IsPassthrough returns whether the audio converter will operate in passthrough
// mode. The return value would be typically input to
// gst_base_transform_set_passthrough().
//
// The function returns the following values:
//
//    - ok: TRUE when no conversion will actually occur.
//
func (convert *AudioConverter) IsPassthrough() bool {
	var _arg0 *C.GstAudioConverter // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))

	_cret = C.gst_audio_converter_is_passthrough(_arg0)
	runtime.KeepAlive(convert)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reset convert to the state it was when it was first created, clearing any
// history it might currently have.
func (convert *AudioConverter) Reset() {
	var _arg0 *C.GstAudioConverter // out

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))

	C.gst_audio_converter_reset(_arg0)
	runtime.KeepAlive(convert)
}

// Samples: perform the conversion with in_frames in in to out_frames in out
// using convert.
//
// In case the samples are interleaved, in and out must point to an array with a
// single element pointing to a block of interleaved samples.
//
// If non-interleaved samples are used, in and out must point to an array with
// pointers to memory blocks, one for each channel.
//
// in may be NULL, in which case in_frames of silence samples are processed by
// the converter.
//
// This function always produces out_frames of output and consumes in_frames of
// input. Use gst_audio_converter_get_out_frames() and
// gst_audio_converter_get_in_frames() to make sure in_frames and out_frames are
// matching and in and out point to enough memory.
//
// The function takes the following parameters:
//
//    - flags: extra AudioConverterFlags.
//    - in (optional): input frames.
//    - inFrames: number of input frames.
//    - out (optional): output frames.
//    - outFrames: number of output frames.
//
// The function returns the following values:
//
//    - ok: TRUE is the conversion could be performed.
//
func (convert *AudioConverter) Samples(flags AudioConverterFlags, in *unsafe.Pointer, inFrames uint, out *unsafe.Pointer, outFrames uint) bool {
	var _arg0 *C.GstAudioConverter     // out
	var _arg1 C.GstAudioConverterFlags // out
	var _arg2 *C.gpointer              // out
	var _arg3 C.gsize                  // out
	var _arg4 *C.gpointer              // out
	var _arg5 C.gsize                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))
	_arg1 = C.GstAudioConverterFlags(flags)
	if in != nil {
		_arg2 = (*C.gpointer)(unsafe.Pointer(in))
	}
	_arg3 = C.gsize(inFrames)
	if out != nil {
		_arg4 = (*C.gpointer)(unsafe.Pointer(out))
	}
	_arg5 = C.gsize(outFrames)

	_cret = C.gst_audio_converter_samples(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(in)
	runtime.KeepAlive(inFrames)
	runtime.KeepAlive(out)
	runtime.KeepAlive(outFrames)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsInplace returns whether the audio converter can perform the
// conversion in-place. The return value would be typically input to
// gst_base_transform_set_in_place().
//
// The function returns the following values:
//
//    - ok: TRUE when the conversion can be done in place.
//
func (convert *AudioConverter) SupportsInplace() bool {
	var _arg0 *C.GstAudioConverter // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))

	_cret = C.gst_audio_converter_supports_inplace(_arg0)
	runtime.KeepAlive(convert)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UpdateConfig: set in_rate, out_rate and config as extra configuration for
// convert.
//
// in_rate and out_rate specify the new sample rates of input and output
// formats. A value of 0 leaves the sample rate unchanged.
//
// config can be NULL, in which case, the current configuration is not changed.
//
// If the parameters in config can not be set exactly, this function returns
// FALSE and will try to update as much state as possible. The new state can
// then be retrieved and refined with gst_audio_converter_get_config().
//
// Look at the GST_AUDIO_CONVERTER_OPT_* fields to check valid configuration
// option and values.
//
// The function takes the following parameters:
//
//    - inRate: input rate.
//    - outRate: output rate.
//    - config (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: TRUE when the new parameters could be set.
//
func (convert *AudioConverter) UpdateConfig(inRate int, outRate int, config *gst.Structure) bool {
	var _arg0 *C.GstAudioConverter // out
	var _arg1 C.gint               // out
	var _arg2 C.gint               // out
	var _arg3 *C.GstStructure      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstAudioConverter)(gextras.StructNative(unsafe.Pointer(convert)))
	_arg1 = C.gint(inRate)
	_arg2 = C.gint(outRate)
	if config != nil {
		_arg3 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)
	}

	_cret = C.gst_audio_converter_update_config(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(inRate)
	runtime.KeepAlive(outRate)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
