// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
import "C"

// GType values.
var (
	GTypeAudioConverterFlags = coreglib.Type(C.gst_audio_converter_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioConverterFlags, F: marshalAudioConverterFlags},
	})
}

// AUDIO_CONVERTER_OPT_DITHER_METHOD The dither method to use when changing bit
// depth. Default is T_AUDIO_DITHER_NONE.
const AUDIO_CONVERTER_OPT_DITHER_METHOD = "GstAudioConverter.dither-method"

// AUDIO_CONVERTER_OPT_MIX_MATRIX The channel mapping matrix.
//
// The matrix coefficients must be between -1 and 1: the number of rows is equal
// to the number of output channels and the number of columns is equal to the
// number of input channels.
//
//
// Example matrix generation code
//
// To generate the matrix using code:
//
//    GValue v = G_VALUE_INIT;
//    GValue v2 = G_VALUE_INIT;
//    GValue v3 = G_VALUE_INIT;
//
//    g_value_init (&v2, GST_TYPE_ARRAY);
//    g_value_init (&v3, G_TYPE_DOUBLE);
//    g_value_set_double (&v3, 1);
//    gst_value_array_append_value (&v2, &v3);
//    g_value_unset (&v3);
//    [ Repeat for as many double as your input channels - unset and reinit v3 ]
//    g_value_init (&v, GST_TYPE_ARRAY);
//    gst_value_array_append_value (&v, &v2);
//    g_value_unset (&v2);
//    [ Repeat for as many v2's as your output channels - unset and reinit v2]
//    g_object_set_property (G_OBJECT (audiomixmatrix), "matrix", &v);
//    g_value_unset (&v);.
const AUDIO_CONVERTER_OPT_MIX_MATRIX = "GstAudioConverter.mix-matrix"

// AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD The noise shaping method to use to
// mask noise from quantization errors. Default is T_AUDIO_NOISE_SHAPING_NONE.
const AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD = "GstAudioConverter.noise-shaping-method"

// AUDIO_CONVERTER_OPT_QUANTIZATION The quantization amount. Components will be
// quantized to multiples of this value. Default is 1.
const AUDIO_CONVERTER_OPT_QUANTIZATION = "GstAudioConverter.quantization"

// AUDIO_CONVERTER_OPT_RESAMPLER_METHOD The resampler method to use when
// changing sample rates. Default is T_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL.
const AUDIO_CONVERTER_OPT_RESAMPLER_METHOD = "GstAudioConverter.resampler-method"

// AudioConverterFlags: extra flags passed to gst_audio_converter_new() and
// gst_audio_converter_samples().
type AudioConverterFlags C.guint

const (
	// AudioConverterFlagNone: no flag.
	AudioConverterFlagNone AudioConverterFlags = 0b0
	// AudioConverterFlagInWritable: input sample arrays are writable and can be
	// used as temporary storage during conversion.
	AudioConverterFlagInWritable AudioConverterFlags = 0b1
	// AudioConverterFlagVariableRate: allow arbitrary rate updates with
	// gst_audio_converter_update_config().
	AudioConverterFlagVariableRate AudioConverterFlags = 0b10
)

func marshalAudioConverterFlags(p uintptr) (interface{}, error) {
	return AudioConverterFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AudioConverterFlags.
func (a AudioConverterFlags) String() string {
	if a == 0 {
		return "AudioConverterFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AudioConverterFlagNone:
			builder.WriteString("None|")
		case AudioConverterFlagInWritable:
			builder.WriteString("InWritable|")
		case AudioConverterFlagVariableRate:
			builder.WriteString("VariableRate|")
		default:
			builder.WriteString(fmt.Sprintf("AudioConverterFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AudioConverterFlags) Has(other AudioConverterFlags) bool {
	return (a & other) == other
}
