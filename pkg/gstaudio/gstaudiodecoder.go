// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void _gotk4_gstaudio1_AudioDecoderClass_flush(GstAudioDecoder*, gboolean);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_transform_meta(GstAudioDecoder*, GstBuffer*, GstMeta*, GstBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_stop(GstAudioDecoder*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_start(GstAudioDecoder*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_src_query(GstAudioDecoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_src_event(GstAudioDecoder*, GstEvent*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_sink_query(GstAudioDecoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_sink_event(GstAudioDecoder*, GstEvent*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_set_format(GstAudioDecoder*, GstCaps*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_propose_allocation(GstAudioDecoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_open(GstAudioDecoder*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_negotiate(GstAudioDecoder*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_decide_allocation(GstAudioDecoder*, GstQuery*);
// extern gboolean _gotk4_gstaudio1_AudioDecoderClass_close(GstAudioDecoder*);
// extern GstFlowReturn _gotk4_gstaudio1_AudioDecoderClass_parse(GstAudioDecoder*, GstAdapter*, gint*, gint*);
// extern GstFlowReturn _gotk4_gstaudio1_AudioDecoderClass_handle_frame(GstAudioDecoder*, GstBuffer*);
// extern GstCaps* _gotk4_gstaudio1_AudioDecoderClass_getcaps(GstAudioDecoder*, GstCaps*);
// GstCaps* _gotk4_gstaudio1_AudioDecoder_virtual_getcaps(void* fnptr, GstAudioDecoder* arg0, GstCaps* arg1) {
//   return ((GstCaps* (*)(GstAudioDecoder*, GstCaps*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstaudio1_AudioDecoder_virtual_handle_frame(void* fnptr, GstAudioDecoder* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstAudioDecoder*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstaudio1_AudioDecoder_virtual_parse(void* fnptr, GstAudioDecoder* arg0, GstAdapter* arg1, gint* arg2, gint* arg3) {
//   return ((GstFlowReturn (*)(GstAudioDecoder*, GstAdapter*, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_close(void* fnptr, GstAudioDecoder* arg0) {
//   return ((gboolean (*)(GstAudioDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_decide_allocation(void* fnptr, GstAudioDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_negotiate(void* fnptr, GstAudioDecoder* arg0) {
//   return ((gboolean (*)(GstAudioDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_open(void* fnptr, GstAudioDecoder* arg0) {
//   return ((gboolean (*)(GstAudioDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_propose_allocation(void* fnptr, GstAudioDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_set_format(void* fnptr, GstAudioDecoder* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_sink_event(void* fnptr, GstAudioDecoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_sink_query(void* fnptr, GstAudioDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_src_event(void* fnptr, GstAudioDecoder* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_src_query(void* fnptr, GstAudioDecoder* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioDecoder*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_start(void* fnptr, GstAudioDecoder* arg0) {
//   return ((gboolean (*)(GstAudioDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_stop(void* fnptr, GstAudioDecoder* arg0) {
//   return ((gboolean (*)(GstAudioDecoder*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioDecoder_virtual_transform_meta(void* fnptr, GstAudioDecoder* arg0, GstBuffer* arg1, GstMeta* arg2, GstBuffer* arg3) {
//   return ((gboolean (*)(GstAudioDecoder*, GstBuffer*, GstMeta*, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstaudio1_AudioDecoder_virtual_flush(void* fnptr, GstAudioDecoder* arg0, gboolean arg1) {
//   ((void (*)(GstAudioDecoder*, gboolean))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeAudioDecoder = coreglib.Type(C.gst_audio_decoder_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioDecoder, F: marshalAudioDecoder},
	})
}

// AUDIO_DECODER_MAX_ERRORS: default maximum number of errors tolerated before
// signaling error.
const AUDIO_DECODER_MAX_ERRORS = 10

// AUDIO_DECODER_SINK_NAME: name of the templates for the sink pad.
const AUDIO_DECODER_SINK_NAME = "sink"

// AUDIO_DECODER_SRC_NAME: name of the templates for the source pad.
const AUDIO_DECODER_SRC_NAME = "src"

// AudioDecoderOverrides contains methods that are overridable.
type AudioDecoderOverrides struct {
	// The function returns the following values:
	//
	Close func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DecideAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	Flush func(hard bool)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	caps func(filter *gst.Caps) *gst.Caps
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	HandleFrame func(buffer *gst.Buffer) gst.FlowReturn
	// Negotiate with downstream elements to currently configured AudioInfo.
	// Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
	// negotiate fails.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the negotiation succeeded, else FALSE.
	//
	Negotiate func() bool
	// The function returns the following values:
	//
	Open func() bool
	// The function takes the following parameters:
	//
	//    - adapter
	//    - offset
	//    - length
	//
	// The function returns the following values:
	//
	Parse func(adapter *gstbase.Adapter, offset, length *int) gst.FlowReturn
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProposeAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SetFormat func(caps *gst.Caps) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SinkQuery func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcEvent func(event *gst.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SrcQuery func(query *gst.Query) bool
	// The function returns the following values:
	//
	Start func() bool
	// The function returns the following values:
	//
	Stop func() bool
	// The function takes the following parameters:
	//
	//    - outbuf
	//    - meta
	//    - inbuf
	//
	// The function returns the following values:
	//
	TransformMeta func(outbuf *gst.Buffer, meta *gst.Meta, inbuf *gst.Buffer) bool
}

func defaultAudioDecoderOverrides(v *AudioDecoder) AudioDecoderOverrides {
	return AudioDecoderOverrides{
		Close:             v.close,
		DecideAllocation:  v.decideAllocation,
		Flush:             v.flush,
		caps:              v.caps,
		HandleFrame:       v.handleFrame,
		Negotiate:         v.negotiate,
		Open:              v.open,
		Parse:             v.parse,
		ProposeAllocation: v.proposeAllocation,
		SetFormat:         v.setFormat,
		SinkEvent:         v.sinkEvent,
		SinkQuery:         v.sinkQuery,
		SrcEvent:          v.srcEvent,
		SrcQuery:          v.srcQuery,
		Start:             v.start,
		Stop:              v.stop,
		TransformMeta:     v.transformMeta,
	}
}

// AudioDecoder: this base class is for audio decoders turning encoded data into
// raw audio samples.
//
// GstAudioDecoder and subclass should cooperate as follows.
//
// Configuration
//
//    * Initially, GstAudioDecoder calls start when the decoder element
//      is activated, which allows subclass to perform any global setup.
//      Base class (context) parameters can already be set according to subclass
//      capabilities (or possibly upon receive more information in subsequent
//      set_format).
//    * GstAudioDecoder calls set_format to inform subclass of the format
//      of input audio data that it is about to receive.
//      While unlikely, it might be called more than once, if changing input
//      parameters require reconfiguration.
//    * GstAudioDecoder calls stop at end of all processing.
//
// As of configuration stage, and throughout processing, GstAudioDecoder
// provides various (context) parameters, e.g. describing the format of output
// audio data (valid when output caps have been set) or current parsing state.
// Conversely, subclass can and should configure context to inform base class of
// its expectation w.r.t. buffer handling.
//
// Data processing
//
//    * Base class gathers input data, and optionally allows subclass
//      to parse this into subsequently manageable (as defined by subclass)
//      chunks.  Such chunks are subsequently referred to as 'frames',
//      though they may or may not correspond to 1 (or more) audio format frame.
//    * Input frame is provided to subclass' handle_frame.
//    * If codec processing results in decoded data, subclass should call
//      gst_audio_decoder_finish_frame to have decoded data pushed
//      downstream.
//    * Just prior to actually pushing a buffer downstream,
//      it is passed to pre_push.  Subclass should either use this callback
//      to arrange for additional downstream pushing or otherwise ensure such
//      custom pushing occurs after at least a method call has finished since
//      setting src pad caps.
//    * During the parsing process GstAudioDecoderClass will handle both
//      srcpad and sinkpad events. Sink events will be passed to subclass
//      if event callback has been provided.
//
// Shutdown phase
//
//    * GstAudioDecoder class calls stop to inform the subclass that data
//      parsing will be stopped.
//
// Subclass is responsible for providing pad template caps for source and sink
// pads. The pads need to be named "sink" and "src". It also needs to set the
// fixed caps on srcpad, when the format is ensured. This is typically when base
// class calls subclass' set_format function, though it might be delayed until
// calling gst_audio_decoder_finish_frame.
//
// In summary, above process should have subclass concentrating on codec data
// processing while leaving other matters to base class, such as most notably
// timestamp handling. While it may exert more control in this area (see e.g.
// pre_push), it is very much not recommended.
//
// In particular, base class will try to arrange for perfect output timestamps
// as much as possible while tracking upstream timestamps. To this end, if
// deviation between the next ideal expected perfect timestamp and upstream
// exceeds AudioDecoder:tolerance, then resync to upstream occurs (which would
// happen always if the tolerance mechanism is disabled).
//
// In non-live pipelines, baseclass can also (configurably) arrange for output
// buffer aggregation which may help to redue large(r) numbers of small(er)
// buffers being pushed and processed downstream. Note that this feature is only
// available if the buffer layout is interleaved. For planar buffers, the
// decoder implementation is fully responsible for the output buffer size.
//
// On the other hand, it should be noted that baseclass only provides limited
// seeking support (upon explicit subclass request), as full-fledged support
// should rather be left to upstream demuxer, parser or alike. This simple
// approach caters for seeking and duration reporting using estimated input
// bitrates.
//
// Things that subclass need to take care of:
//
//    * Provide pad templates
//    * Set source pad caps when appropriate
//    * Set user-configurable properties to sane defaults for format and
//       implementing codec at hand, and convey some subclass capabilities and
//       expectations in context.
//
//    * Accept data in handle_frame and provide encoded results to
//       gst_audio_decoder_finish_frame.  If it is prepared to perform
//       PLC, it should also accept NULL data in handle_frame and provide for
//       data for indicated duration.
type AudioDecoder struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*AudioDecoder)(nil)
)

// AudioDecoderer describes types inherited from class AudioDecoder.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioDecoderer interface {
	coreglib.Objector
	baseAudioDecoder() *AudioDecoder
}

var _ AudioDecoderer = (*AudioDecoder)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioDecoder, *AudioDecoderClass, AudioDecoderOverrides](
		GTypeAudioDecoder,
		initAudioDecoderClass,
		wrapAudioDecoder,
		defaultAudioDecoderOverrides,
	)
}

func initAudioDecoderClass(gclass unsafe.Pointer, overrides AudioDecoderOverrides, classInitFunc func(*AudioDecoderClass)) {
	pclass := (*C.GstAudioDecoderClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioDecoder))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_close)
	}

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_decide_allocation)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_flush)
	}

	if overrides.caps != nil {
		pclass.getcaps = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_getcaps)
	}

	if overrides.HandleFrame != nil {
		pclass.handle_frame = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_handle_frame)
	}

	if overrides.Negotiate != nil {
		pclass.negotiate = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_negotiate)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_open)
	}

	if overrides.Parse != nil {
		pclass.parse = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_parse)
	}

	if overrides.ProposeAllocation != nil {
		pclass.propose_allocation = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_propose_allocation)
	}

	if overrides.SetFormat != nil {
		pclass.set_format = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_set_format)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_sink_event)
	}

	if overrides.SinkQuery != nil {
		pclass.sink_query = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_sink_query)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_src_event)
	}

	if overrides.SrcQuery != nil {
		pclass.src_query = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_src_query)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_stop)
	}

	if overrides.TransformMeta != nil {
		pclass.transform_meta = (*[0]byte)(C._gotk4_gstaudio1_AudioDecoderClass_transform_meta)
	}

	if classInitFunc != nil {
		class := (*AudioDecoderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioDecoder(obj *coreglib.Object) *AudioDecoder {
	return &AudioDecoder{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalAudioDecoder(p uintptr) (interface{}, error) {
	return wrapAudioDecoder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (dec *AudioDecoder) baseAudioDecoder() *AudioDecoder {
	return dec
}

// BaseAudioDecoder returns the underlying base object.
func BaseAudioDecoder(obj AudioDecoderer) *AudioDecoder {
	return obj.baseAudioDecoder()
}

// AllocateOutputBuffer: helper function that allocates a buffer to hold an
// audio frame for dec's current output format.
//
// The function takes the following parameters:
//
//    - size of the buffer.
//
// The function returns the following values:
//
//    - buffer: allocated buffer.
//
func (dec *AudioDecoder) AllocateOutputBuffer(size uint) *gst.Buffer {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gsize            // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = C.gsize(size)

	_cret = C.gst_audio_decoder_allocate_output_buffer(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// FinishFrame collects decoded data and pushes it downstream.
//
// buf may be NULL in which case the indicated number of frames are discarded
// and considered to have produced no output (e.g. lead-in or setup frames).
// Otherwise, source pad caps must be set when it is called with valid data in
// buf.
//
// Note that a frame received in AudioDecoderClass.handle_frame() may be
// invalidated by a call to this function.
//
// The function takes the following parameters:
//
//    - buf (optional): decoded data.
//    - frames: number of decoded frames represented by decoded data.
//
// The function returns the following values:
//
//    - flowReturn that should be escalated to caller (of caller).
//
func (dec *AudioDecoder) FinishFrame(buf *gst.Buffer, frames int) gst.FlowReturn {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstBuffer       // out
	var _arg2 C.gint             // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if buf != nil {
		_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf)), nil)
	}
	_arg2 = C.gint(frames)

	_cret = C.gst_audio_decoder_finish_frame(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(frames)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// FinishSubframe collects decoded data and pushes it downstream. This function
// may be called multiple times for a given input frame.
//
// buf may be NULL in which case it is assumed that the current input frame is
// finished. This is equivalent to calling gst_audio_decoder_finish_subframe()
// with a NULL buffer and frames=1 after having pushed out all decoded audio
// subframes using this function.
//
// When called with valid data in buf the source pad caps must have been set
// already.
//
// Note that a frame received in AudioDecoderClass.handle_frame() may be
// invalidated by a call to this function.
//
// The function takes the following parameters:
//
//    - buf (optional): decoded data.
//
// The function returns the following values:
//
//    - flowReturn that should be escalated to caller (of caller).
//
func (dec *AudioDecoder) FinishSubframe(buf *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstBuffer       // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if buf != nil {
		_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf)), nil)
	}

	_cret = C.gst_audio_decoder_finish_subframe(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(buf)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Allocator lets AudioDecoder sub-classes to know the memory allocator used by
// the base class and its params.
//
// Unref the allocator after use it.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) the AllocationParams of allocator.
//
func (dec *AudioDecoder) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstAudioDecoder    // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	C.gst_audio_decoder_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(dec)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_params)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocator, _params
}

// The function returns the following values:
//
//    - audioInfo describing the input audio format.
//
func (dec *AudioDecoder) AudioInfo() *AudioInfo {
	var _arg0 *C.GstAudioDecoder // out
	var _cret *C.GstAudioInfo    // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_audio_info(_arg0)
	runtime.KeepAlive(dec)

	var _audioInfo *AudioInfo // out

	_audioInfo = (*AudioInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _audioInfo
}

// The function returns the following values:
//
//    - gint: currently configured decoder delay.
//
func (dec *AudioDecoder) Delay() int {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_delay(_arg0)
	runtime.KeepAlive(dec)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Drainable queries decoder drain handling.
//
// The function returns the following values:
//
//    - ok: TRUE if drainable handling is enabled.
//
//      MT safe.
//
func (dec *AudioDecoder) Drainable() bool {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_drainable(_arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - gint: currently configured byte to time conversion setting.
//
func (dec *AudioDecoder) EstimateRate() int {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_estimate_rate(_arg0)
	runtime.KeepAlive(dec)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Latency sets the variables pointed to by min and max to the currently
// configured latency.
//
// The function returns the following values:
//
//    - min (optional): pointer to storage to hold minimum latency.
//    - max (optional): pointer to storage to hold maximum latency.
//
func (dec *AudioDecoder) Latency() (min, max gst.ClockTime) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.GstClockTime     // in
	var _arg2 C.GstClockTime     // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	C.gst_audio_decoder_get_latency(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(dec)

	var _min gst.ClockTime // out
	var _max gst.ClockTime // out

	_min = uint64(_arg1)
	type _ = gst.ClockTime
	type _ = uint64
	_max = uint64(_arg2)
	type _ = gst.ClockTime
	type _ = uint64

	return _min, _max
}

// The function returns the following values:
//
//    - gint: currently configured decoder tolerated error count.
//
func (dec *AudioDecoder) MaxErrors() int {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_max_errors(_arg0)
	runtime.KeepAlive(dec)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MinLatency queries decoder's latency aggregation.
//
// The function returns the following values:
//
//    - clockTime: aggregation latency.
//
//      MT safe.
//
func (dec *AudioDecoder) MinLatency() gst.ClockTime {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.GstClockTime     // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_min_latency(_arg0)
	runtime.KeepAlive(dec)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// NeedsFormat queries decoder required format handling.
//
// The function returns the following values:
//
//    - ok: TRUE if required format handling is enabled.
//
//      MT safe.
//
func (dec *AudioDecoder) NeedsFormat() bool {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_needs_format(_arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseState: return current parsing (sync and eos) state.
//
// The function returns the following values:
//
//    - sync (optional): pointer to a variable to hold the current sync state.
//    - eos (optional): pointer to a variable to hold the current eos state.
//
func (dec *AudioDecoder) ParseState() (sync, eos bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // in
	var _arg2 C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	C.gst_audio_decoder_get_parse_state(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(dec)

	var _sync bool // out
	var _eos bool  // out

	if _arg1 != 0 {
		_sync = true
	}
	if _arg2 != 0 {
		_eos = true
	}

	return _sync, _eos
}

// Plc queries decoder packet loss concealment handling.
//
// The function returns the following values:
//
//    - ok: TRUE if packet loss concealment is enabled.
//
//      MT safe.
//
func (dec *AudioDecoder) Plc() bool {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_plc(_arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - gint: currently configured plc handling.
//
func (dec *AudioDecoder) PlcAware() int {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gint             // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_plc_aware(_arg0)
	runtime.KeepAlive(dec)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tolerance queries current audio jitter tolerance threshold.
//
// The function returns the following values:
//
//    - clockTime: decoder audio jitter tolerance threshold.
//
//      MT safe.
//
func (dec *AudioDecoder) Tolerance() gst.ClockTime {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.GstClockTime     // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_get_tolerance(_arg0)
	runtime.KeepAlive(dec)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Negotiate with downstream elements to currently configured AudioInfo. Unmark
// GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if negotiate
// fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (dec *AudioDecoder) Negotiate() bool {
	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C.gst_audio_decoder_negotiate(_arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyGetcaps returns caps that express caps (or sink template caps if caps ==
// NULL) restricted to rate/channels/... combinations supported by downstream
// elements.
//
// The function takes the following parameters:
//
//    - caps (optional): initial caps.
//    - filter (optional) caps.
//
// The function returns the following values:
//
//    - ret owned by caller.
//
func (decoder *AudioDecoder) ProxyGetcaps(caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstCaps         // out
	var _arg2 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	if filter != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_audio_decoder_proxy_getcaps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// SetAllocationCaps sets a caps in allocation query which are different from
// the set pad's caps. Use this function before calling
// gst_audio_decoder_negotiate(). Setting to NULL the allocation query will use
// the caps from the pad.
//
// The function takes the following parameters:
//
//    - allocationCaps (optional) or NULL.
//
func (dec *AudioDecoder) SetAllocationCaps(allocationCaps *gst.Caps) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstCaps         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if allocationCaps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(allocationCaps)))
	}

	C.gst_audio_decoder_set_allocation_caps(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(allocationCaps)
}

// SetDrainable configures decoder drain handling. If drainable, subclass might
// be handed a NULL buffer to have it return any leftover decoded data.
// Otherwise, it is not considered so capable and will only ever be passed real
// data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (dec *AudioDecoder) SetDrainable(enabled bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_decoder_set_drainable(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetEstimateRate allows baseclass to perform byte to time estimated
// conversion.
//
// The function takes the following parameters:
//
//    - enabled: whether to enable byte to time conversion.
//
func (dec *AudioDecoder) SetEstimateRate(enabled bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_decoder_set_estimate_rate(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetLatency sets decoder latency.
//
// The function takes the following parameters:
//
//    - min: minimum latency.
//    - max: maximum latency.
//
func (dec *AudioDecoder) SetLatency(min, max gst.ClockTime) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.GstClockTime     // out
	var _arg2 C.GstClockTime     // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = C.guint64(min)
	type _ = gst.ClockTime
	type _ = uint64
	_arg2 = C.guint64(max)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_decoder_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetMaxErrors sets numbers of tolerated decoder errors, where a tolerated one
// is then only warned about, but more than tolerated will lead to fatal error.
// You can set -1 for never returning fatal errors. Default is set to
// GST_AUDIO_DECODER_MAX_ERRORS.
//
// The function takes the following parameters:
//
//    - num: max tolerated errors.
//
func (dec *AudioDecoder) SetMaxErrors(num int) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = C.gint(num)

	C.gst_audio_decoder_set_max_errors(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(num)
}

// SetMinLatency sets decoder minimum aggregation latency.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - num: new minimum latency.
//
func (dec *AudioDecoder) SetMinLatency(num gst.ClockTime) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.GstClockTime     // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = C.guint64(num)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_decoder_set_min_latency(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(num)
}

// SetNeedsFormat configures decoder format needs. If enabled, subclass needs to
// be negotiated with format caps before it can process any data. It will then
// never be handed any data before it has been configured. Otherwise, it might
// be handed data without having been configured and is then expected being able
// to do so either by default or based on the input data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (dec *AudioDecoder) SetNeedsFormat(enabled bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_decoder_set_needs_format(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetOutputCaps: configure output caps on the srcpad of dec. Similar to
// gst_audio_decoder_set_output_format(), but allows subclasses to specify
// output caps that can't be expressed via AudioInfo e.g. caps that have caps
// features.
//
// The function takes the following parameters:
//
//    - caps: (fixed) Caps.
//
// The function returns the following values:
//
//    - ok: TRUE on success.
//
func (dec *AudioDecoder) SetOutputCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstCaps         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_audio_decoder_set_output_caps(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetOutputFormat: configure output info on the srcpad of dec.
//
// The function takes the following parameters:
//
//    - info: AudioInfo.
//
// The function returns the following values:
//
//    - ok: TRUE on success.
//
func (dec *AudioDecoder) SetOutputFormat(info *AudioInfo) bool {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstAudioInfo    // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_audio_decoder_set_output_format(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPlc: enable or disable decoder packet loss concealment, provided subclass
// and codec are capable and allow handling plc.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - enabled: new state.
//
func (dec *AudioDecoder) SetPlc(enabled bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_audio_decoder_set_plc(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(enabled)
}

// SetPlcAware indicates whether or not subclass handles packet loss concealment
// (plc).
//
// The function takes the following parameters:
//
//    - plc: new plc state.
//
func (dec *AudioDecoder) SetPlcAware(plc bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if plc {
		_arg1 = C.TRUE
	}

	C.gst_audio_decoder_set_plc_aware(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(plc)
}

// SetTolerance configures decoder audio jitter tolerance threshold.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - tolerance: new tolerance.
//
func (dec *AudioDecoder) SetTolerance(tolerance gst.ClockTime) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.GstClockTime     // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = C.guint64(tolerance)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_decoder_set_tolerance(_arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(tolerance)
}

// SetUseDefaultPadAcceptcaps lets AudioDecoder sub-classes decide if they want
// the sink pad to use the default pad query handler to reply to accept-caps
// queries.
//
// By setting this to true it is possible to further customize the default
// handler with GST_PAD_SET_ACCEPT_INTERSECT and GST_PAD_SET_ACCEPT_TEMPLATE.
//
// The function takes the following parameters:
//
//    - use: if the default pad accept-caps query handling should be used.
//
func (decoder *AudioDecoder) SetUseDefaultPadAcceptcaps(use bool) {
	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(decoder).Native()))
	if use {
		_arg1 = C.TRUE
	}

	C.gst_audio_decoder_set_use_default_pad_acceptcaps(_arg0, _arg1)
	runtime.KeepAlive(decoder)
	runtime.KeepAlive(use)
}

// The function returns the following values:
//
func (dec *AudioDecoder) close() bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.close

	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (dec *AudioDecoder) flush(hard bool) {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.flush

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	if hard {
		_arg1 = C.TRUE
	}

	C._gotk4_gstaudio1_AudioDecoder_virtual_flush(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(hard)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) caps(filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.getcaps

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstCaps         // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_getcaps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) handleFrame(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.handle_frame

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstBuffer       // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_handle_frame(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Negotiate: negotiate with downstream elements to currently configured
// AudioInfo. Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it
// again if negotiate fails.
//
// The function returns the following values:
//
//    - ok: TRUE if the negotiation succeeded, else FALSE.
//
func (dec *AudioDecoder) negotiate() bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.negotiate

	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_negotiate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (dec *AudioDecoder) open() bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.open

	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - adapter
//    - offset
//    - length
//
// The function returns the following values:
//
func (dec *AudioDecoder) parse(adapter *gstbase.Adapter, offset, length *int) gst.FlowReturn {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.parse

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstAdapter      // out
	var _arg2 *C.gint            // out
	var _arg3 *C.gint            // out
	var _cret C.GstFlowReturn    // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstAdapter)(unsafe.Pointer(coreglib.InternObject(adapter).Native()))
	_arg2 = (*C.gint)(unsafe.Pointer(offset))
	_arg3 = (*C.gint)(unsafe.Pointer(length))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_parse(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(adapter)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(length)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) proposeAllocation(query *gst.Query) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.propose_allocation

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_propose_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) setFormat(caps *gst.Caps) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.set_format

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstCaps         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_set_format(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.sink_event

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) sinkQuery(query *gst.Query) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.sink_query

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_sink_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.src_event

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstEvent        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (dec *AudioDecoder) srcQuery(query *gst.Query) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.src_query

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstQuery        // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_src_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dec)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (dec *AudioDecoder) start() bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.start

	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (dec *AudioDecoder) stop() bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(dec))
	fnarg := gclass.stop

	var _arg0 *C.GstAudioDecoder // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(dec).Native()))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - outbuf
//    - meta
//    - inbuf
//
// The function returns the following values:
//
func (enc *AudioDecoder) transformMeta(outbuf *gst.Buffer, meta *gst.Meta, inbuf *gst.Buffer) bool {
	gclass := (*C.GstAudioDecoderClass)(coreglib.PeekParentClass(enc))
	fnarg := gclass.transform_meta

	var _arg0 *C.GstAudioDecoder // out
	var _arg1 *C.GstBuffer       // out
	var _arg2 *C.GstMeta         // out
	var _arg3 *C.GstBuffer       // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstAudioDecoder)(unsafe.Pointer(coreglib.InternObject(enc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))
	_arg2 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))

	_cret = C._gotk4_gstaudio1_AudioDecoder_virtual_transform_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(enc)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(inbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioDecoderClass subclasses can override any of the available virtual
// methods or not, as needed. At minimum handle_frame (and likely set_format)
// needs to be overridden.
//
// An instance of this type is always passed by reference.
type AudioDecoderClass struct {
	*audioDecoderClass
}

// audioDecoderClass is the struct that's finalized.
type audioDecoderClass struct {
	native *C.GstAudioDecoderClass
}

// ElementClass: parent class structure.
func (a *AudioDecoderClass) ElementClass() *gst.ElementClass {
	valptr := &a.native.element_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
