// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void _gotk4_gstaudio1_AudioCdSrcClass_close(GstAudioCdSrc*);
// extern gboolean _gotk4_gstaudio1_AudioCdSrcClass_open(GstAudioCdSrc*, gchar*);
// extern GstBuffer* _gotk4_gstaudio1_AudioCdSrcClass_read_sector(GstAudioCdSrc*, gint);
// GstBuffer* _gotk4_gstaudio1_AudioCdSrc_virtual_read_sector(void* fnptr, GstAudioCdSrc* arg0, gint arg1) {
//   return ((GstBuffer* (*)(GstAudioCdSrc*, gint))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioCdSrc_virtual_open(void* fnptr, GstAudioCdSrc* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstAudioCdSrc*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstaudio1_AudioCdSrc_virtual_close(void* fnptr, GstAudioCdSrc* arg0) {
//   ((void (*)(GstAudioCdSrc*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioCdSrcMode = coreglib.Type(C.gst_audio_cd_src_mode_get_type())
	GTypeAudioCdSrc     = coreglib.Type(C.gst_audio_cd_src_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioCdSrcMode, F: marshalAudioCdSrcMode},
		coreglib.TypeMarshaler{T: GTypeAudioCdSrc, F: marshalAudioCdSrc},
	})
}

// AudioCdSrcMode: mode in which the CD audio source operates. Influences
// timestamping, EOS handling and seeking.
type AudioCdSrcMode C.gint

const (
	// AudioCdSrcModeNormal: each single track is a stream.
	AudioCdSrcModeNormal AudioCdSrcMode = iota
	// AudioCdSrcModeContinuous: entire disc is a single stream.
	AudioCdSrcModeContinuous
)

func marshalAudioCdSrcMode(p uintptr) (interface{}, error) {
	return AudioCdSrcMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioCdSrcMode.
func (a AudioCdSrcMode) String() string {
	switch a {
	case AudioCdSrcModeNormal:
		return "Normal"
	case AudioCdSrcModeContinuous:
		return "Continuous"
	default:
		return fmt.Sprintf("AudioCdSrcMode(%d)", a)
	}
}

// AudioCdSrcOverrides contains methods that are overridable.
type AudioCdSrcOverrides struct {
	Close func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Open func(device string) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ReadSector func(sector int) *gst.Buffer
}

func defaultAudioCdSrcOverrides(v *AudioCdSrc) AudioCdSrcOverrides {
	return AudioCdSrcOverrides{
		Close:      v.close,
		Open:       v.open,
		ReadSector: v.readSector,
	}
}

// AudioCdSrc provides a base class for CD digital audio (CDDA) sources, which
// handles things like seeking, querying, discid calculation, tags, and buffer
// timestamping.
//
//
// Using GstAudioCdSrc-based elements in applications
//
// GstAudioCdSrc registers two Format<!-- -->s of its own, namely the "track"
// format and the "sector" format. Applications will usually only find the
// "track" format interesting. You can retrieve that Format for use in seek
// events or queries with gst_format_get_by_nick("track").
//
// In order to query the number of tracks, for example, an application would set
// the CDDA source element to READY or PAUSED state and then query the the
// number of tracks via gst_element_query_duration() using the track format
// acquired above. Applications can query the currently playing track in the
// same way.
//
// Alternatively, applications may retrieve the currently playing track and the
// total number of tracks from the taglist that will posted on the bus whenever
// the CD is opened or the currently playing track changes. The taglist will
// contain GST_TAG_TRACK_NUMBER and GST_TAG_TRACK_COUNT tags.
//
// Applications playing back CD audio using playbin and cdda://n URIs should
// issue a seek command in track format to change between tracks, rather than
// setting a new cdda://n+1 URI on playbin (as setting a new URI on playbin
// involves closing and re-opening the CD device, which is much much slower).
//
//
// Tags and meta-information
//
// CDDA sources will automatically emit a number of tags, details about which
// can be found in the libgsttag documentation. Those tags are:
// T_TAG_CDDA_CDDB_DISCID, T_TAG_CDDA_CDDB_DISCID_FULL,
// T_TAG_CDDA_MUSICBRAINZ_DISCID, T_TAG_CDDA_MUSICBRAINZ_DISCID_FULL, among
// others.
//
// Tracks and Table of Contents (TOC)
//
// Applications will be informed of the available tracks via a TOC message on
// the pipeline's Bus. The Toc will contain a TocEntry for each track, with
// information about each track. The duration for each track can be retrieved
// via the T_TAG_DURATION tag from each entry's tag list, or calculated via
// gst_toc_entry_get_start_stop_times(). The track entries in the TOC will be
// sorted by track number.
type AudioCdSrc struct {
	_ [0]func() // equal guard
	gstbase.PushSrc

	gst.URIHandler
}

var (
	_ gstbase.BaseSrcer = (*AudioCdSrc)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioCdSrc, *AudioCdSrcClass, AudioCdSrcOverrides](
		GTypeAudioCdSrc,
		initAudioCdSrcClass,
		wrapAudioCdSrc,
		defaultAudioCdSrcOverrides,
	)
}

func initAudioCdSrcClass(gclass unsafe.Pointer, overrides AudioCdSrcOverrides, classInitFunc func(*AudioCdSrcClass)) {
	pclass := (*C.GstAudioCdSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioCdSrc))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstaudio1_AudioCdSrcClass_close)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstaudio1_AudioCdSrcClass_open)
	}

	if overrides.ReadSector != nil {
		pclass.read_sector = (*[0]byte)(C._gotk4_gstaudio1_AudioCdSrcClass_read_sector)
	}

	if classInitFunc != nil {
		class := (*AudioCdSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioCdSrc(obj *coreglib.Object) *AudioCdSrc {
	return &AudioCdSrc{
		PushSrc: gstbase.PushSrc{
			BaseSrc: gstbase.BaseSrc{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
		URIHandler: gst.URIHandler{
			Object: obj,
		},
	}
}

func marshalAudioCdSrc(p uintptr) (interface{}, error) {
	return wrapAudioCdSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddTrack: CDDA sources use this function from their start vfunc to announce
// the available data and audio tracks to the base source class. The caller
// should allocate track on the stack, the base source will do a shallow copy of
// the structure (and take ownership of the taglist if there is one).
//
// The function takes the following parameters:
//
//    - track address of AudioCdSrcTrack to add.
//
// The function returns the following values:
//
//    - ok: FALSE on error, otherwise TRUE.
//
func (src *AudioCdSrc) AddTrack(track *AudioCdSrcTrack) bool {
	var _arg0 *C.GstAudioCdSrc      // out
	var _arg1 *C.GstAudioCdSrcTrack // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioCdSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstAudioCdSrcTrack)(gextras.StructNative(unsafe.Pointer(track)))

	_cret = C.gst_audio_cd_src_add_track(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(track)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (src *AudioCdSrc) close() {
	gclass := (*C.GstAudioCdSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.close

	var _arg0 *C.GstAudioCdSrc // out

	_arg0 = (*C.GstAudioCdSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	C._gotk4_gstaudio1_AudioCdSrc_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *AudioCdSrc) open(device string) bool {
	gclass := (*C.GstAudioCdSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.open

	var _arg0 *C.GstAudioCdSrc // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstAudioCdSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(device)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gstaudio1_AudioCdSrc_virtual_open(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *AudioCdSrc) readSector(sector int) *gst.Buffer {
	gclass := (*C.GstAudioCdSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.read_sector

	var _arg0 *C.GstAudioCdSrc // out
	var _arg1 C.gint           // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstAudioCdSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.gint(sector)

	_cret = C._gotk4_gstaudio1_AudioCdSrc_virtual_read_sector(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(sector)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// AudioCdSrcClass: audio CD source base class.
//
// An instance of this type is always passed by reference.
type AudioCdSrcClass struct {
	*audioCdSrcClass
}

// audioCdSrcClass is the struct that's finalized.
type audioCdSrcClass struct {
	native *C.GstAudioCdSrcClass
}

// PushsrcClass: parent class.
func (a *AudioCdSrcClass) PushsrcClass() *gstbase.PushSrcClass {
	valptr := &a.native.pushsrc_class
	var _v *gstbase.PushSrcClass // out
	_v = (*gstbase.PushSrcClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AudioCdSrcTrack: CD track abstraction to communicate TOC entries to the base
// class.
//
// This structure is only for use by sub-classed in connection with
// gst_audio_cd_src_add_track().
//
// Applications will be informed of the available tracks via a TOC message on
// the pipeline's Bus instead.
//
// An instance of this type is always passed by reference.
type AudioCdSrcTrack struct {
	*audioCdSrcTrack
}

// audioCdSrcTrack is the struct that's finalized.
type audioCdSrcTrack struct {
	native *C.GstAudioCdSrcTrack
}

// IsAudio: whether this is an audio track.
func (a *AudioCdSrcTrack) IsAudio() bool {
	valptr := &a.native.is_audio
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Num: track number in TOC (usually starts from 1, but not always).
func (a *AudioCdSrcTrack) Num() uint {
	valptr := &a.native.num
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Start: first sector of this track (LBA).
func (a *AudioCdSrcTrack) Start() uint {
	valptr := &a.native.start
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// End: last sector of this track (LBA).
func (a *AudioCdSrcTrack) End() uint {
	valptr := &a.native.end
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// IsAudio: whether this is an audio track.
func (a *AudioCdSrcTrack) SetIsAudio(isAudio bool) {
	valptr := &a.native.is_audio
	if isAudio {
		*valptr = C.TRUE
	}
}

// Num: track number in TOC (usually starts from 1, but not always).
func (a *AudioCdSrcTrack) SetNum(num uint) {
	valptr := &a.native.num
	*valptr = C.guint(num)
}

// Start: first sector of this track (LBA).
func (a *AudioCdSrcTrack) SetStart(start uint) {
	valptr := &a.native.start
	*valptr = C.guint(start)
}

// End: last sector of this track (LBA).
func (a *AudioCdSrcTrack) SetEnd(end uint) {
	valptr := &a.native.end
	*valptr = C.guint(end)
}
