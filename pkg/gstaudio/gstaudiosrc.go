// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gstbase"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void _gotk4_gstaudio1_AudioSrcClass_reset(GstAudioSrc*);
// extern guint _gotk4_gstaudio1_AudioSrcClass_read(GstAudioSrc*, gpointer, guint, GstClockTime*);
// extern guint _gotk4_gstaudio1_AudioSrcClass_delay(GstAudioSrc*);
// extern gboolean _gotk4_gstaudio1_AudioSrcClass_unprepare(GstAudioSrc*);
// extern gboolean _gotk4_gstaudio1_AudioSrcClass_prepare(GstAudioSrc*, GstAudioRingBufferSpec*);
// extern gboolean _gotk4_gstaudio1_AudioSrcClass_open(GstAudioSrc*);
// extern gboolean _gotk4_gstaudio1_AudioSrcClass_close(GstAudioSrc*);
// gboolean _gotk4_gstaudio1_AudioSrc_virtual_close(void* fnptr, GstAudioSrc* arg0) {
//   return ((gboolean (*)(GstAudioSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioSrc_virtual_open(void* fnptr, GstAudioSrc* arg0) {
//   return ((gboolean (*)(GstAudioSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioSrc_virtual_prepare(void* fnptr, GstAudioSrc* arg0, GstAudioRingBufferSpec* arg1) {
//   return ((gboolean (*)(GstAudioSrc*, GstAudioRingBufferSpec*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioSrc_virtual_unprepare(void* fnptr, GstAudioSrc* arg0) {
//   return ((gboolean (*)(GstAudioSrc*))(fnptr))(arg0);
// };
// guint _gotk4_gstaudio1_AudioSrc_virtual_delay(void* fnptr, GstAudioSrc* arg0) {
//   return ((guint (*)(GstAudioSrc*))(fnptr))(arg0);
// };
// guint _gotk4_gstaudio1_AudioSrc_virtual_read(void* fnptr, GstAudioSrc* arg0, gpointer arg1, guint arg2, GstClockTime* arg3) {
//   return ((guint (*)(GstAudioSrc*, gpointer, guint, GstClockTime*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstaudio1_AudioSrc_virtual_reset(void* fnptr, GstAudioSrc* arg0) {
//   ((void (*)(GstAudioSrc*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioSrc = coreglib.Type(C.gst_audio_src_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioSrc, F: marshalAudioSrc},
	})
}

// AudioSrcOverrides contains methods that are overridable.
type AudioSrcOverrides struct {
	// The function returns the following values:
	//
	Close func() bool
	// The function returns the following values:
	//
	Delay func() uint
	// The function returns the following values:
	//
	Open func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Prepare func(spec *AudioRingBufferSpec) bool
	// The function takes the following parameters:
	//
	//    - data (optional)
	//    - length
	//    - timestamp
	//
	// The function returns the following values:
	//
	Read  func(data unsafe.Pointer, length uint, timestamp *gst.ClockTime) uint
	Reset func()
	// The function returns the following values:
	//
	Unprepare func() bool
}

func defaultAudioSrcOverrides(v *AudioSrc) AudioSrcOverrides {
	return AudioSrcOverrides{
		Close:     v.close,
		Delay:     v.delay,
		Open:      v.open,
		Prepare:   v.prepare,
		Read:      v.read,
		Reset:     v.reset,
		Unprepare: v.unprepare,
	}
}

// AudioSrc: this is the most simple base class for audio sources that only
// requires subclasses to implement a set of simple functions:
//
// * open() :Open the device. * prepare() :Configure the device with the
// specified format. * read() :Read samples from the device. * reset() :Unblock
// reads and flush the device. * delay() :Get the number of samples in the
// device but not yet read. * unprepare() :Undo operations done by prepare. *
// close() :Close the device.
//
// All scheduling of samples and timestamps is done in this base class together
// with AudioBaseSrc using a default implementation of a AudioRingBuffer that
// uses threads.
type AudioSrc struct {
	_ [0]func() // equal guard
	AudioBaseSrc
}

var (
	_ gstbase.BaseSrcer = (*AudioSrc)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AudioSrc, *AudioSrcClass, AudioSrcOverrides](
		GTypeAudioSrc,
		initAudioSrcClass,
		wrapAudioSrc,
		defaultAudioSrcOverrides,
	)
}

func initAudioSrcClass(gclass unsafe.Pointer, overrides AudioSrcOverrides, classInitFunc func(*AudioSrcClass)) {
	pclass := (*C.GstAudioSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioSrc))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_close)
	}

	if overrides.Delay != nil {
		pclass.delay = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_delay)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_open)
	}

	if overrides.Prepare != nil {
		pclass.prepare = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_prepare)
	}

	if overrides.Read != nil {
		pclass.read = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_read)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_reset)
	}

	if overrides.Unprepare != nil {
		pclass.unprepare = (*[0]byte)(C._gotk4_gstaudio1_AudioSrcClass_unprepare)
	}

	if classInitFunc != nil {
		class := (*AudioSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioSrc(obj *coreglib.Object) *AudioSrc {
	return &AudioSrc{
		AudioBaseSrc: AudioBaseSrc{
			PushSrc: gstbase.PushSrc{
				BaseSrc: gstbase.BaseSrc{
					Element: gst.Element{
						GstObject: gst.GstObject{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
						},
					},
				},
			},
		},
	}
}

func marshalAudioSrc(p uintptr) (interface{}, error) {
	return wrapAudioSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
func (src *AudioSrc) close() bool {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.close

	var _arg0 *C.GstAudioSrc // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstaudio1_AudioSrc_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (src *AudioSrc) delay() uint {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.delay

	var _arg0 *C.GstAudioSrc // out
	var _cret C.guint        // in

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstaudio1_AudioSrc_virtual_delay(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
func (src *AudioSrc) open() bool {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.open

	var _arg0 *C.GstAudioSrc // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstaudio1_AudioSrc_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (src *AudioSrc) prepare(spec *AudioRingBufferSpec) bool {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.prepare

	var _arg0 *C.GstAudioSrc            // out
	var _arg1 *C.GstAudioRingBufferSpec // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))

	_cret = C._gotk4_gstaudio1_AudioSrc_virtual_prepare(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - data (optional)
//    - length
//    - timestamp
//
// The function returns the following values:
//
func (src *AudioSrc) read(data unsafe.Pointer, length uint, timestamp *gst.ClockTime) uint {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.read

	var _arg0 *C.GstAudioSrc  // out
	var _arg1 C.gpointer      // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstClockTime // out
	var _cret C.guint         // in

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))
	_arg2 = C.guint(length)
	_arg3 = (*C.guint64)(unsafe.Pointer(timestamp))
	type _ = *gst.ClockTime
	type _ = *uint64

	_cret = C._gotk4_gstaudio1_AudioSrc_virtual_read(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(data)
	runtime.KeepAlive(length)
	runtime.KeepAlive(timestamp)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (src *AudioSrc) reset() {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.reset

	var _arg0 *C.GstAudioSrc // out

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	C._gotk4_gstaudio1_AudioSrc_virtual_reset(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)
}

// The function returns the following values:
//
func (src *AudioSrc) unprepare() bool {
	gclass := (*C.GstAudioSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.unprepare

	var _arg0 *C.GstAudioSrc // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstAudioSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstaudio1_AudioSrc_virtual_unprepare(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioSrcClass class. Override the vmethod to implement functionality.
//
// An instance of this type is always passed by reference.
type AudioSrcClass struct {
	*audioSrcClass
}

// audioSrcClass is the struct that's finalized.
type audioSrcClass struct {
	native *C.GstAudioSrcClass
}

// ParentClass: parent class.
func (a *AudioSrcClass) ParentClass() *AudioBaseSrcClass {
	valptr := &a.native.parent_class
	var _v *AudioBaseSrcClass // out
	_v = (*AudioBaseSrcClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
