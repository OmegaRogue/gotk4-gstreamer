// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <gst/audio/audio.h>
import "C"

// BufferAddAudioMeta allocates and attaches a AudioMeta on buffer, which must
// be writable for that purpose. The fields of the AudioMeta are directly
// populated from the arguments of this function.
//
// When info->layout is GST_AUDIO_LAYOUT_NON_INTERLEAVED and offsets is NULL,
// the offsets are calculated with a formula that assumes the planes are tightly
// packed and in sequence: offsets[channel] = channel * samples * sample_stride
//
// It is not allowed for channels to overlap in memory, i.e. for each i in [0,
// channels), the range [offsets[i], offsets[i] + samples * sample_stride) must
// not overlap with any other such range. This function will assert if the
// parameters specified cause this restriction to be violated.
//
// It is, obviously, also not allowed to specify parameters that would cause
// out-of-bounds memory access on buffer. This is also checked, which means that
// you must add enough memory on the buffer before adding this meta.
//
// The function takes the following parameters:
//
//    - buffer: Buffer.
//    - info: audio properties of the buffer.
//    - samples: number of valid samples in the buffer.
//    - offsets (optional) (in bytes) where each channel plane starts in the
//      buffer or NULL to calculate it (see below); must be NULL also when
//      info->layout is GST_AUDIO_LAYOUT_INTERLEAVED.
//
// The function returns the following values:
//
//    - audioMeta that was attached on the buffer.
//
func BufferAddAudioMeta(buffer *gst.Buffer, info *AudioInfo, samples uint, offsets *uint) *AudioMeta {
	var _arg1 *C.GstBuffer    // out
	var _arg2 *C.GstAudioInfo // out
	var _arg3 C.gsize         // out
	var _arg4 *C.gsize        // out
	var _cret *C.GstAudioMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.GstAudioInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg3 = C.gsize(samples)
	if offsets != nil {
		_arg4 = (*C.gsize)(unsafe.Pointer(offsets))
	}

	_cret = C.gst_buffer_add_audio_meta(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)
	runtime.KeepAlive(samples)
	runtime.KeepAlive(offsets)

	var _audioMeta *AudioMeta // out

	_audioMeta = (*AudioMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _audioMeta
}

// AudioMeta defines an audio downmix matrix to be send along with audio
// buffers. These functions in this module help to create and attach the meta as
// well as extracting it.
//
// An instance of this type is always passed by reference.
type AudioMeta struct {
	*audioMeta
}

// audioMeta is the struct that's finalized.
type audioMeta struct {
	native *C.GstAudioMeta
}

// Meta: parent Meta.
func (a *AudioMeta) Meta() *gst.Meta {
	valptr := &a.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Info: audio properties of the buffer.
func (a *AudioMeta) Info() *AudioInfo {
	valptr := &a.native.info
	var _v *AudioInfo // out
	_v = (*AudioInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Samples: number of valid samples in the buffer.
func (a *AudioMeta) Samples() uint {
	valptr := &a.native.samples
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offsets offsets (in bytes) where each channel plane starts in the buffer or
// NULL if the buffer has interleaved layout; if not NULL, this is guaranteed to
// be an array of info.channels elements.
func (a *AudioMeta) Offsets() *uint {
	valptr := &a.native.offsets
	var _v *uint // out
	_v = (*uint)(unsafe.Pointer(*valptr))
	return _v
}

// Samples: number of valid samples in the buffer.
func (a *AudioMeta) SetSamples(samples uint) {
	valptr := &a.native.samples
	*valptr = C.gsize(samples)
}
