// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
import "C"

// GType values.
var (
	GTypeAudioFormat      = coreglib.Type(C.gst_audio_format_get_type())
	GTypeAudioLayout      = coreglib.Type(C.gst_audio_layout_get_type())
	GTypeAudioFormatFlags = coreglib.Type(C.gst_audio_format_flags_get_type())
	GTypeAudioPackFlags   = coreglib.Type(C.gst_audio_pack_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioFormat, F: marshalAudioFormat},
		coreglib.TypeMarshaler{T: GTypeAudioLayout, F: marshalAudioLayout},
		coreglib.TypeMarshaler{T: GTypeAudioFormatFlags, F: marshalAudioFormatFlags},
		coreglib.TypeMarshaler{T: GTypeAudioPackFlags, F: marshalAudioPackFlags},
	})
}

// AUDIO_CHANNELS_RANGE: maximum range of allowed channels, for use in template
// caps strings.
const AUDIO_CHANNELS_RANGE = "(int) [ 1, max ]"

// AUDIO_DEF_CHANNELS: standard number of channels used in consumer audio.
const AUDIO_DEF_CHANNELS = 2

// AUDIO_DEF_FORMAT: standard format used in consumer audio.
const AUDIO_DEF_FORMAT = "S16LE"

// AUDIO_DEF_RATE: standard sampling rate used in consumer audio.
const AUDIO_DEF_RATE = 44100

// AUDIO_FORMATS_ALL: list of all audio formats, for use in template caps
// strings.
//
// Formats are sorted by decreasing "quality", using these criteria by priority:
// - depth - width - Float > Signed > Unsigned - native endianness preferred.
const AUDIO_FORMATS_ALL = "{ F64BE, F64LE, F32BE, F32LE, S32BE, S32LE, U32BE, U32LE, S24_32BE, S24_32LE, U24_32BE, U24_32LE, S24BE, S24LE, U24BE, U24LE, S20BE, S20LE, U20BE, U20LE, S18BE, S18LE, U18BE, U18LE, S16BE, S16LE, U16BE, U16LE, S8, U8 }"

// AUDIO_RATE_RANGE: maximum range of allowed sample rates, for use in template
// caps strings.
const AUDIO_RATE_RANGE = "(int) [ 1, max ]"

// AudioFormat: enum value describing the most common audio formats.
type AudioFormat C.gint

const (
	// AudioFormatUnknown: unknown or unset audio format.
	AudioFormatUnknown AudioFormat = 0
	// AudioFormatEncoded: encoded audio format.
	AudioFormatEncoded AudioFormat = 1
	// AudioFormatS8: 8 bits in 8 bits, signed.
	AudioFormatS8 AudioFormat = 2
	// AudioFormatU8: 8 bits in 8 bits, unsigned.
	AudioFormatU8 AudioFormat = 3
	// AudioFormatS16LE: 16 bits in 16 bits, signed, little endian.
	AudioFormatS16LE AudioFormat = 4
	// AudioFormatS16Be: 16 bits in 16 bits, signed, big endian.
	AudioFormatS16Be AudioFormat = 5
	// AudioFormatU16LE: 16 bits in 16 bits, unsigned, little endian.
	AudioFormatU16LE AudioFormat = 6
	// AudioFormatU16Be: 16 bits in 16 bits, unsigned, big endian.
	AudioFormatU16Be AudioFormat = 7
	// AudioFormatS2432LE: 24 bits in 32 bits, signed, little endian.
	AudioFormatS2432LE AudioFormat = 8
	// AudioFormatS2432Be: 24 bits in 32 bits, signed, big endian.
	AudioFormatS2432Be AudioFormat = 9
	// AudioFormatU2432LE: 24 bits in 32 bits, unsigned, little endian.
	AudioFormatU2432LE AudioFormat = 10
	// AudioFormatU2432Be: 24 bits in 32 bits, unsigned, big endian.
	AudioFormatU2432Be AudioFormat = 11
	// AudioFormatS32LE: 32 bits in 32 bits, signed, little endian.
	AudioFormatS32LE AudioFormat = 12
	// AudioFormatS32Be: 32 bits in 32 bits, signed, big endian.
	AudioFormatS32Be AudioFormat = 13
	// AudioFormatU32LE: 32 bits in 32 bits, unsigned, little endian.
	AudioFormatU32LE AudioFormat = 14
	// AudioFormatU32Be: 32 bits in 32 bits, unsigned, big endian.
	AudioFormatU32Be AudioFormat = 15
	// AudioFormatS24LE: 24 bits in 24 bits, signed, little endian.
	AudioFormatS24LE AudioFormat = 16
	// AudioFormatS24Be: 24 bits in 24 bits, signed, big endian.
	AudioFormatS24Be AudioFormat = 17
	// AudioFormatU24LE: 24 bits in 24 bits, unsigned, little endian.
	AudioFormatU24LE AudioFormat = 18
	// AudioFormatU24Be: 24 bits in 24 bits, unsigned, big endian.
	AudioFormatU24Be AudioFormat = 19
	// AudioFormatS20LE: 20 bits in 24 bits, signed, little endian.
	AudioFormatS20LE AudioFormat = 20
	// AudioFormatS20Be: 20 bits in 24 bits, signed, big endian.
	AudioFormatS20Be AudioFormat = 21
	// AudioFormatU20LE: 20 bits in 24 bits, unsigned, little endian.
	AudioFormatU20LE AudioFormat = 22
	// AudioFormatU20Be: 20 bits in 24 bits, unsigned, big endian.
	AudioFormatU20Be AudioFormat = 23
	// AudioFormatS18LE: 18 bits in 24 bits, signed, little endian.
	AudioFormatS18LE AudioFormat = 24
	// AudioFormatS18Be: 18 bits in 24 bits, signed, big endian.
	AudioFormatS18Be AudioFormat = 25
	// AudioFormatU18LE: 18 bits in 24 bits, unsigned, little endian.
	AudioFormatU18LE AudioFormat = 26
	// AudioFormatU18Be: 18 bits in 24 bits, unsigned, big endian.
	AudioFormatU18Be AudioFormat = 27
	// AudioFormatF32LE: 32-bit floating point samples, little endian.
	AudioFormatF32LE AudioFormat = 28
	// AudioFormatF32Be: 32-bit floating point samples, big endian.
	AudioFormatF32Be AudioFormat = 29
	// AudioFormatF64LE: 64-bit floating point samples, little endian.
	AudioFormatF64LE AudioFormat = 30
	// AudioFormatF64Be: 64-bit floating point samples, big endian.
	AudioFormatF64Be AudioFormat = 31
	// AudioFormatS16: 16 bits in 16 bits, signed, native endianness.
	AudioFormatS16 AudioFormat = 4
	// AudioFormatU16: 16 bits in 16 bits, unsigned, native endianness.
	AudioFormatU16 AudioFormat = 6
	// AudioFormatS2432: 24 bits in 32 bits, signed, native endianness.
	AudioFormatS2432 AudioFormat = 8
	// AudioFormatU2432: 24 bits in 32 bits, unsigned, native endianness.
	AudioFormatU2432 AudioFormat = 10
	// AudioFormatS32: 32 bits in 32 bits, signed, native endianness.
	AudioFormatS32 AudioFormat = 12
	// AudioFormatU32: 32 bits in 32 bits, unsigned, native endianness.
	AudioFormatU32 AudioFormat = 14
	// AudioFormatS24: 24 bits in 24 bits, signed, native endianness.
	AudioFormatS24 AudioFormat = 16
	// AudioFormatU24: 24 bits in 24 bits, unsigned, native endianness.
	AudioFormatU24 AudioFormat = 18
	// AudioFormatS20: 20 bits in 24 bits, signed, native endianness.
	AudioFormatS20 AudioFormat = 20
	// AudioFormatU20: 20 bits in 24 bits, unsigned, native endianness.
	AudioFormatU20 AudioFormat = 22
	// AudioFormatS18: 18 bits in 24 bits, signed, native endianness.
	AudioFormatS18 AudioFormat = 24
	// AudioFormatU18: 18 bits in 24 bits, unsigned, native endianness.
	AudioFormatU18 AudioFormat = 26
	// AudioFormatF32: 32-bit floating point samples, native endianness.
	AudioFormatF32 AudioFormat = 28
	// AudioFormatF64: 64-bit floating point samples, native endianness.
	AudioFormatF64 AudioFormat = 30
)

func marshalAudioFormat(p uintptr) (interface{}, error) {
	return AudioFormat(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioFormat.
func (a AudioFormat) String() string {
	switch a {
	case AudioFormatUnknown:
		return "Unknown"
	case AudioFormatEncoded:
		return "Encoded"
	case AudioFormatS8:
		return "S8"
	case AudioFormatU8:
		return "U8"
	case AudioFormatS16LE:
		return "S16LE"
	case AudioFormatS16Be:
		return "S16Be"
	case AudioFormatU16LE:
		return "U16LE"
	case AudioFormatU16Be:
		return "U16Be"
	case AudioFormatS2432LE:
		return "S2432LE"
	case AudioFormatS2432Be:
		return "S2432Be"
	case AudioFormatU2432LE:
		return "U2432LE"
	case AudioFormatU2432Be:
		return "U2432Be"
	case AudioFormatS32LE:
		return "S32LE"
	case AudioFormatS32Be:
		return "S32Be"
	case AudioFormatU32LE:
		return "U32LE"
	case AudioFormatU32Be:
		return "U32Be"
	case AudioFormatS24LE:
		return "S24LE"
	case AudioFormatS24Be:
		return "S24Be"
	case AudioFormatU24LE:
		return "U24LE"
	case AudioFormatU24Be:
		return "U24Be"
	case AudioFormatS20LE:
		return "S20LE"
	case AudioFormatS20Be:
		return "S20Be"
	case AudioFormatU20LE:
		return "U20LE"
	case AudioFormatU20Be:
		return "U20Be"
	case AudioFormatS18LE:
		return "S18LE"
	case AudioFormatS18Be:
		return "S18Be"
	case AudioFormatU18LE:
		return "U18LE"
	case AudioFormatU18Be:
		return "U18Be"
	case AudioFormatF32LE:
		return "F32LE"
	case AudioFormatF32Be:
		return "F32Be"
	case AudioFormatF64LE:
		return "F64LE"
	case AudioFormatF64Be:
		return "F64Be"
	default:
		return fmt.Sprintf("AudioFormat(%d)", a)
	}
}

// AudioFormatBuildInteger: construct a AudioFormat with given parameters.
//
// The function takes the following parameters:
//
//    - sign: signed or unsigned format.
//    - endianness: g_LITTLE_ENDIAN or G_BIG_ENDIAN.
//    - width: amount of bits used per sample.
//    - depth: amount of used bits in width.
//
// The function returns the following values:
//
//    - audioFormat or GST_AUDIO_FORMAT_UNKNOWN when no audio format exists with
//      the given parameters.
//
func AudioFormatBuildInteger(sign bool, endianness, width, depth int) AudioFormat {
	var _arg1 C.gboolean       // out
	var _arg2 C.gint           // out
	var _arg3 C.gint           // out
	var _arg4 C.gint           // out
	var _cret C.GstAudioFormat // in

	if sign {
		_arg1 = C.TRUE
	}
	_arg2 = C.gint(endianness)
	_arg3 = C.gint(width)
	_arg4 = C.gint(depth)

	_cret = C.gst_audio_format_build_integer(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(sign)
	runtime.KeepAlive(endianness)
	runtime.KeepAlive(width)
	runtime.KeepAlive(depth)

	var _audioFormat AudioFormat // out

	_audioFormat = AudioFormat(_cret)

	return _audioFormat
}

// AudioFormatFillSilence: fill length bytes in dest with silence samples for
// info.
//
// Deprecated: Use gst_audio_format_info_fill_silence() instead.
//
// The function takes the following parameters:
//
//    - info: AudioFormatInfo.
//    - dest: destination to fill.
//
func AudioFormatFillSilence(info *AudioFormatInfo, dest []byte) {
	var _arg1 *C.GstAudioFormatInfo // out
	var _arg2 C.gpointer            // out
	var _arg3 C.gsize

	_arg1 = (*C.GstAudioFormatInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg3 = (C.gsize)(len(dest))
	if len(dest) > 0 {
		_arg2 = (C.gpointer)(unsafe.Pointer(&dest[0]))
	}

	C.gst_audio_format_fill_silence(_arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(dest)
}

// AudioFormatFromString: convert the format string to its AudioFormat.
//
// The function takes the following parameters:
//
//    - format string.
//
// The function returns the following values:
//
//    - audioFormat for format or GST_AUDIO_FORMAT_UNKNOWN when the string is not
//      a known format.
//
func AudioFormatFromString(format string) AudioFormat {
	var _arg1 *C.gchar         // out
	var _cret C.GstAudioFormat // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(format)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_audio_format_from_string(_arg1)
	runtime.KeepAlive(format)

	var _audioFormat AudioFormat // out

	_audioFormat = AudioFormat(_cret)

	return _audioFormat
}

// AudioFormatGetInfo: get the AudioFormatInfo for format.
//
// The function takes the following parameters:
//
//    - format: AudioFormat.
//
// The function returns the following values:
//
//    - audioFormatInfo for format.
//
func AudioFormatGetInfo(format AudioFormat) *AudioFormatInfo {
	var _arg1 C.GstAudioFormat      // out
	var _cret *C.GstAudioFormatInfo // in

	_arg1 = C.GstAudioFormat(format)

	_cret = C.gst_audio_format_get_info(_arg1)
	runtime.KeepAlive(format)

	var _audioFormatInfo *AudioFormatInfo // out

	_audioFormatInfo = (*AudioFormatInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _audioFormatInfo
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func AudioFormatToString(format AudioFormat) string {
	var _arg1 C.GstAudioFormat // out
	var _cret *C.gchar         // in

	_arg1 = C.GstAudioFormat(format)

	_cret = C.gst_audio_format_to_string(_arg1)
	runtime.KeepAlive(format)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// AudioLayout: layout of the audio samples for the different channels.
type AudioLayout C.gint

const (
	// AudioLayoutInterleaved: interleaved audio.
	AudioLayoutInterleaved AudioLayout = iota
	// AudioLayoutNonInterleaved: non-interleaved audio.
	AudioLayoutNonInterleaved
)

func marshalAudioLayout(p uintptr) (interface{}, error) {
	return AudioLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioLayout.
func (a AudioLayout) String() string {
	switch a {
	case AudioLayoutInterleaved:
		return "Interleaved"
	case AudioLayoutNonInterleaved:
		return "NonInterleaved"
	default:
		return fmt.Sprintf("AudioLayout(%d)", a)
	}
}

// AudioFormatFlags: different audio flags that a format info can have.
type AudioFormatFlags C.guint

const (
	// AudioFormatFlagInteger: integer samples.
	AudioFormatFlagInteger AudioFormatFlags = 0b1
	// AudioFormatFlagFloat: float samples.
	AudioFormatFlagFloat AudioFormatFlags = 0b10
	// AudioFormatFlagSigned: signed samples.
	AudioFormatFlagSigned AudioFormatFlags = 0b100
	// AudioFormatFlagComplex: complex layout.
	AudioFormatFlagComplex AudioFormatFlags = 0b10000
	// AudioFormatFlagUnpack: format can be used in AudioFormatUnpack and
	// AudioFormatPack functions.
	AudioFormatFlagUnpack AudioFormatFlags = 0b100000
)

func marshalAudioFormatFlags(p uintptr) (interface{}, error) {
	return AudioFormatFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AudioFormatFlags.
func (a AudioFormatFlags) String() string {
	if a == 0 {
		return "AudioFormatFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(110)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AudioFormatFlagInteger:
			builder.WriteString("Integer|")
		case AudioFormatFlagFloat:
			builder.WriteString("Float|")
		case AudioFormatFlagSigned:
			builder.WriteString("Signed|")
		case AudioFormatFlagComplex:
			builder.WriteString("Complex|")
		case AudioFormatFlagUnpack:
			builder.WriteString("Unpack|")
		default:
			builder.WriteString(fmt.Sprintf("AudioFormatFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AudioFormatFlags) Has(other AudioFormatFlags) bool {
	return (a & other) == other
}

// AudioPackFlags: different flags that can be used when packing and unpacking.
type AudioPackFlags C.guint

const (
	// AudioPackFlagNone: no flag.
	AudioPackFlagNone AudioPackFlags = 0b0
	// AudioPackFlagTruncateRange: when the source has a smaller depth than the
	// target format, set the least significant bits of the target to 0. This is
	// likely slightly faster but less accurate. When this flag is not
	// specified, the most significant bits of the source are duplicated in the
	// least significant bits of the destination.
	AudioPackFlagTruncateRange AudioPackFlags = 0b1
)

func marshalAudioPackFlags(p uintptr) (interface{}, error) {
	return AudioPackFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AudioPackFlags.
func (a AudioPackFlags) String() string {
	if a == 0 {
		return "AudioPackFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(44)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AudioPackFlagNone:
			builder.WriteString("None|")
		case AudioPackFlagTruncateRange:
			builder.WriteString("TruncateRange|")
		default:
			builder.WriteString(fmt.Sprintf("AudioPackFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AudioPackFlags) Has(other AudioPackFlags) bool {
	return (a & other) == other
}

// The function returns the following values:
//
func AudioFormatInfoGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_audio_format_info_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// AudioFormatInfo: information for an audio format.
//
// An instance of this type is always passed by reference.
type AudioFormatInfo struct {
	*audioFormatInfo
}

// audioFormatInfo is the struct that's finalized.
type audioFormatInfo struct {
	native *C.GstAudioFormatInfo
}

// FillSilence: fill length bytes in dest with silence samples for info.
//
// The function takes the following parameters:
//
//    - dest: destination to fill.
//
func (info *AudioFormatInfo) FillSilence(dest []byte) {
	var _arg0 *C.GstAudioFormatInfo // out
	var _arg1 C.gpointer            // out
	var _arg2 C.gsize

	_arg0 = (*C.GstAudioFormatInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (C.gsize)(len(dest))
	if len(dest) > 0 {
		_arg1 = (C.gpointer)(unsafe.Pointer(&dest[0]))
	}

	C.gst_audio_format_info_fill_silence(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(dest)
}
