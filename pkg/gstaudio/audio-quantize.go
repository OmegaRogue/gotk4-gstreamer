// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
import "C"

// GType values.
var (
	GTypeAudioDitherMethod       = coreglib.Type(C.gst_audio_dither_method_get_type())
	GTypeAudioNoiseShapingMethod = coreglib.Type(C.gst_audio_noise_shaping_method_get_type())
	GTypeAudioQuantizeFlags      = coreglib.Type(C.gst_audio_quantize_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioDitherMethod, F: marshalAudioDitherMethod},
		coreglib.TypeMarshaler{T: GTypeAudioNoiseShapingMethod, F: marshalAudioNoiseShapingMethod},
		coreglib.TypeMarshaler{T: GTypeAudioQuantizeFlags, F: marshalAudioQuantizeFlags},
	})
}

// AudioDitherMethod: set of available dithering methods.
type AudioDitherMethod C.gint

const (
	// AudioDitherNone: no dithering.
	AudioDitherNone AudioDitherMethod = iota
	// AudioDitherRpdf: rectangular dithering.
	AudioDitherRpdf
	// AudioDitherTpdf: triangular dithering (default).
	AudioDitherTpdf
	// AudioDitherTpdfHf: high frequency triangular dithering.
	AudioDitherTpdfHf
)

func marshalAudioDitherMethod(p uintptr) (interface{}, error) {
	return AudioDitherMethod(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioDitherMethod.
func (a AudioDitherMethod) String() string {
	switch a {
	case AudioDitherNone:
		return "None"
	case AudioDitherRpdf:
		return "Rpdf"
	case AudioDitherTpdf:
		return "Tpdf"
	case AudioDitherTpdfHf:
		return "TpdfHf"
	default:
		return fmt.Sprintf("AudioDitherMethod(%d)", a)
	}
}

// AudioNoiseShapingMethod: set of available noise shaping methods.
type AudioNoiseShapingMethod C.gint

const (
	// AudioNoiseShapingNone: no noise shaping (default).
	AudioNoiseShapingNone AudioNoiseShapingMethod = iota
	// AudioNoiseShapingErrorFeedback: error feedback.
	AudioNoiseShapingErrorFeedback
	// AudioNoiseShapingSimple: simple 2-pole noise shaping.
	AudioNoiseShapingSimple
	// AudioNoiseShapingMedium: medium 5-pole noise shaping.
	AudioNoiseShapingMedium
	// AudioNoiseShapingHigh: high 8-pole noise shaping.
	AudioNoiseShapingHigh
)

func marshalAudioNoiseShapingMethod(p uintptr) (interface{}, error) {
	return AudioNoiseShapingMethod(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioNoiseShapingMethod.
func (a AudioNoiseShapingMethod) String() string {
	switch a {
	case AudioNoiseShapingNone:
		return "None"
	case AudioNoiseShapingErrorFeedback:
		return "ErrorFeedback"
	case AudioNoiseShapingSimple:
		return "Simple"
	case AudioNoiseShapingMedium:
		return "Medium"
	case AudioNoiseShapingHigh:
		return "High"
	default:
		return fmt.Sprintf("AudioNoiseShapingMethod(%d)", a)
	}
}

// AudioQuantizeFlags: extra flags that can be passed to
// gst_audio_quantize_new().
type AudioQuantizeFlags C.guint

const (
	// AudioQuantizeFlagNone: no flags.
	AudioQuantizeFlagNone AudioQuantizeFlags = 0b0
	// AudioQuantizeFlagNonInterleaved samples are non-interleaved.
	AudioQuantizeFlagNonInterleaved AudioQuantizeFlags = 0b1
)

func marshalAudioQuantizeFlags(p uintptr) (interface{}, error) {
	return AudioQuantizeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AudioQuantizeFlags.
func (a AudioQuantizeFlags) String() string {
	if a == 0 {
		return "AudioQuantizeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(53)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AudioQuantizeFlagNone:
			builder.WriteString("None|")
		case AudioQuantizeFlagNonInterleaved:
			builder.WriteString("NonInterleaved|")
		default:
			builder.WriteString(fmt.Sprintf("AudioQuantizeFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AudioQuantizeFlags) Has(other AudioQuantizeFlags) bool {
	return (a & other) == other
}
