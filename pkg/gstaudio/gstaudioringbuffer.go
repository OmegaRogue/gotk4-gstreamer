// Code generated by girgen. DO NOT EDIT.

package gstaudio

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/audio/audio.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gstaudio1_AudioRingBufferClass_clear_all(GstAudioRingBuffer*);
// extern void _gotk4_gstaudio1_AudioRingBufferCallback(GstAudioRingBuffer*, guint8*, guint, gpointer);
// extern guint _gotk4_gstaudio1_AudioRingBufferClass_delay(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_stop(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_start(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_resume(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_release(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_pause(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_open_device(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_close_device(GstAudioRingBuffer*);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_activate(GstAudioRingBuffer*, gboolean);
// extern gboolean _gotk4_gstaudio1_AudioRingBufferClass_acquire(GstAudioRingBuffer*, GstAudioRingBufferSpec*);
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_acquire(void* fnptr, GstAudioRingBuffer* arg0, GstAudioRingBufferSpec* arg1) {
//   return ((gboolean (*)(GstAudioRingBuffer*, GstAudioRingBufferSpec*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_activate(void* fnptr, GstAudioRingBuffer* arg0, gboolean arg1) {
//   return ((gboolean (*)(GstAudioRingBuffer*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_close_device(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_open_device(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_pause(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_release(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_resume(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_start(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstaudio1_AudioRingBuffer_virtual_stop(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((gboolean (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// guint _gotk4_gstaudio1_AudioRingBuffer_virtual_delay(void* fnptr, GstAudioRingBuffer* arg0) {
//   return ((guint (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gstaudio1_AudioRingBuffer_virtual_clear_all(void* fnptr, GstAudioRingBuffer* arg0) {
//   ((void (*)(GstAudioRingBuffer*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioRingBufferFormatType = coreglib.Type(C.gst_audio_ring_buffer_format_type_get_type())
	GTypeAudioRingBufferState      = coreglib.Type(C.gst_audio_ring_buffer_state_get_type())
	GTypeAudioRingBuffer           = coreglib.Type(C.gst_audio_ring_buffer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioRingBufferFormatType, F: marshalAudioRingBufferFormatType},
		coreglib.TypeMarshaler{T: GTypeAudioRingBufferState, F: marshalAudioRingBufferState},
		coreglib.TypeMarshaler{T: GTypeAudioRingBuffer, F: marshalAudioRingBuffer},
	})
}

// AudioRingBufferFormatType: format of the samples in the ringbuffer.
type AudioRingBufferFormatType C.gint

const (
	// AudioRingBufferFormatTypeRaw samples in linear or float.
	AudioRingBufferFormatTypeRaw AudioRingBufferFormatType = iota
	// AudioRingBufferFormatTypeMuLaw samples in mulaw.
	AudioRingBufferFormatTypeMuLaw
	// AudioRingBufferFormatTypeALaw samples in alaw.
	AudioRingBufferFormatTypeALaw
	// AudioRingBufferFormatTypeImaAdpcm samples in ima adpcm.
	AudioRingBufferFormatTypeImaAdpcm
	// AudioRingBufferFormatTypeMpeg samples in mpeg audio (but not AAC) format.
	AudioRingBufferFormatTypeMpeg
	// AudioRingBufferFormatTypeGsm samples in gsm format.
	AudioRingBufferFormatTypeGsm
	// AudioRingBufferFormatTypeIec958 samples in IEC958 frames (e.g. AC3).
	AudioRingBufferFormatTypeIec958
	// AudioRingBufferFormatTypeAc3 samples in AC3 format.
	AudioRingBufferFormatTypeAc3
	// AudioRingBufferFormatTypeEac3 samples in EAC3 format.
	AudioRingBufferFormatTypeEac3
	// AudioRingBufferFormatTypeDts samples in DTS format.
	AudioRingBufferFormatTypeDts
	// AudioRingBufferFormatTypeMpeg2Aac samples in MPEG-2 AAC ADTS format.
	AudioRingBufferFormatTypeMpeg2Aac
	// AudioRingBufferFormatTypeMpeg4Aac samples in MPEG-4 AAC ADTS format.
	AudioRingBufferFormatTypeMpeg4Aac
	// AudioRingBufferFormatTypeMpeg2AacRaw samples in MPEG-2 AAC raw format
	// (Since: 1.12).
	AudioRingBufferFormatTypeMpeg2AacRaw
	// AudioRingBufferFormatTypeMpeg4AacRaw samples in MPEG-4 AAC raw format
	// (Since: 1.12).
	AudioRingBufferFormatTypeMpeg4AacRaw
	// AudioRingBufferFormatTypeFlac samples in FLAC format (Since: 1.12).
	AudioRingBufferFormatTypeFlac
)

func marshalAudioRingBufferFormatType(p uintptr) (interface{}, error) {
	return AudioRingBufferFormatType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioRingBufferFormatType.
func (a AudioRingBufferFormatType) String() string {
	switch a {
	case AudioRingBufferFormatTypeRaw:
		return "Raw"
	case AudioRingBufferFormatTypeMuLaw:
		return "MuLaw"
	case AudioRingBufferFormatTypeALaw:
		return "ALaw"
	case AudioRingBufferFormatTypeImaAdpcm:
		return "ImaAdpcm"
	case AudioRingBufferFormatTypeMpeg:
		return "Mpeg"
	case AudioRingBufferFormatTypeGsm:
		return "Gsm"
	case AudioRingBufferFormatTypeIec958:
		return "Iec958"
	case AudioRingBufferFormatTypeAc3:
		return "Ac3"
	case AudioRingBufferFormatTypeEac3:
		return "Eac3"
	case AudioRingBufferFormatTypeDts:
		return "Dts"
	case AudioRingBufferFormatTypeMpeg2Aac:
		return "Mpeg2Aac"
	case AudioRingBufferFormatTypeMpeg4Aac:
		return "Mpeg4Aac"
	case AudioRingBufferFormatTypeMpeg2AacRaw:
		return "Mpeg2AacRaw"
	case AudioRingBufferFormatTypeMpeg4AacRaw:
		return "Mpeg4AacRaw"
	case AudioRingBufferFormatTypeFlac:
		return "Flac"
	default:
		return fmt.Sprintf("AudioRingBufferFormatType(%d)", a)
	}
}

// AudioRingBufferState: state of the ringbuffer.
type AudioRingBufferState C.gint

const (
	// AudioRingBufferStateStopped: ringbuffer is stopped.
	AudioRingBufferStateStopped AudioRingBufferState = iota
	// AudioRingBufferStatePaused: ringbuffer is paused.
	AudioRingBufferStatePaused
	// AudioRingBufferStateStarted: ringbuffer is started.
	AudioRingBufferStateStarted
	// AudioRingBufferStateError: ringbuffer has encountered an error after it
	// has been started, e.g. because the device was disconnected (Since: 1.2).
	AudioRingBufferStateError
)

func marshalAudioRingBufferState(p uintptr) (interface{}, error) {
	return AudioRingBufferState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioRingBufferState.
func (a AudioRingBufferState) String() string {
	switch a {
	case AudioRingBufferStateStopped:
		return "Stopped"
	case AudioRingBufferStatePaused:
		return "Paused"
	case AudioRingBufferStateStarted:
		return "Started"
	case AudioRingBufferStateError:
		return "Error"
	default:
		return fmt.Sprintf("AudioRingBufferState(%d)", a)
	}
}

// AudioRingBufferCallback: this function is set with
// gst_audio_ring_buffer_set_callback() and is called to fill the memory at data
// with len bytes of samples.
type AudioRingBufferCallback func(rbuf AudioRingBufferer, data []byte)

// AudioRingBufferOverrides contains methods that are overridable.
type AudioRingBufferOverrides struct {
	// Acquire: allocate the resources for the ringbuffer. This function fills
	// in the data pointer of the ring buffer with a valid Buffer to which
	// samples can be written.
	//
	// The function takes the following parameters:
	//
	//    - spec specs of the buffer.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be acquired, FALSE on error.
	//
	//      MT safe.
	//
	Acquire func(spec *AudioRingBufferSpec) bool
	// Activate buf to start or stop pulling data.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//    - active: new mode.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be activated in the requested mode,
	//      FALSE on error.
	//
	Activate func(active bool) bool
	// ClearAll: clear all samples from the ringbuffer.
	//
	// MT safe.
	ClearAll func()
	// CloseDevice: close the audio device associated with the ring buffer. The
	// ring buffer should already have been released via
	// gst_audio_ring_buffer_release().
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be closed, FALSE on error.
	//
	//      MT safe.
	//
	CloseDevice func() bool
	// Delay: get the number of samples queued in the audio device. This is
	// usually less than the segment size but can be bigger when the
	// implementation uses another internal buffer between the audio device.
	//
	// For playback ringbuffers this is the amount of samples transferred from
	// the ringbuffer to the device but still not played.
	//
	// For capture ringbuffers this is the amount of samples in the device that
	// are not yet transferred to the ringbuffer.
	//
	// The function returns the following values:
	//
	//    - guint: number of samples queued in the audio device.
	//
	//      MT safe.
	//
	Delay func() uint
	// OpenDevice: open the audio device associated with the ring buffer. Does
	// not perform any setup on the device. You must open the device before
	// acquiring the ring buffer.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be opened, FALSE on error.
	//
	//      MT safe.
	//
	OpenDevice func() bool
	// Pause processing samples from the ringbuffer.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be paused, FALSE on error.
	//
	//      MT safe.
	//
	Pause func() bool
	// Release: free the resources of the ringbuffer.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be released, FALSE on error.
	//
	//      MT safe.
	//
	Release func() bool
	// The function returns the following values:
	//
	Resume func() bool
	// Start processing samples from the ringbuffer.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be started, FALSE on error.
	//
	//      MT safe.
	//
	Start func() bool
	// Stop processing samples from the ringbuffer.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the device could be stopped, FALSE on error.
	//
	//      MT safe.
	//
	Stop func() bool
}

func defaultAudioRingBufferOverrides(v *AudioRingBuffer) AudioRingBufferOverrides {
	return AudioRingBufferOverrides{
		Acquire:     v.acquire,
		Activate:    v.activate,
		ClearAll:    v.clearAll,
		CloseDevice: v.closeDevice,
		Delay:       v.delay,
		OpenDevice:  v.openDevice,
		Pause:       v.pause,
		Release:     v.release,
		Resume:      v.resume,
		Start:       v.start,
		Stop:        v.stop,
	}
}

// AudioRingBuffer: this object is the base class for audio ringbuffers used by
// the base audio source and sink classes.
//
// The ringbuffer abstracts a circular buffer of data. One reader and one writer
// can operate on the data from different threads in a lockfree manner. The base
// class is sufficiently flexible to be used as an abstraction for DMA based
// ringbuffers as well as a pure software implementations.
type AudioRingBuffer struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*AudioRingBuffer)(nil)
)

// AudioRingBufferer describes types inherited from class AudioRingBuffer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioRingBufferer interface {
	coreglib.Objector
	baseAudioRingBuffer() *AudioRingBuffer
}

var _ AudioRingBufferer = (*AudioRingBuffer)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioRingBuffer, *AudioRingBufferClass, AudioRingBufferOverrides](
		GTypeAudioRingBuffer,
		initAudioRingBufferClass,
		wrapAudioRingBuffer,
		defaultAudioRingBufferOverrides,
	)
}

func initAudioRingBufferClass(gclass unsafe.Pointer, overrides AudioRingBufferOverrides, classInitFunc func(*AudioRingBufferClass)) {
	pclass := (*C.GstAudioRingBufferClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioRingBuffer))))

	if overrides.Acquire != nil {
		pclass.acquire = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_acquire)
	}

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_activate)
	}

	if overrides.ClearAll != nil {
		pclass.clear_all = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_clear_all)
	}

	if overrides.CloseDevice != nil {
		pclass.close_device = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_close_device)
	}

	if overrides.Delay != nil {
		pclass.delay = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_delay)
	}

	if overrides.OpenDevice != nil {
		pclass.open_device = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_open_device)
	}

	if overrides.Pause != nil {
		pclass.pause = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_pause)
	}

	if overrides.Release != nil {
		pclass.release = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_release)
	}

	if overrides.Resume != nil {
		pclass.resume = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_resume)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferClass_stop)
	}

	if classInitFunc != nil {
		class := (*AudioRingBufferClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioRingBuffer(obj *coreglib.Object) *AudioRingBuffer {
	return &AudioRingBuffer{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalAudioRingBuffer(p uintptr) (interface{}, error) {
	return wrapAudioRingBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (buf *AudioRingBuffer) baseAudioRingBuffer() *AudioRingBuffer {
	return buf
}

// BaseAudioRingBuffer returns the underlying base object.
func BaseAudioRingBuffer(obj AudioRingBufferer) *AudioRingBuffer {
	return obj.baseAudioRingBuffer()
}

// Acquire: allocate the resources for the ringbuffer. This function fills in
// the data pointer of the ring buffer with a valid Buffer to which samples can
// be written.
//
// The function takes the following parameters:
//
//    - spec specs of the buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be acquired, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Acquire(spec *AudioRingBufferSpec) bool {
	var _arg0 *C.GstAudioRingBuffer     // out
	var _arg1 *C.GstAudioRingBufferSpec // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))

	_cret = C.gst_audio_ring_buffer_acquire(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Activate buf to start or stop pulling data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - active: new mode.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be activated in the requested mode, FALSE on
//      error.
//
func (buf *AudioRingBuffer) Activate(active bool) bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gboolean            // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C.gst_audio_ring_buffer_activate(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Advance subclasses should call this function to notify the fact that advance
// segments are now processed by the device.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - advance: number of segments written.
//
func (buf *AudioRingBuffer) Advance(advance uint) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.guint               // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = C.guint(advance)

	C.gst_audio_ring_buffer_advance(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(advance)
}

// Clear the given segment of the buffer with silence samples. This function is
// used by subclasses.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - segment to clear.
//
func (buf *AudioRingBuffer) Clear(segment int) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = C.gint(segment)

	C.gst_audio_ring_buffer_clear(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(segment)
}

// ClearAll: clear all samples from the ringbuffer.
//
// MT safe.
func (buf *AudioRingBuffer) ClearAll() {
	var _arg0 *C.GstAudioRingBuffer // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	C.gst_audio_ring_buffer_clear_all(_arg0)
	runtime.KeepAlive(buf)
}

// CloseDevice: close the audio device associated with the ring buffer. The ring
// buffer should already have been released via gst_audio_ring_buffer_release().
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be closed, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) CloseDevice() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_close_device(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Convert src_val in src_fmt to the equivalent value in dest_fmt. The result
// will be put in dest_val.
//
// The function takes the following parameters:
//
//    - srcFmt: source format.
//    - srcVal: source value.
//    - destFmt: destination format.
//
// The function returns the following values:
//
//    - destVal: location to store the converted value.
//    - ok: TRUE if the conversion succeeded.
//
func (buf *AudioRingBuffer) Convert(srcFmt gst.Format, srcVal int64, destFmt gst.Format) (int64, bool) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.GstFormat           // out
	var _arg2 C.gint64              // out
	var _arg3 C.GstFormat           // out
	var _arg4 C.gint64              // in
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = C.GstFormat(srcFmt)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFmt)

	_cret = C.gst_audio_ring_buffer_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(srcFmt)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFmt)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// Delay: get the number of samples queued in the audio device. This is usually
// less than the segment size but can be bigger when the implementation uses
// another internal buffer between the audio device.
//
// For playback ringbuffers this is the amount of samples transferred from the
// ringbuffer to the device but still not played.
//
// For capture ringbuffers this is the amount of samples in the device that are
// not yet transferred to the ringbuffer.
//
// The function returns the following values:
//
//    - guint: number of samples queued in the audio device.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Delay() uint {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.guint               // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_delay(_arg0)
	runtime.KeepAlive(buf)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DeviceIsOpen checks the status of the device associated with the ring buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device was open, FALSE if it was closed.
//
//      MT safe.
//
func (buf *AudioRingBuffer) DeviceIsOpen() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_device_is_open(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsAcquired: check if the ringbuffer is acquired and ready to use.
//
// The function returns the following values:
//
//    - ok: TRUE if the ringbuffer is acquired, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) IsAcquired() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_is_acquired(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive: check if buf is activated.
//
// MT safe.
//
// The function returns the following values:
//
//    - ok: TRUE if the device is active.
//
func (buf *AudioRingBuffer) IsActive() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_is_active(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFlushing: check if buf is flushing.
//
// MT safe.
//
// The function returns the following values:
//
//    - ok: TRUE if the device is flushing.
//
func (buf *AudioRingBuffer) IsFlushing() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_is_flushing(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MayStart: tell the ringbuffer that it is allowed to start playback when the
// ringbuffer is filled with samples.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - allowed: new value.
//
func (buf *AudioRingBuffer) MayStart(allowed bool) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	if allowed {
		_arg1 = C.TRUE
	}

	C.gst_audio_ring_buffer_may_start(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(allowed)
}

// OpenDevice: open the audio device associated with the ring buffer. Does not
// perform any setup on the device. You must open the device before acquiring
// the ring buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be opened, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) OpenDevice() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_open_device(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause processing samples from the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be paused, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Pause() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_pause(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrepareRead returns a pointer to memory where the data from segment segment
// can be found. This function is mostly used by subclasses.
//
// The function returns the following values:
//
//    - segment to read.
//    - readptr: the pointer to the memory where samples can be read.
//    - ok: FALSE if the buffer is not started.
//
//      MT safe.
//
func (buf *AudioRingBuffer) PrepareRead() (int, []byte, bool) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gint                // in
	var _arg2 *C.guint8             // in
	var _arg3 C.gint                // in
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_prepare_read(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(buf)

	var _segment int    // out
	var _readptr []byte // out
	var _ok bool        // out

	_segment = int(_arg1)
	defer C.free(unsafe.Pointer(_arg2))
	_readptr = make([]byte, _arg3)
	copy(_readptr, unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), _arg3))
	if _cret != 0 {
		_ok = true
	}

	return _segment, _readptr, _ok
}

// Read len samples from the ringbuffer into the memory pointed to by data. The
// first sample should be read from position sample in the ringbuffer.
//
// len should not be a multiple of the segment size of the ringbuffer although
// it is recommended.
//
// timestamp will return the timestamp associated with the data returned.
//
// The function takes the following parameters:
//
//    - sample position of the data.
//    - data: where the data should be read.
//
// The function returns the following values:
//
//    - timestamp: where the timestamp is returned.
//    - guint: number of samples read from the ringbuffer or -1 on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Read(sample uint64, data []byte) (gst.ClockTime, uint) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.guint64             // out
	var _arg2 *C.guint8             // out
	var _arg3 C.guint
	var _arg4 C.GstClockTime // in
	var _cret C.guint        // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = C.guint64(sample)
	_arg3 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_audio_ring_buffer_read(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(data)

	var _timestamp gst.ClockTime // out
	var _guint uint              // out

	_timestamp = uint64(_arg4)
	type _ = gst.ClockTime
	type _ = uint64
	_guint = uint(_cret)

	return _timestamp, _guint
}

// Release: free the resources of the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be released, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Release() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_release(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SamplesDone: get the number of samples that were processed by the ringbuffer
// since it was last started. This does not include the number of samples not
// yet processed (see gst_audio_ring_buffer_delay()).
//
// The function returns the following values:
//
//    - guint64: number of samples processed by the ringbuffer.
//
//      MT safe.
//
func (buf *AudioRingBuffer) SamplesDone() uint64 {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.guint64             // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_samples_done(_arg0)
	runtime.KeepAlive(buf)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// SetCallback sets the given callback function on the buffer. This function
// will be called every time a segment has been written to a device.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - cb (optional): callback to set.
//
func (buf *AudioRingBuffer) SetCallback(cb AudioRingBufferCallback) {
	var _arg0 *C.GstAudioRingBuffer        // out
	var _arg1 C.GstAudioRingBufferCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	if cb != nil {
		_arg1 = (*[0]byte)(C._gotk4_gstaudio1_AudioRingBufferCallback)
		_arg2 = C.gpointer(gbox.Assign(cb))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gst_audio_ring_buffer_set_callback_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(cb)
}

// SetFlushing: set the ringbuffer to flushing mode or normal mode.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - flushing: new mode.
//
func (buf *AudioRingBuffer) SetFlushing(flushing bool) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	if flushing {
		_arg1 = C.TRUE
	}

	C.gst_audio_ring_buffer_set_flushing(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(flushing)
}

// SetSample: make sure that the next sample written to the device is accounted
// for as being the sample sample written to the device. This value will be used
// in reporting the current sample position of the ringbuffer.
//
// This function will also clear the buffer with silence.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - sample number to set.
//
func (buf *AudioRingBuffer) SetSample(sample uint64) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.guint64             // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = C.guint64(sample)

	C.gst_audio_ring_buffer_set_sample(_arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(sample)
}

// The function takes the following parameters:
//
//    - readseg
//    - timestamp
//
func (buf *AudioRingBuffer) SetTimestamp(readseg int, timestamp gst.ClockTime) {
	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gint                // out
	var _arg2 C.GstClockTime        // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = C.gint(readseg)
	_arg2 = C.guint64(timestamp)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_audio_ring_buffer_set_timestamp(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(readseg)
	runtime.KeepAlive(timestamp)
}

// Start processing samples from the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be started, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Start() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_start(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop processing samples from the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be stopped, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) Stop() bool {
	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C.gst_audio_ring_buffer_stop(_arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Acquire: allocate the resources for the ringbuffer. This function fills in
// the data pointer of the ring buffer with a valid Buffer to which samples can
// be written.
//
// The function takes the following parameters:
//
//    - spec specs of the buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be acquired, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) acquire(spec *AudioRingBufferSpec) bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.acquire

	var _arg0 *C.GstAudioRingBuffer     // out
	var _arg1 *C.GstAudioRingBufferSpec // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_acquire(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Activate: activate buf to start or stop pulling data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - active: new mode.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be activated in the requested mode, FALSE on
//      error.
//
func (buf *AudioRingBuffer) activate(active bool) bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.activate

	var _arg0 *C.GstAudioRingBuffer // out
	var _arg1 C.gboolean            // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// clearAll: clear all samples from the ringbuffer.
//
// MT safe.
func (buf *AudioRingBuffer) clearAll() {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.clear_all

	var _arg0 *C.GstAudioRingBuffer // out

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	C._gotk4_gstaudio1_AudioRingBuffer_virtual_clear_all(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)
}

// closeDevice: close the audio device associated with the ring buffer. The ring
// buffer should already have been released via gst_audio_ring_buffer_release().
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be closed, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) closeDevice() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.close_device

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_close_device(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Delay: get the number of samples queued in the audio device. This is usually
// less than the segment size but can be bigger when the implementation uses
// another internal buffer between the audio device.
//
// For playback ringbuffers this is the amount of samples transferred from the
// ringbuffer to the device but still not played.
//
// For capture ringbuffers this is the amount of samples in the device that are
// not yet transferred to the ringbuffer.
//
// The function returns the following values:
//
//    - guint: number of samples queued in the audio device.
//
//      MT safe.
//
func (buf *AudioRingBuffer) delay() uint {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.delay

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.guint               // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_delay(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// openDevice: open the audio device associated with the ring buffer. Does not
// perform any setup on the device. You must open the device before acquiring
// the ring buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be opened, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) openDevice() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.open_device

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_open_device(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause: pause processing samples from the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be paused, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) pause() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.pause

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_pause(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Release: free the resources of the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be released, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) release() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.release

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_release(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
func (buf *AudioRingBuffer) resume() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.resume

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_resume(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start: start processing samples from the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be started, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) start() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.start

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop: stop processing samples from the ringbuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the device could be stopped, FALSE on error.
//
//      MT safe.
//
func (buf *AudioRingBuffer) stop() bool {
	gclass := (*C.GstAudioRingBufferClass)(coreglib.PeekParentClass(buf))
	fnarg := gclass.stop

	var _arg0 *C.GstAudioRingBuffer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioRingBuffer)(unsafe.Pointer(coreglib.InternObject(buf).Native()))

	_cret = C._gotk4_gstaudio1_AudioRingBuffer_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioRingBufferDebugSpecBuff: print debug info about the buffer sized in spec
// to the debug log.
//
// The function takes the following parameters:
//
//    - spec to debug.
//
func AudioRingBufferDebugSpecBuff(spec *AudioRingBufferSpec) {
	var _arg1 *C.GstAudioRingBufferSpec // out

	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))

	C.gst_audio_ring_buffer_debug_spec_buff(_arg1)
	runtime.KeepAlive(spec)
}

// AudioRingBufferDebugSpecCaps: print debug info about the parsed caps in spec
// to the debug log.
//
// The function takes the following parameters:
//
//    - spec to debug.
//
func AudioRingBufferDebugSpecCaps(spec *AudioRingBufferSpec) {
	var _arg1 *C.GstAudioRingBufferSpec // out

	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))

	C.gst_audio_ring_buffer_debug_spec_caps(_arg1)
	runtime.KeepAlive(spec)
}

// AudioRingBufferParseCaps: parse caps into spec.
//
// The function takes the following parameters:
//
//    - spec: spec.
//    - caps: Caps.
//
// The function returns the following values:
//
//    - ok: TRUE if the caps could be parsed.
//
func AudioRingBufferParseCaps(spec *AudioRingBufferSpec, caps *gst.Caps) bool {
	var _arg1 *C.GstAudioRingBufferSpec // out
	var _arg2 *C.GstCaps                // out
	var _cret C.gboolean                // in

	_arg1 = (*C.GstAudioRingBufferSpec)(gextras.StructNative(unsafe.Pointer(spec)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_audio_ring_buffer_parse_caps(_arg1, _arg2)
	runtime.KeepAlive(spec)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AudioRingBufferClass vmethods that subclasses can override to implement the
// ringbuffer.
//
// An instance of this type is always passed by reference.
type AudioRingBufferClass struct {
	*audioRingBufferClass
}

// audioRingBufferClass is the struct that's finalized.
type audioRingBufferClass struct {
	native *C.GstAudioRingBufferClass
}

// ParentClass: parent class.
func (a *AudioRingBufferClass) ParentClass() *gst.ObjectClass {
	valptr := &a.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AudioRingBufferSpec: structure containing the format specification of the
// ringbuffer.
//
// An instance of this type is always passed by reference.
type AudioRingBufferSpec struct {
	*audioRingBufferSpec
}

// audioRingBufferSpec is the struct that's finalized.
type audioRingBufferSpec struct {
	native *C.GstAudioRingBufferSpec
}

// Caps caps that generated the Spec.
func (a *AudioRingBufferSpec) Caps() *gst.Caps {
	valptr := &a.native.caps
	var _v *gst.Caps // out
	_v = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Type: sample type.
func (a *AudioRingBufferSpec) Type() AudioRingBufferFormatType {
	valptr := &a.native._type
	var _v AudioRingBufferFormatType // out
	_v = AudioRingBufferFormatType(*valptr)
	return _v
}

// Info: AudioInfo.
func (a *AudioRingBufferSpec) Info() *AudioInfo {
	valptr := &a.native.info
	var _v *AudioInfo // out
	_v = (*AudioInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// LatencyTime: latency in microseconds.
func (a *AudioRingBufferSpec) LatencyTime() uint64 {
	valptr := &a.native.latency_time
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// BufferTime: total buffer size in microseconds.
func (a *AudioRingBufferSpec) BufferTime() uint64 {
	valptr := &a.native.buffer_time
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Segsize: size of one segment in bytes.
func (a *AudioRingBufferSpec) Segsize() int {
	valptr := &a.native.segsize
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Segtotal: total number of segments.
func (a *AudioRingBufferSpec) Segtotal() int {
	valptr := &a.native.segtotal
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Seglatency: number of segments queued in the lower level device, defaults to
// segtotal.
func (a *AudioRingBufferSpec) Seglatency() int {
	valptr := &a.native.seglatency
	var _v int // out
	_v = int(*valptr)
	return _v
}

// LatencyTime: latency in microseconds.
func (a *AudioRingBufferSpec) SetLatencyTime(latencyTime uint64) {
	valptr := &a.native.latency_time
	*valptr = C.guint64(latencyTime)
}

// BufferTime: total buffer size in microseconds.
func (a *AudioRingBufferSpec) SetBufferTime(bufferTime uint64) {
	valptr := &a.native.buffer_time
	*valptr = C.guint64(bufferTime)
}

// Segsize: size of one segment in bytes.
func (a *AudioRingBufferSpec) SetSegsize(segsize int) {
	valptr := &a.native.segsize
	*valptr = C.gint(segsize)
}

// Segtotal: total number of segments.
func (a *AudioRingBufferSpec) SetSegtotal(segtotal int) {
	valptr := &a.native.segtotal
	*valptr = C.gint(segtotal)
}

// Seglatency: number of segments queued in the lower level device, defaults to
// segtotal.
func (a *AudioRingBufferSpec) SetSeglatency(seglatency int) {
	valptr := &a.native.seglatency
	*valptr = C.gint(seglatency)
}
