// Code generated by girgen. DO NOT EDIT.

package gstrtsp

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/rtsp/rtsp.h>
import "C"

// GType values.
var (
	GTypeRTSPLowerTrans = coreglib.Type(C.gst_rtsp_lower_trans_get_type())
	GTypeRTSPProfile    = coreglib.Type(C.gst_rtsp_profile_get_type())
	GTypeRTSPTransMode  = coreglib.Type(C.gst_rtsp_trans_mode_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRTSPLowerTrans, F: marshalRTSPLowerTrans},
		coreglib.TypeMarshaler{T: GTypeRTSPProfile, F: marshalRTSPProfile},
		coreglib.TypeMarshaler{T: GTypeRTSPTransMode, F: marshalRTSPTransMode},
	})
}

// RTSPLowerTrans: different transport methods.
type RTSPLowerTrans C.guint

const (
	// RtspLowerTransUnknown: invalid transport flag.
	RtspLowerTransUnknown RTSPLowerTrans = 0b0
	// RtspLowerTransUDP: stream data over UDP.
	RtspLowerTransUDP RTSPLowerTrans = 0b1
	// RtspLowerTransUDPMcast: stream data over UDP multicast.
	RtspLowerTransUDPMcast RTSPLowerTrans = 0b10
	// RtspLowerTransTCP: stream data over TCP.
	RtspLowerTransTCP RTSPLowerTrans = 0b100
	// RtspLowerTransHTTP: stream data tunneled over HTTP.
	RtspLowerTransHTTP RTSPLowerTrans = 0b10000
	// RtspLowerTransTLS: encrypt TCP and HTTP with TLS.
	RtspLowerTransTLS RTSPLowerTrans = 0b100000
)

func marshalRTSPLowerTrans(p uintptr) (interface{}, error) {
	return RTSPLowerTrans(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTSPLowerTrans.
func (r RTSPLowerTrans) String() string {
	if r == 0 {
		return "RTSPLowerTrans(0)"
	}

	var builder strings.Builder
	builder.Grow(117)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtspLowerTransUnknown:
			builder.WriteString("Unknown|")
		case RtspLowerTransUDP:
			builder.WriteString("UDP|")
		case RtspLowerTransUDPMcast:
			builder.WriteString("UDPMcast|")
		case RtspLowerTransTCP:
			builder.WriteString("TCP|")
		case RtspLowerTransHTTP:
			builder.WriteString("HTTP|")
		case RtspLowerTransTLS:
			builder.WriteString("TLS|")
		default:
			builder.WriteString(fmt.Sprintf("RTSPLowerTrans(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTSPLowerTrans) Has(other RTSPLowerTrans) bool {
	return (r & other) == other
}

// RTSPProfile: transfer profile to use.
type RTSPProfile C.guint

const (
	// RtspProfileUnknown: invalid profile.
	RtspProfileUnknown RTSPProfile = 0b0
	// RtspProfileAvp: audio/Visual profile (RFC 3551).
	RtspProfileAvp RTSPProfile = 0b1
	// RtspProfileSavp: secure Audio/Visual profile (RFC 3711).
	RtspProfileSavp RTSPProfile = 0b10
	// RtspProfileAvpf: audio/Visual profile with feedback (RFC 4585).
	RtspProfileAvpf RTSPProfile = 0b100
	// RtspProfileSavpf: secure Audio/Visual profile with feedback (RFC 5124).
	RtspProfileSavpf RTSPProfile = 0b1000
)

func marshalRTSPProfile(p uintptr) (interface{}, error) {
	return RTSPProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTSPProfile.
func (r RTSPProfile) String() string {
	if r == 0 {
		return "RTSPProfile(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtspProfileUnknown:
			builder.WriteString("Unknown|")
		case RtspProfileAvp:
			builder.WriteString("Avp|")
		case RtspProfileSavp:
			builder.WriteString("Savp|")
		case RtspProfileAvpf:
			builder.WriteString("Avpf|")
		case RtspProfileSavpf:
			builder.WriteString("Savpf|")
		default:
			builder.WriteString(fmt.Sprintf("RTSPProfile(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTSPProfile) Has(other RTSPProfile) bool {
	return (r & other) == other
}

// RTSPTransMode: transfer mode to use.
type RTSPTransMode C.guint

const (
	// RtspTransUnknown: invalid tansport mode.
	RtspTransUnknown RTSPTransMode = 0b0
	// RtspTransRtp: transfer RTP data.
	RtspTransRtp RTSPTransMode = 0b1
	// RtspTransRdt: transfer RDT (RealMedia) data.
	RtspTransRdt RTSPTransMode = 0b10
)

func marshalRTSPTransMode(p uintptr) (interface{}, error) {
	return RTSPTransMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTSPTransMode.
func (r RTSPTransMode) String() string {
	if r == 0 {
		return "RTSPTransMode(0)"
	}

	var builder strings.Builder
	builder.Grow(42)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtspTransUnknown:
			builder.WriteString("Unknown|")
		case RtspTransRtp:
			builder.WriteString("Rtp|")
		case RtspTransRdt:
			builder.WriteString("Rdt|")
		default:
			builder.WriteString(fmt.Sprintf("RTSPTransMode(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTSPTransMode) Has(other RTSPTransMode) bool {
	return (r & other) == other
}

// RTSPRange provides helper functions to deal with time ranges.
//
// An instance of this type is always passed by reference.
type RTSPRange struct {
	*rtspRange
}

// rtspRange is the struct that's finalized.
type rtspRange struct {
	native *C.GstRTSPRange
}

// NewRTSPRange creates a new RTSPRange instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewRTSPRange(min, max int) RTSPRange {
	var f0 C.gint // out
	f0 = C.gint(min)
	var f1 C.gint // out
	f1 = C.gint(max)

	v := C.GstRTSPRange{
		min: f0,
		max: f1,
	}

	return *(*RTSPRange)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Min: minimum value of the range.
func (r *RTSPRange) Min() int {
	valptr := &r.native.min
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Max: maximum value of the range.
func (r *RTSPRange) Max() int {
	valptr := &r.native.max
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Min: minimum value of the range.
func (r *RTSPRange) SetMin(min int) {
	valptr := &r.native.min
	*valptr = C.gint(min)
}

// Max: maximum value of the range.
func (r *RTSPRange) SetMax(max int) {
	valptr := &r.native.max
	*valptr = C.gint(max)
}

// RTSPTransport provides helper functions to deal with RTSP transport strings.
//
// An instance of this type is always passed by reference.
type RTSPTransport struct {
	*rtspTransport
}

// rtspTransport is the struct that's finalized.
type rtspTransport struct {
	native *C.GstRTSPTransport
}

// Trans: transport mode.
func (r *RTSPTransport) Trans() RTSPTransMode {
	valptr := &r.native.trans
	var _v RTSPTransMode // out
	_v = RTSPTransMode(*valptr)
	return _v
}

// Profile: tansport profile.
func (r *RTSPTransport) Profile() RTSPProfile {
	valptr := &r.native.profile
	var _v RTSPProfile // out
	_v = RTSPProfile(*valptr)
	return _v
}

// LowerTransport: lower transport.
func (r *RTSPTransport) LowerTransport() RTSPLowerTrans {
	valptr := &r.native.lower_transport
	var _v RTSPLowerTrans // out
	_v = RTSPLowerTrans(*valptr)
	return _v
}

// Destination: destination ip/hostname.
func (r *RTSPTransport) Destination() string {
	valptr := &r.native.destination
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Source: source ip/hostname.
func (r *RTSPTransport) Source() string {
	valptr := &r.native.source
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Layers: number of layers.
func (r *RTSPTransport) Layers() uint {
	valptr := &r.native.layers
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// ModePlay: if play mode was selected.
func (r *RTSPTransport) ModePlay() bool {
	valptr := &r.native.mode_play
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// ModeRecord: if record mode was selected.
func (r *RTSPTransport) ModeRecord() bool {
	valptr := &r.native.mode_record
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Append is append mode was selected.
func (r *RTSPTransport) Append() bool {
	valptr := &r.native.append
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Interleaved: interleave range.
func (r *RTSPTransport) Interleaved() *RTSPRange {
	valptr := &r.native.interleaved
	var _v *RTSPRange // out
	_v = (*RTSPRange)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TTL: time to live for multicast UDP.
func (r *RTSPTransport) TTL() uint {
	valptr := &r.native.ttl
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Port: port pair for multicast sessions.
func (r *RTSPTransport) Port() *RTSPRange {
	valptr := &r.native.port
	var _v *RTSPRange // out
	_v = (*RTSPRange)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ClientPort: client port pair for receiving data. For TCP based transports,
// applications can use this field to store the sender and receiver ports of the
// client.
func (r *RTSPTransport) ClientPort() *RTSPRange {
	valptr := &r.native.client_port
	var _v *RTSPRange // out
	_v = (*RTSPRange)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ServerPort: server port pair for receiving data. For TCP based transports,
// applications can use this field to store the sender and receiver ports of the
// server.
func (r *RTSPTransport) ServerPort() *RTSPRange {
	valptr := &r.native.server_port
	var _v *RTSPRange // out
	_v = (*RTSPRange)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Ssrc: ssrc that the sender/receiver will use.
func (r *RTSPTransport) Ssrc() uint {
	valptr := &r.native.ssrc
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Layers: number of layers.
func (r *RTSPTransport) SetLayers(layers uint) {
	valptr := &r.native.layers
	*valptr = C.guint(layers)
}

// ModePlay: if play mode was selected.
func (r *RTSPTransport) SetModePlay(modePlay bool) {
	valptr := &r.native.mode_play
	if modePlay {
		*valptr = C.TRUE
	}
}

// ModeRecord: if record mode was selected.
func (r *RTSPTransport) SetModeRecord(modeRecord bool) {
	valptr := &r.native.mode_record
	if modeRecord {
		*valptr = C.TRUE
	}
}

// Append is append mode was selected.
func (r *RTSPTransport) SetAppend(append bool) {
	valptr := &r.native.append
	if append {
		*valptr = C.TRUE
	}
}

// TTL: time to live for multicast UDP.
func (r *RTSPTransport) SetTTL(ttl uint) {
	valptr := &r.native.ttl
	*valptr = C.guint(ttl)
}

// Ssrc: ssrc that the sender/receiver will use.
func (r *RTSPTransport) SetSsrc(ssrc uint) {
	valptr := &r.native.ssrc
	*valptr = C.guint(ssrc)
}

// AsText: convert transport into a string that can be used to signal the
// transport in an RTSP SETUP response.
//
// The function returns the following values:
//
//    - utf8: string describing the RTSP transport or NULL when the transport is
//      invalid.
//
func (transport *RTSPTransport) AsText() string {
	var _arg0 *C.GstRTSPTransport // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstRTSPTransport)(gextras.StructNative(unsafe.Pointer(transport)))

	_cret = C.gst_rtsp_transport_as_text(_arg0)
	runtime.KeepAlive(transport)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// MediaType: get the media type of transport. This media type is typically used
// to generate Caps events.
//
// The function returns the following values:
//
//    - mediaType: media type of transport.
//    - rtspResult: T_RTSP_OK.
//
func (transport *RTSPTransport) MediaType() (string, RTSPResult) {
	var _arg0 *C.GstRTSPTransport // out
	var _arg1 *C.gchar            // in
	var _cret C.GstRTSPResult     // in

	_arg0 = (*C.GstRTSPTransport)(gextras.StructNative(unsafe.Pointer(transport)))

	_cret = C.gst_rtsp_transport_get_media_type(_arg0, &_arg1)
	runtime.KeepAlive(transport)

	var _mediaType string      // out
	var _rtspResult RTSPResult // out

	_mediaType = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	_rtspResult = RTSPResult(_cret)

	return _mediaType, _rtspResult
}

// Init: initialize transport so that it can be used.
//
// The function returns the following values:
//
//    - rtspResult: T_RTSP_OK.
//
func (transport *RTSPTransport) Init() RTSPResult {
	var _arg0 *C.GstRTSPTransport // out
	var _cret C.GstRTSPResult     // in

	_arg0 = (*C.GstRTSPTransport)(gextras.StructNative(unsafe.Pointer(transport)))

	_cret = C.gst_rtsp_transport_init(_arg0)
	runtime.KeepAlive(transport)

	var _rtspResult RTSPResult // out

	_rtspResult = RTSPResult(_cret)

	return _rtspResult
}

// RTSPTransportGetManager: get the Element that can handle the buffers
// transported over trans.
//
// It is possible that there are several managers available, use option to
// selected one.
//
// manager will contain an element name or NULL when no manager is
// needed/available for trans.
//
// The function takes the following parameters:
//
//    - trans: RTSPTransMode.
//    - option index.
//
// The function returns the following values:
//
//    - manager (optional): location to hold the result.
//    - rtspResult: T_RTSP_OK.
//
func RTSPTransportGetManager(trans RTSPTransMode, option uint) (string, RTSPResult) {
	var _arg1 C.GstRTSPTransMode // out
	var _arg2 *C.gchar           // in
	var _arg3 C.guint            // out
	var _cret C.GstRTSPResult    // in

	_arg1 = C.GstRTSPTransMode(trans)
	_arg3 = C.guint(option)

	_cret = C.gst_rtsp_transport_get_manager(_arg1, &_arg2, _arg3)
	runtime.KeepAlive(trans)
	runtime.KeepAlive(option)

	var _manager string        // out
	var _rtspResult RTSPResult // out

	if _arg2 != nil {
		_manager = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	}
	_rtspResult = RTSPResult(_cret)

	return _manager, _rtspResult
}

// RTSPTransportParse: parse the RTSP transport string str into transport.
//
// The function takes the following parameters:
//
//    - str: transport string.
//    - transport: RTSPTransport.
//
// The function returns the following values:
//
//    - rtspResult: RTSPResult.
//
func RTSPTransportParse(str string, transport *RTSPTransport) RTSPResult {
	var _arg1 *C.gchar            // out
	var _arg2 *C.GstRTSPTransport // out
	var _cret C.GstRTSPResult     // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstRTSPTransport)(gextras.StructNative(unsafe.Pointer(transport)))

	_cret = C.gst_rtsp_transport_parse(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(transport)

	var _rtspResult RTSPResult // out

	_rtspResult = RTSPResult(_cret)

	return _rtspResult
}
