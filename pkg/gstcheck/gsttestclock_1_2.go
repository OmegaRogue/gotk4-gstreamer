// Code generated by girgen. DO NOT EDIT.

package gstcheck

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/check/check.h>
import "C"

// GType values.
var (
	GTypeTestClock = coreglib.Type(C.gst_test_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTestClock, F: marshalTestClock},
	})
}

// TestClockOverrides contains methods that are overridable.
type TestClockOverrides struct {
}

func defaultTestClockOverrides(v *TestClock) TestClockOverrides {
	return TestClockOverrides{}
}

// TestClock is an implementation of Clock which has different behaviour
// compared to SystemClock. Time for SystemClock advances according to the
// system time, while time for TestClock changes only when
// gst_test_clock_set_time() or gst_test_clock_advance_time() are called.
// TestClock provides unit tests with the possibility to precisely advance the
// time in a deterministic manner, independent of the system time or any other
// external factors.
//
// Advancing the time of a TestClock
//
//      #include <gst/gst.h>
//      #include <gst/check/gstcheck.h>
//      #include <gst/check/gsttestclock.h>
//
//      GstClockTime latency;
//      GstElement *element;
//      GstPad *srcpad;
//      GstClock *clock;
//      GstTestClock *test_clock;
//      GstBuffer buf;
//      GstClockID pending_id;
//      GstClockID processed_id;
//
//      latency = 42 * GST_MSECOND;
//      element = create_element (latency, ...);
//      srcpad = get_source_pad (element);
//
//      clock = gst_test_clock_new ();
//      test_clock = GST_TEST_CLOCK (clock);
//      gst_element_set_clock (element, clock);
//
//      GST_INFO ("Set time, create and push the first buffer\n");
//      gst_test_clock_set_time (test_clock, 0);
//      buf = create_test_buffer (gst_clock_get_time (clock), ...);
//      gst_assert_cmpint (gst_pad_push (srcpad, buf), ==, GST_FLOW_OK);
//
//      GST_INFO ("Block until element is waiting for a clock notification\n");
//      gst_test_clock_wait_for_next_pending_id (test_clock, &pending_id);
//      GST_INFO ("Advance to the requested time of the clock notification\n");
//      gst_test_clock_advance_time (test_clock, latency);
//      GST_INFO ("Release the next blocking wait and make sure it is the one from element\n");
//      processed_id = gst_test_clock_process_next_clock_id (test_clock);
//      g_assert (processed_id == pending_id);
//      g_assert_cmpint (GST_CLOCK_ENTRY_STATUS (processed_id), ==, GST_CLOCK_OK);
//      gst_clock_id_unref (pending_id);
//      gst_clock_id_unref (processed_id);
//
//      GST_INFO ("Validate that element produced an output buffer and check its timestamp\n");
//      g_assert_cmpint (get_number_of_output_buffer (...), ==, 1);
//      buf = get_buffer_pushed_by_element (element, ...);
//      g_assert_cmpint (GST_BUFFER_TIMESTAMP (buf), ==, latency);
//      gst_buffer_unref (buf);
//      GST_INFO ("Check that element does not wait for any clock notification\n");
//      g_assert (!gst_test_clock_peek_next_pending_id (test_clock, NULL));
//
//      GST_INFO ("Set time, create and push the second buffer\n");
//      gst_test_clock_advance_time (test_clock, 10 * GST_SECOND);
//      buf = create_test_buffer (gst_clock_get_time (clock), ...);
//      gst_assert_cmpint (gst_pad_push (srcpad, buf), ==, GST_FLOW_OK);
//
//      GST_INFO ("Block until element is waiting for a new clock notification\n");
//      (gst_test_clock_wait_for_next_pending_id (test_clock, &pending_id);
//      GST_INFO ("Advance past 7ms beyond the requested time of the clock notification\n");
//      gst_test_clock_advance_time (test_clock, latency + 7 * GST_MSECOND);
//      GST_INFO ("Release the next blocking wait and make sure it is the one from element\n");
//      processed_id = gst_test_clock_process_next_clock_id (test_clock);
//      g_assert (processed_id == pending_id);
//      g_assert_cmpint (GST_CLOCK_ENTRY_STATUS (processed_id), ==, GST_CLOCK_OK);
//      gst_clock_id_unref (pending_id);
//      gst_clock_id_unref (processed_id);
//
//      GST_INFO ("Validate that element produced an output buffer and check its timestamp\n");
//      g_assert_cmpint (get_number_of_output_buffer (...), ==, 1);
//      buf = get_buffer_pushed_by_element (element, ...);
//      g_assert_cmpint (GST_BUFFER_TIMESTAMP (buf), ==,
//          10 * GST_SECOND + latency + 7 * GST_MSECOND);
//      gst_buffer_unref (buf);
//      GST_INFO ("Check that element does not wait for any clock notification\n");
//      g_assert (!gst_test_clock_peek_next_pending_id (test_clock, NULL));
//      ...
//
// Since TestClock is only supposed to be used in unit tests it calls
// g_assert(), g_assert_cmpint() or g_assert_cmpuint() to validate all function
// arguments. This will highlight any issues with the unit test code itself.
type TestClock struct {
	_ [0]func() // equal guard
	gst.Clock
}

var (
	_ gst.Clocker = (*TestClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TestClock, *TestClockClass, TestClockOverrides](
		GTypeTestClock,
		initTestClockClass,
		wrapTestClock,
		defaultTestClockOverrides,
	)
}

func initTestClockClass(gclass unsafe.Pointer, overrides TestClockOverrides, classInitFunc func(*TestClockClass)) {
	if classInitFunc != nil {
		class := (*TestClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTestClock(obj *coreglib.Object) *TestClock {
	return &TestClock{
		Clock: gst.Clock{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTestClock(p uintptr) (interface{}, error) {
	return wrapTestClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTestClock creates a new test clock with its time set to zero.
//
// MT safe.
//
// The function returns the following values:
//
//    - testClock cast to Clock.
//
func NewTestClock() *TestClock {
	var _cret *C.GstClock // in

	_cret = C.gst_test_clock_new()

	var _testClock *TestClock // out

	_testClock = wrapTestClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testClock
}

// NewTestClockWithStartTime creates a new test clock with its time set to the
// specified time.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - startTime set to the desired start time of the clock.
//
// The function returns the following values:
//
//    - testClock cast to Clock.
//
func NewTestClockWithStartTime(startTime gst.ClockTime) *TestClock {
	var _arg1 C.GstClockTime // out
	var _cret *C.GstClock    // in

	_arg1 = C.guint64(startTime)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_test_clock_new_with_start_time(_arg1)
	runtime.KeepAlive(startTime)

	var _testClock *TestClock // out

	_testClock = wrapTestClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testClock
}

// AdvanceTime advances the time of the test_clock by the amount given by delta.
// The time of test_clock is monotonically increasing, therefore providing a
// delta which is negative or zero is a programming error.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - delta: positive ClockTimeDiff to be added to the time of the clock.
//
func (testClock *TestClock) AdvanceTime(delta gst.ClockTimeDiff) {
	var _arg0 *C.GstTestClock    // out
	var _arg1 C.GstClockTimeDiff // out

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = C.gint64(delta)
	type _ = gst.ClockTimeDiff
	type _ = int64

	C.gst_test_clock_advance_time(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(delta)
}

// Crank: "crank" consists of three steps: 1: Wait for a ClockID to be
// registered with the TestClock. 2: Advance the TestClock to the time the
// ClockID is waiting, unless the clock time is already passed the clock id
// (Since: 1.18). 3: Release the ClockID wait. A "crank" can be though of as the
// notion of manually driving the clock forward to its next logical step.
//
// The function returns the following values:
//
//    - ok: TRUE if the crank was successful, FALSE otherwise.
//
//      MT safe.
//
func (testClock *TestClock) Crank() bool {
	var _arg0 *C.GstTestClock // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))

	_cret = C.gst_test_clock_crank(_arg0)
	runtime.KeepAlive(testClock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextEntryTime: retrieve the requested time for the next pending clock
// notification.
//
// MT safe.
//
// The function returns the following values:
//
//    - clockTime set to the time of the next pending clock notification. If no
//      clock notifications have been requested GST_CLOCK_TIME_NONE will be
//      returned.
//
func (testClock *TestClock) NextEntryTime() gst.ClockTime {
	var _arg0 *C.GstTestClock // out
	var _cret C.GstClockTime  // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))

	_cret = C.gst_test_clock_get_next_entry_time(_arg0)
	runtime.KeepAlive(testClock)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// HasID checks whether test_clock was requested to provide the clock
// notification given by id.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - id clock notification.
//
// The function returns the following values:
//
//    - ok: TRUE if the clock has been asked to provide the given clock
//      notification, FALSE otherwise.
//
func (testClock *TestClock) HasID(id gst.ClockID) bool {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(id))
	type _ = gst.ClockID
	type _ = unsafe.Pointer

	_cret = C.gst_test_clock_has_id(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(id)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeekIDCount: determine the number of pending clock notifications that have
// been requested from the test_clock.
//
// MT safe.
//
// The function returns the following values:
//
//    - guint: number of pending clock notifications.
//
func (testClock *TestClock) PeekIDCount() uint {
	var _arg0 *C.GstTestClock // out
	var _cret C.guint         // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))

	_cret = C.gst_test_clock_peek_id_count(_arg0)
	runtime.KeepAlive(testClock)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PeekNextPendingID determines if the pending_id is the next clock notification
// scheduled to be triggered given the current time of the test_clock.
//
// MT safe.
//
// The function returns the following values:
//
//    - pendingId (optional) clock notification to look for.
//    - ok: TRUE if pending_id is the next clock notification to be triggered,
//      FALSE otherwise.
//
func (testClock *TestClock) PeekNextPendingID() (gst.ClockID, bool) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))

	_cret = C.gst_test_clock_peek_next_pending_id(_arg0, &_arg1)
	runtime.KeepAlive(testClock)

	var _pendingId gst.ClockID // out
	var _ok bool               // out

	_pendingId = (unsafe.Pointer)(unsafe.Pointer(_arg1))
	type _ = gst.ClockID
	type _ = unsafe.Pointer
	if _cret != 0 {
		_ok = true
	}

	return _pendingId, _ok
}

// ProcessID processes and releases the pending ID.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - pendingId: ClockID.
//
// The function returns the following values:
//
func (testClock *TestClock) ProcessID(pendingId gst.ClockID) bool {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(pendingId))
	type _ = gst.ClockID
	type _ = unsafe.Pointer

	_cret = C.gst_test_clock_process_id(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(pendingId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProcessIDList processes and releases the pending IDs in the list.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - pendingList (optional): list of pending ClockIDs.
//
// The function returns the following values:
//
func (testClock *TestClock) ProcessIDList(pendingList []gst.ClockID) uint {
	var _arg0 *C.GstTestClock // out
	var _arg1 *C.GList        // out
	var _cret C.guint         // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	if pendingList != nil {
		for i := len(pendingList) - 1; i >= 0; i-- {
			src := pendingList[i]
			var dst *C.GstClockID // out
			dst = (C.gpointer)(unsafe.Pointer(src))
			type _ = gst.ClockID
			type _ = unsafe.Pointer
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}

	_cret = C.gst_test_clock_process_id_list(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(pendingList)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ProcessNextClockID: MT safe.
//
// The function returns the following values:
//
//    - clockID (optional) containing the next pending clock notification.
//
func (testClock *TestClock) ProcessNextClockID() gst.ClockID {
	var _arg0 *C.GstTestClock // out
	var _cret C.GstClockID    // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))

	_cret = C.gst_test_clock_process_next_clock_id(_arg0)
	runtime.KeepAlive(testClock)

	var _clockID gst.ClockID // out

	_clockID = (unsafe.Pointer)(unsafe.Pointer(_cret))
	type _ = gst.ClockID
	type _ = unsafe.Pointer

	return _clockID
}

// SetTime sets the time of test_clock to the time given by new_time. The time
// of test_clock is monotonically increasing, therefore providing a new_time
// which is earlier or equal to the time of the clock as given by
// gst_clock_get_time() is a programming error.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - newTime later than that returned by gst_clock_get_time().
//
func (testClock *TestClock) SetTime(newTime gst.ClockTime) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockTime  // out

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = C.guint64(newTime)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_test_clock_set_time(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(newTime)
}

// TimedWaitForMultiplePendingIDs blocks until at least count clock
// notifications have been requested from test_clock, or the timeout expires.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - count: number of pending clock notifications to wait for.
//    - timeoutMs: timeout in milliseconds.
//
// The function returns the following values:
//
//    - pendingList (optional): address of a #GList pointer variable to store the
//      list of pending ClockIDs that expired, or NULL.
//    - ok: gboolean TRUE if the waits have been registered, FALSE if not. (Could
//      be that it timed out waiting or that more waits than waits was found).
//
func (testClock *TestClock) TimedWaitForMultiplePendingIDs(count, timeoutMs uint) ([]gst.ClockID, bool) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out
	var _arg3 *C.GList        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = C.guint(count)
	_arg2 = C.guint(timeoutMs)

	_cret = C.gst_test_clock_timed_wait_for_multiple_pending_ids(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(count)
	runtime.KeepAlive(timeoutMs)

	var _pendingList []gst.ClockID // out
	var _ok bool                   // out

	if _arg3 != nil {
		_pendingList = make([]gst.ClockID, 0, gextras.ListSize(unsafe.Pointer(_arg3)))
		gextras.MoveList(unsafe.Pointer(_arg3), true, func(v unsafe.Pointer) {
			src := (*C.GstClockID)(v)
			var dst gst.ClockID // out
			dst = (unsafe.Pointer)(unsafe.Pointer(src))
			type _ = gst.ClockID
			type _ = unsafe.Pointer
			_pendingList = append(_pendingList, dst)
		})
	}
	if _cret != 0 {
		_ok = true
	}

	return _pendingList, _ok
}

// WaitForMultiplePendingIDs blocks until at least count clock notifications
// have been requested from test_clock. There is no timeout for this wait, see
// the main description of TestClock.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - count: number of pending clock notifications to wait for.
//
// The function returns the following values:
//
//    - pendingList (optional): address of a #GList pointer variable to store the
//      list of pending ClockIDs that expired, or NULL.
//
func (testClock *TestClock) WaitForMultiplePendingIDs(count uint) []gst.ClockID {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.guint         // out
	var _arg2 *C.GList        // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = C.guint(count)

	C.gst_test_clock_wait_for_multiple_pending_ids(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(count)

	var _pendingList []gst.ClockID // out

	if _arg2 != nil {
		_pendingList = make([]gst.ClockID, 0, gextras.ListSize(unsafe.Pointer(_arg2)))
		gextras.MoveList(unsafe.Pointer(_arg2), true, func(v unsafe.Pointer) {
			src := (*C.GstClockID)(v)
			var dst gst.ClockID // out
			dst = (unsafe.Pointer)(unsafe.Pointer(src))
			type _ = gst.ClockID
			type _ = unsafe.Pointer
			_pendingList = append(_pendingList, dst)
		})
	}

	return _pendingList
}

// WaitForNextPendingID waits until a clock notification is requested from
// test_clock. There is no timeout for this wait, see the main description of
// TestClock. A reference to the pending clock notification is stored in
// pending_id.
//
// MT safe.
//
// The function returns the following values:
//
//    - pendingId (optional) information about the pending clock notification.
//
func (testClock *TestClock) WaitForNextPendingID() gst.ClockID {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))

	C.gst_test_clock_wait_for_next_pending_id(_arg0, &_arg1)
	runtime.KeepAlive(testClock)

	var _pendingId gst.ClockID // out

	_pendingId = (unsafe.Pointer)(unsafe.Pointer(_arg1))
	type _ = gst.ClockID
	type _ = unsafe.Pointer

	return _pendingId
}

// WaitForPendingIDCount blocks until at least count clock notifications have
// been requested from test_clock. There is no timeout for this wait, see the
// main description of TestClock.
//
// Deprecated: use gst_test_clock_wait_for_multiple_pending_ids() instead.
//
// The function takes the following parameters:
//
//    - count: number of pending clock notifications to wait for.
//
func (testClock *TestClock) WaitForPendingIDCount(count uint) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.InternObject(testClock).Native()))
	_arg1 = C.guint(count)

	C.gst_test_clock_wait_for_pending_id_count(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(count)
}

// TestClockClass class of a TestClock, which has no virtual methods to
// override.
//
// An instance of this type is always passed by reference.
type TestClockClass struct {
	*testClockClass
}

// testClockClass is the struct that's finalized.
type testClockClass struct {
	native *C.GstTestClockClass
}

// ParentClass: parent class structure.
func (t *TestClockClass) ParentClass() *gst.ClockClass {
	valptr := &t.native.parent_class
	var _v *gst.ClockClass // out
	_v = (*gst.ClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
