// Code generated by girgen. DO NOT EDIT.

package gstcheck

import (
	"runtime"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/check/check.h>
// extern void callbackDelete(gpointer);
// extern GstPadProbeReturn _gotk4_gstcheck1_PadProbeCallback(GstPad*, GstPadProbeInfo*, gpointer);
// extern GstPadProbeReturn _gotk4_gst1_PadProbeCallback(GstPad*, GstPadProbeInfo*, gpointer);
import "C"

// Harness is meant to make writing unit test for GStreamer much easier. It can
// be thought of as a way of treating a Element as a black box,
// deterministically feeding it data, and controlling what data it outputs.
//
// The basic structure of Harness is two "floating" Pads that connect to the
// harnessed Element src and sink Pads like so:
//
//              __________________________
//     _____   |  _____            _____  |   _____
//    |     |  | |     |          |     | |  |     |
//    | src |--+-| sink|  Element | src |-+--| sink|
//    |_____|  | |_____|          |_____| |  |_____|
//             |__________________________|
//
//
// With this, you can now simulate any environment the Element might find itself
// in. By specifying the Caps of the harness Pads, using functions like
// gst_harness_set_src_caps() or gst_harness_set_sink_caps_str(), you can test
// how the Element interacts with different caps sets.
//
// Your harnessed Element can of course also be a bin, and using
// gst_harness_new_parse() supporting standard gst-launch syntax, you can easily
// test a whole pipeline instead of just one element.
//
// You can then go on to push Buffers and Events on to the srcpad, using
// functions like gst_harness_push() and gst_harness_push_event(), and then pull
// them out to examine them with gst_harness_pull() and
// gst_harness_pull_event().
//
// A simple buffer-in buffer-out example
//
//    gst_harness_push_from_src (h);
//
// An instance of this type is always passed by reference.
type Harness struct {
	*harness
}

// harness is the struct that's finalized.
type harness struct {
	native *C.GstHarness
}

// Element: element inside the harness.
func (h *Harness) Element() gst.Elementer {
	valptr := &h.native.element
	var _v gst.Elementer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gst.Elementer)
			return ok
		})
		rv, ok := casted.(gst.Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_v = rv
	}
	return _v
}

// Srcpad: internal harness source pad.
func (h *Harness) Srcpad() *gst.Pad {
	valptr := &h.native.srcpad
	var _v *gst.Pad // out
	{
		obj := coreglib.Take(unsafe.Pointer(*valptr))
		_v = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}
	return _v
}

// Sinkpad: internal harness sink pad.
func (h *Harness) Sinkpad() *gst.Pad {
	valptr := &h.native.sinkpad
	var _v *gst.Pad // out
	{
		obj := coreglib.Take(unsafe.Pointer(*valptr))
		_v = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}
	return _v
}

// SrcHarness: source (input) harness (if any).
func (h *Harness) SrcHarness() *Harness {
	valptr := &h.native.src_harness
	var _v *Harness // out
	_v = (*Harness)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// SinkHarness: sink (output) harness (if any).
func (h *Harness) SinkHarness() *Harness {
	valptr := &h.native.sink_harness
	var _v *Harness // out
	_v = (*Harness)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// AddElementSinkPad links the specified Pad the GstHarness srcpad.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - sinkpad to link to the harness srcpad.
//
func (h *Harness) AddElementSinkPad(sinkpad *gst.Pad) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	C.gst_harness_add_element_sink_pad(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(sinkpad)
}

// AddElementSrcPad links the specified Pad the GstHarness sinkpad. This can be
// useful if perhaps the srcpad did not exist at the time of creating the
// harness, like a demuxer that provides a sometimes-pad after receiving data.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - srcpad to link to the harness sinkpad.
//
func (h *Harness) AddElementSrcPad(srcpad *gst.Pad) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))

	C.gst_harness_add_element_src_pad(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(srcpad)
}

// AddProbe: convenience function to allows you to call gst_pad_add_probe on a
// Pad of a Element that are residing inside the Harness, by using normal
// gst_pad_add_probe syntax
//
// MT safe.
//
// The function takes the following parameters:
//
//    - elementName with a ElementFactory name.
//    - padName with the name of the pad to attach the probe to.
//    - mask (see gst_pad_add_probe).
//    - callback (see gst_pad_add_probe).
//
func (h *Harness) AddProbe(elementName string, padName string, mask gst.PadProbeType, callback gst.PadProbeCallback) {
	var _arg0 *C.GstHarness         // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 C.GstPadProbeType     // out
	var _arg4 C.GstPadProbeCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(padName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GstPadProbeType(mask)
	_arg4 = (*[0]byte)(C._gotk4_gst1_PadProbeCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gst_harness_add_probe(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(h)
	runtime.KeepAlive(elementName)
	runtime.KeepAlive(padName)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(callback)
}

// AddProposeAllocationMeta: add api with params as one of the supported
// metadata API to propose when receiving an allocation query.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - api: metadata API.
//    - params (optional): API specific parameters.
//
func (h *Harness) AddProposeAllocationMeta(api coreglib.Type, params *gst.Structure) {
	var _arg0 *C.GstHarness   // out
	var _arg1 C.GType         // out
	var _arg2 *C.GstStructure // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.GType(api)
	if params != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_harness_add_propose_allocation_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(api)
	runtime.KeepAlive(params)
}

// AddSink: similar to gst_harness_add_sink_harness, this is a convenience to
// directly create a sink-harness using the sink_element_name name specified.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - sinkElementName with the name of a Element.
//
func (h *Harness) AddSink(sinkElementName string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(sinkElementName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_add_sink(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(sinkElementName)
}

// AddSinkHarness: similar to gst_harness_add_src, this allows you to send the
// data coming out of your harnessed Element to a sink-element, allowing to test
// different responses the element output might create in sink elements. An
// example might be an existing sink providing some analytical data on the input
// it receives that can be useful to your testing. If the goal is to test a
// sink-element itself, this is better achieved using gst_harness_new directly
// on the sink.
//
// If a sink-harness already exists it will be replaced.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - sinkHarness to be added as a sink-harness.
//
func (h *Harness) AddSinkHarness(sinkHarness *Harness) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(sinkHarness)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(sinkHarness)), nil)

	C.gst_harness_add_sink_harness(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(sinkHarness)
}

// AddSinkParse: similar to gst_harness_add_sink, this allows you to specify a
// launch-line instead of just an element name. See gst_harness_add_src_parse
// for details.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - launchline with the name of a Element.
//
func (h *Harness) AddSinkParse(launchline string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(launchline)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_add_sink_parse(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(launchline)
}

// AddSrc: similar to gst_harness_add_src_harness, this is a convenience to
// directly create a src-harness using the src_element_name name specified.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - srcElementName with the name of a Element.
//    - hasClockWait specifying if the Element uses gst_clock_wait_id internally.
//
func (h *Harness) AddSrc(srcElementName string, hasClockWait bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcElementName)))
	defer C.free(unsafe.Pointer(_arg1))
	if hasClockWait {
		_arg2 = C.TRUE
	}

	C.gst_harness_add_src(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(srcElementName)
	runtime.KeepAlive(hasClockWait)
}

// AddSrcHarness src-harness is a great way of providing the Harness with data.
// By adding a src-type Element, it is then easy to use functions like
// gst_harness_push_from_src or gst_harness_src_crank_and_push_many to provide
// your harnessed element with input. The has_clock_wait variable is a great way
// to control you src-element with, in that you can have it produce a buffer for
// you by simply cranking the clock, and not have it spin out of control
// producing buffers as fast as possible.
//
// If a src-harness already exists it will be replaced.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - srcHarness to be added as a src-harness.
//    - hasClockWait specifying if the Element uses gst_clock_wait_id internally.
//
func (h *Harness) AddSrcHarness(srcHarness *Harness, hasClockWait bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstHarness // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(srcHarness)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(srcHarness)), nil)
	if hasClockWait {
		_arg2 = C.TRUE
	}

	C.gst_harness_add_src_harness(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(srcHarness)
	runtime.KeepAlive(hasClockWait)
}

// AddSrcParse: similar to gst_harness_add_src, this allows you to specify a
// launch-line, which can be useful for both having more then one Element acting
// as your src (Like a src producing raw buffers, and then an encoder, providing
// encoded data), but also by allowing you to set properties like "is-live"
// directly on the elements.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - launchline describing a gst-launch type line.
//    - hasClockWait specifying if the Element uses gst_clock_wait_id internally.
//
func (h *Harness) AddSrcParse(launchline string, hasClockWait bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(launchline)))
	defer C.free(unsafe.Pointer(_arg1))
	if hasClockWait {
		_arg2 = C.TRUE
	}

	C.gst_harness_add_src_parse(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(launchline)
	runtime.KeepAlive(hasClockWait)
}

// BuffersInQueue: number of Buffers currently in the Harness sinkpad Queue
//
// MT safe.
//
// The function returns the following values:
//
//    - guint number of buffers in the queue.
//
func (h *Harness) BuffersInQueue() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_buffers_in_queue(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// BuffersReceived: total number of Buffers that has arrived on the Harness
// sinkpad. This number includes buffers that have been dropped as well as
// buffers that have already been pulled out.
//
// MT safe.
//
// The function returns the following values:
//
//    - guint number of buffers received.
//
func (h *Harness) BuffersReceived() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_buffers_received(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CrankMultipleClockWaits: similar to gst_harness_crank_single_clock_wait(),
// this is the function to use if your harnessed element(s) are using more then
// one gst_clock_id_wait. Failing to do so can (and will) make it racy which
// ClockID you actually are releasing, where as this function will process all
// the waits at the same time, ensuring that one thread can't register another
// wait before both are released.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - waits describing the number of ClockIDs to crank.
//
// The function returns the following values:
//
//    - ok: gboolean TRUE if the "crank" was successful, FALSE if not.
//
func (h *Harness) CrankMultipleClockWaits(waits uint) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 C.guint       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.guint(waits)

	_cret = C.gst_harness_crank_multiple_clock_waits(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(waits)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CrankSingleClockWait: "crank" consists of three steps: 1: Wait for a ClockID
// to be registered with the TestClock. 2: Advance the TestClock to the time the
// ClockID is waiting for. 3: Release the ClockID wait. Together, this provides
// an easy way to not have to think about the details around clocks and time,
// but still being able to write deterministic tests that are dependent on this.
// A "crank" can be though of as the notion of manually driving the clock
// forward to its next logical step.
//
// MT safe.
//
// The function returns the following values:
//
//    - ok: gboolean TRUE if the "crank" was successful, FALSE if not.
//
func (h *Harness) CrankSingleClockWait() bool {
	var _arg0 *C.GstHarness // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_crank_single_clock_wait(_arg0)
	runtime.KeepAlive(h)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateBuffer allocates a buffer using a BufferPool if present, or else using
// the configured Allocator and AllocationParams
//
// MT safe.
//
// The function takes the following parameters:
//
//    - size specifying the size of the buffer.
//
// The function returns the following values:
//
//    - buffer of size size.
//
func (h *Harness) CreateBuffer(size uint) *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gsize       // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.gsize(size)

	_cret = C.gst_harness_create_buffer(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// DumpToFile allows you to dump the Buffers the Harness sinkpad Queue to a
// file.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - filename with a the name of a file.
//
func (h *Harness) DumpToFile(filename string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_dump_to_file(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(filename)
}

// EventsInQueue: number of Events currently in the Harness sinkpad Queue
//
// MT safe.
//
// The function returns the following values:
//
//    - guint number of events in the queue.
//
func (h *Harness) EventsInQueue() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_events_in_queue(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// EventsReceived: total number of Events that has arrived on the Harness
// sinkpad This number includes events handled by the harness as well as events
// that have already been pulled out.
//
// MT safe.
//
// The function returns the following values:
//
//    - guint number of events received.
//
func (h *Harness) EventsReceived() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_events_received(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// FindElement: most useful in conjunction with gst_harness_new_parse, this will
// scan the Elements inside the Harness, and check if any of them matches
// element_name. Typical usecase being that you need to access one of the
// harnessed elements for properties and/or signals.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - elementName with a ElementFactory name.
//
// The function returns the following values:
//
//    - element (optional) or NULL if not found.
//
func (h *Harness) FindElement(elementName string) gst.Elementer {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_harness_find_element(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(elementName)

	var _element gst.Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Elementer)
				return ok
			})
			rv, ok := casted.(gst.Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// Allocator gets the allocator and its params that has been decided to use
// after an allocation query.
//
// MT safe.
//
// The function returns the following values:
//
//    - allocator (optional): Allocator used.
//    - params (optional) of allocator.
//
func (h *Harness) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstHarness         // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(h)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_params)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocator, _params
}

// LastPushedTimestamp: get the timestamp of the last Buffer pushed on the
// Harness srcpad, typically with gst_harness_push or gst_harness_push_from_src.
//
// MT safe.
//
// The function returns the following values:
//
//    - clockTime with the timestamp or GST_CLOCK_TIME_NONE if no Buffer has been
//      pushed on the Harness srcpad.
//
func (h *Harness) LastPushedTimestamp() gst.ClockTime {
	var _arg0 *C.GstHarness  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_get_last_pushed_timestamp(_arg0)
	runtime.KeepAlive(h)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// Testclock: get the TestClock. Useful if specific operations on the testclock
// is needed.
//
// MT safe.
//
// The function returns the following values:
//
//    - testClock or NULL if the testclock is not present.
//
func (h *Harness) Testclock() *TestClock {
	var _arg0 *C.GstHarness   // out
	var _cret *C.GstTestClock // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_get_testclock(_arg0)
	runtime.KeepAlive(h)

	var _testClock *TestClock // out

	_testClock = wrapTestClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testClock
}

// Play: this will set the harnessed Element to GST_STATE_PLAYING. Elements
// without a sink-Pad and with the GST_ELEMENT_FLAG_SOURCE flag set is
// considered a src Element Non-src Elements (like sinks and filters) are
// automatically set to playing by the Harness, but src Elements are not to
// avoid them starting to produce buffers. Hence, for src Element you must call
// gst_harness_play() explicitly.
//
// MT safe.
func (h *Harness) Play() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_play(_arg0)
	runtime.KeepAlive(h)
}

// Pull pulls a Buffer from the Queue on the Harness sinkpad. The pull will
// timeout in 60 seconds. This is the standard way of getting a buffer from a
// harnessed Element.
//
// MT safe.
//
// The function returns the following values:
//
//    - buffer or NULL if timed out.
//
func (h *Harness) Pull() *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull(_arg0)
	runtime.KeepAlive(h)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// PullEvent pulls an Event from the Queue on the Harness sinkpad. Timeouts
// after 60 seconds similar to gst_harness_pull.
//
// MT safe.
//
// The function returns the following values:
//
//    - event or NULL if timed out.
//
func (h *Harness) PullEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// PullUntilEos pulls a Buffer from the Queue on the Harness sinkpad. The pull
// will block until an EOS event is received, or timeout in 60 seconds. MT safe.
//
// The function returns the following values:
//
//    - buf or NULL if EOS or timeout occures first.
//    - ok: TRUE on success, FALSE on timeout.
//
func (h *Harness) PullUntilEos() (*gst.Buffer, bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstBuffer  // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull_until_eos(_arg0, &_arg1)
	runtime.KeepAlive(h)

	var _buf *gst.Buffer // out
	var _ok bool         // out

	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buf)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _buf, _ok
}

// PullUpstreamEvent pulls an Event from the Queue on the Harness srcpad.
// Timeouts after 60 seconds similar to gst_harness_pull.
//
// MT safe.
//
// The function returns the following values:
//
//    - event or NULL if timed out.
//
func (h *Harness) PullUpstreamEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull_upstream_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// Push pushes a Buffer on the Harness srcpad. The standard way of interacting
// with an harnessed element.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - buffer to push.
//
// The function returns the following values:
//
//    - flowReturn with the result from the push.
//
func (h *Harness) Push(buffer *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_harness_push(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushAndPull: basically a gst_harness_push and a gst_harness_pull in one line.
// Reflects the fact that you often want to do exactly this in your test: Push
// one buffer in, and inspect the outcome.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - buffer to push.
//
// The function returns the following values:
//
//    - ret or NULL if timed out.
//
func (h *Harness) PushAndPull(buffer *gst.Buffer) *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstBuffer  // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_harness_push_and_pull(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(buffer)

	var _ret *gst.Buffer // out

	_ret = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// PushEvent pushes an Event on the Harness srcpad.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - event to push.
//
// The function returns the following values:
//
//    - ok with the result from the push.
//
func (h *Harness) PushEvent(event *gst.Event) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_harness_push_event(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PushFromSrc: transfer data from the src-Harness to the main-Harness. It
// consists of 4 steps: 1: Make sure the src is started. (see: gst_harness_play)
// 2: Crank the clock (see: gst_harness_crank_single_clock_wait) 3: Pull a
// Buffer from the src-Harness (see: gst_harness_pull) 4: Push the same Buffer
// into the main-Harness (see: gst_harness_push)
//
// MT safe.
//
// The function returns the following values:
//
//    - flowReturn with the result of the push.
//
func (h *Harness) PushFromSrc() gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_push_from_src(_arg0)
	runtime.KeepAlive(h)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushToSink: transfer one Buffer from the main-Harness to the sink-Harness.
// See gst_harness_push_from_src for details.
//
// MT safe.
//
// The function returns the following values:
//
//    - flowReturn with the result of the push.
//
func (h *Harness) PushToSink() gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_push_to_sink(_arg0)
	runtime.KeepAlive(h)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushUpstreamEvent pushes an Event on the Harness sinkpad.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - event to push.
//
// The function returns the following values:
//
//    - ok with the result from the push.
//
func (h *Harness) PushUpstreamEvent(event *gst.Event) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_harness_push_upstream_event(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryLatency: get the min latency reported by any harnessed Element.
//
// MT safe.
//
// The function returns the following values:
//
//    - clockTime with min latency.
//
func (h *Harness) QueryLatency() gst.ClockTime {
	var _arg0 *C.GstHarness  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_query_latency(_arg0)
	runtime.KeepAlive(h)

	var _clockTime gst.ClockTime // out

	_clockTime = uint64(_cret)
	type _ = gst.ClockTime
	type _ = uint64

	return _clockTime
}

// SetBlockingPushMode: setting this will make the harness block in the
// chain-function, and then release when gst_harness_pull() or
// gst_harness_try_pull() is called. Can be useful when wanting to control a
// src-element that is not implementing gst_clock_id_wait() so it can't be
// controlled by the TestClock, since it otherwise would produce buffers as fast
// as possible.
//
// MT safe.
func (h *Harness) SetBlockingPushMode() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_set_blocking_push_mode(_arg0)
	runtime.KeepAlive(h)
}

// SetCaps sets the GstHarness srcpad and sinkpad caps.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - in to set on the harness srcpad.
//    - out to set on the harness sinkpad.
//
func (h *Harness) SetCaps(in *gst.Caps, out *gst.Caps) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstCaps    // out
	var _arg2 *C.GstCaps    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(in)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(in)), nil)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(out)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(out)), nil)

	C.gst_harness_set_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(in)
	runtime.KeepAlive(out)
}

// SetCapsStr sets the GstHarness srcpad and sinkpad caps using strings.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - in: gchar describing a Caps to set on the harness srcpad.
//    - out: gchar describing a Caps to set on the harness sinkpad.
//
func (h *Harness) SetCapsStr(in string, out string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(in)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(out)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_harness_set_caps_str(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(in)
	runtime.KeepAlive(out)
}

// SetDropBuffers: when set to TRUE, instead of placing the buffers arriving
// from the harnessed Element inside the sinkpads Queue, they are instead
// unreffed.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - dropBuffers specifying to drop outgoing buffers or not.
//
func (h *Harness) SetDropBuffers(dropBuffers bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if dropBuffers {
		_arg1 = C.TRUE
	}

	C.gst_harness_set_drop_buffers(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(dropBuffers)
}

// SetForwarding as a convenience, a src-harness will forward
// GST_EVENT_STREAM_START, GST_EVENT_CAPS and GST_EVENT_SEGMENT to the
// main-harness if forwarding is enabled, and forward any sticky-events from the
// main-harness to the sink-harness. It will also forward the
// GST_QUERY_ALLOCATION.
//
// If forwarding is disabled, the user will have to either manually push these
// events from the src-harness using gst_harness_src_push_event(), or create and
// push them manually. While this will allow full control and inspection of
// these events, for the most cases having forwarding enabled will be sufficient
// when writing a test where the src-harness' main function is providing data
// for the main-harness.
//
// Forwarding is enabled by default.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - forwarding to enable/disable forwarding.
//
func (h *Harness) SetForwarding(forwarding bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if forwarding {
		_arg1 = C.TRUE
	}

	C.gst_harness_set_forwarding(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(forwarding)
}

// SetLive sets the liveness reported by Harness when receiving a latency-query.
// The default is TRUE.
//
// The function takes the following parameters:
//
//    - isLive: TRUE for live, FALSE for non-live.
//
func (h *Harness) SetLive(isLive bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if isLive {
		_arg1 = C.TRUE
	}

	C.gst_harness_set_live(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(isLive)
}

// SetProposeAllocator sets the allocator and params to propose when receiving
// an allocation query.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - allocator (optional): Allocator.
//    - params (optional): AllocationParams.
//
func (h *Harness) SetProposeAllocator(allocator gst.Allocatorrer, params *gst.AllocationParams) {
	var _arg0 *C.GstHarness          // out
	var _arg1 *C.GstAllocator        // out
	var _arg2 *C.GstAllocationParams // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if allocator != nil {
		_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_harness_set_propose_allocator(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// SetSinkCaps sets the GstHarness sinkpad caps.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - caps to set on the harness sinkpad.
//
func (h *Harness) SetSinkCaps(caps *gst.Caps) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstCaps    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	C.gst_harness_set_sink_caps(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(caps)
}

// SetSinkCapsStr sets the GstHarness sinkpad caps using a string.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - str: gchar describing a Caps to set on the harness sinkpad.
//
func (h *Harness) SetSinkCapsStr(str string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_set_sink_caps_str(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(str)
}

// SetSrcCaps sets the GstHarness srcpad caps. This must be done before any
// buffers can legally be pushed from the harness to the element.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - caps to set on the harness srcpad.
//
func (h *Harness) SetSrcCaps(caps *gst.Caps) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstCaps    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	C.gst_harness_set_src_caps(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(caps)
}

// SetSrcCapsStr sets the GstHarness srcpad caps using a string. This must be
// done before any buffers can legally be pushed from the harness to the
// element.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - str: gchar describing a Caps to set on the harness srcpad.
//
func (h *Harness) SetSrcCapsStr(str string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_set_src_caps_str(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(str)
}

// SetTime: advance the TestClock to a specific time.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - time to advance the clock to.
//
// The function returns the following values:
//
//    - ok: gboolean TRUE if the time could be set. FALSE if not.
//
func (h *Harness) SetTime(time gst.ClockTime) bool {
	var _arg0 *C.GstHarness  // out
	var _arg1 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.guint64(time)
	type _ = gst.ClockTime
	type _ = uint64

	_cret = C.gst_harness_set_time(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(time)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUpstreamLatency sets the min latency reported by Harness when receiving a
// latency-query.
//
// The function takes the following parameters:
//
//    - latency specifying the latency.
//
func (h *Harness) SetUpstreamLatency(latency gst.ClockTime) {
	var _arg0 *C.GstHarness  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.guint64(latency)
	type _ = gst.ClockTime
	type _ = uint64

	C.gst_harness_set_upstream_latency(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(latency)
}

// SinkPushMany: convenience that calls gst_harness_push_to_sink pushes number
// of times. Will abort the pushing if any one push fails.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - pushes with the number of calls to gst_harness_push_to_sink.
//
// The function returns the following values:
//
//    - flowReturn with the result of the push.
//
func (h *Harness) SinkPushMany(pushes int) gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _arg1 C.gint          // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.gint(pushes)

	_cret = C.gst_harness_sink_push_many(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(pushes)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SrcCrankAndPushMany: transfer data from the src-Harness to the main-Harness.
// Similar to gst_harness_push_from_src, this variant allows you to specify how
// many cranks and how many pushes to perform. This can be useful for both
// moving a lot of data at the same time, as well as cases when one crank does
// not equal one buffer to push and v.v.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - cranks with the number of calls to gst_harness_crank_single_clock_wait.
//    - pushes with the number of calls to gst_harness_push.
//
// The function returns the following values:
//
//    - flowReturn with the result of the push.
//
func (h *Harness) SrcCrankAndPushMany(cranks int, pushes int) gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _arg1 C.gint          // out
	var _arg2 C.gint          // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.gint(cranks)
	_arg2 = C.gint(pushes)

	_cret = C.gst_harness_src_crank_and_push_many(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(cranks)
	runtime.KeepAlive(pushes)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SrcPushEvent: similar to what gst_harness_src_push does with Buffers, this
// transfers a Event from the src-Harness to the main-Harness. Note that some
// Events are being transferred automagically. Look at sink_forward_pad for
// details.
//
// MT safe.
//
// The function returns the following values:
//
//    - ok with the result of the push.
//
func (h *Harness) SrcPushEvent() bool {
	var _arg0 *C.GstHarness // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_src_push_event(_arg0)
	runtime.KeepAlive(h)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TakeAllDataAsBuffer pulls all pending data from the harness and returns it as
// a single buffer.
//
// The function returns the following values:
//
//    - buffer: data as a buffer. Unref with gst_buffer_unref() when no longer
//      needed.
//
func (h *Harness) TakeAllDataAsBuffer() *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_take_all_data_as_buffer(_arg0)
	runtime.KeepAlive(h)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// TakeAllData pulls all pending data from the harness and returns it as a
// single #GBytes.
//
// The function returns the following values:
//
//    - bytes: pointer to the data, newly allocated. Free with g_free() when no
//      longer needed.
//
func (h *Harness) TakeAllData() *glib.Bytes {
	var _arg0 *C.GstHarness // out
	var _cret *C.GBytes     // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_take_all_data_as_bytes(_arg0)
	runtime.KeepAlive(h)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Teardown tears down a GstHarness, freeing all resources allocated using it.
//
// MT safe.
func (h *Harness) Teardown() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_teardown(_arg0)
	runtime.KeepAlive(h)
}

// TryPull pulls a Buffer from the Queue on the Harness sinkpad. Unlike
// gst_harness_pull this will not wait for any buffers if not any are present,
// and return NULL straight away.
//
// MT safe.
//
// The function returns the following values:
//
//    - buffer or NULL if no buffers are present in the Queue.
//
func (h *Harness) TryPull() *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_try_pull(_arg0)
	runtime.KeepAlive(h)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// TryPullEvent pulls an Event from the Queue on the Harness sinkpad. See
// gst_harness_try_pull for details.
//
// MT safe.
//
// The function returns the following values:
//
//    - event or NULL if no buffers are present in the Queue.
//
func (h *Harness) TryPullEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_try_pull_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// TryPullUpstreamEvent pulls an Event from the Queue on the Harness srcpad. See
// gst_harness_try_pull for details.
//
// MT safe.
//
// The function returns the following values:
//
//    - event or NULL if no buffers are present in the Queue.
//
func (h *Harness) TryPullUpstreamEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_try_pull_upstream_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// UpstreamEventsInQueue: number of Events currently in the Harness srcpad Queue
//
// MT safe.
//
// The function returns the following values:
//
//    - guint number of events in the queue.
//
func (h *Harness) UpstreamEventsInQueue() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_upstream_events_in_queue(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UpstreamEventsReceived: total number of Events that has arrived on the
// Harness srcpad This number includes events handled by the harness as well as
// events that have already been pulled out.
//
// MT safe.
//
// The function returns the following values:
//
//    - guint number of events received.
//
func (h *Harness) UpstreamEventsReceived() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_upstream_events_received(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UseSystemclock sets the system Clock on the GstHarness Element
//
// MT safe.
func (h *Harness) UseSystemclock() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_use_systemclock(_arg0)
	runtime.KeepAlive(h)
}

// UseTestclock sets the TestClock on the Harness Element
//
// MT safe.
func (h *Harness) UseTestclock() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_use_testclock(_arg0)
	runtime.KeepAlive(h)
}

// WaitForClockIDWaits waits for timeout seconds until waits number of ClockID
// waits is registered with the TestClock. Useful for writing deterministic
// tests, where you want to make sure that an expected number of waits have been
// reached.
//
// MT safe.
//
// The function takes the following parameters:
//
//    - waits describing the numbers of ClockID registered with the TestClock.
//    - timeout describing how many seconds to wait for waits to be true.
//
// The function returns the following values:
//
//    - ok: gboolean TRUE if the waits have been registered, FALSE if not. (Could
//      be that it timed out waiting or that more waits than waits was found).
//
func (h *Harness) WaitForClockIDWaits(waits uint, timeout uint) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 C.guint       // out
	var _arg2 C.guint       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.guint(waits)
	_arg2 = C.guint(timeout)

	_cret = C.gst_harness_wait_for_clock_id_waits(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(waits)
	runtime.KeepAlive(timeout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
