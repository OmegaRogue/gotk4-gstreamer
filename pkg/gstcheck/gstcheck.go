// Code generated by girgen. DO NOT EDIT.

package gstcheck

import (
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/OmegaRogue/gotk4-gstreamer/pkg/gst"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gstreamer-check-1.0 gstreamer-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <gst/check/check.h>
import "C"

// CheckAbiList verifies that reference values and current values are equals in
// list.
//
// The function takes the following parameters:
//
//    - list of GstCheckABIStruct to be verified.
//    - haveAbiSizes: whether there is a reference ABI size already specified, if
//      it is FALSE and the GST_ABI environment variable is set, usable code for
//      list will be printed.
//
func CheckAbiList(list *CheckABIStruct, haveAbiSizes bool) {
	var _arg1 *C.GstCheckABIStruct // out
	var _arg2 C.gboolean           // out

	_arg1 = (*C.GstCheckABIStruct)(gextras.StructNative(unsafe.Pointer(list)))
	if haveAbiSizes {
		_arg2 = C.TRUE
	}

	C.gst_check_abi_list(_arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(haveAbiSizes)
}

// CheckBufferData: compare the buffer contents with data and size.
//
// The function takes the following parameters:
//
//    - buffer to compare.
//    - data (optional) to compare to.
//    - size of data to compare.
//
func CheckBufferData(buffer *gst.Buffer, data unsafe.Pointer, size uint) {
	var _arg1 *C.GstBuffer    // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize         // out

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(data))
	_arg3 = C.gsize(size)

	C.gst_check_buffer_data(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)
}

// CheckCapsEqual: compare two caps with gst_caps_is_equal and fail unless they
// are equal.
//
// The function takes the following parameters:
//
//    - caps1: first caps to compare.
//    - caps2: second caps to compare.
//
func CheckCapsEqual(caps1, caps2 *gst.Caps) {
	var _arg1 *C.GstCaps // out
	var _arg2 *C.GstCaps // out

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	C.gst_check_caps_equal(_arg1, _arg2)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)
}

// CheckChainFunc: fake chain function that appends the buffer to the internal
// list of buffers.
//
// The function takes the following parameters:
//
//    - pad
//    - parent
//    - buffer
//
// The function returns the following values:
//
func CheckChainFunc(pad *gst.Pad, parent gst.GstObjector, buffer *gst.Buffer) gst.FlowReturn {
	var _arg1 *C.GstPad       // out
	var _arg2 *C.GstObject    // out
	var _arg3 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_check_chain_func(_arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// CheckDropBuffers: unref and remove all buffers that are in the global buffers
// GList, emptying the list.
func CheckDropBuffers() {
	C.gst_check_drop_buffers()
}

// CheckElementPushBuffer: create an element using the factory providing the
// element_name and push the buffer_in to this element. The element should
// create one buffer and this will be compared with buffer_out. We only check
// the caps and the data of the buffers. This function unrefs the buffers.
//
// The function takes the following parameters:
//
//    - elementName: name of the element that needs to be created.
//    - bufferIn: push this buffer to the element.
//    - capsIn expected of the sinkpad of the element.
//    - bufferOut: compare the result with this buffer.
//    - capsOut expected of the srcpad of the element.
//
func CheckElementPushBuffer(elementName string, bufferIn *gst.Buffer, capsIn *gst.Caps, bufferOut *gst.Buffer, capsOut *gst.Caps) {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GstBuffer // out
	var _arg3 *C.GstCaps   // out
	var _arg4 *C.GstBuffer // out
	var _arg5 *C.GstCaps   // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(bufferIn)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsIn)))
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(bufferOut)))
	_arg5 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsOut)))

	C.gst_check_element_push_buffer(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(elementName)
	runtime.KeepAlive(bufferIn)
	runtime.KeepAlive(capsIn)
	runtime.KeepAlive(bufferOut)
	runtime.KeepAlive(capsOut)
}

// CheckElementPushBufferList: create an element using the factory providing the
// element_name and push the buffers in buffer_in to this element. The element
// should create the buffers equal to the buffers in buffer_out. We only check
// the size and the data of the buffers. This function unrefs the buffers in the
// two lists. The last_flow_return parameter indicates the expected flow return
// value from pushing the final buffer in the list. This can be used to set up a
// test which pushes some buffers and then an invalid buffer, when the final
// buffer is expected to fail, for example.
//
// The function takes the following parameters:
//
//    - elementName: name of the element that needs to be created.
//    - bufferIn: list of buffers that needs to be pushed to the element.
//    - capsIn expected of the sinkpad of the element.
//    - bufferOut: list of buffers that we expect from the element.
//    - capsOut expected of the srcpad of the element.
//    - lastFlowReturn: last buffer push needs to give this GstFlowReturn.
//
func CheckElementPushBufferList(elementName string, bufferIn []*gst.Buffer, capsIn *gst.Caps, bufferOut []*gst.Buffer, capsOut *gst.Caps, lastFlowReturn gst.FlowReturn) {
	var _arg1 *C.gchar        // out
	var _arg2 *C.GList        // out
	var _arg3 *C.GstCaps      // out
	var _arg4 *C.GList        // out
	var _arg5 *C.GstCaps      // out
	var _arg6 C.GstFlowReturn // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))
	for i := len(bufferIn) - 1; i >= 0; i-- {
		src := bufferIn[i]
		var dst *C.GstBuffer // out
		dst = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsIn)))
	for i := len(bufferOut) - 1; i >= 0; i-- {
		src := bufferOut[i]
		var dst *C.GstBuffer // out
		dst = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		_arg4 = C.g_list_prepend(_arg4, C.gpointer(unsafe.Pointer(dst)))
	}
	_arg5 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsOut)))
	_arg6 = C.GstFlowReturn(lastFlowReturn)

	C.gst_check_element_push_buffer_list(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(elementName)
	runtime.KeepAlive(bufferIn)
	runtime.KeepAlive(capsIn)
	runtime.KeepAlive(bufferOut)
	runtime.KeepAlive(capsOut)
	runtime.KeepAlive(lastFlowReturn)
}

// The function takes the following parameters:
//
//    - message
//    - typ
//    - domain
//    - code
//
func CheckMessageError(message *gst.Message, typ gst.MessageType, domain glib.Quark, code int) {
	var _arg1 *C.GstMessage    // out
	var _arg2 C.GstMessageType // out
	var _arg3 C.GQuark         // out
	var _arg4 C.gint           // out

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg2 = C.GstMessageType(typ)
	_arg3 = C.guint32(domain)
	type _ = glib.Quark
	type _ = uint32
	_arg4 = C.gint(code)

	C.gst_check_message_error(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(message)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
}

// CheckSetupElement: setup an element for a filter test with mysrcpad and
// mysinkpad.
//
// The function takes the following parameters:
//
//    - factory: factory.
//
// The function returns the following values:
//
//    - element: new element.
//
func CheckSetupElement(factory string) gst.Elementer {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factory)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_check_setup_element(_arg1)
	runtime.KeepAlive(factory)

	var _element gst.Elementer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gst.Elementer)
			return ok
		})
		rv, ok := casted.(gst.Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	return _element
}

// CheckSetupEvents: push stream-start, caps and segment event, which consist of
// the minimum required events to allow streaming. Caps is optional to allow raw
// src testing. If element has more than one src or sink pad, use
// gst_check_setup_events_with_stream_id() instead.
//
// The function takes the following parameters:
//
//    - srcpad: src Pad to push on.
//    - element use to create the stream id.
//    - caps (optional) in case caps event must be sent.
//    - format of the default segment to send.
//
func CheckSetupEvents(srcpad *gst.Pad, element gst.Elementer, caps *gst.Caps, format gst.Format) {
	var _arg1 *C.GstPad     // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.GstCaps    // out
	var _arg4 C.GstFormat   // out

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg4 = C.GstFormat(format)

	C.gst_check_setup_events(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(element)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(format)
}

// CheckSetupEventsWithStreamID: push stream-start, caps and segment event,
// which consist of the minimum required events to allow streaming. Caps is
// optional to allow raw src testing.
//
// The function takes the following parameters:
//
//    - srcpad: src Pad to push on.
//    - element use to create the stream id.
//    - caps (optional) in case caps event must be sent.
//    - format of the default segment to send.
//    - streamId: unique identifier for the stream.
//
func CheckSetupEventsWithStreamID(srcpad *gst.Pad, element gst.Elementer, caps *gst.Caps, format gst.Format, streamId string) {
	var _arg1 *C.GstPad     // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.GstCaps    // out
	var _arg4 C.GstFormat   // out
	var _arg5 *C.gchar      // out

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg4 = C.GstFormat(format)
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
	defer C.free(unsafe.Pointer(_arg5))

	C.gst_check_setup_events_with_stream_id(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(element)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(format)
	runtime.KeepAlive(streamId)
}

// CheckSetupSinkPad does the same as #gst_check_setup_sink_pad_by_name with the
// <emphasis> name </emphasis> parameter equal to "src".
//
// The function takes the following parameters:
//
//    - element to setup pad on.
//    - tmpl: pad template.
//
// The function returns the following values:
//
//    - pad: new pad that can be used to check the output of element.
//
func CheckSetupSinkPad(element gst.Elementer, tmpl *gst.StaticPadTemplate) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))

	_cret = C.gst_check_setup_sink_pad(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// CheckSetupSinkPadByName creates a new sink pad (based on the given tmpl) and
// links it to the given element src pad (the pad that matches the given name).
// You can set event/chain/query functions on this pad to check the output of
// the element.
//
// The function takes the following parameters:
//
//    - element to setup pad on.
//    - tmpl: pad template.
//    - name: name of the element src pad that will be linked to the sink pad
//      that will be setup.
//
// The function returns the following values:
//
//    - pad: new pad that can be used to check the output of element.
//
func CheckSetupSinkPadByName(element gst.Elementer, tmpl *gst.StaticPadTemplate, name string) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _arg3 *C.gchar                // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_check_setup_sink_pad_by_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(name)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// CheckSetupSrcPad does the same as #gst_check_setup_src_pad_by_name with the
// <emphasis> name </emphasis> parameter equal to "sink".
//
// The function takes the following parameters:
//
//    - element to setup pad on.
//    - tmpl: pad template.
//
// The function returns the following values:
//
//    - pad: new pad that can be used to inject data on element.
//
func CheckSetupSrcPad(element gst.Elementer, tmpl *gst.StaticPadTemplate) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))

	_cret = C.gst_check_setup_src_pad(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// CheckSetupSrcPadByName creates a new src pad (based on the given tmpl) and
// links it to the given element sink pad (the pad that matches the given name).
// Before using the src pad to push data on element you need to call
// #gst_check_setup_events on the created src pad.
//
// Example of how to push a buffer on element:
//
//    static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
//    GST_PAD_SINK,
//    GST_PAD_ALWAYS,
//    GST_STATIC_CAPS (YOUR_CAPS_TEMPLATE_STRING)
//    );
//    static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
//    GST_PAD_SRC,
//    GST_PAD_ALWAYS,
//    GST_STATIC_CAPS (YOUR_CAPS_TEMPLATE_STRING)
//    );
//
//    GstElement * element = gst_check_setup_element ("element");
//    GstPad * mysrcpad = gst_check_setup_src_pad (element, &srctemplate);
//    GstPad * mysinkpad = gst_check_setup_sink_pad (element, &sinktemplate);
//
//    gst_pad_set_active (mysrcpad, TRUE);
//    gst_pad_set_active (mysinkpad, TRUE);
//    fail_unless (gst_element_set_state (element, GST_STATE_PLAYING) == GST_STATE_CHANGE_SUCCESS, "could not set to playing");
//
//    GstCaps * caps = gst_caps_from_string (YOUR_DESIRED_SINK_CAPS);
//    gst_check_setup_events (mysrcpad, element, caps, GST_FORMAT_TIME);
//    gst_caps_unref (caps);
//
//    fail_unless (gst_pad_push (mysrcpad, gst_buffer_new_and_alloc(2)) == GST_FLOW_OK);
//
// For very simple input/output test scenarios checkout
// #gst_check_element_push_buffer_list and #gst_check_element_push_buffer.
//
// The function takes the following parameters:
//
//    - element to setup src pad on.
//    - tmpl: pad template.
//    - name: name of the element sink pad that will be linked to the src pad
//      that will be setup.
//
// The function returns the following values:
//
//    - pad: new pad that can be used to inject data on element.
//
func CheckSetupSrcPadByName(element gst.Elementer, tmpl *gst.StaticPadTemplate, name string) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _arg3 *C.gchar                // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_check_setup_src_pad_by_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(name)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// The function takes the following parameters:
//
func CheckTeardownElement(element gst.Elementer) {
	var _arg1 *C.GstElement // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_check_teardown_element(_arg1)
	runtime.KeepAlive(element)
}

// The function takes the following parameters:
//
//    - element
//    - name
//
func CheckTeardownPadByName(element gst.Elementer, name string) {
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_check_teardown_pad_by_name(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)
}

// The function takes the following parameters:
//
func CheckTeardownSinkPad(element gst.Elementer) {
	var _arg1 *C.GstElement // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_check_teardown_sink_pad(_arg1)
	runtime.KeepAlive(element)
}

// The function takes the following parameters:
//
func CheckTeardownSrcPad(element gst.Elementer) {
	var _arg1 *C.GstElement // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_check_teardown_src_pad(_arg1)
	runtime.KeepAlive(element)
}

// CheckABIStruct: instance of this type is always passed by reference.
type CheckABIStruct struct {
	*checkABIStruct
}

// checkABIStruct is the struct that's finalized.
type checkABIStruct struct {
	native *C.GstCheckABIStruct
}

// Name: name of the structure.
func (c *CheckABIStruct) Name() string {
	valptr := &c.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Size: current size of a structure.
func (c *CheckABIStruct) Size() int {
	valptr := &c.native.size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// AbiSize: reference size of the structure.
func (c *CheckABIStruct) AbiSize() int {
	valptr := &c.native.abi_size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Size: current size of a structure.
func (c *CheckABIStruct) SetSize(size int) {
	valptr := &c.native.size
	*valptr = C.int(size)
}

// AbiSize: reference size of the structure.
func (c *CheckABIStruct) SetAbiSize(abiSize int) {
	valptr := &c.native.abi_size
	*valptr = C.int(abiSize)
}
